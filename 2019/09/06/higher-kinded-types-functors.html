<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Higher Kinded Types: Functors &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Common Algorithms" href="../../08/10/common-algorithms.html" /><link rel="prev" title="Higher Kinded Types: Monads" href="../07/higher-kinded-types-monads.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>September 06, 2019</span>
        </div>
    <div class="section" id="higher-kinded-types-functors">
<h1>Higher Kinded Types: Functors</h1>
<p>This blog post is an excerpt from my book, <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>. The code samples
are in TypeScript. If you enjoy the article, you can use the discount code
<strong>vlri40</strong> for a 40% discount on the book.</p>
<div class="section" id="an-even-more-general-map">
<h2>An Even More General Map</h2>
<p>In the <a class="reference external" href="https://vladris.com/blog/2019/08/10/common-algorithms.html">previous post</a>
we saw a generic <span class="docutils literal"><span class="pre">map()</span></span> implementation working on iterators. Iterators
abstract data structure traversal, so <span class="docutils literal"><span class="pre">map()</span></span> can apply a function to
elements in any data structure.</p>
<img alt="../../../_images/map1.png" class="align-center" src="../../../_images/map1.png" />
<p>In the figure, <span class="docutils literal"><span class="pre">map()</span></span> takes an iterator over a sequence, in this case a list
of circles, and a function which transforms a circle. <span class="docutils literal"><span class="pre">map()</span></span> applies the
function to each element in the sequence, and produces a new sequence with the
transformed elements.</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="o">*</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This implementation works on iterators, but we should be able to apply a
function of the form <span class="docutils literal"><span class="pre">(item:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> to other types too. Let’s take, as an
example, an <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span> type:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="nx">value</span>: <span class="kt">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">assigned</span>: <span class="kt">boolean</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value?</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">assigned</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">assigned</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">hasValue</span><span class="p">()</span><span class="o">:</span> <span class="kt">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">assigned</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">getValue</span><span class="p">()</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">assigned</span><span class="p">)</span> <span class="k">throw</span> <span class="ne">Error</span><span class="p">();</span>

        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It feels natural to be able to map a function <span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> over an
<span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span>. If the optional contains a value of type <span class="docutils literal"><span class="pre">T</span></span>, mapping the
function over it should return an <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span> containing the result of
applying the function. On the other hand, if the optional doesn’t contain a
value, mapping would result in an empty <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span>.</p>
<img alt="../../../_images/map2.png" class="align-center" src="../../../_images/map2.png" />
<p>Let’s sketch out an implementation for this. We’ll put this function in a
namespace. Since TypeScript doesn’t support function overloading, in order to
have multiple functions with the same name, we need this so the compiler can
determine which function we are calling. Here’s the <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span> <span class="docutils literal"><span class="pre">map()</span></span>
implementation:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">namespace</span> <span class="nx">Optional</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">optional</span>: <span class="kt">Optional</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">optional</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="ow">new</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">optional</span><span class="p">.</span><span class="nx">getValue</span><span class="p">()));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="ow">new</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">export</span></span> simply makes the function visible outside the namespace. If the
optional has a value, we extract it, pass it to <span class="docutils literal"><span class="pre">func()</span></span>, and use its result
to initialize an <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span>. If the optional is empty, we create a new
empty <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span>.</p>
<p>We can do something very similar with the TypeScript sum type <span class="docutils literal"><span class="pre">T</span></span> or
<span class="docutils literal"><span class="pre">undefined</span></span>. The <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span> we just saw is a DIY version of such a type
that works even in languages which don’t support sum types natively, but
TypeScript does. Let’s see how we can map over a “native” optional type
<span class="docutils literal"><span class="pre">T</span> <span class="pre">|</span> <span class="pre">undefined</span></span>.</p>
<p>Mapping a function <span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> over <span class="docutils literal"><span class="pre">T</span> <span class="pre">|</span> <span class="pre">undefined</span></span> should apply the
function and return its result if we have a value of type <span class="docutils literal"><span class="pre">T</span></span>, or return
<span class="docutils literal"><span class="pre">undefined</span></span> if we start with <span class="docutils literal"><span class="pre">undefined</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">namespace</span> <span class="nx">SumType</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">value</span>: <span class="kt">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">U</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These types can’t be iterated over, but it still makes sense for a <span class="docutils literal"><span class="pre">map()</span></span>
function to exist for them. Let’s define another simple generic type,
<span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>. This type simply wraps a value of type <span class="docutils literal"><span class="pre">T</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Can we map a function <span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> over this type? We can. As you might
have guessed, <span class="docutils literal"><span class="pre">map()</span></span> for <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> would return a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>: it will take
the value <span class="docutils literal"><span class="pre">T</span></span> out of <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, apply the function to it, and put the result
back into a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>.</p>
<img alt="../../../_images/map3.png" class="align-center" src="../../../_images/map3.png" />
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">namespace</span> <span class="nx">Box</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="ow">new</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are many generic types over which we can map functions. Why is this
useful? It’s useful because <span class="docutils literal"><span class="pre">map()</span></span>, just like iterators, provides another
way to decouple types which store data from functions which operate on that
data.</p>
</div>
<div class="section" id="processing-results-or-propagating-errors">
<h2>Processing Results or Propagating Errors</h2>
<p>As a concrete example, let’s take a couple of functions which process a
numerical value. We’ll implement a simple <span class="docutils literal"><span class="pre">square()</span></span>, a function which takes
a number as an argument and returns its square. We’ll also implement
<span class="docutils literal"><span class="pre">stringify()</span></span>, a function which takes a number as an argument and returns its
string representation:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">square</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span> <span class="o">**</span> <span class="mf">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s say we have a function <span class="docutils literal"><span class="pre">readNumber()</span></span>, which reads a numeric value
from a file. Since we are dealing with input, we might run into some problems:
what if the file doesn’t exist or can’t be opened? In that case,
<span class="docutils literal"><span class="pre">readNumber()</span></span> will return <span class="docutils literal"><span class="pre">undefined</span></span>. We won’t look at the implementation
of this function, the important thing for our example is its return type:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">readNumber</span><span class="p">()</span><span class="o">:</span> <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="cm">/* Implementation omitted */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we want to read a number and process it by applying <span class="docutils literal"><span class="pre">square()</span></span> to it first,
then <span class="docutils literal"><span class="pre">stringify()</span></span>, we need to ensure we actually have a numerical value as
opposed to <span class="docutils literal"><span class="pre">undefined</span></span>. A possible implementation is to convert from
<span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span> to just <span class="docutils literal"><span class="pre">number</span></span> using <span class="docutils literal"><span class="pre">if</span></span> statements wherever
needed:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">process</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="nx">readNumber</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">square</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have two functions that operate on numbers, but since our input can also be
<span class="docutils literal"><span class="pre">undefined</span></span>, we need to explicitly handle that case. This is not particularly
bad, but in general the less branching our code has, the less complex it is. It
is easier to understand, to maintain, and there are less opportunities for bugs.
Another way to look at this is that <span class="docutils literal"><span class="pre">process()</span></span> itself simply propagates
<span class="docutils literal"><span class="pre">undefined</span></span>, it doesn’t do anything useful with it. It would be better if we
can keep <span class="docutils literal"><span class="pre">process()</span></span> responsible for processing, and let someone else handle
error cases. How can we do this? With the <span class="docutils literal"><span class="pre">map()</span></span> we implemented for sum
types:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">namespace</span> <span class="nx">SumType</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">value</span>: <span class="kt">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">U</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">process</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="nx">readNumber</span><span class="p">();</span>

    <span class="kd">let</span> <span class="nx">squaredValue</span> <span class="o">=</span> <span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">square</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">squaredValue</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Instead of explicitly checking for <span class="docutils literal"><span class="pre">undefined</span></span>, we call <span class="docutils literal"><span class="pre">map()</span></span> to apply
<span class="docutils literal"><span class="pre">square()</span></span> on the value. If it is <span class="docutils literal"><span class="pre">undefined</span></span>, <span class="docutils literal"><span class="pre">map()</span></span> will give us back
<span class="docutils literal"><span class="pre">undefined</span></span>. Just like with <span class="docutils literal"><span class="pre">square()</span></span>, we <span class="docutils literal"><span class="pre">map()</span></span> our <span class="docutils literal"><span class="pre">stringify()</span></span>
function on the <span class="docutils literal"><span class="pre">squaredValue</span></span>. If it is <span class="docutils literal"><span class="pre">undefined</span></span>, <span class="docutils literal"><span class="pre">map()</span></span> will return
<span class="docutils literal"><span class="pre">undefined</span></span>.</p>
<p>Now our <span class="docutils literal"><span class="pre">process()</span></span> implementation has no branching – the responsibility of
unpacking <span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span> into a <span class="docutils literal"><span class="pre">number</span></span> and checking for
<span class="docutils literal"><span class="pre">undefined</span></span> is handled by <span class="docutils literal"><span class="pre">map()</span></span>. <span class="docutils literal"><span class="pre">map()</span></span> is generic and can be used
across many other types (like <span class="docutils literal"><span class="pre">string</span> <span class="pre">|</span> <span class="pre">undefined</span></span>) and in many other
processing functions.</p>
<p>In our case, since <span class="docutils literal"><span class="pre">square()</span></span> is guaranteed to return a <span class="docutils literal"><span class="pre">number</span></span>, we can
create a small lambda which chains <span class="docutils literal"><span class="pre">square()</span></span> and <span class="docutils literal"><span class="pre">stringify()</span></span>, and pass
that to <span class="docutils literal"><span class="pre">map()</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">process</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="nx">readNumber</span><span class="p">();</span>

    <span class="k">return</span> <span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span>
        <span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">square</span><span class="p">(</span><span class="nx">value</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a functional implementation of <span class="docutils literal"><span class="pre">process()</span></span>, in which the error
propagation is delegated to <span class="docutils literal"><span class="pre">map()</span></span>. We’ll talk more about error handling
in a later blog post, when we will discuss monads. For now, let’s look at
another application of <span class="docutils literal"><span class="pre">map()</span></span>.</p>
</div>
<div class="section" id="mix-and-match-function-application">
<h2>Mix-and-match Function Application</h2>
<p>Without the <span class="docutils literal"><span class="pre">map()</span></span> family of functions, if we have a <span class="docutils literal"><span class="pre">square()</span></span> function
which squares a <span class="docutils literal"><span class="pre">number</span></span>, we would have to implement some additional logic to
get a <span class="docutils literal"><span class="pre">number</span></span> from a <span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span> sum type. Similarly, we would
have to implement some additional logic to get a value from a <span class="docutils literal"><span class="pre">Box&lt;number&gt;</span></span>,
and package it back in a <span class="docutils literal"><span class="pre">Box&lt;number&gt;</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">squareSumType</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">)</span>
    <span class="o">:</span> <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">square</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">squareBox</span><span class="p">(</span><span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="ow">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">square</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So far this isn’t too bad. But what if we want something similar with
<span class="docutils literal"><span class="pre">stringify()</span></span>? We’ll again end up writing two functions which look a lot like
the previous ones:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">stringifySumType</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">)</span>
    <span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">stringifyBox</span><span class="p">(</span><span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="ow">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This starts to look like duplicate code, which is never good. If we have
<span class="docutils literal"><span class="pre">map()</span></span> functions available for <span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span> and <span class="docutils literal"><span class="pre">Box</span></span>, they
provide the abstraction to remove the duplicate code. We can pass either
<span class="docutils literal"><span class="pre">square()</span></span> or <span class="docutils literal"><span class="pre">stringify()</span></span> to either <span class="docutils literal"><span class="pre">SumType.map()</span></span> or to
<span class="docutils literal"><span class="pre">Box.map()</span></span>, no additional code needed:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">x</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="mf">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">y</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="ow">new</span> <span class="nx">Box</span><span class="p">(</span><span class="mf">42</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Box</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">));</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">square</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Box</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">square</span><span class="p">));</span>
</pre></div>
</div>
<p>Now let’s define this family of <span class="docutils literal"><span class="pre">map()</span></span> functions.</p>
</div>
<div class="section" id="functors-and-higher-kinded-types">
<h2>Functors and Higher Kinded Types</h2>
<p>What we just talked about in this section are <em>functors</em>.</p>
<p>A functor is a generalization of functions that perform mapping operations. For
any generic type like <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, a <span class="docutils literal"><span class="pre">map()</span></span> operation which takes a
<span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> and a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span> and produces a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span> is a
functor.</p>
<img alt="../../../_images/map4.png" class="align-center" src="../../../_images/map4.png" />
<p>In the figure we have a generic type <span class="docutils literal"><span class="pre">H</span></span> which contains 0, 1, or more values
of some type <span class="docutils literal"><span class="pre">T</span></span>, and a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span>. In this case <span class="docutils literal"><span class="pre">T</span></span> is
an empty circle and <span class="docutils literal"><span class="pre">U</span></span> is a full circle. The <span class="docutils literal"><span class="pre">map()</span></span> functor unpacks the
<span class="docutils literal"><span class="pre">T</span></span> or <span class="docutils literal"><span class="pre">T</span></span>s from the <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span> instance, applies the function, then places
the result back into an <span class="docutils literal"><span class="pre">H&lt;U&gt;</span></span>.</p>
<p>Functors are extremely powerful concepts, but most mainstream languages do not
have a good way to express them. That’s because the general definition of a
functor relies on <em>higher kinded types</em>.</p>
<p>A generic type is a type which has a type parameter, for example a generic type
<span class="docutils literal"><span class="pre">T</span></span>, or a type like <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, have a type parameter <span class="docutils literal"><span class="pre">T</span></span>. A higher kinded
type, just like a higher-order function, represents a type parameter with
another type parameter. For example, <span class="docutils literal"><span class="pre">T&lt;U&gt;</span></span> or <span class="docutils literal"><span class="pre">Box&lt;T&lt;U&gt;&gt;</span></span>, have a type
parameter <span class="docutils literal"><span class="pre">T</span></span> which, in turn, has a type parameter <span class="docutils literal"><span class="pre">U</span></span>.</p>
<p>Since we don’t have a good way to express higher kinded types in TypeScript, C#,
or Java, we can’t define a construct using the type system to express a functor.
Languages like Haskell and Idris, with more powerful type systems, make these
definitions possible. In our case though, since we can’t enforce this capability
through the type system, we can think of it more as a pattern.</p>
<p>We can say a functor is any type <span class="docutils literal"><span class="pre">H</span></span> with a type parameter <span class="docutils literal"><span class="pre">T</span></span> (<span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span>)
for which we have a function <span class="docutils literal"><span class="pre">map()</span></span> which takes an argument of type <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span>,
and a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span>, and returns a value of type <span class="docutils literal"><span class="pre">H&lt;U&gt;</span></span>.</p>
<p>Alternately, if we want to be more object-oriented, we can make <span class="docutils literal"><span class="pre">map()</span></span> a
member function and say <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span> is a functor if it has a method <span class="docutils literal"><span class="pre">map()</span></span> which
takes a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span> and returns a value of type <span class="docutils literal"><span class="pre">H&lt;U&gt;</span></span>.</p>
<p>To see exactly where the type system is lacking, we can try to sketch out an
interface for it. Let’s call this interface <span class="docutils literal"><span class="pre">Functor</span></span> and have it declare
<span class="docutils literal"><span class="pre">map()</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can update <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> to implement this interface:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="k">implements</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="ow">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code compiles, the only problem is that it isn’t specific enough. Calling
<span class="docutils literal"><span class="pre">map()</span></span> on <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> returns an instance of type <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>. But if we work
with <span class="docutils literal"><span class="pre">Functor</span></span> interfaces, we see that the <span class="docutils literal"><span class="pre">map()</span></span> declaration specifies
it returns a <span class="docutils literal"><span class="pre">Functor&lt;U&gt;</span></span>, not a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>. This isn’t specific enough. We
need a way to specify, when we declare the interface, exactly what the return
type of <span class="docutils literal"><span class="pre">map()</span></span> will be (in this case <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>).</p>
<p>We would like to be able to say “this interface will be implemented by a type
<span class="docutils literal"><span class="pre">H</span></span> with a type argument <span class="docutils literal"><span class="pre">T</span></span>”. The following code shows how this declaration
would look like if TypeScript supported higher kinded types. It obviously
doesn’t compile:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">H</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">H</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="k">implements</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="ow">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Lacking this, let’s just think of our <span class="docutils literal"><span class="pre">map()</span></span> implementations as a pattern for
applying functions to generic types, or “values in some box”.</p>
</div>
<div class="section" id="functors-for-functions">
<h2>Functors for Functions</h2>
<p>Note that we also have functors over functions. Given a function with any number
of arguments that returns a value of type <span class="docutils literal"><span class="pre">T</span></span>, we can map a function which
takes a <span class="docutils literal"><span class="pre">T</span></span> and produces a <span class="docutils literal"><span class="pre">U</span></span> over it, and end up with a function which
takes the same inputs as the original function and returns a value of type
<span class="docutils literal"><span class="pre">U</span></span>. <span class="docutils literal"><span class="pre">map()</span></span> in this case is simply function composition.</p>
<img alt="../../../_images/map5.png" class="align-center" src="../../../_images/map5.png" />
<p>Mapping a function over another function composes the two functions. The result
is a function which takes the same arguments as the original function and
returns a value of the second function’s return type. The two functions need to
be compatible – the second function must expect an argument of the same type as
the one returned by the original function.</p>
<p>As an example, let’s take a function which takes two arguments of type <span class="docutils literal"><span class="pre">T</span></span>,
and produces a value of type <span class="docutils literal"><span class="pre">T</span></span> and implement its corresponding <span class="docutils literal"><span class="pre">map()</span></span>.
This will return a function which takes two arguments of type <span class="docutils literal"><span class="pre">T</span></span> and returns
a value of type <span class="docutils literal"><span class="pre">U</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">namespace</span> <span class="nb">Function</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">f</span><span class="o">:</span> <span class="p">(</span><span class="nx">arg1</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">arg2</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">T</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="nx">arg1</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">arg2</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">U</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="nx">arg1</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">arg2</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">func</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">map()</span></span> takes a function <span class="docutils literal"><span class="pre">(T,</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">T</span></span>, and a function <span class="docutils literal"><span class="pre">T</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> to map
over it. It returns a lambda function <span class="docutils literal"><span class="pre">(T,</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span>.</p>
<p>Let’s map <span class="docutils literal"><span class="pre">stringify()</span></span> over a function <span class="docutils literal"><span class="pre">add()</span></span>, which takes two numbers and
returns their sum. The result is a function which takes two numbers and returns
a string, the stringified result of adding the two numbers:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">result</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">add</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">)(</span><span class="mf">40</span><span class="p">,</span> <span class="mf">2</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li><span class="docutils literal"><span class="pre">map()</span></span> generalizes beyond iterators, to other generic types</li>
<li>Functors encapsulate data “unboxing”, with applications in composition and
error propagation</li>
<li>With higher kinded types, we can express constructs like functors using
generics which themselves have type parameters</li>
</ul>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../07/higher-kinded-types-monads.html">Higher Kinded Types: Monads</a></li>
            <li class="right"><a href="../../08/10/common-algorithms.html">Common Algorithms</a> &raquo; </li>
        </ul></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
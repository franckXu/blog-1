<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Variance &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Notes on Data Engineering" href="../08/notes-on-data-engineering.html" /><link rel="prev" title="Time and Complexity" href="../../../2020/01/19/time-and-complexity.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>December 27, 2019</span>
        </div>
    <div class="section" id="variance">
<h1>Variance</h1>
<p>This blog post is an excerpt from my book, <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>. The code samples
are in TypeScript. If you enjoy the article, you can use the discount code
<strong>vlri40</strong> for a 40% discount on the book.</p>
<div class="section" id="subtyping-relationships">
<h2>Subtyping Relationships</h2>
<p>We know that if <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">extends</span> <span class="pre">Shape</span></span>, then <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of
<span class="docutils literal"><span class="pre">Shape</span></span>. Let’s try to answer a few trickier questions:</p>
<ul class="simple">
<li>What is the subtyping relationship between the sum types <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span></span>
and <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span>?</li>
<li>What is the subtyping relationship between an array of triangles
(<span class="docutils literal"><span class="pre">Triangle[]</span></span>) and an array of shapes (<span class="docutils literal"><span class="pre">Shape[]</span></span>)?</li>
<li>What is the subtyping relationship between a generic data structure like
<span class="docutils literal"><span class="pre">List&lt;T&gt;</span></span>, for <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> and <span class="docutils literal"><span class="pre">List&lt;Shape&gt;</span></span>?</li>
<li>What about the function types <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Shape</span></span> and <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span>?</li>
<li>Conversely, what about the function type <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and
the function type <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span>?</li>
</ul>
<p>These are important questions, as they tell us which of these types can be
substituted for their subtypes. Whenever we see a function that expects an
argument of one of these types, we should understand whether we can provide a
subtype instead.</p>
<p>The challenge in the above examples is that things aren’t as straightforward
as <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">extends</span> <span class="pre">Shape</span></span>. We are looking at types which are defined <em>based</em>
on <span class="docutils literal"><span class="pre">Triangle</span></span> and <span class="docutils literal"><span class="pre">Shape</span></span>. <span class="docutils literal"><span class="pre">Triangle</span></span> and <span class="docutils literal"><span class="pre">Shape</span></span> are either part of
the sum types, or the types of elements of a collection, or a function’s
argument types or return types.</p>
</div>
<div class="section" id="subtyping-and-sum-types">
<h2>Subtyping and Sum Types</h2>
<p>Let’s take the simplest example first, the sum type. Let’s say we have a
<span class="docutils literal"><span class="pre">draw()</span></span> function which can draw a <span class="docutils literal"><span class="pre">Triangle</span></span>, a <span class="docutils literal"><span class="pre">Square</span></span>, or a
<span class="docutils literal"><span class="pre">Circle</span></span>. Can we pass a <span class="docutils literal"><span class="pre">Triangle</span></span> or <span class="docutils literal"><span class="pre">Square</span></span> to it? As you might have
guessed, the answer is “yes”. We can check that such code compiles:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">const</span> <span class="nx">TriangleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Triangle</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">TriangleType</span><span class="p">]</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>
    <span class="cm">/* Triangle members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">SquareType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Square</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">SquareType</span><span class="p">]</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>
    <span class="cm">/* Square members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">CircleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Circle</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">CircleType</span><span class="p">]</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>
    <span class="cm">/* Circle members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeShape</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span> <span class="o">|</span> <span class="nx">Square</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">shape</span>: <span class="kt">Triangle</span> <span class="o">|</span> <span class="nx">Square</span> <span class="o">|</span> <span class="nx">Circle</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>

<span class="nx">draw</span><span class="p">(</span><span class="nx">makeShape</span><span class="p">());</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">makeShape()</span></span> returns a <span class="docutils literal"><span class="pre">Triangle</span></span> or a <span class="docutils literal"><span class="pre">Square</span></span> while <span class="docutils literal"><span class="pre">draw()</span></span>
accepts a <span class="docutils literal"><span class="pre">Triangle</span></span>, a <span class="docutils literal"><span class="pre">Square</span></span> or a <span class="docutils literal"><span class="pre">Circle</span></span> (implementations
omitted).</p>
<p>We enforce nominal subtyping throughout these examples since we’re not
providing full implementations for these types. In practice, they would have
various different properties and methods to distinguish them. We simulate that
with unique symbols for our examples, as leaving the classes empty would make
all of them equivalent due to TypeScript’s <a class="reference external" href="https://en.wikipedia.org/wiki/Structural_type_system">structural subtyping</a>.</p>
<p>As expected, this code compiles. The opposite doesn’t: if we can draw a
<span class="docutils literal"><span class="pre">Triangle</span></span> or a <span class="docutils literal"><span class="pre">Square</span></span> and we attempt to draw a <span class="docutils literal"><span class="pre">Triangle</span></span>, <span class="docutils literal"><span class="pre">Square</span></span>,
or <span class="docutils literal"><span class="pre">Circle</span></span>, the compiler will complain because we might end up passing a
<span class="docutils literal"><span class="pre">Circle</span></span> to the <span class="docutils literal"><span class="pre">draw()</span></span> function, which wouldn’t know what to do with it.
We can confirm that the below code doesn’t compile:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeShape</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span> <span class="o">|</span> <span class="nx">Square</span> <span class="o">|</span> <span class="nx">Circle</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">shape</span>: <span class="kt">Triangle</span> <span class="o">|</span> <span class="nx">Square</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>

<span class="nx">draw</span><span class="p">(</span><span class="nx">makeShape</span><span class="p">());</span>
</pre></div>
</div>
<p>We flipped the types so <span class="docutils literal"><span class="pre">makeShape()</span></span> could also return a <span class="docutils literal"><span class="pre">Circle</span></span>, while
<span class="docutils literal"><span class="pre">draw()</span></span> no longer accepts a <span class="docutils literal"><span class="pre">Circle</span></span>. This no longer compiles.</p>
<p>This means that <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span></span> is a subtype of
<span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span>: we can always substitute a <span class="docutils literal"><span class="pre">Triangle</span></span> or
<span class="docutils literal"><span class="pre">Square</span></span> for a <span class="docutils literal"><span class="pre">Triangle</span></span>, <span class="docutils literal"><span class="pre">Square</span></span>, or <span class="docutils literal"><span class="pre">Circle</span></span>, but not the other way
around. This might seem counterintuitive, since <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span></span> is “less”
than <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span>. Whenever we use inheritance, we end up
with a subtype that has more properties than its supertype. For sum types it
works the opposite way: the supertype has more types than the subtype.</p>
<img alt="../../../_images/sum-types.png" class="align-center" src="../../../_images/sum-types.png" />
<p>Say we have an <span class="docutils literal"><span class="pre">EquilateralTriangle</span></span> which inherits from <span class="docutils literal"><span class="pre">Triangle</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">const</span> <span class="nx">EquilateralTriangleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">EquilateralTriangle</span> <span class="k">extends</span> <span class="nx">Triangle</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">EquilateralTriangleType</span><span class="p">]</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>
    <span class="cm">/* EquilateralTriangle members */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As an exercise, check what happens when we mix sum types with inheritance.
Does <span class="docutils literal"><span class="pre">makeShape()</span></span> returning <span class="docutils literal"><span class="pre">EquilateralTriangle</span> <span class="pre">|</span> <span class="pre">Square</span></span> and <span class="docutils literal"><span class="pre">draw()</span></span>
accepting <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span> work? What about <span class="docutils literal"><span class="pre">makeShape()</span></span>
returning <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span></span> and <span class="docutils literal"><span class="pre">draw()</span></span> accepting
<span class="docutils literal"><span class="pre">EquilateralTriangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span>?</p>
</div>
<div class="section" id="subtyping-and-collections">
<h2>Subtyping and Collections</h2>
<p>Now let’s look at types which contain a set of values of some other type. Let’s
start with arrays: can we pass an array of <span class="docutils literal"><span class="pre">Triangle</span></span> objects to a <span class="docutils literal"><span class="pre">draw()</span></span>
function which accepts an array of <span class="docutils literal"><span class="pre">Shape</span></span> objects, if <span class="docutils literal"><span class="pre">Triangle</span></span> is a
subtype of <span class="docutils literal"><span class="pre">Shape</span></span>?</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="cm">/* Shape members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">TriangleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Triangle</span> <span class="k">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">TriangleType</span><span class="p">]</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>
    <span class="cm">/* Triangle members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeTriangles</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span><span class="p">[];</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">shapes</span>: <span class="kt">Shape</span><span class="p">[])</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>

<span class="nx">draw</span><span class="p">(</span><span class="nx">makeTriangles</span><span class="p">());</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>. <span class="docutils literal"><span class="pre">makeTriangles()</span></span> returns an array of
<span class="docutils literal"><span class="pre">Triangle</span></span> objects. <span class="docutils literal"><span class="pre">draw()</span></span> accepts an array of <span class="docutils literal"><span class="pre">Shape</span></span> objects. We can
use an array of <span class="docutils literal"><span class="pre">Triangle</span></span> objects as an array of <span class="docutils literal"><span class="pre">Shape</span></span> objects</p>
<p>This might not be surprising, but it is an important observation: <em>arrays
preserve the subtyping relationship of the underlying types they are storing</em>.
As expected, the opposite doesn’t work: if we try to pass an array of <span class="docutils literal"><span class="pre">Shape</span></span>
objects where an array of <span class="docutils literal"><span class="pre">Triangle</span></span> objects is expected, the code won’t
compile.</p>
<img alt="../../../_images/arrays.png" class="align-center" src="../../../_images/arrays.png" />
<p>Arrays are basic types that come out-of-the-box in many programming languages.
What if we define a custom collection, say a <span class="docutils literal"><span class="pre">LinkedList&lt;T&gt;</span></span>?</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>
    <span class="nx">next</span>: <span class="kt">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">append</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="ow">new</span> <span class="nx">LinkedList</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeTriangles</span><span class="p">()</span><span class="o">:</span> <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">Triangle</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">shapes</span>: <span class="kt">LinkedList</span><span class="o">&lt;</span><span class="nx">Shape</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>

<span class="nx">draw</span><span class="p">(</span><span class="nx">makeTriangles</span><span class="p">());</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">LinkedList&lt;T&gt;</span></span> is a generic linked list collection. <span class="docutils literal"><span class="pre">makeTriangle()</span></span> now
returns a linked list of traingles. <span class="docutils literal"><span class="pre">draw()</span></span> accepts a linked list of shapes.
This code compiles.</p>
<p>Even without an out-of-the-box type, TypeScript correctly establishes that
<span class="docutils literal"><span class="pre">LinkedList&lt;Triangle&gt;</span></span> is a subtype of <span class="docutils literal"><span class="pre">LinkedList&lt;Shape&gt;</span></span>. Like before,
the opposite doesn’t compile - we can’t pass a <span class="docutils literal"><span class="pre">LinkedList&lt;Shape&gt;</span></span> as a
<span class="docutils literal"><span class="pre">LinkedList&lt;Triangle&gt;</span></span>.</p>
<blockquote>
<div><p><strong>Covariance</strong></p>
<p>A type which preserves the subtyping relationship of its underlying type is
called <em>covariant</em>. An array is covariant, because it preserves the
subtyping relationship: <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, so
<span class="docutils literal"><span class="pre">Triangle[]</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape[]</span></span>.</p>
</div></blockquote>
<p>Various languages behave differently when dealing with arrays and collections
like <span class="docutils literal"><span class="pre">LinkedList&lt;T&gt;</span></span>. For example, in C# we would have to explicitly state
covariance for a type like <span class="docutils literal"><span class="pre">LinkedList&lt;T&gt;</span></span> by declaring an interface and
using the <span class="docutils literal"><span class="pre">out</span></span> keyword (<span class="docutils literal"><span class="pre">ILinkedList&lt;out</span> <span class="pre">T&gt;</span></span>), otherwise the compiler will
not deduce the subtyping relationship.</p>
<p>An alternative to covariance is to simply ignore the subtyping relationship
between two given types and consider a <span class="docutils literal"><span class="pre">LinkedList&lt;Shape&gt;</span></span> and
<span class="docutils literal"><span class="pre">LinkedList&lt;Triangle&gt;</span></span> as types with no subtyping relationship between them
(neither is a subtype of the other). This is not the case in TypeScript, but it
is in C#, where a <span class="docutils literal"><span class="pre">List&lt;Shape&gt;</span></span> and a <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> have no subtyping
relationship.</p>
<blockquote>
<div><p><strong>Invariance</strong></p>
<p>A type which ignores the subtyping relationship of its underlying type is
called invariant. A C# <span class="docutils literal"><span class="pre">List&lt;T&gt;</span></span> is invariant, because it ignores the
subtyping relationship “<span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>”, so
<span class="docutils literal"><span class="pre">List&lt;Shape&gt;</span></span> and <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> have no subtype-supertype
relationship.</p>
</div></blockquote>
<p>Now that we looked at how collections relate to each other in terms of
subtyping and saw two common types of variance, let’s see how function types
related to each other.</p>
</div>
<div class="section" id="subtyping-and-function-return-types">
<h2>Subtyping and Function Return Types</h2>
<p>We’ll start with the simpler case first: see what substitutions we can make
between a function that returns a <span class="docutils literal"><span class="pre">Triangle</span></span> and a function that returns a
<span class="docutils literal"><span class="pre">Shape</span></span>. We’ll declare two factory functions, a <span class="docutils literal"><span class="pre">makeShape()</span></span> which
returns a <span class="docutils literal"><span class="pre">Shape</span></span> and a <span class="docutils literal"><span class="pre">makeTriangle()</span></span> which returns a <span class="docutils literal"><span class="pre">Triangle</span></span>.</p>
<p>We’ll then implement a <span class="docutils literal"><span class="pre">useFactory()</span></span> function which takes a function of
type <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Shape</span></span> as argument and returns a <span class="docutils literal"><span class="pre">Shape</span></span>. We’ll try passing
<span class="docutils literal"><span class="pre">makeTriangle()</span></span> to it:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeTriangle</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeShape</span><span class="p">()</span><span class="o">:</span> <span class="nx">Shape</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">factory</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">Shape</span><span class="p">)</span><span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">factory</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">shape1</span>: <span class="kt">Shape</span> <span class="o">=</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">makeShape</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">shape2</span>: <span class="kt">Shape</span> <span class="o">=</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">makeTriangle</span><span class="p">);</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">useFactory()</span></span> takes a function with no arguments which returns a <span class="docutils literal"><span class="pre">Shape</span></span>
and calls it. Both <span class="docutils literal"><span class="pre">makeTriangle()</span></span> and <span class="docutils literal"><span class="pre">makeShape()</span></span> can be used as
arguments to <span class="docutils literal"><span class="pre">useFactory()</span></span>.</p>
<p>Nothing out of the ordinary here: we can pass a function that returns a
<span class="docutils literal"><span class="pre">Triangle</span></span> as a function that returns a <span class="docutils literal"><span class="pre">Shape</span></span>, because the return value
(a <span class="docutils literal"><span class="pre">Triangle</span></span>) is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, so we can assign it to a <span class="docutils literal"><span class="pre">Shape</span></span>.</p>
<img alt="../../../_images/function-returns.png" class="align-center" src="../../../_images/function-returns.png" />
<p>The opposite doesn’t work: if we change our <span class="docutils literal"><span class="pre">useFactory()</span></span> to expect a
<span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span> argument and try to pass it <span class="docutils literal"><span class="pre">makeShape()</span></span>, the code won’t
compile:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeTriangle</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeShape</span><span class="p">()</span><span class="o">:</span> <span class="nx">Shape</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">factory</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">Triangle</span><span class="p">)</span><span class="o">:</span> <span class="nx">Triangle</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">factory</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">shape1</span>: <span class="kt">Shape</span> <span class="o">=</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">makeShape</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">shape2</span>: <span class="kt">Shape</span> <span class="o">=</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">makeTriangle</span><span class="p">);</span>
</pre></div>
</div>
<p>We replaced <span class="docutils literal"><span class="pre">Shape</span></span> with <span class="docutils literal"><span class="pre">Triangle</span></span> in the <span class="docutils literal"><span class="pre">useFactory()</span></span> definition. The
code fails to compile: we can’t use <span class="docutils literal"><span class="pre">makeShape()</span></span> as a <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span>.</p>
<p>This is again pretty straightforward: we can’t use <span class="docutils literal"><span class="pre">makeShape()</span></span> as a function
of type <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span> because <span class="docutils literal"><span class="pre">makeShape()</span></span> returns a <span class="docutils literal"><span class="pre">Shape</span></span> object.
That object could be a <span class="docutils literal"><span class="pre">Triangle</span></span>, but it might be a <span class="docutils literal"><span class="pre">Square</span></span>.
<span class="docutils literal"><span class="pre">useFactory()</span></span> promises to return a <span class="docutils literal"><span class="pre">Triangle</span></span>, so it can’t return a
supertype of <span class="docutils literal"><span class="pre">Triangle</span></span>. It could, of course, return a subtype, like
<span class="docutils literal"><span class="pre">EquilateralTriangle</span></span>, given a <span class="docutils literal"><span class="pre">makeEquilateralTriangle()</span></span>.</p>
<p>Functions are covariant in their return types. In other words, if <span class="docutils literal"><span class="pre">Triangle</span></span>
is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, a function type like <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span> is a subtype
of a function <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Shape</span></span>. Note that the function types don’t have to
describe functions that don’t take any arguments. If <span class="docutils literal"><span class="pre">makeTriangle()</span></span> and
<span class="docutils literal"><span class="pre">makeShape()</span></span> both took a couple of number arguments, they would still be
covariant as we just saw.</p>
<p>This is the behavior followed by most mainstream programming languages. The
same rules are followed for overriding methods in inherited types, changing
their return type. If we implement a <span class="docutils literal"><span class="pre">ShapeMaker</span></span> class which provides a
<span class="docutils literal"><span class="pre">make()</span></span> method that returns a <span class="docutils literal"><span class="pre">Shape</span></span>, we can override it in a derived
class <span class="docutils literal"><span class="pre">TriangleMaker</span></span> to return <span class="docutils literal"><span class="pre">Triangle</span></span> instead. The compiler will
allow this, as calling either of the <span class="docutils literal"><span class="pre">make()</span></span> methods will give us a
<span class="docutils literal"><span class="pre">Shape</span></span> object:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nx">ShapeMaker</span> <span class="p">{</span>
    <span class="nx">make</span><span class="p">()</span><span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
        <span class="k">return</span> <span class="ow">new</span> <span class="nx">Shape</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">TriangleMaker</span> <span class="k">extends</span> <span class="nx">ShapeMaker</span> <span class="p">{</span>
    <span class="nx">make</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span> <span class="p">{</span>
        <span class="k">return</span> <span class="ow">new</span> <span class="nx">Triangle</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is, again, allowed behavior in most mainstream programming languages, as
most consider functions covariant in their return type. Let’s now see what
happens to function types whose argument types are subtypes of each other.</p>
</div>
<div class="section" id="subtyping-and-function-argument-types">
<h2>Subtyping and Function Argument Types</h2>
<p>We’ll turn things inside out, so instead of a function that returns a <span class="docutils literal"><span class="pre">Shape</span></span>
and a function that returns a <span class="docutils literal"><span class="pre">Triangle</span></span>, we’ll take a function that takes a
<span class="docutils literal"><span class="pre">Shape</span></span> as argument and a function that takes a <span class="docutils literal"><span class="pre">Triangle</span></span> as argument.
We’ll call these <span class="docutils literal"><span class="pre">drawShape()</span></span> and <span class="docutils literal"><span class="pre">drawTriangle()</span></span>. How do
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> relate to one
another?</p>
<p>Let’s introduce another function, <span class="docutils literal"><span class="pre">render()</span></span>, which takes as arguments a
<span class="docutils literal"><span class="pre">Triangle</span></span> and an <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> function. It simply calls
the given function with the given <span class="docutils literal"><span class="pre">Triangle</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">drawShape</span><span class="p">(</span><span class="nx">shape</span>: <span class="kt">Shape</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">drawTriangle</span><span class="p">(</span><span class="nx">triangle</span>: <span class="kt">Triangle</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span>
    <span class="nx">triangle</span>: <span class="kt">Triangle</span><span class="p">,</span>
    <span class="nx">drawFunc</span><span class="o">:</span> <span class="p">(</span><span class="nx">argument</span>: <span class="kt">Triangle</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="ow">void</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span> <span class="p">{</span>
    <span class="nx">drawFunc</span><span class="p">(</span><span class="nx">triangle</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">drawShape()</span></span> takes a <span class="docutils literal"><span class="pre">Shape</span></span> argument, <span class="docutils literal"><span class="pre">drawTriangle()</span></span> takes a
<span class="docutils literal"><span class="pre">Triangle</span></span> argument. <span class="docutils literal"><span class="pre">render()</span></span> expects a <span class="docutils literal"><span class="pre">Triangle</span></span> and a function that
takes a <span class="docutils literal"><span class="pre">Triangle</span></span> as argument. <span class="docutils literal"><span class="pre">render()</span></span> simply calls the provided
function passing it the triangle it received.</p>
<p>Here comes the interesting bit: in this case, we can safely pass
<span class="docutils literal"><span class="pre">drawShape()</span></span> to the <span class="docutils literal"><span class="pre">render()</span></span> function! That means we can use a
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> where an <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> is
expected.</p>
<p>Logically it makes sense: we have a <span class="docutils literal"><span class="pre">Triangle</span></span> and we pass it to a drawing
function which can use it as an argument. If the function itself expects a
<span class="docutils literal"><span class="pre">Triangle</span></span>, like our <span class="docutils literal"><span class="pre">drawTriangle()</span></span> function, then of course it works.
But it should also work for a function which expects a supertype of
<span class="docutils literal"><span class="pre">Triangle</span></span>: <span class="docutils literal"><span class="pre">drawShape()</span></span> wants a shape - any shape - to draw. Since it
doesn’t use anything that’s triangle-specific, it is more general than
<span class="docutils literal"><span class="pre">drawTriangle()</span></span>, it can accept any shape as argument, be it <span class="docutils literal"><span class="pre">Triangle</span></span> or
<span class="docutils literal"><span class="pre">Square</span></span>. So in this particular case, the subtyping relationship is reversed.</p>
<blockquote>
<div><p><strong>Contravariance</strong></p>
<p>A type which reverses the subtyping relationship of its underlying type is
called <em>contravariant</em>. In most programming languages, functions are
contravariant with regards to their arguments. A function which expects a
<span class="docutils literal"><span class="pre">Triangle</span></span> as argument can be substituted with a function which expects a
<span class="docutils literal"><span class="pre">Shape</span></span> as argument. The relationship of the functions is the reverse of
the relationship of the argument types: if <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype
<span class="docutils literal"><span class="pre">Shape</span></span>, the type of a function taking a <span class="docutils literal"><span class="pre">Triangle</span></span> as an argument is a
supertype of the type of a function taking a <span class="docutils literal"><span class="pre">Shape</span></span> as an argument.</p>
</div></blockquote>
<img alt="../../../_images/function-arguments.png" class="align-center" src="../../../_images/function-arguments.png" />
<p>We said “most programming languages” in the definition above. A notable
exception is TypeScript. In TypeScript, we can also do the opposite: pass a
function which expects a subtype instead of a function which expects a
supertype. This was an explicit design choice, to facilitate common JavaScript
programming patterns. It can lead to runtime issues though. Let’s look at an
example. We’ll first define a method <span class="docutils literal"><span class="pre">isRightAngled()</span></span> on our <span class="docutils literal"><span class="pre">Triangle</span></span>
type, which would determine whether a given instance describes a right-angled
triangle. The implementation of the method is not important:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="cm">/* Shape members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">TriangleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Triangle</span> <span class="k">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">TriangleType</span><span class="p">]</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>

    <span class="nx">isRightAngled</span><span class="p">()</span><span class="o">:</span> <span class="kt">boolean</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

        <span class="cm">/* Determine whether it is a right-angled triangle */</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* More Triangle members */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s reverse the drawing example and let’s say our <span class="docutils literal"><span class="pre">render()</span></span> function
expects a <span class="docutils literal"><span class="pre">Shape</span></span> instead of a <span class="docutils literal"><span class="pre">Triangle</span></span>, and a function which can draw
shapes <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> instead of a function which can only draw
triangles <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">drawShape</span><span class="p">(</span><span class="nx">shape</span>: <span class="kt">Shape</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">drawTriangle</span><span class="p">(</span><span class="nx">triangle</span>: <span class="kt">Triangle</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span>
    <span class="nx">shape</span>: <span class="kt">Shape</span><span class="p">,</span>
    <span class="nx">drawFunc</span><span class="o">:</span> <span class="p">(</span><span class="nx">argument</span>: <span class="kt">Shape</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="ow">void</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span> <span class="p">{</span>
    <span class="nx">drawFunc</span><span class="p">(</span><span class="nx">shape</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">drawShape()</span></span> and <span class="docutils literal"><span class="pre">drawTriangle()</span></span> are just like before. <span class="docutils literal"><span class="pre">render()</span></span> now
expects a <span class="docutils literal"><span class="pre">Shape</span></span> and a function that takes a <span class="docutils literal"><span class="pre">Shape</span></span> as argument.</p>
<p>Here’s how we can cause a runtime error: we can define <span class="docutils literal"><span class="pre">drawTriangle()</span></span> to
actually use something that is triangle-specific, like the <span class="docutils literal"><span class="pre">isRightAngled()</span></span>
method we just added. We then call <span class="docutils literal"><span class="pre">render()</span></span> with a <span class="docutils literal"><span class="pre">Shape</span></span> object (not a
<span class="docutils literal"><span class="pre">Triangle</span></span>) and <span class="docutils literal"><span class="pre">drawTriangle()</span></span>.</p>
<p>Now <span class="docutils literal"><span class="pre">drawTriangle()</span></span> will receive a <span class="docutils literal"><span class="pre">Shape</span></span> object and attempt to call
<span class="docutils literal"><span class="pre">isRightAngled()</span></span> on it, but since the <span class="docutils literal"><span class="pre">Shape</span></span> is not a <span class="docutils literal"><span class="pre">Triangle</span></span>, this
will cause an error:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">drawTriangle</span><span class="p">(</span><span class="nx">triangle</span>: <span class="kt">Triangle</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">isRightAngled</span><span class="p">());</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span>
    <span class="nx">shape</span>: <span class="kt">Shape</span><span class="p">,</span>
    <span class="nx">drawFunc</span><span class="o">:</span> <span class="p">(</span><span class="nx">argument</span>: <span class="kt">Shape</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="ow">void</span><span class="p">)</span><span class="o">:</span> <span class="ow">void</span> <span class="p">{</span>
    <span class="nx">drawFunc</span><span class="p">(</span><span class="nx">shape</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">render</span><span class="p">(</span><span class="ow">new</span> <span class="nx">Shape</span><span class="p">(),</span> <span class="nx">drawTriangle</span><span class="p">);</span>
</pre></div>
</div>
<p>We can pass a <span class="docutils literal"><span class="pre">Shape</span></span> and <span class="docutils literal"><span class="pre">drawTriangle()</span></span> to <span class="docutils literal"><span class="pre">render()</span></span>. This code will
compile but it will fail at runtime with a JavaScript error, since the runtime
won’t be able to find <span class="docutils literal"><span class="pre">isRightAngled()</span></span> on the <span class="docutils literal"><span class="pre">Shape</span></span> object we gave to
<span class="docutils literal"><span class="pre">drawTriangle()</span></span>. This is not ideal but, as mentioned before, it was a
conscious decision made during the implementation of TypeScript.</p>
<p>In TypeScript, if <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, a function of type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and a function of type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> can be substituted for each other. Effectively,
they are both subtypes of each other. This property is called <em>bivariance</em>.</p>
<blockquote>
<div><p><strong>Bivariance</strong></p>
<p>Types are <em>bivariant</em> if, from the subtyping relationship of their
underlying types, they become subtypes of each other. In TypeScript, if
<span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, the function types
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> are
subtypes of each other.</p>
</div></blockquote>
<img alt="../../../_images/bivariance.png" class="align-center" src="../../../_images/bivariance.png" />
<p>Again, the bivariance of functions with respect to their arguments in TypeScript
allows incorrect code to compile. We rely on static type checking to eliminate
runtime errors at compile time. For TypeScript it was a deliberate design
decision to enable common JavaScript programming patterns.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We looked at what types can be substituted with what other types. While
subtyping is straight-forward when dealing with simple inheritance, things get
more complicated when we add types parameterized on other types. These could
be collections, function types, or other generic types. The way the subtyping
relationships of these parameterized types is removed, preserved, reversed, or
made two-way based on the relationship of their underlying types is called
<em>variance</em>.</p>
<ul class="simple">
<li><em>Invariant</em> types ignore the subtyping relationship of their underlying types.</li>
<li><em>Covariant</em> types preserve the subtyping relationship of their underlying
types. If <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, an array of type
<span class="docutils literal"><span class="pre">Triangle[]</span></span> is a subtype of an array of type <span class="docutils literal"><span class="pre">Shape[]</span></span>. In most
programming languages, function types are covariant in their return types.</li>
<li><em>Contravariant</em> types reverse the subtyping relationship of their underlying
types. If <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, the function type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> is a subtype of the function type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> in most languages. This is not true for
TypeScript, where function types are bivariant with regards to their argument
types.</li>
<li><em>Bivariant</em> types are subtypes of each other when their underlying types are
in a subtyping relationship. If <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, the
function type <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and the function type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> are subtypes of each other (functions of
both types can be substituted for one another).</li>
</ul>
<p>While some common rules exist across programming languages, there is no one way
to support variance. You should understand what the type system of
your programming language does and how it establishes subtyping relationships.
This is important to know, as these rules tell us what can be substituted for
what. Do you need to implement a function to transform a <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> into
a <span class="docutils literal"><span class="pre">List&lt;Shape&gt;</span></span>, or can you just use the <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> as-is? It all
depends on the variance of <span class="docutils literal"><span class="pre">List&lt;T&gt;</span></span> in your programming language of choice.</p>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../../../2020/01/19/time-and-complexity.html">Time and Complexity</a></li>
            <li class="right"><a href="../08/notes-on-data-engineering.html">Notes on Data Engineering</a> &raquo; </li>
        </ul></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
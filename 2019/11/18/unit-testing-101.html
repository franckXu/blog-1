<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Unit Testing 101 &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Programming with Types RTM" href="../../10/16/programming-with-types-rtm.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/disqus.js"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>November 18, 2019</span>
        </div>
    <div class="section" id="unit-testing-101">
<h1>Unit Testing 101</h1>
<p>I wrote a while back about <a class="reference external" href="https://vladris.com/blog/2017/11/09/notes-on-unit-testing.html">unit testing</a>
from a philosophical perspective. This post is going to be more pragmatic. My
team is currently doing some MQ work which includes improving our unit test
story across the codebase. I put together a short unit tests 101 presentation
outlining some key principles:</p>
<ul class="simple">
<li>Run with each build</li>
<li>100% reliability</li>
<li>Test the public interface</li>
</ul>
<div class="section" id="run-with-each-build">
<h2>Run with Each Build</h2>
<p>Unit tests that don’t run aren’t very useful. I’ve seen projects before where
a unit test project does exist but the tests only run if manually executed.</p>
<p>The problem with this approach is that tests can stay not running for
days/weeks/months, and when they finally run, a bunch of them fail. Good luck
finding the change that introduced the regression. And wait, were we running
with that behavior all this time?</p>
<p>The biggest bang for the buck is making sure unit tests run as part of a
continuous integration build and pull requests get auto-rejected if a unit
test fails.</p>
</div>
<div class="section" id="reliability">
<h2>100% Reliability</h2>
<p>Once unit tests run with each build, the next most important thing to look
into is ensuring they pass consistently. Flaky unit tests are bad because
there’s no easy way to tell if a test run failed because of a regression or a
flaky test. Worst, if flaky tests are the standard, engineers start ignoring
the results. Hard to distill the signal from the noise in those situations.
Merge policies become more lax - after all, we can’t demand 100% green if
some unit tests randomly fail.</p>
<p>But stepping back, when are tests flaky? When they perform IO. Hitting the
network, connecting to a database, reading a file, these are all cases in
which a transient issue outside of our control can cause a test to fail.
That’s why unit tests shouldn’t perform IO, rather they should work against
mocks.</p>
<p>Let’s take, as an example, a method which performs a GET request and logs to
the console whether the request was successful:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span>
            <span class="s">&quot;https://www.example.com&quot;</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>

        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsSuccessStatusCode</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In its current form, the method isn’t really testable. Writing code without
thinking about testability yields such methods. We can refactor this to be
more testable. First, let’s put all IO behind interfaces:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">interface</span> <span class="n">IHttpClient</span>
<span class="p">{</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;</span> <span class="n">GetAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">interface</span> <span class="n">IOutput</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="kt">bool</span> <span class="k">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can update our <span class="docutils literal"><span class="pre">Example</span></span> to use these interfaces instead of directly
working with <span class="docutils literal"><span class="pre">HttpClient</span></span> and <span class="docutils literal"><span class="pre">Console</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">IHttpClient</span> <span class="n">client</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">IOutput</span> <span class="n">output</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Example</span><span class="p">(</span><span class="n">IHttpClient</span> <span class="n">client</span><span class="p">,</span> <span class="n">IOutput</span> <span class="n">output</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">client</span> <span class="p">=</span> <span class="n">client</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span>
            <span class="s">&quot;https://www.example.com&quot;</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>

        <span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsSuccessStatusCode</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We add adapters between the interfaces and the actual implementations:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HttpClientWrapper</span> <span class="p">:</span> <span class="n">IHttpClient</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">HttpClient</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;</span> <span class="n">GetAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ConsoleOutput</span> <span class="p">:</span> <span class="n">IOutput</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="kt">bool</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With these adapters, in our production code we can put together an instance
of <span class="docutils literal"><span class="pre">Example</span></span> that works just like the original, but which is componentized
enough that we can actually test it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">example</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Example</span><span class="p">(</span>
    <span class="k">new</span> <span class="nf">HttpClientWrapper</span><span class="p">(),</span>
    <span class="k">new</span> <span class="nf">ConsoleOutput</span><span class="p">());</span>
<span class="n">example</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>
</pre></div>
</div>
<p>In our test code, we can use a framework like Moq <a class="footnote-reference" href="#id2" id="id1">[1]</a> to set up mocks and
verify that the expected calls happen:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">mockClient</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Mock</span><span class="p">&lt;</span><span class="n">IHttpClient</span><span class="p">&gt;();</span>
<span class="n">mockClient</span><span class="p">.</span><span class="n">Setup</span><span class="p">(</span>
    <span class="n">client</span> <span class="p">=&gt;</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="s">&quot;https://www.example.com&quot;</span><span class="p">))</span>
    <span class="p">.</span><span class="n">Returns</span><span class="p">(</span><span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">HttpResponseMessage</span> <span class="p">{</span>
            <span class="n">StatusCode</span> <span class="p">=</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">OK</span>
        <span class="p">}));</span>

<span class="kt">var</span> <span class="n">mockOutput</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Mock</span><span class="p">&lt;</span><span class="n">IOutput</span><span class="p">&gt;();</span>
<span class="n">mockOutput</span><span class="p">.</span><span class="n">Setup</span><span class="p">(</span>
    <span class="n">output</span> <span class="p">=&gt;</span> <span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span>
        <span class="n">It</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;(</span><span class="k">value</span> <span class="p">=&gt;</span> <span class="k">value</span> <span class="p">==</span> <span class="k">true</span><span class="p">)));</span>

<span class="kt">var</span> <span class="n">example</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Example</span><span class="p">(</span>
    <span class="n">mockClient</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span>
    <span class="n">mockOutput</span><span class="p">.</span><span class="n">Object</span><span class="p">);</span>
<span class="n">example</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

<span class="n">mockOutput</span><span class="p">.</span><span class="n">VerifyAll</span><span class="p">();</span>
</pre></div>
</div>
<p>The above code sets up an <span class="docutils literal"><span class="pre">IHttpClient</span></span> mock implementation which so that
when <span class="docutils literal"><span class="pre">GetAsync()</span></span> is called with the argument <span class="docutils literal"><span class="pre">https://www.example.com</span></span>
it returns a <span class="docutils literal"><span class="pre">Task&lt;HttpResponseMessage&gt;</span></span> with a <span class="docutils literal"><span class="pre">StatusCode</span></span> of
<span class="docutils literal"><span class="pre">HttpStatusCode.OK</span></span>. The code also sets up an <span class="docutils literal"><span class="pre">IOutput</span></span> mock which
expects a <span class="docutils literal"><span class="pre">WriteLine()</span></span> call with a <span class="docutils literal"><span class="pre">true</span></span> argument.</p>
<p>We can initialize an instance of <span class="docutils literal"><span class="pre">Example</span></span> with these mocks, call
<span class="docutils literal"><span class="pre">Get()</span></span>, then verify <span class="docutils literal"><span class="pre">mockOutput</span></span> was used as expected.</p>
<div class="section" id="design-for-testability">
<h3>Design for Testability</h3>
<p>The general steps for making code testable:
* Extract interface (if one doesn’t exist already)
* Create adapters if concrete implementation doesn’t implement an interface
* Initialize class with real implementations in production
* Initialize class with mocks in tests
* Setup mocks to behave as required by each test
* Verify mocks</p>
<p>I will not talk about dependency injection in this post, but once all
components of the system expect several interfaces to run, it is worth
thinking about leveraging a DI framework to handle putting things together.</p>
<p>With this approach, we can make any component testable except the adapters.
By their nature, our adapters perform IO. We can’t reliably test
<span class="docutils literal"><span class="pre">HttpClientWrapper</span></span>. But such adapters shouldn’t contain any application
logic, they should be extremely thin, simply forwarding calls to the real
implementation. It’s perfectly fine to not test such trivial code.</p>
</div>
<div class="section" id="seams">
<h3>Seams</h3>
<p>Depending on the language, we can have several other ways to inject mocks. In
C++, for example, we can do it at compile-time, at link-time, or at run-time.</p>
<p>At compile-time, we can use a template parameter as the “interface”, have the
production version of the code instantiate it with one concrete
implementation and have the tests instantiate it with a mock:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TImpl</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">TImpl</span> <span class="n">impl</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">impl</span><span class="p">.</span><span class="n">Do</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteImpl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Concrete implementation</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MockImpl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Mock implementation</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ...</span>

<span class="n">Example</span><span class="o">&lt;</span><span class="n">ConcreteImpl</span><span class="o">&gt;</span> <span class="n">ex</span><span class="p">;</span>
</pre></div>
</div>
<p>At link-time, we can link against the concrete implementations in production
and against mock implementations in tests:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Impl</span> <span class="n">impl</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">impl</span><span class="p">.</span><span class="n">Do</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// In concrete implementation file:</span>
<span class="k">class</span> <span class="nc">Impl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Concrete implementation</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// In mock implementation file:</span>
<span class="k">class</span> <span class="nc">Impl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Mock implementation</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>At run-time, we can do something similar to our C# example above. There are
pros and cons with each approach. The run-time approach is what most
languages do, so easy to understand, though it adds more overhead. The
link-time approach is lean, but could end up being confusing: we have to
check makefiles to understand which code ends up in the binary and which code
doesn’t. The compile-time approach makes the code uglier, and requires making
implementation public.</p>
</div>
</div>
<div class="section" id="test-the-public-interface">
<h2>Test The Public Interface</h2>
<p>This one I did mention in my previous blog post to. The key point here is
that, while test frameworks usually provide various unnatural ways to access
an object’s internals, tests should focus on the public members.</p>
<p>The public members define the “contract” that a class provides. Tests should
ensure the contract is respected and not worry about the implementation. With
this approach, the implementation can easily be refactored and we know things
still work as expected as long as all tests pass. On the other hand, if we
have tests that cover various implementation details, they might break if we
move things around, even though the class still behaves correctly. In
general, having to update tests whenever we make tweaks to the implementation
is not ideal.</p>
<p>The other way to look at it is that if we have some code deep in the
implementation that can’t be reached through the public members, then it is
likely dead code.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Unit tests should run as part of continuous integration, otherwise they
aren’t really useful.</li>
<li>Unit tests have to be 100% reliable. We achieve this by isolating IO and
mocking it in tests.</li>
<li>Testability recipe:<ul>
<li>Code against interfaces, declare interfaces if none are available</li>
<li>Use thin adapters to make any concrete implementation compatible with any
interface</li>
<li>Use concrete implementations in production and mocks in tests</li>
</ul>
</li>
<li>In some languages there are multiple seams where we can inject mocks. In C++
we can do it at compile-time, at link-time, and at run-time. Each has its pros
and cons.</li>
<li>Test the public interface not the implementation.</li>
</ul>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Moq is my favorite C# mocking library: <a class="reference external" href="https://github.com/moq/moq4">https://github.com/moq/moq4</a>.</td></tr>
</tbody>
</table>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="../../10/16/programming-with-types-rtm.html">Programming with Types RTM</a> &raquo; </li>
        </ul><div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "vladris";    var disqus_identifier = "2019/11/18/unit-testing-101";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Common Algorithms &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="A Switchless State Machine" href="../../07/16/a-switchless-state-machine.html" /><link rel="prev" title="Higher Kinded Types: Functors" href="../../09/06/higher-kinded-types-functors.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/disqus.js"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>August 10, 2019</span>
        </div>
    <div class="section" id="common-algorithms">
<h1>Common Algorithms</h1>
<p>This blog post is an excerpt from my book, <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>. The code samples
are in TypeScript. If you enjoy the article, you can use the discount code
<strong>vlri40</strong> for a 40% discount on the book.</p>
<div class="section" id="a-few-common-algorithms">
<h2>A Few Common Algorithms</h2>
<p>There are many algorithms commonly used to process a sequence of data. Let’s
list a few of them. We will not look at the implementation, just describe what
arguments besides the iterable they expect and how they process the data. We’ll
also mention some synonyms under which the algorithm might appear.</p>
<ul class="simple">
<li><span class="docutils literal"><span class="pre">map()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values, a function <span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span>
and returns a sequence of <span class="docutils literal"><span class="pre">U</span></span> values applying the function to all the
elements in the sequence. It is also known as <span class="docutils literal"><span class="pre">fmap()</span></span>, <span class="docutils literal"><span class="pre">select()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">filter()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values, a predicate
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">boolean</span></span> and returns a sequence of <span class="docutils literal"><span class="pre">T</span></span> values containing
all the items for which the predicate returns true. It is also known as
<span class="docutils literal"><span class="pre">where()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">reduce()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values, an initial value of type
<span class="docutils literal"><span class="pre">T</span></span>, and an operation which combines two <span class="docutils literal"><span class="pre">T</span></span> values into one
<span class="docutils literal"><span class="pre">(x:</span> <span class="pre">T,</span> <span class="pre">y:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">T</span></span>. It returns a single value <span class="docutils literal"><span class="pre">T</span></span> after combining all the
elements in the sequence using the operation. It is also known as <span class="docutils literal"><span class="pre">fold()</span></span>,
<span class="docutils literal"><span class="pre">collect()</span></span>, <span class="docutils literal"><span class="pre">accumulate()</span></span>, <span class="docutils literal"><span class="pre">aggregate()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">any()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a predicate
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">boolean</span></span>. It returns true if any one of the elements of the
sequence satisfies the predicate.</li>
<li><span class="docutils literal"><span class="pre">all()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a predicate
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">boolean</span></span>. It returns true if all of the elements of the
sequence satisfy the predicate.</li>
<li><span class="docutils literal"><span class="pre">none()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a predicate
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">boolean</span></span>. It returns true if none of the elements of the
sequence satisfy the predicate.</li>
<li><span class="docutils literal"><span class="pre">take()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a number <span class="docutils literal"><span class="pre">n</span></span>. It returns a
sequence consisting of the first <span class="docutils literal"><span class="pre">n</span></span> elements of the original sequence. It
is also known as <span class="docutils literal"><span class="pre">limit()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">drop()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a number <span class="docutils literal"><span class="pre">n</span></span>. It returns a
sequence consisting of all the elements of the original sequence except the
first <span class="docutils literal"><span class="pre">n</span></span>. The first <span class="docutils literal"><span class="pre">n</span></span> elements are dropped. It is also known as
<span class="docutils literal"><span class="pre">skip()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">zip()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a sequence of <span class="docutils literal"><span class="pre">U</span></span> values. It
returns a sequence containing pairs of <span class="docutils literal"><span class="pre">T</span></span> and <span class="docutils literal"><span class="pre">U</span></span> values, effectively
“zipping” together the two sequences.</li>
</ul>
<p>There are many more algorithms for sorting, reversing, splitting and
concatenating sequences. The good news is that, because these algorithms are
so useful and generally applicable, we don’t need to implement them. Most
languages have libraries which provide these algorithms and more. For
JavaScript, there is the <span class="docutils literal"><span class="pre">underscore.js</span></span> package and the <span class="docutils literal"><span class="pre">lodash</span></span>
package, both providing a plethora of such algorithms (at the time of
writing, these libraries don’t support iterators, only the JavaScript
built-in array and object types). In Java, they are found in the
<span class="docutils literal"><span class="pre">java.util.stream</span> <span class="pre">package</span></span>. In C# they are in the <span class="docutils literal"><span class="pre">System.Linq</span></span>
namespace. In C++ they are found in the <span class="docutils literal"><span class="pre">&lt;algorithm&gt;</span></span> standard library
header.</p>
</div>
<div class="section" id="algorithms-instead-of-loops">
<h2>Algorithms Instead of Loops</h2>
<p>While you might be surprised, a good rule of thumb is to check, whenever you
find yourself writing a loop, whether there is a library algorithm or a
pipeline that can do the job. Usually we write loops to process a sequence –
exactly what the algorithms we talked about do.</p>
<p>The reason to prefer library algorithms to custom code in loops is that there
is less opportunity for mistakes: library algorithms are tried and tested,
implemented efficiently, and the code we end up with is easier to understand
as the operations are spelled out.</p>
</div>
<div class="section" id="implementing-a-fluent-pipeline">
<h2>Implementing a Fluent Pipeline</h2>
<p>Most libraries also provide a fluent API to chain algorithms together into a
pipeline. Fluent APIs are APIs based on method chaining, making the code much
easier to read. To see the difference between a fluent and a non-fluent API,
let’s take a look at a simple filter/reduce pipeline.</p>
<p>Let’s start with a simple implementation of the two algorithms. To implement
<span class="docutils literal"><span class="pre">filter()</span></span> we can use a generator. We take an <span class="docutils literal"><span class="pre">Itreable&lt;T&gt;</span></span> as the input
sequence and a predicate from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">boolean</span></span>, and return another
sequence as an <span class="docutils literal"><span class="pre">IterableIterator&lt;T&gt;</span></span>. <span class="docutils literal"><span class="pre">ItreableIterator</span></span> is the return
type of all generators in TypeScript. The function will simply traverse the
sequence and for each element, if the predicate returns true, yield the
element to the caller:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="o">*</span><span class="nx">filter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">items</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nx">pred</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)</span>
    <span class="o">:</span><span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">item</span> <span class="nx">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pred</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">yield</span> <span class="nx">item</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">reduce()</span></span> takes an <span class="docutils literal"><span class="pre">Iterable&lt;T&gt;</span></span> as the input sequence and an initial
value of type <span class="docutils literal"><span class="pre">T</span></span>. It also takes a function <span class="docutils literal"><span class="pre">(T,</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">T</span></span> which combines
(reduces) two values of type <span class="docutils literal"><span class="pre">T</span></span> into one. This function iterates over the
sequence and reduces all the elements to a single value, which it returns:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">reduce</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">items</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nx">init</span>: <span class="kt">T</span><span class="p">,</span>
    <span class="nx">op</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">)</span>
    <span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">T</span> <span class="o">=</span> <span class="nx">init</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">item</span> <span class="nx">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s look at how we could combine these algorithms into a pipeline which
sums up all even values of an array. We will pass the array to <span class="docutils literal"><span class="pre">filter()</span></span>
first, with a predicate which returns true for even numbers. Next, we will
reduce the resulting sequence using an initial value of 0 and the function
<span class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">=&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">sequence</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>

<span class="kr">const</span> <span class="nx">result</span>: <span class="kt">number</span> <span class="o">=</span>
    <span class="nx">reduce</span><span class="p">(</span>
        <span class="nx">filter</span><span class="p">(</span>
            <span class="nx">sequence</span><span class="p">,</span>
            <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Even though we apply <span class="docutils literal"><span class="pre">filter()</span></span> first, then pass the result to <span class="docutils literal"><span class="pre">reduce()</span></span>,
if we read the code from left to right, we see <span class="docutils literal"><span class="pre">reduce()</span></span> before
<span class="docutils literal"><span class="pre">filter()</span></span>. It’s also a bit hard to make sense of which arguments go with
which function in the pipeline. Fluent APIs make the code much easier to read.
Currently, all our algorithms take an iterable as the first argument and
return an iterable. We can use object-oriented programming to improve our API.
We can put all our algorithms into a class which wraps an iterable. Then we
can call any of them without explicitly providing an iterable as the first
argument – the iterable is a member of the class. Let’s do this for
<span class="docutils literal"><span class="pre">map()</span></span>, <span class="docutils literal"><span class="pre">filter()</span></span>, and <span class="docutils literal"><span class="pre">reduce()</span></span>, by grouping them into a new
<span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> class wrapping an iterable:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">FluentIterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">iter</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="nx">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">yield</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="nx">filter</span><span class="p">(</span><span class="nx">pred</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="nx">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">pred</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">yield</span> <span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">reduce</span><span class="p">(</span><span class="nx">init</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">op</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">T</span> <span class="o">=</span> <span class="nx">init</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="nx">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can create a <span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> out of an <span class="docutils literal"><span class="pre">Iterable&lt;T&gt;</span></span>, so we can
rewrite our filter/reduce pipeline into a more fluent form. We create a
<span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span>, call <span class="docutils literal"><span class="pre">filter()</span></span> on it, then we create a new
<span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> out of its result, and call <span class="docutils literal"><span class="pre">reduce()</span></span> on it:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">sequence</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>

<span class="kr">const</span> <span class="nx">result</span>: <span class="kt">number</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span>
            <span class="nx">sequence</span>
        <span class="p">).</span><span class="nx">filter</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Now <span class="docutils literal"><span class="pre">filter()</span></span> appears before <span class="docutils literal"><span class="pre">reduce()</span></span>, and it’s very clear which
arguments go to which function. The only problem is we need to create a new
<span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> after each function call. We can improve our API by
having our <span class="docutils literal"><span class="pre">map()</span></span> and <span class="docutils literal"><span class="pre">filter()</span></span> functions return a <span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span>
instead of the default <span class="docutils literal"><span class="pre">IterableIterator&lt;T&gt;</span></span>. Note we don’t need to change
<span class="docutils literal"><span class="pre">reduce()</span></span>, because <span class="docutils literal"><span class="pre">reduce()</span></span> returns a single value of type <span class="docutils literal"><span class="pre">T</span></span>, not
an iterable.</p>
<p>Since we’re using generators, we can’t simply change the return type. Generators
exist to provide convenient syntax for functions, but they always return an
<span class="docutils literal"><span class="pre">IterableIterator&lt;T&gt;</span></span>. What we can do instead is to move the implementations
to a couple of private methods, <span class="docutils literal"><span class="pre">mapImpl()</span></span> and <span class="docutils literal"><span class="pre">filterImpl()</span></span>, and handle
the conversion from <span class="docutils literal"><span class="pre">IterableIterator&lt;T&gt;</span></span> to <span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> in the
public <span class="docutils literal"><span class="pre">map()</span></span> and <span class="docutils literal"><span class="pre">reduce()</span></span> methods:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">FluentIterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">iter</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">FluentIterable</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">mapImpl</span><span class="p">(</span><span class="nx">func</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kr">private</span> <span class="o">*</span><span class="nx">mapImpl</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="nx">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">yield</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">filter</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">pred</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">FluentIterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">filterImpl</span><span class="p">(</span><span class="nx">pred</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kr">private</span> <span class="o">*</span><span class="nx">filterImpl</span><span class="p">(</span><span class="nx">pred</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="nx">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">pred</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
                <span class="nx">yield</span> <span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">reduce</span><span class="p">(</span><span class="nx">init</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">op</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">T</span> <span class="o">=</span> <span class="nx">init</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">value</span> <span class="nx">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this updated implementation, we can more easily chain the algorithms, as
each returns a <span class="docutils literal"><span class="pre">FluentIterable</span></span>, which contains all the algorithms as
methods:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">sequence</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>

<span class="kr">const</span> <span class="nx">result</span>: <span class="kt">number</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span><span class="nx">sequence</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, in true fluent fashion, the code reads easily from left to right and we
can chain any number of algorithms that make up our pipeline with a very
natural syntax. Most algorithm libraries take a similar approach, making it
as easy as possible to chain multiple algorithms together.</p>
<p>Depending on the programming language, one downside of a fluent API approach
is that our <span class="docutils literal"><span class="pre">FluentIterable</span></span> ends up containing all the algorithms, so it is
difficult to extend - if it is part of a library, calling code can’t easily
add a new algorithm without modifying the class. C# provides extension
methods, which enable us to add methods to a class or interface without
modifying its code. Not all languages have such features though. That being
said, in most situations you should be using an existing algorithm library,
not implementing a new one from scratch.</p>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../../09/06/higher-kinded-types-functors.html">Higher Kinded Types: Functors</a></li>
            <li class="right"><a href="../../07/16/a-switchless-state-machine.html">A Switchless State Machine</a> &raquo; </li>
        </ul><div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "vladris";    var disqus_identifier = "2019/08/10/common-algorithms";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Home &mdash; Blog</title>
            <link rel="stylesheet" href="_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="_static/main.css" type="text/css">
            <link rel="stylesheet" href="_static/flat.css" type="text/css">
            <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/main.js"></script>
        <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script><script type="text/javascript" src="_static/disqus.js"></script><script type="text/javascript" src="_static/google_analytics.js"></script><link rel="stylesheet" href="_static/extra.css" type="text/css" /></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>July 06, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/07/06/dependency-injection-in-c.html">Dependency Injection in C++</a></h1>
<p>In this post, I will switch gears from functional C++ to object oriented C++ and
talk about dependency injection.</p>
<p>Let’s start with a simple example: take a <span class="docutils literal"><span class="pre">Car</span></span> class with a <span class="docutils literal"><span class="pre">Drive()</span></span>
method. Let’s say this class contains a <span class="docutils literal"><span class="pre">V8Engine</span></span> attribute with <span class="docutils literal"><span class="pre">Start()</span></span>
and <span class="docutils literal"><span class="pre">Stop()</span></span> methods. An initial implementation might look like this:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">V8Engine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="dependency-injection-with-interfaces">
<h2>Dependency Injection with Interfaces</h2>
<p>In the above example, <span class="docutils literal"><span class="pre">Car</span></span> is tightly coupled to <span class="docutils literal"><span class="pre">V8Engine</span></span>, meaning we
can’t create a car without a concrete engine implementation. If we want the
ability to swap various engines or use a mock engine during testing, we could
reverse the dependency by creating an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and decoupling
<span class="docutils literal"><span class="pre">Car</span></span> from the concrete <span class="docutils literal"><span class="pre">V8Engine</span></span> implementation. This way, we only expose
an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and a factory function. <span class="docutils literal"><span class="pre">Car</span></span> can work against that:</p>
<p><em>IEngine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">();</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* start the engine */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* stop the engine */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="notes">
<h2>Notes</h2>
<div class="section" id="a-note-on-headers">
<h3>A note on headers</h3>
<p>Headers simply get textually included in each compilation unit by the
<span class="docutils literal"><span class="pre">#include</span></span> directive. It is not mandatory to provide a header file for each
class declaration. If a class can be scoped to a single source file, then it
doesn’t need a header declaration (for example the <span class="docutils literal"><span class="pre">V8Engine</span></span> class above
does not need a V8Engine.h header corresponding to the V8Engine.cpp). It is also
a good idea to have public headers and internal headers: public headers contain
the public API surface and can be included by other parts of the system, while
internal headers are only used within the component and should not be included
by external code.</p>
<p>Default should be the least visible: try to keep everything inside the cpp file
(like V8Engine.cpp). If that is not enough, an internal header might do. A
declartion should be pulled into a public header only when external components
need to reference it.</p>
</div>
<div class="section" id="a-note-on-interfaces">
<h3>A note on interfaces</h3>
<p>It’s a good idea to declare a default virtual destructor: if a deriving type has
a destructor, it won’t get called if we store an upcast pointer to the interface
unless the interface declares a virtual destructor. Note a destructor does not
to be expicitly defined - compiler might generate a default one.</p>
<p>MSVC compiler provides a <span class="docutils literal"><span class="pre">__declspec(novtable)</span></span> <a class="footnote-reference" href="#id2" id="id1">[1]</a> custom attribute which
tells the compiler not to generate a vtable for pure abstract classes. This
reduces code size. Below is the <span class="docutils literal"><span class="pre">IEngine</span></span> declaration with this attribute:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">novtable</span><span class="p">)</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>I won’t include it in the code samples in this post, but it’s worth keeping in
mind when working with MSVC.</p>
</div>
<div class="section" id="a-note-on-factory-functions">
<h3>A note on factory functions</h3>
<p>When working with interfaces as opposed to concrete types, we use factory
functions to get object instances. Below is a possible naming convention, taking
object ownership into account:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">MakeFoo</span><span class="p">();</span>
<span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">GetFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>The first function, <span class="docutils literal"><span class="pre">MakeFoo</span></span>, returns a unique pointer, passing ownership to
the caller. Like in the example above, the <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> can be moved into the
object, which ends up owning it. Use a Make when each call creates a new
instance.</p>
<p>The second function implies there already exists an <span class="docutils literal"><span class="pre">IFoo</span></span> object which is
owned by someone else, with the guarantee that it will outlive the caller. In
that case, there is no need for pointers and we can simply return a reference to
the object. This can be used, for example, for singletons. Below is an example
of a singleton <span class="docutils literal"><span class="pre">Engine</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">UseEngine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The third function, <span class="docutils literal"><span class="pre">GetFoo</span></span>, implies shared ownership - we get an object that
other objects might hold a reference to, but we don’t have the lifetime
guarantee a singleton would give us, so we need to use a shared pointer to make
sure the object is kept alive long enough.</p>
</div>
</div>
<div class="section" id="mocking">
<h2>Mocking</h2>
<p>Since <span class="docutils literal"><span class="pre">Car</span></span> now works with an <span class="docutils literal"><span class="pre">IEngine</span></span> interface, in test code we can mock
the engine:</p>
<p><em>Test.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span> <span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also expose <span class="docutils literal"><span class="pre">Car</span></span> as a simple interface, hiding its implementation
details, in which case we would end up with the following:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would become:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">car</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test ICar without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note this allows the caller to pass in any <span class="docutils literal"><span class="pre">IEngine</span></span>. We provide an
out-of-the-box <span class="docutils literal"><span class="pre">V8Engine</span></span> but other engines can be injected when <span class="docutils literal"><span class="pre">Car</span></span> gets
constructed. The headers IEngine.h and ICar.h are public per our above
defintion.</p>
<p>In general, it’s great if we can get the rest of the component code and unit
tests to work against the interface. Sometimes though we might need to know more
about the actual implementation inside our component, even if externally we only
expose an interface. In that case, we can add an internal Car.h header:</p>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em> becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can include the internal header, and, while not necessarily recommended,
we can cast <span class="docutils literal"><span class="pre">ICar</span></span> to <span class="docutils literal"><span class="pre">Car</span></span> inside the component:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">icar</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">MakeV8Engine</span><span class="p">());</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">car</span><span class="p">);</span>
</pre></div>
</div>
<p>Another trick if needing access to internals (again, not something necessarily
recommended), is to make the unit test class testing <span class="docutils literal"><span class="pre">Car</span></span> a friend of the
<span class="docutils literal"><span class="pre">Car</span></span> class, in which case it can access its private members.</p>
<p>In summary, with this approach we are able to:</p>
<ul class="simple">
<li>Hide implementation details in the .cpp files</li>
<li>Work against abstract interfaces</li>
<li>Inject dependencies during object construction</li>
</ul>
</div>
<div class="section" id="dependecy-injection-with-templates">
<h2>Dependecy Injection with Templates</h2>
<p>An alternative to the above is to use templates. In this case, we would have to
provide the implementation inside the header file, as code needs to be available
when templates get instantiated:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note <span class="docutils literal"><span class="pre">Car</span></span> is implemented in the header and <span class="docutils literal"><span class="pre">V8Engine</span></span> is also a publicly
visible header. Now we can create an instance of <span class="docutils literal"><span class="pre">Car</span></span> like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="p">...</span>

<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
</pre></div>
</div>
<p>Mocking the engine in test code would look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach we are able to:</p>
<ul class="simple">
<li>Inject dependencies during template instantiation</li>
<li>No need for virtual calls (note <span class="docutils literal"><span class="pre">TEngine</span></span> is not an interface, so calls can
be resolved at compile-time)</li>
<li><span class="docutils literal"><span class="pre">Car&lt;T&gt;</span></span> can be default-constructed</li>
</ul>
<p>A drawback here is we expose the implementation details of <span class="docutils literal"><span class="pre">Car</span></span> inside the
header file and we have to make this publicly visible.</p>
</div>
<div class="section" id="hybrid-approach">
<h2>Hybrid Approach</h2>
<p>We can use a hybrid approach if we don’t need an extrnally injected <span class="docutils literal"><span class="pre">Engine</span></span>.
Say our component provides a <span class="docutils literal"><span class="pre">V8Engine</span></span>, a <span class="docutils literal"><span class="pre">V6Engine</span></span>, and we have a
<span class="docutils literal"><span class="pre">MockEngine</span></span> used during testing. We have the same componentization
requirements but don’t need to expose all the details to consumers. In that case
we could have something like this:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
</pre></div>
</div>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"V6Engine.h"</span><span class="cp"/>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V6Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would remain the same as in the example above, where we worked against a
<span class="docutils literal"><span class="pre">Car</span></span> type (not an <span class="docutils literal"><span class="pre">ICar</span></span>) which we instantiate with a <span class="docutils literal"><span class="pre">MockEngine</span></span>.</p>
<p>With this approach:</p>
<ul class="simple">
<li>Our external API is an interface</li>
<li>Internally we still inject the dependency using a template</li>
</ul>
<p>With this approach, we do have an interface and virtual calls for <span class="docutils literal"><span class="pre">Car</span></span> but
not for <span class="docutils literal"><span class="pre">TEngine</span></span> types. One drawback with this approach is that consumers
cannot inject their own Engine type: we can only create cars with engines that
are known within our component.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We decoupled <span class="docutils literal"><span class="pre">Car</span></span> from <span class="docutils literal"><span class="pre">V8Engine</span></span> and looked at three ways of injecting
the dependency:</p>
<ul class="simple">
<li>Using interfaces, where dependency is injected at runtime during object
creation</li>
<li>Using templates, where dependency is injected at compile-time during template
instantiation</li>
<li>A hybrid approach which uses templates internally but exposes only interfaces
publicly</li>
</ul>
<p>Each of these approaches has pros and cons, the tradeoffs mostly being around
encapsulation (how much of the component code we expose publicly), runtime
(templates are instantiated at compile-time so no virtual calls etc.), type
constraints (with templates we don’t require engines to implement a particular
<span class="docutils literal"><span class="pre">IEngine</span></span> interface), and flexibility (with the hybrid approach we can’t
inject an external engine, we can only use what the component has available
internally).</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For more details on <span class="docutils literal"><span class="pre">novtable</span></span>, see <a class="reference external" href="https://msdn.microsoft.com/en-us/library/k13k85ky.aspx">MSDN</a>.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/07/06/dependency-injection-in-c.html#disqus_thread" data-disqus-identifier="2016/07/06/dependency-injection-in-c">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>May 07, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/05/07/deconstructing-quicksort.html">Deconstructing Quicksort</a></h1>
<div class="section" id="quicksort-in-haskell-and-c">
<h2>Quicksort in Haskell and C</h2>
<p>The <a class="reference external" href="https://wiki.haskell.org/Introduction">Introduction on the Haskell wiki</a>
shows how quicksort can be implemented in Haskell compared to C. The Haskell
implementation looks like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="nf">quicksort</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">quicksort</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">quicksort</span> <span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">quicksort</span> <span class="n">lesser</span><span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="p">(</span><span class="n">quicksort</span> <span class="n">greater</span><span class="p">)</span>
    <span class="kr">where</span>
        <span class="n">lesser</span>  <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
        <span class="n">greater</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
</div>
<p>The proposed C implementation looks like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="c1">// To sort array a[] of size n: qsort(a,0,n-1)</span>
<span class="kt">void</span> <span class="nf">qsort</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">hi</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">hi</span><span class="p">];</span>

    <span class="k">do</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">((</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">))</span>
          <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">((</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">))</span>
          <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
          <span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
          <span class="n">a</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">);</span>

    <span class="n">a</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
    <span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

    <span class="n">qsort</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">l</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
    <span class="n">qsort</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">hi</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ugly. Hard to read. Not very expressive. To quote the wiki page:</p>
<blockquote>
<div>Whereas the C program describes the particular steps the machine must make
to perform a sort – with most code dealing with the low-level details of
data manipulation – the Haskell program encodes the sorting algorithm at a
much higher level, with improved brevity and clarity as a result (at the
cost of efficiency unless compiled by a very smart compiler).</div></blockquote>
<p>So the above C implementation doesn’t really make the algorithm obvious, rather
it outlines the steps the machine needs to take to implement it. Can we do
better in C++? The main disadvantage of Haskell, as outlined on the wiki, is
that it doesn’t perform the sort in-place, so lots of data gets allocated and
freed while running the sort. How would an in-place quicksort look like in C++?
Could we write it so that the algorithm stands out, as opposed to the machine
instructions?</p>
</div>
<div class="section" id="id1">
<h2>Deconstructing Quicksort</h2>
<p>So how does quicksort work? Given a list of elements, it picks a pivot element,
partitions the list so that all elements smaller than the pivot go to its left
and the elements larger than the pivot go to its right, then the algorithm is
recursively applied to the left and right lists. An empty list is already
sorted, so that’s where the recursion stops.</p>
<p>Let’s review the Haskell implementation. Quicksort stops when the list is empty:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="nf">quicksort</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>For a non-empty list, pick the head as the pivot and recursively apply
quicksort to elements lesser and greater than the pivot (concatenating back the
results):</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="nf">quicksort</span> <span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">quicksort</span> <span class="n">lesser</span><span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="p">(</span><span class="n">quicksort</span> <span class="n">greater</span><span class="p">)</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">lesser</span></span> and <span class="docutils literal"><span class="pre">greater</span></span> are obtained by filtering the list using <span class="docutils literal"><span class="pre">&lt;</span> <span class="pre">p</span></span> and
<span class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">p</span></span> as predicates:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="kr">where</span>
    <span class="n">lesser</span>  <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
    <span class="n">greater</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
</div>
<p>In C++, one way to implement quicksort is this <a class="footnote-reference" href="#id4" id="id2">[1]</a>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">I</span> <span class="n">f</span><span class="p">,</span> <span class="n">I</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">stable_partition</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span>
        <span class="p">[</span><span class="n">pivot</span> <span class="o">=</span> <span class="o">*</span><span class="n">f</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elem</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">;</span> <span class="p">});</span>

    <span class="n">quicksort</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="n">quicksort</span><span class="p">(</span><span class="o">++</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pretty concise. We use iterators, so <span class="docutils literal"><span class="pre">I</span></span> here would be an iterator over the
container we want to sort. <span class="docutils literal"><span class="pre">f</span></span> and <span class="docutils literal"><span class="pre">l</span></span> are the iterators to the start and
end of the range. Note iterators denote half-open ranges <span class="docutils literal"><span class="pre">[f,</span> <span class="pre">l)</span></span>, so <span class="docutils literal"><span class="pre">l</span></span>
does not have to point to a valid element (it points to “after the last element
in the range”).</p>
<p>We introduced <span class="docutils literal"><span class="pre">stable_partition</span></span>, an algorithm which, given a range and a
predicate, partitions the range such that the elements which satisfy the
predicate appear before the elements which don’t satisfy the predicate. It is
stable because it won’t change the relative order of elements in either of the
two groups. For example, applying <span class="docutils literal"><span class="pre">stable_partition</span></span> to <span class="docutils literal"><span class="pre">5</span> <span class="pre">4</span> <span class="pre">3</span> <span class="pre">2</span> <span class="pre">1</span></span> with
the predicate <span class="docutils literal"><span class="pre">&lt;</span> <span class="pre">3</span></span> would always yield <span class="docutils literal"><span class="pre">2</span> <span class="pre">1</span> <span class="pre">5</span> <span class="pre">4</span> <span class="pre">3</span></span> - first group is <span class="docutils literal"><span class="pre">2</span> <span class="pre">1</span></span>
(<span class="docutils literal"><span class="pre">&lt;</span> <span class="pre">3</span></span>), second group is <span class="docutils literal"><span class="pre">5</span> <span class="pre">4</span> <span class="pre">3</span></span> (<span class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">3</span></span>) and the relative order of
elements in each group is the same as in the initial range (<span class="docutils literal"><span class="pre">2</span></span> before <span class="docutils literal"><span class="pre">1</span></span>,
<span class="docutils literal"><span class="pre">5</span></span> before <span class="docutils literal"><span class="pre">4</span></span> before <span class="docutils literal"><span class="pre">3</span></span>). <span class="docutils literal"><span class="pre">stable_partition</span></span> returns an iterator to
the first element not satisfying the predicate (in this case the iterator would
point to <span class="docutils literal"><span class="pre">5</span></span>).</p>
<p>Line by line, if the range is empty, stop:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>Get an iterator to the position of the pivot element, using <span class="docutils literal"><span class="pre">stable_partition</span></span>
and the predicate “less than the value of the pivot”:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">stable_partition</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span>
    <span class="p">[</span><span class="n">pivot</span> <span class="o">=</span> <span class="o">*</span><span class="n">f</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elem</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
<p>The lambda captures the value of <span class="docutils literal"><span class="pre">*f</span></span> and uses it in the predicate
<span class="docutils literal"><span class="pre">elem</span> <span class="pre">&lt;</span> <span class="pre">pivot</span></span>. After this step, our range is partitioned and we have an
iterator to the new position of the pivot. We need to recursively sort the
range from the first element up to the pivot:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">quicksort</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<p>Then we also need to sort the range from the element next to the pivot up to the
last element:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">quicksort</span><span class="p">(</span><span class="o">++</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
</pre></div>
</div>
<p>Done.</p>
</div>
<div class="section" id="stable-partition">
<h2>Stable Partition</h2>
<p>This might arguably sound like cheating a bit, since we introduced
<span class="docutils literal"><span class="pre">stable_partition</span></span>. On the other hand, <span class="docutils literal"><span class="pre">stable_partition</span></span> is a standard
algorithm and the Haskell implementation uses <span class="docutils literal"><span class="pre">filter</span></span> itself. I will stop
the Haskell comparison here <a class="footnote-reference" href="#id5" id="id3">[2]</a> and attempt to decompose further, so in the end
we have a quicksort built out of nice functional building blocks.</p>
<p>So far we have a recursive quicksort implementation which uses
<span class="docutils literal"><span class="pre">stable_partition</span></span>. How would we go about implementing <span class="docutils literal"><span class="pre">stable_partition</span></span>?
Here is one way to do it:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">P</span><span class="o">&gt;</span> <span class="n">I</span> <span class="n">stable_partition</span><span class="p">(</span><span class="n">I</span> <span class="n">f</span><span class="p">,</span> <span class="n">I</span> <span class="n">l</span><span class="p">,</span> <span class="n">P</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">f</span> <span class="o">+</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">stable_partition</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">pred</span><span class="p">),</span>
                  <span class="n">m</span><span class="p">,</span>
                  <span class="n">stable_partition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">pred</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a recursive implementation with the following basic idea: we stop if we
have an empty range or a range with a single element. Otherwise we divide the
range in two by finding the middle point. We then recursively partition the
ranges left and right of the midpoint. After this is done, we have two consecutive
ranges which are both partitioned, it’s just that the elements satisfying the
predicate in the right range should come before the elements not satisfying the
predicate in the left range. We need to rotate them around the midpoint.</p>
<p>Let’s take as an example the range over <span class="docutils literal"><span class="pre">10</span> <span class="pre">1</span> <span class="pre">9</span> <span class="pre">2</span> <span class="pre">8</span> <span class="pre">3</span> <span class="pre">7</span> <span class="pre">4</span> <span class="pre">6</span> <span class="pre">5</span></span> and the
predicate <span class="docutils literal"><span class="pre">&lt;</span> <span class="pre">7</span></span>. We would split this in two ranges around the midpoint:
<span class="docutils literal"><span class="pre">10</span> <span class="pre">1</span> <span class="pre">9</span> <span class="pre">2</span> <span class="pre">8</span></span> and <span class="docutils literal"><span class="pre">3</span> <span class="pre">7</span> <span class="pre">4</span> <span class="pre">6</span> <span class="pre">5</span></span>. Assuming the sub-ranges get stable-partitioned,
we end up with <span class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">10</span> <span class="pre">9</span> <span class="pre">8</span></span> and <span class="docutils literal"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">6</span> <span class="pre">5</span> <span class="pre">|</span> <span class="pre">7</span></span> (I’m using <span class="docutils literal"><span class="pre">|</span></span> to mark the
partition point). Now sticking them back together, we have <span class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">|</span> <span class="pre">10</span> <span class="pre">9</span> <span class="pre">8</span> <span class="pre">|</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">6</span> <span class="pre">5</span> <span class="pre">|</span> <span class="pre">7</span></span>
but we would like to have <span class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">6</span> <span class="pre">5</span> <span class="pre">|</span> <span class="pre">10</span> <span class="pre">9</span> <span class="pre">8</span> <span class="pre">7</span></span> (note this is a stable
partition, the elements aren’t supposed to get sorted, rather relative order is
preserved). In other words, the first partition of the left range, <span class="docutils literal"><span class="pre">1</span> <span class="pre">2</span></span>, is
OK, the last partition of the right range, <span class="docutils literal"><span class="pre">7</span></span> is OK, we only need to swap
<span class="docutils literal"><span class="pre">10</span> <span class="pre">9</span> <span class="pre">8</span></span> with <span class="docutils literal"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">6</span> <span class="pre">5</span></span>. This is done with a rotation.</p>
<p><span class="docutils literal"><span class="pre">rotate</span></span> takes as arguments an iterator to the beginning of a range, an
iterator to the element around which we want to rotate, and an iterator to the
end of the range. It helps that <span class="docutils literal"><span class="pre">stable_partition</span></span> returns just the iterators
we need to feed into <span class="docutils literal"><span class="pre">rotate</span></span> (the partition points of the left and right
sub-ranges). Rotating them around the midpoint yields the stable partition of
the whole range.</p>
<p>Line by line, <span class="docutils literal"><span class="pre">stable_partition</span></span> of an empty range returns the iterator to
the last element:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">stable_partition</span></span> of a single element returns either <span class="docutils literal"><span class="pre">f</span></span> or <span class="docutils literal"><span class="pre">f</span> <span class="pre">+</span> <span class="pre">1</span></span>,
depending on whether <span class="docutils literal"><span class="pre">*f</span></span> satisfies the predicate. A shorthand of writing
this is <span class="docutils literal"><span class="pre">f</span> <span class="pre">+</span> <span class="pre">pred(*f)</span></span> which converts the boolean returned by pred into
either 1 or 0 (a longer way of writing the same would’ve been <span class="docutils literal"><span class="pre">f</span> <span class="pre">+</span> <span class="pre">pred(*f)</span> <span class="pre">?</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">0</span></span>):</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">f</span> <span class="o">+</span> <span class="n">pred</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, we determine the midpoint, which is <span class="docutils literal"><span class="pre">f</span></span> + half the distance between
<span class="docutils literal"><span class="pre">f</span></span> and <span class="docutils literal"><span class="pre">l</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>Then we recursively apply <span class="docutils literal"><span class="pre">stable_partition</span></span> to <span class="docutils literal"><span class="pre">[f,</span> <span class="pre">m)</span></span>, <span class="docutils literal"><span class="pre">[m,</span> <span class="pre">l)</span></span>, and
rotate the partition points returned around the midpoint <span class="docutils literal"><span class="pre">m</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">return</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">stable_partition</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">pred</span><span class="p">),</span>
              <span class="n">m</span><span class="p">,</span>
              <span class="n">stable_partition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">pred</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="rotate">
<h2>Rotate</h2>
<p><span class="docutils literal"><span class="pre">rotate</span></span> is also a standard algorithm, but let’s look at a possible
implementation. Given the beginning and end iterators over a range, and an
iterator within the range around which we want to rotate, we move the elements
so that the first group appears after the second group and return an iterator
to where the initial first element ends up in the final sequence.</p>
<p>There are more efficient ways of rotating by swapping elements while making
sure we don’t overlap ranges, but a neat way of doing a rotation is using
reverse:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span> <span class="n">I</span> <span class="n">rotate</span><span class="p">(</span><span class="n">I</span> <span class="n">f</span><span class="p">,</span> <span class="n">I</span> <span class="n">p</span><span class="p">,</span> <span class="n">I</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">l</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Given a pivot point <span class="docutils literal"><span class="pre">p</span></span> around which we want to rotate, we can perform the
rotation by reversing first the range <span class="docutils literal"><span class="pre">[f,</span> <span class="pre">p)</span></span>, then the range <span class="docutils literal"><span class="pre">[p,</span> <span class="pre">l)</span></span>,
then the whole range <span class="docutils literal"><span class="pre">[f,</span> <span class="pre">l)</span></span>.</p>
<p>For example, given <span class="docutils literal"><span class="pre">E</span> <span class="pre">F</span> <span class="pre">G</span> <span class="pre">H</span> <span class="pre">I</span> <span class="pre">J</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span></span>, we would like to rotate it so
<span class="docutils literal"><span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span></span> appears before <span class="docutils literal"><span class="pre">E</span> <span class="pre">F</span> <span class="pre">G</span> <span class="pre">H</span> <span class="pre">I</span> <span class="pre">J</span></span>. So marking the pivot point with <span class="docutils literal"><span class="pre">|</span></span>:
<span class="docutils literal"><span class="pre">E</span> <span class="pre">F</span> <span class="pre">G</span> <span class="pre">H</span> <span class="pre">I</span> <span class="pre">J</span> <span class="pre">|</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span></span>. First, we reverse the first group and end up with
<span class="docutils literal"><span class="pre">J</span> <span class="pre">I</span> <span class="pre">H</span> <span class="pre">G</span> <span class="pre">F</span> <span class="pre">E</span> <span class="pre">|</span> <span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span></span>. Next, we reverse the second group, and end up with
<span class="docutils literal"><span class="pre">J</span> <span class="pre">I</span> <span class="pre">H</span> <span class="pre">G</span> <span class="pre">F</span> <span class="pre">E</span> <span class="pre">|</span> <span class="pre">D</span> <span class="pre">C</span> <span class="pre">B</span> <span class="pre">A</span></span>. Last, we reverse the whole range: <span class="docutils literal"><span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span> <span class="pre">|</span> <span class="pre">E</span> <span class="pre">F</span> <span class="pre">G</span> <span class="pre">H</span> <span class="pre">I</span> <span class="pre">J</span></span>,
which ends up with exactly what we wanted.</p>
<p>I won’t go line by line over the above as the calls to reverse are trivial, the
only thing worth noting is the returned iterator, determined by adding the
distance between the pivot point and the end of the range to the iterator
pointing to the beginning of the range. This is, in fact, the new position the
initial first element takes (refer to the example above where first element is
<span class="docutils literal"><span class="pre">E</span></span> with initial position <span class="docutils literal"><span class="pre">f</span></span> and final position <span class="docutils literal"><span class="pre">f</span> <span class="pre">+</span> <span class="pre">4</span></span>, 4 being the
distance between the pivot and end of the range, namely the length of the range
<span class="docutils literal"><span class="pre">A</span> <span class="pre">B</span> <span class="pre">C</span> <span class="pre">D</span></span>).</p>
</div>
<div class="section" id="reverse">
<h2>Reverse</h2>
<p>For completeness, let’s also provide a tail-recursive implementation of reverse:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">reverse</span><span class="p">(</span><span class="n">I</span> <span class="n">f</span><span class="p">,</span> <span class="n">I</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="o">--</span><span class="n">l</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>

    <span class="n">reverse</span><span class="p">(</span><span class="o">++</span><span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We swap the first and last elements, then recurse, stopping when we either have
an empty range, or a range consisting of a single element, as it is meaningless
to swap an element with itself. Note the check for swapping an element with
itself could be pushed down to the <span class="docutils literal"><span class="pre">swap</span></span> function, but by design it isn’t
because <span class="docutils literal"><span class="pre">swap</span></span> is used in many algorithms and performing this check on every
call quickly becomes expensive.</p>
<p>Line by line, we stop if we have an empty range:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>We then decrement <span class="docutils literal"><span class="pre">l</span></span> so we have a closed range <span class="docutils literal"><span class="pre">[f,</span> <span class="pre">l]</span></span> to work with as
opposed to the half open <span class="docutils literal"><span class="pre">[f,</span> <span class="pre">l)</span></span>. We check again that the range is not empty:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="o">--</span><span class="n">l</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>It might be tempting to skip the first check and just perform this one, the
problem is that if <span class="docutils literal"><span class="pre">f</span> <span class="pre">==</span> <span class="pre">l</span></span> and we call <span class="docutils literal"><span class="pre">--l</span></span> we are trying to move <span class="docutils literal"><span class="pre">l</span></span> to
before the beginning of the range, which is undefined behavior.</p>
<p>Once we have both <span class="docutils literal"><span class="pre">f</span></span> and <span class="docutils literal"><span class="pre">l</span></span> pointing to the beginning and end elements in
the range, we swap their values:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, we advance <span class="docutils literal"><span class="pre">f</span></span> and recurse. No need to decrement <span class="docutils literal"><span class="pre">l</span></span>, as by
convention we expect a half open range <span class="docutils literal"><span class="pre">[f,</span> <span class="pre">l)</span></span> so we take care of decrementing
<span class="docutils literal"><span class="pre">l</span></span> inside the function as explained above.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">reverse</span><span class="p">(</span><span class="o">++</span><span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We deconstructed quicksort in C++ and covered a few standard algorithms with
naïve implementations (the standard library provides highly optimized
implementations of these algorithms):</p>
<ul class="simple">
<li><span class="docutils literal"><span class="pre">quicksort</span></span> can be implemented recursively by relying on <span class="docutils literal"><span class="pre">stable_partition</span></span></li>
<li><span class="docutils literal"><span class="pre">stable_partition</span></span> can be implemented recursively by relying on <span class="docutils literal"><span class="pre">rotate</span></span></li>
<li><span class="docutils literal"><span class="pre">rotate</span></span> can be implemented as three calls to <span class="docutils literal"><span class="pre">reverse</span></span></li>
<li><span class="docutils literal"><span class="pre">reverse</span></span> can be implemented recursively by relying on <span class="docutils literal"><span class="pre">swap</span></span></li>
</ul>
<p>The algorithms implemented above are all 4 lines long and are implemented in a
functional style which avoids the complex loops of the C implementation
proposed on the Haskell wiki.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>We can also use <span class="docutils literal"><span class="pre">bind(less&lt;&gt;{},</span> <span class="pre">placeholders::_1,</span> <span class="pre">*f)</span></span> and have a
curried <span class="docutils literal"><span class="pre">less</span></span> instead of a lambda predicate.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Haskell is an awesome language and I’m not trying to bash on it here, or
write a C++ vs Haskell post. I was simply inspired by the Haskell wiki
page about quicksort and started thinking about a modern C++ way of
approaching the same problem.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/05/07/deconstructing-quicksort.html#disqus_thread" data-disqus-identifier="2016/05/07/deconstructing-quicksort">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>April 24, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/04/24/abusing-maps.html">(Ab)using Maps</a></h1>
<div class="section" id="mapping-pattern">
<h2>Mapping pattern</h2>
<p>Using hash maps (or dictionaries, or lookups) is a very natural way of coding in
some languages, especially dynamic languages, where usually an object can be
treated as a map itself, to which attributes and methods can be added or removed
at runtime.</p>
<p>In practice though, maps are often used to convert a value of one type into a
value of a different type. It is not uncommon to have very small maps like</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>Here it is useful to make a distinction between the pattern and the data
structure. The coding pattern itself is great - mapping a value from a type to
a value of another type should definitely be declarative. Below is a
counterexample of non-declarative mapping:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">Bar</span> <span class="nf">barFromFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar3</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is really ugly. As I mentioned in <a class="reference internal" href="2016/01/04/clean-code-part-1.html#clean-code-1"><span>Clean Code - Part 1</span></a>, branching should be
avoided whenever possible, and this is a good opportunity to use a declarative
approach as opposed to a bunch of branching logic. That being said, while the
mapping pattern is great, in C++ the data structure most developers default to
is not the optimal one for this.</p>
</div>
<div class="section" id="the-problem-with-unordered-map">
<h2>The problem with unordered_map</h2>
<p>If you are coding in C++, odds are you care a little bit about the runtime
footprint of your code. In that case, you might be surprised to learn that,
while an <span class="docutils literal"><span class="pre">unordered_map</span></span> in C++ (or a lookup or hash map or dictionary in any
other language) has an average lookup cost of <span class="docutils literal"><span class="pre">O(1)</span></span>, there are better ways to
implement the above pattern.</p>
<p>A map in C++ is implemented as a red-black tree containing buckets of hashed
values. Calling <span class="docutils literal"><span class="pre">at()</span></span> on a map implies the given key has to be hashed and
the tree traversed to find the value. Calling <span class="docutils literal"><span class="pre">[]</span></span> on an inexistent key will
add it to the data structure, which might trigger a rebalancing of the tree.
There is a lot of work happening under the hood, and while this makes sense for
an <span class="docutils literal"><span class="pre">unordered_map</span></span> of arbitrarily large size, for small lookups it is a lot
of overhead.</p>
</div>
<div class="section" id="alternatives">
<h2>Alternatives</h2>
<p>An alternative to <span class="docutils literal"><span class="pre">unordered_map</span></span> provided by the boost library is
<span class="docutils literal"><span class="pre">flat_map</span></span> <a class="footnote-reference" href="#id3" id="id1">[1]</a>. This has similar semantics to an <span class="docutils literal"><span class="pre">unordered_map</span></span>, but the
key-values are stored in a contiguous data structure so traversing it is more
efficient than walking a tree.</p>
<p>In general, there are a couple of approaches for keeping a hash map in a linear
data structure:</p>
<ul class="simple">
<li>The keys can be kept sorted, which has <span class="docutils literal"><span class="pre">O(N)</span></span> worst case insertion since it
might require all elements to be moved to fit a new one and <span class="docutils literal"><span class="pre">O(logN)</span></span> lookup
(binary search)</li>
<li>The keys can be kept unsorted, which has <span class="docutils literal"><span class="pre">O(1)</span></span> insertion (simple append) but
<span class="docutils literal"><span class="pre">O(N)</span></span> lookup (linear search)</li>
</ul>
<p>For very small-sized lookups, the cost of hashing itself might out-weight a
linear traversal, so for a small N</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>performs worse than</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
    <span class="n">fooBarMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span>
    <span class="n">fooBarMap</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
    <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">foo</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
<p>On my machine (using MSVC 2015 STL implementation), for an N of 5, <span class="docutils literal"><span class="pre">find_if</span></span>
on a vector is about twice as fast as the equivalent <span class="docutils literal"><span class="pre">unordered_map</span></span> lookup.</p>
</div>
<div class="section" id="initialization-cost">
<h2>Initialization cost</h2>
<p>There’s event more hidden cost: <span class="docutils literal"><span class="pre">std::vector</span></span> manages a dynamic array which is
allocated on the heap. Having an <span class="docutils literal"><span class="pre">std::vector</span></span> initialized with key-values as
described above, even if more efficent than an <span class="docutils literal"><span class="pre">unordered_map</span></span>, still has
some associated cost in terms of heap allocations (albeit smaller than
<span class="docutils literal"><span class="pre">unordered_map</span></span>). <span class="docutils literal"><span class="pre">std::array</span></span> is a much better suited container for cases
when the key-values are known at compile time, as <span class="docutils literal"><span class="pre">std::array</span></span> simply wraps a
regular array which is not allocated on the heap. So a more efficient (in terms
of initialization cost) way of declaring such a look up is</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">arrray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>We can still apply the <span class="docutils literal"><span class="pre">std::find_if</span></span> algorithm on this array, but we skip a
heap allocation. Depending on the template types used, we might be able to skip
any allocations whatsoever (if both types are trivial <a class="footnote-reference" href="#id4" id="id2">[2]</a>). For example, note
that <span class="docutils literal"><span class="pre">std::string</span></span>, similarly to a vector, wraps a heap-allocated <span class="docutils literal"><span class="pre">char*</span></span>
and constructing it requires heap allocations. <span class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></span> to a string
literal on the other hand is just a pointer to the <span class="docutils literal"><span class="pre">.rodata</span></span> segment. So this</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="s">"foo1"</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo2"</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo3"</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>performs three heap allocations (for <span class="docutils literal"><span class="pre">"foo1"</span></span>, <span class="docutils literal"><span class="pre">"foo2"</span></span>, and <span class="docutils literal"><span class="pre">"foo3"</span></span>),
while the (mostly) equivalent</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="s">"foo1"</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo2"</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo3"</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>shouldn’t perform any allocations.</p>
</div>
<div class="section" id="associative-array">
<h2>associative_array</h2>
<p>Since in practice maps are often used to implement the above described pattern
of mapping a value from one type to a value of a different type for a small
set of known values, it would be great to combine the efficiency of an array
with the nice lookup semantics of an <span class="docutils literal"><span class="pre">unordered_map</span></span> conatiner.</p>
<p>I propose a generic container of the following shape:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">TKey</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">KeyEqual</span> <span class="o">=</span> <span class="n">key_equal</span><span class="o">&lt;</span><span class="n">TKey</span><span class="o">&gt;&gt;</span>
<span class="k">struct</span> <span class="n">associative_array</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">m_array</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">keq_equal</span></span> should simply resolve to <span class="docutils literal"><span class="pre">==</span></span> for most types, but be
specialized for strings types (to use <span class="docutils literal"><span class="pre">strcmp</span></span>, <span class="docutils literal"><span class="pre">wcscmp</span></span> etc.) and allow
clients to specialize their own <span class="docutils literal"><span class="pre">key_equal</span></span> when needed.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">key_equal</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">key_equal</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="c1">// specializations for wchar_t and const variations of the above</span>
</pre></div>
</div>
<p>Satisfying the container concept is fairly easy (eg. <span class="docutils literal"><span class="pre">size()</span></span> would return
<span class="docutils literal"><span class="pre">N</span></span>, iterators over the member array are trivial to implement etc.), the only
interesting methods are <span class="docutils literal"><span class="pre">find()</span></span>, <span class="docutils literal"><span class="pre">at()</span></span>, and <span class="docutils literal"><span class="pre">operator[]</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="p">...</span>
<span class="k">struct</span> <span class="n">associative_array</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
            <span class="n">begin</span><span class="p">(),</span>
            <span class="n">end</span><span class="p">(),</span>
            <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">KeyEqual</span><span class="p">{}(</span><span class="n">key</span><span class="p">,</span> <span class="n">elem</span><span class="p">.</span><span class="n">first</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">end</span><span class="p">())</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"..."</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">find()</span></span> wraps <span class="docutils literal"><span class="pre">std::find_if</span></span> leveraging <span class="docutils literal"><span class="pre">KeyEqual</span></span> (with default
implementation as <span class="docutils literal"><span class="pre">key_equal</span></span>), <span class="docutils literal"><span class="pre">at()</span></span> wraps a bounds-checked <span class="docutils literal"><span class="pre">find</span></span>,
while <span class="docutils literal"><span class="pre">operator[]</span></span> does not check bounds. <span class="docutils literal"><span class="pre">const</span></span> implementations of the
above are also needed (identical except returning <span class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></span>).</p>
<p>Such a container would have similar semantics to <span class="docutils literal"><span class="pre">std::unordered_map</span></span> (minus
the ability to add elements given a key not already present in the container)
and the same performance profile of <span class="docutils literal"><span class="pre">std::array</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">associative_array</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>Note the only syntax difference between above and <span class="docutils literal"><span class="pre">unordered_map</span></span> is the
container type, the extra size <span class="docutils literal"><span class="pre">N</span></span> which needs to be specified at
declaration time, and an extra pair of curly braces. In practice, this should
have a significantly better lookup time than an unordered_map for a small N
(linear time, but since N is small and no hashing or heap traversal occurs,
should clock better than a map lookup) and virtually zero initialization time
- depending on the <span class="docutils literal"><span class="pre">TKey</span></span> and <span class="docutils literal"><span class="pre">T</span></span> types used, it is possible to declare
an <span class="docutils literal"><span class="pre">associative_array</span></span> as a <span class="docutils literal"><span class="pre">constexpr</span></span> fully evaluated at compile-time.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Boost <span class="docutils literal"><span class="pre">flat_map</span></span> documentation is <a class="reference external" href="http://www.boost.org/doc/libs/1_56_0/doc/html/boost/container/flat_map.html">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>For more details on trivial types, see the <a class="reference external" href="http://www.cplusplus.com/reference/type_traits/is_trivial/">is_trivial type trait</a>.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/04/24/abusing-maps.html#disqus_thread" data-disqus-identifier="2016/04/24/abusing-maps">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>March 11, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/03/11/arguments-and-smart-pointers.html">Arguments and Smart Pointers</a></h1>
<p>For efficiency reasons, C++ had a myriad of ways to pass data around. A
function can take arguments in several forms:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>
</div>
<p>No to mention adding <span class="docutils literal"><span class="pre">const</span></span> and smart pointers into the mix.</p>
<p>And speaking of pointers, we have raw pointers, <span class="docutils literal"><span class="pre">unique_ptr</span></span>, <span class="docutils literal"><span class="pre">shared_ptr,</span></span>
<span class="docutils literal"><span class="pre">CComPtr</span></span>/<span class="docutils literal"><span class="pre">ComPtr</span></span> (for Windows COM objects), and, if you are working in
older codebases, <span class="docutils literal"><span class="pre">auto_ptr</span></span>, and maybe even some homebrewed refcounted
pointers.</p>
<p>All of this might seem a bit daunting and make C++ seem more complicated than
it really is. One way to think about it is from the ownership perspective:
objects are resources and the key question is “who owns this resource?”. This
should dictate both how a particular resource is allocated (and released) and
the shape function arguments should take. Lifetime is also an important
consideration - a resource shouldn’t be released while other components expect
it to be available, but it should be released as soon as it is no longer
needed.</p>
<p>In this post I will try to cover the various ways in which resources can be
allocated, owned, and passed around.</p>
<div class="section" id="stack-objects-and-passing-arguments">
<h2>Stack Objects and Passing Arguments</h2>
<p>The simplest, clearest thing to do is allocate objects on the stack. A stack
object doesn’t involve any pointers:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The variable <span class="docutils literal"><span class="pre">bar</span></span> of type <span class="docutils literal"><span class="pre">Bar</span></span> is created on the stack. Once the stack
frame is popped (once the function is done executing, either through a normal
return or due to an exception) the object goes away. This is the easiest, safest
thing to do. The only reasons we wouldn’t always do this are time and space
requirements: lifetime-wise, we might want to somehow use <span class="docutils literal"><span class="pre">bar</span></span> after
<span class="docutils literal"><span class="pre">foo()</span></span> returns - for example we might want to pass it around to some other
object that wants to use at a later time; in terms of space, stack memory is
more limited than the heap, so large objects are better kept on the heap to
avoid overflow.</p>
<div class="section" id="pass-by-value">
<h3>Pass by value</h3>
<p>One way to get around the lifetime requirement is to pass the object by value:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="n">Bar</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// hands bar off to some other object</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s assume for this example that <span class="docutils literal"><span class="pre">do_suff</span></span> takes the argument and sticks it
into some global object which will use it as some future time.</p>
<p>The above code will simply create a copy of the object, so whatever <span class="docutils literal"><span class="pre">do_suff</span></span>
gets won’t be the original resource which gets freed once the function returns,
rather a copy of it. Copying an object costs both run time and space, but if
neither are a big concern, this is a great, safe way of ensuring resources don’t
get released before we’re done with them.</p>
</div>
<div class="section" id="move">
<h3>Move</h3>
<p>C++11 introduces a cheaper way of achieving this, through move semantics:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;&amp;</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// hands bar off to some other object</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With move semantics, the resource is actually <em>moved</em> into the <span class="docutils literal"><span class="pre">do_suff</span></span>
function. Once this happens, the original object is left in an undefined state
and shouldn’t be used anymore. This approach is usually employed when we have a
sink argument - we <em>sink</em> <span class="docutils literal"><span class="pre">bar</span></span> to its final resting place somewhere and
<span class="docutils literal"><span class="pre">foo()</span></span> no longer cares about it after passing it down to <span class="docutils literal"><span class="pre">do_stuff</span></span>.</p>
<p>One thing to keep in mind is that <span class="docutils literal"><span class="pre">move</span></span> is not magic, so <span class="docutils literal"><span class="pre">Bar</span></span> needs to
declare a <a class="reference external" href="http://en.cppreference.com/w/cpp/language/move_constructor">move constructor</a>
in order for this to do what we expect it to do. If Bar doesn’t declare a move
constructor, the above becomes a simple copy <a class="footnote-reference" href="#id4" id="id1">[1]</a>.</p>
</div>
<div class="section" id="pass-by-reference">
<h3>Pass by reference</h3>
<p>On the flipside, when we care about the size, so that we don’t want to create a
copy of the object, but we aren’t worried about the lifetime - meaning the
object we pass to <span class="docutils literal"><span class="pre">do_stuff</span></span> won’t have to outlive the function call, we can
pass by reference:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// bar is only used within do_suff</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the <span class="docutils literal"><span class="pre">const</span></span> above - this means <span class="docutils literal"><span class="pre">do_suff</span></span> will use <span class="docutils literal"><span class="pre">bar</span></span> but won’t
modify it. By default, arguments should be marked as <span class="docutils literal"><span class="pre">const</span></span> unless the
function does indeed need to alter the object. Regardless of constness, in this
case we pass a reference to <span class="docutils literal"><span class="pre">bar</span></span> as an argument, which is very cheap (a
reference has the same size as a pointer). The only caveat is that <span class="docutils literal"><span class="pre">do_stuff</span></span>
should not pass this to some other object that outlives the function call (eg. a
global object which tries to use it later), because as soon as <span class="docutils literal"><span class="pre">foo</span></span> returns,
the reference becomes invalid.</p>
</div>
<div class="section" id="pass-by-pointer">
<h3>Pass by pointer</h3>
<p>A pointer argument would look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">*</span> <span class="n">bar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A good rule of thumb is to not do this. The difference between passing by
reference and by pointer in this case is that a pointer can be null, while a
reference can’t. So passing by pointer here automatically brings the need to
perform null checks to ensure bad things don’t happen. You would need to make a
very good argument to convince me during code review that using a pointer
instead of a reference is appropriate. Unless working against a legacy API which
can’t be changed, I highly discourage use of raw pointers.</p>
</div>
<div class="section" id="summary">
<h3>Summary</h3>
<p>In summary, when designing an API:</p>
<ol class="arabic simple">
<li>Take argument by value if copying it is not a concern</li>
<li>Take argument by <span class="docutils literal"><span class="pre">const&amp;</span></span> if it’s not a sink argument, meaning we don’t
need to refer to it passed the function call</li>
<li>Take argument by reference (<span class="docutils literal"><span class="pre">&amp;</span></span>) if 2) but the API needs to modify it</li>
<li>Take argument by <span class="docutils literal"><span class="pre">&amp;&amp;</span></span> if it’s a sink argument, the type has a move
constructor, and copying it is expensive</li>
<li>Don’t pass raw pointers around</li>
</ol>
</div>
</div>
<div class="section" id="heap-objects-and-smart-pointers">
<h2>Heap Objects and Smart Pointers</h2>
<p>In all of the examples above, <span class="docutils literal"><span class="pre">bar</span></span> was an object created on the stack. This
works great in some cases, but some objects are simply too big to fit on the
stack, or it doesn’t make sense for them to do so (if, for example, we want to
vary their size at runtime). In this case, we allocate the object on the heap
and keep a pointer to it.</p>
<p>Once we start working with heap objects, ownership becomes even more important:
unlike stack objects, which get automatically destroyed when their stack frame
gets popped, heap objects need to be explicitly deleted. This responsibility
should be with the <em>owner</em> of the object.</p>
<div class="section" id="unique-pointer">
<h3>Unique pointer</h3>
<p>A unique pointer (<span class="docutils literal"><span class="pre">std::unique_ptr</span></span>) is a wrapper around a raw pointer which
will automatically delete the heap object when it goes out of scope itself:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// ptrBar goes out of scope =&gt; heap object gets deleted</span>
</pre></div>
</div>
<p>The above call to <span class="docutils literal"><span class="pre">make_unique</span></span> allocates an instance of Bar on the heap and
wraps the pointer to it into the unique pointer <span class="docutils literal"><span class="pre">ptrBar</span></span>. Now <span class="docutils literal"><span class="pre">ptrBar</span></span>
<em>owns</em> the object and as soon as ptrBar goes out of scope, the heap object is
also deleted.</p>
<p>Unique pointers cannot be copied, so we can never accidentally have more than
one single <span class="docutils literal"><span class="pre">unique_ptr</span></span> pointing to the same heap object:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar2</span> <span class="o">=</span> <span class="n">ptrBar</span><span class="p">;</span> <span class="c1">// Won't compile</span>
</pre></div>
</div>
<p>Of course, if we <em>really</em> want to, we can get the raw pointer out of <span class="docutils literal"><span class="pre">ptrBar</span></span>
using <span class="docutils literal"><span class="pre">get()</span></span> and we can initialize a <span class="docutils literal"><span class="pre">unique_ptr</span></span> from a raw pointer -</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Please don't do this</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar2</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
</div>
<p>but this is very bad - now both pointers think they have sole ownership of the
resource, and as soon as one goes out of scope, using the other one leads to
undefined behavior. In general, the same way there are very few good reasons to
use raw pointers, there are very few good reasons to call <span class="docutils literal"><span class="pre">get()</span></span> on a smart
pointer.</p>
</div>
<div class="section" id="shared-pointer">
<h3>Shared pointer</h3>
<p>Sometimes, we do need to have several pointers pointing to the same heap object.
In this case, we can use shared pointers. Shared pointers pointing to the same
heap object keep a common reference count. Whenever a new shared pointer is
created for that particular heap object, the reference count is incremented.
Whenever a shared pointer for that heap object goes out of scope, the reference
count is decremented. Once the last shared pointer goes out of scope, the heap
object is deleted.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="c1">// one pointer to a Bar object on the heap (ref count = 1)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptrBar2</span><span class="p">(</span><span class="n">ptrBar1</span><span class="p">);</span>
        <span class="c1">// second shared pointer (ref count = 2)</span>
    <span class="p">}</span>
    <span class="c1">// ptrBar2 goes out of scope (ref count = 1)</span>
<span class="p">}</span>
<span class="c1">// ptrBar1 goes out of scope (ref count = 0) =&gt; heap object is deleted</span>
</pre></div>
</div>
<p>Shared pointers incur a bit more overhead than unique pointers - reference
counting needs to be atomic to account for multi-threaded environments, which
comes with a runtime cost. The reference count itself also needs to be stored
somewhere, which is a small space cost. Unique pointers don’t have these time
and space costs since they don’t need to count references - there is always only
one pointer to the object.</p>
<p>Costs aside, shared pointers also don’t make the ownership clear - there are
several instances “owning” the heap resource at the same time, which can
potentially alter it and step on each other’s toes. In general, prefer unique
pointers to shared pointers whenever possible.</p>
</div>
<div class="section" id="raw-pointer">
<h3>Raw pointer</h3>
<p>Avoid using raw pointers. Raw pointers don’t express ownership, so they don’t
offer the same guarantees that a) the resource pointed to gets properly cleaned
up and b) the resource pointed to is still valid at a given time. This leads to
dereferencing invalid memory and double-deletes (trying to free the same heap
object multiple times), which means undefined behavior. Also, don’t mix smart
and raw pointers - the smart pointers will keep doing their job happily, with
the potential of making the raw pointers invalid.</p>
</div>
<div class="section" id="com-pointers">
<h3>COM pointers</h3>
<p>On Windows, COM uses a different reference counting mechanism: the base
<span class="docutils literal"><span class="pre">IUnknown</span></span> interface declares <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> methods, which
implementations are expected to use to keep track of the reference count.
<span class="docutils literal"><span class="pre">CComPtr</span></span> (in ATL) and <span class="docutils literal"><span class="pre">ComPtr</span></span> (in WRL) are the COM smart pointers. They
call <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> on the owned object, and the owned object is
supposed to delete itself once its reference count drops to 0. Note that COM
uses a slightly different mechanism than the standard library shared pointers -
instead of the smart pointer keeping track of the reference count in the control
block and deleting the object once the last reference goes away, COM objects are
expected to keep track of their reference count themselves through the
<span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> methods and self-delete when the last reference goes
away (through <span class="docutils literal"><span class="pre">Release</span></span> call). The COM smart pointers only need to call
<span class="docutils literal"><span class="pre">Release</span></span> when they go out of scope.</p>
<p>It’s not a good idea to have both standard library and COM pointers point to the
same object, as each might decide to delete the object at different times -
<span class="docutils literal"><span class="pre">shared_ptr</span></span> looks at the <span class="docutils literal"><span class="pre">shared_ptr</span></span> refcount while COM objects look at
their internal reference count. So a <span class="docutils literal"><span class="pre">shared_ptr</span></span> might decide to delete an
object while a <span class="docutils literal"><span class="pre">ComPtr</span></span> still expects it to be valid or vice-versa. In
general, when working with COM objects, use COM smart pointers.</p>
</div>
<div class="section" id="auto-ptr">
<h3>auto_ptr</h3>
<p><span class="docutils literal"><span class="pre">auto_ptr</span></span> is a deprecated smart pointer. Unless working with an old compiler
and standard library, use <span class="docutils literal"><span class="pre">unique_ptr</span></span> or <span class="docutils literal"><span class="pre">shared_ptr</span></span> instead.</p>
</div>
<div class="section" id="other-smart-pointers">
<h3>Other smart pointers</h3>
<p>Old code bases might have custom smart pointer implementations, for the simple
fact that automatic memory management is always a good idea, and there is C++
code that predates the introduction of smart pointers into the standard library.
When interoperating with legacy code, use whatever works, but when writing new
code, do prefer standard library smart pointers to homebrewed ones.</p>
</div>
<div class="section" id="id2">
<h3>Summary</h3>
<p>In summary, when creating objects:</p>
<ol class="arabic simple">
<li>Create them on the stack if feasible (note that standard library types
like <span class="docutils literal"><span class="pre">std::vector</span></span> and <span class="docutils literal"><span class="pre">std::string</span></span> internally keep their data on
the heap, but they fit perfectly well on the stack, so you don’t need to
create an <span class="docutils literal"><span class="pre">std::vector</span></span> on the heap just because you are planning to
store a lot of elements in it - the vector manages a heap array
internally already).</li>
<li>Use a <span class="docutils literal"><span class="pre">unique_ptr</span></span> when creating them on the heap, to make ownership
obvious.</li>
<li>Use a <span class="docutils literal"><span class="pre">shared_ptr</span></span> only when <span class="docutils literal"><span class="pre">unique_ptr</span></span> isn’t sufficient (review
your design first, might be a design issue).</li>
<li>Use COM smart pointers like <span class="docutils literal"><span class="pre">CComPtr</span></span> when dealing with COM.</li>
<li>Don’t use <span class="docutils literal"><span class="pre">auto_ptr</span></span> or other old constructs unless working with legacy
code/compiler.</li>
<li>Don’t use raw pointers.</li>
</ol>
</div>
</div>
<div class="section" id="passing-smart-pointers-as-arguments">
<h2>Passing Smart Pointers as Arguments</h2>
<p>We covered passing arguments and smart pointers. Now combining the two, how do
we pass heap objects as arguments? Turns out Herb Sutter has
<a class="reference external" href="http://bit.ly/227Na5c">a great post</a> on this exact topic on his blog. I can’t
hope to explain better than him, so go read his post. I will try to summarize:</p>
<div class="section" id="pass-by-reference-the-pointed-to-type">
<h3>Pass by reference the pointed-to type</h3>
<p>Rather than forcing callers to use <span class="docutils literal"><span class="pre">unique_ptr</span></span> or <span class="docutils literal"><span class="pre">shared_ptr</span></span> by
specifying the smart pointer type (which makes assumptions about ownership),
just ask for a reference to the pointed-to-type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">*</span><span class="n">ptrBar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Herb also mentions raw pointer to the underlying type if the argument can be
null, but as I mentioned above, I’d rather stick to references and discourage
use of raw pointers as a general rule of thumb.</p>
</div>
<div class="section" id="pass-smart-pointer-by-value">
<h3>Pass smart pointer by value</h3>
<p>Passing a <span class="docutils literal"><span class="pre">unique_ptr</span></span> by value implies a sink argument - since a
<span class="docutils literal"><span class="pre">unique_ptr</span></span> cannot be copied, it has to be <span class="docutils literal"><span class="pre">std::move</span></span>‘d in. Interestingly,
Scott Meyers has <a class="reference external" href="http://bit.ly/1WgkvEh">a post</a> on his blog where he
disagrees with this and argues that arguments of move-only types should be
specified as <span class="docutils literal"><span class="pre">&amp;&amp;</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span> <span class="c1">// sink</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Passing a <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value implies the function wants to partake in the
ownership - in other words, will keep somewhere a reference to the object after
the function returns, but unlike the above <span class="docutils literal"><span class="pre">unique_ptr</span></span> example, it won’t have
exclusive ownership of the resource:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">);</span> <span class="c1">// copy-constructs another shared_ptr which shares ownership of the heap object</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pass-smart-pointer-by-reference">
<h3>Pass smart pointer by reference</h3>
<p>Only expect a smart pointer by non-const reference if the function is going to
modify the smart pointer itself (eg. by making it point to a different object).
In my experience, this is a rare occurrence.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Implies this function modifies the pointer itself.</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span>
</pre></div>
</div>
<p>There is no good reason to expect a <span class="docutils literal"><span class="pre">const&amp;</span></span> to a <span class="docutils literal"><span class="pre">unique_ptr</span></span>, just reference
the underlying type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// void do_stuff(const unique_ptr&lt;Bar&gt;&amp; ptrBar);</span>
<span class="c1">// No reason to use the above as opposed to</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>
</pre></div>
</div>
<p>Expect <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">shared_ptr</span></span> only if the function <em>might</em> create a copy
of the smart pointer. If the function would never create a copy of the pointer,
simply use <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type. If the function would always copy the
pointer, expect <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Might or might not share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span>

<span class="c1">// Will never share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>

<span class="c1">// Will always share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>Summary</h3>
<p>A summary of the summary:</p>
<ol class="arabic simple">
<li>Take argument by <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type if you only care about the heap
object, not about the pointer.</li>
<li>Take <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> by <span class="docutils literal"><span class="pre">&amp;&amp;</span></span> to transfer ownership.</li>
<li>Take <span class="docutils literal"><span class="pre">shared_ptr</span></span> argument by value to partake in ownership.</li>
<li>Take smart pointer by (non-const) reference only if you are going to
modify the smart pointer itself.</li>
<li>No need for <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">unique_ptr</span></span> (just take <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type)</li>
<li>Take <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">shared_ptr</span></span> only if unknown whether function wants
ownership (take by <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type if function never wants
ownership, <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value if function always wants ownership).</li>
</ol>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Move constructors can be implicitly declared by the compiler if certain
conditions are met, see <a class="reference external" href="http://en.cppreference.com/w/cpp/language/move_constructor#Implicitly-declared_move_constructor">here</a>
for details.</td></tr>
</tbody>
</table>
</div>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/03/11/arguments-and-smart-pointers.html#disqus_thread" data-disqus-identifier="2016/03/11/arguments-and-smart-pointers">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>January 07, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/01/07/clean-code-part-2.html">Clean Code - Part 2</a></h1>
<p>In <a class="reference external" href="2016/01/04/clean-code-part-1">Part 1</a> I talked about writing less code and
writing simple code. In this post I will cover writing stateless code and
writing readable code.</p>
<div class="section" id="write-stateless-code">
<h2>Write Stateless Code</h2>
<blockquote>
<div><p>A <strong>pure function</strong> is a <strong>function</strong> where the return value is only
determined by its input values, without observable side effects. This is
how <strong>functions</strong> in math work: <span class="docutils literal"><span class="pre">Math.cos(x)</span></span> will, for the same value
of <span class="docutils literal"><span class="pre">x</span></span>, always return the same result.</p>
<p><em>Source:</em> <a class="reference external" href="http://www.sitepoint.com/functional-programming-pure-functions/">SitePoint</a></p>
</div></blockquote>
<p>Things break when a program gets into a “bad state”. There are a couple of ways
to make this less likely to happen: making data immutable and writing functions
that don’t have side-effects (<em>pure</em> functions).</p>
<div class="section" id="immutable-data">
<h3>Immutable data</h3>
<p>If something shouldn’t change, mark it as immutable and let the compiler enforce
that. A good rule of thumb is to mark things as <span class="docutils literal"><span class="pre">const</span></span> (<span class="docutils literal"><span class="pre">const&amp;</span></span>,
<span class="docutils literal"><span class="pre">const*</span></span> etc.) and/or <span class="docutils literal"><span class="pre">readonly</span></span> by default, and make them mutable only when
truly needed <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>A simple example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">StringUtil</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Both <span class="docutils literal"><span class="pre">StringUtil::Concat1</span></span> and <span class="docutils literal"><span class="pre">StringUtil::Concat2</span></span> return the same thing
for the same input, the difference being that <span class="docutils literal"><span class="pre">Concat2</span></span>, as opposed to
<span class="docutils literal"><span class="pre">Concat1</span></span>, modifies its first argument. In a bigger function, such a change
might be introduced accidentally and have unexpected consequences down the line.</p>
<p>A simple way to address this is by explicitly marking the arguments as
<span class="docutils literal"><span class="pre">const</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">StringUtil</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat1</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat2</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span> <span class="c1">// Won't compile - can't call append on str1</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this case, <span class="docutils literal"><span class="pre">Concat2</span></span> won’t compile, so we can rely on the compiler to
eliminate this type of unintended behavior.</p>
<p>Another example: a simple <span class="docutils literal"><span class="pre">UpCase</span></span> function which calls <span class="docutils literal"><span class="pre">toupper</span></span> on each
character of the given string, upcasing it in place:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">UpCase</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">);</span>
        <span class="n">string</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Calling it with</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">char</span><span class="o">*</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">UpCase</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>
</pre></div>
</div>
<p>will lead to a crash at runtime - the function will try to call <span class="docutils literal"><span class="pre">toupper</span></span> on
the characters of <span class="docutils literal"><span class="pre">myString</span></span>. The problem is that <span class="docutils literal"><span class="pre">myString</span></span> is a <span class="docutils literal"><span class="pre">char*</span></span>
to a string literal which gets compiled into the read-only data segment of the
binary. This cannot be modified.</p>
<p>To catch this type of errors at compile-time, we again only need to mark the
immutable data as such:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">UpCase</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span> <span class="c1">// Won't compile - can't call UpCase on myString</span>
</pre></div>
</div>
<p>In contrast with the previous example, the argument to <span class="docutils literal"><span class="pre">UpCase</span></span> is mutable by
design (the API is modifying the string in-place), but marking <span class="docutils literal"><span class="pre">myString</span></span> as
<span class="docutils literal"><span class="pre">const</span></span> tells the complier this is non-mutable data, so it can’t be used with
this API.</p>
</div>
<div class="section" id="pure-functions">
<h3>Pure functions</h3>
<p>Another way to reduce states is to use pure functions. Unfortunately there isn’t
a lot of syntax-level support for this in C++ and C# (C++ supports <span class="docutils literal"><span class="pre">const</span></span>
member functions, which guarantee at compile time that calling the member
function on an instance of the type won’t change the attributes of that
instance) <a class="footnote-reference" href="#id6" id="id2">[2]</a></p>
<p>This goes back to the recommendation from Part 1 of using generic algorithms and
predicates rather than implementing raw loops. In many cases, traversal state is
encapsulated in the library algorithm or in an iterator, and predicates ideally
don’t have side-effects.</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span>
                <span class="n">Where</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">).</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>Above code (also from Part 1) doesn’t hold any state: traversal is handled by
the Linq methods, the predicates are pure.</p>
<p>In general, try to encapsulate state in parts of the code built to manage state,
and keep the rest stateless. Note that immutable data and pure functions are
also an advantage in concurrent applications, since they can’t generate race
conditions.</p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Prefer pure functions to stateful functions and, if state is needed, keep it
contained</li>
<li>By default mark everything as <span class="docutils literal"><span class="pre">const</span></span> (or <span class="docutils literal"><span class="pre">readonly</span></span>), and only remove
the constraint when mutability is explicitly needed</li>
</ul>
</div>
</div>
<div class="section" id="write-readable-code">
<h2>Write Readable Code</h2>
<blockquote>
<div><p>In computer science, the <strong>expressive power</strong> (also called
<strong>expressiveness</strong> or expressivity) of a language is the breadth of ideas
that can be represented and communicated in that language [...]</p>
<ul class="simple">
<li>regardless of ease (theoretical expressivity)</li>
<li><strong>concisely and readily</strong> (practical expressivity)</li>
</ul>
<p><em>Source:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Expressive_power_(computer_science)">Wikipedia</a></p>
</div></blockquote>
<p>Code is read many more times than it is written/modified, so it should be
optimized for readability. What I mean by this is making the intent of the code
clear at a glance - this includes giving good descriptive names to variables,
functions, and types, adding useful comments where appropriate (a comment should
describe what the code does if it is non-obvious; a comment like <span class="docutils literal"><span class="pre">foo();</span> <span class="pre">//</span> <span class="pre">calls</span> <span class="pre">foo()</span></span>
is not a useful comment), and in general structure the code for easy reading.</p>
<p>For a counterexample, think back on a piece of code you read that elicited a
WTF. That’s the kind of code you don’t want to write.</p>
<p>I won’t insist much here, since there are countless books and industry best
practices for improving code readability.</p>
<p>Another way to make the code more readable is to have a good knowledge of the
language you are using. The strength of a language lies in its particularities,
so use them whenever appropriate. This means writing <a class="reference external" href="http://stackoverflow.com/questions/84102/what-is-idiomatic-code">idiomatic code</a>,
which implies knowledge of the language idioms. Don’t write C++ code like C
code, write it like C++ code. Don’t write C# code as C++, write it as C# etc.</p>
<p>Also, keep up to date on the language. Language syntax evolves to address needs,
so in general modern syntax introduces simpler, better ways to implement things
than old syntax. Take object allocation and initialization in C++ as an example:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span>
<span class="n">init</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">deinit</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the C way of allocating and initializing a structure on the heap, then
deinitializing and freeing it. Allocation and initialization are separate steps,
with opportunity to leak both memory (by omitting the <span class="docutils literal"><span class="pre">free</span></span> call) and
managed resources (by omitting the <span class="docutils literal"><span class="pre">deinit</span></span> call). Not to mention opportunity
to end up with an initialized struct (by omitting the <span class="docutils literal"><span class="pre">init</span></span> call), or
accidental double-initialization, double-deinitialization, double-free etc.</p>
<p>C++ introduced classes, and the following syntax:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">...</span>
<span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">new</span></span> both allocates memory and calls the constructor, while <span class="docutils literal"><span class="pre">delete</span></span> calls
the destructor then releases the memory. Many of the problems in the C example
go away, but there is still the problem of leaking the resource by omitting the
<span class="docutils literal"><span class="pre">delete</span></span> call, and the issue of calling <span class="docutils literal"><span class="pre">delete</span></span> twice on the same memory
address.</p>
<p>To address these issues, smart pointers were introduced in the language:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">());</span>
</pre></div>
</div>
<p>Smart pointers encapsulate reference counting (how many <span class="docutils literal"><span class="pre">shared_ptr</span></span> objects
point to the same memory address), and automatically release the resource when
the last reference goes away. This gets rid of most problems, but there is an
even better way of allocating heap objects:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">make_shared</span></span> has the advantage of improved performance, by allocating memory
in a single operation for both the object and the shared pointer’s own control
block <a class="footnote-reference" href="#id7" id="id3">[3]</a>. It also prevents leaks due to interleaving <a class="footnote-reference" href="#id8" id="id4">[4]</a>. So as the C++
language evolved, new constructs appeared to address potential problems. Keeping
up to date with these updates, and incorporating them into your code will reduce
the opportunity for bugs, make the code more concise, and thus more readable.</p>
<div class="section" id="beautiful-code">
<h3>Beautiful Code</h3>
<p>I encourage you to not stop at writing <em>working</em> code, rather strive to write
<em>beautiful</em> code. I have the following quote from <a class="reference external" href="http://www.goodreads.com/book/show/5608045-apprenticeship-patterns">Apprenticeship Patterns</a>
on the wall behind my monitors, so I can see it while I work:</p>
<blockquote>
<div>There’s always a better/faster/smarter way to do what you’re currently doing</div></blockquote>
<p>So don’t stop as soon as something works, ask yourself <em>is this the best way to
implement this?</em></p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Come up with good names</li>
<li>Write meaningful comments</li>
<li>Keep up to date with your language</li>
<li>Don’t just write working code, write beautiful code.</li>
</ul>
</div>
</div>
<div class="section" id="epilogue">
<h2>Epilogue</h2>
<p>As I was working on putting together the talk that inspired this post, I
realized there are a few more rules of thumb which I could cover. The current
working draft is:</p>
<ul class="simple">
<li>Write safe code</li>
<li>Write leakproof code</li>
<li>Write responsive code</li>
<li>Write testable code</li>
</ul>
<p>Sometime in the future I hope to continue the series with the above, in the
meantime, I’ll leave you with this one sentence summary:</p>
<blockquote>
<div><p>Always code as if the person who ends up maintaining your code is a violent psychopath who
knows where you live</p>
<p><em>Source:</em> <a class="reference external" href="http://blog.codinghorror.com/coding-for-violent-psychopaths/">Coding Horror</a></p>
</div></blockquote>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>At the time of this writing, there is an <a class="reference external" href="https://github.com/dotnet/roslyn/issues/7626">active proposals</a>
to extend the C# language with an <span class="docutils literal"><span class="pre">immutable</span></span> keyword.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>C# has a <span class="docutils literal"><span class="pre">PureAttribue</span></span> in the <span class="docutils literal"><span class="pre">System.Diagnostics.Contracts</span></span>
namespace (purity not compiler-enforced) and there is an <a class="reference external" href="https://github.com/dotnet/roslyn/issues/7561">active proposal</a>
to add a keyword for it too.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>This is a non-binding requirement in the standard, meaning a standard
library implementation doesn’t <em>have to</em> do this, but most implementations
will. You can read more about it <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Interleaving occurs since call order is not guaranteed. For example, in
<span class="docutils literal"><span class="pre">bar(std::share_ptr&lt;Foo&gt;(new</span> <span class="pre">foo()),</span> <span class="pre">baz())</span></span>, there is no guarantee that
call order will be <span class="docutils literal"><span class="pre">new</span> <span class="pre">foo()</span></span>, then the shared pointer’s constructor, then
<span class="docutils literal"><span class="pre">baz()</span></span>. Calls might get interleaved and executed as <span class="docutils literal"><span class="pre">new</span> <span class="pre">foo()</span></span>, then
<span class="docutils literal"><span class="pre">baz()</span></span>, then the shared pointer constructor, in which case an exception
thrown by <span class="docutils literal"><span class="pre">baz()</span></span> would leak the newly allocated <span class="docutils literal"><span class="pre">Foo</span></span> object, since the
shared pointer didn’t get ownership of it yet.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/01/07/clean-code-part-2.html#disqus_thread" data-disqus-identifier="2016/01/07/clean-code-part-2">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>January 04, 2016</span>
        </div>
        <div class="section">
            <span id="clean-code-1"/><h1><a href="2016/01/04/clean-code-part-1.html">Clean Code - Part 1</a></h1>
<p>These posts are based on a Clean Code talk I did for my team a few months ago,
which, in turn, was inspired by the advice I gave to some of our summer
interns as four rules of thumb for writing cleaner code:</p>
<ul class="simple">
<li>Write less code</li>
<li>Write simple code</li>
<li>Write stateless code</li>
<li>Write readable code</li>
</ul>
<p>I will cover the first two points in this post and the remaining two in Part 2.
I’m talking about C++ and C# throughout, but most of this should be applicable
to any object-oriented or multi-paradigm language.</p>
<div class="section" id="write-less-code">
<h2>Write Less Code</h2>
<blockquote>
<div><p>The number of defects found in open source projects was 0.45 defects/1,000
lines of code, while the industry’s average is around 1 defect per 1,000
lines of code for companies not using automated testing such as static
analysis.</p>
<p><em>Source:</em> <a class="reference external" href="http://www.infoq.com/news/2012/03/Defects-Open-Source-Commercial">InfoQ</a></p>
</div></blockquote>
<p>A great way to have fewer bugs is to have fewer lines of code! What I mean by
this is that churning out many lines of code is by no means a measure of
productivity yet, unfortunately, most developers still feel great when, at the
end of the day, we wrote <em>insert high number</em> LoC.</p>
<div class="section" id="how-to-write-less-code">
<h3>How to write less code?</h3>
<p>Two points to keep in mind: first, don’t reinvent the wheel - don’t write code
if there is an existing library, internal to your company or open-source, that
already does what needs to be done. Case in point, we refactored some code for
a project (C#), extracted some interfaces, componentized things, and wrote a
bunch of unit tests. All of this was great, except we ended up with a bunch of
handcrafted stub classes: for</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IMyComponent</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Foo</span><span class="p">();</span>
    <span class="kt">int</span> <span class="nf">Bar</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">Baz</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>we had</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">MyComponentStub</span> <span class="p">:</span> <span class="n">IMyComponent</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Baz</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">myComponentStub</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyComponentStub</span><span class="p">();</span>
</pre></div>
</div>
<p>and so on. Implementing these stubs was tedious, needless work - we integrated
<a class="reference external" href="https://github.com/Moq/moq4">Moq</a> , a mocking library, and the above code
turned into:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">using</span> <span class="nn">Moq</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">myComponentStub</span> <span class="p">=</span> <span class="n">Mock</span><span class="p">.</span><span class="n">Of</span><span class="p">&lt;</span><span class="n">IMyComponent</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Moq uses reflection to stub out interfaces at run-time, so simply adopting the
library helped us get rid of a lot of code.</p>
<p>The second way to write less code is to know the standard library of your
language of choice. Many times, a block of code can be replaced with a simple
library call. For C++, pay particular attention to the STL <span class="docutils literal"><span class="pre">&lt;algorithm&gt;</span></span> header
and for C#, <span class="docutils literal"><span class="pre">System.Linq</span></span>. Both contain many of useful algorithms which can
replace a lot of code.</p>
<p>I also recommend watching Sean Parent’s <a class="reference external" href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">C++ Seasoning</a>
talk, one of the best tech talks I’ve seen. The example he gives in the talk
(from the Chrome codebase) shows how a couple of lines of STL code can be used
instead of a whole convoluted function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="n">PanelBar</span><span class="o">::</span><span class="n">RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span>

  <span class="c1">// First, find the index of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span> <span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Next, check if the panel has moved to the other side of another panel.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">center_x</span> <span class="o">=</span> <span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">center_x</span> <span class="o">&lt;=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span> <span class="o">||</span>
        <span class="n">i</span> <span class="o">==</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">panel</span> <span class="o">!=</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If it has, then we reorder the panels.</span>
        <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">];</span>
        <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Find the total width of the panels to the left of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">total_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fixed_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span> <span class="o">==</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">total_width</span> <span class="o">+=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">new_fixed_index</span> <span class="o">=</span> <span class="n">fixed_index</span><span class="p">;</span>

  <span class="c1">// Move panels over to the right of the fixed panel until all of the ones</span>
  <span class="c1">// on the left will fit.</span>
  <span class="kt">int</span> <span class="n">avail_width</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">&gt;</span> <span class="n">avail_width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_fixed_index</span><span class="o">--</span><span class="p">;</span>
    <span class="n">CHECK_GE</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">total_width</span> <span class="o">-=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Reorder the fixed panel if its index changed.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_fixed_index</span> <span class="o">!=</span> <span class="n">fixed_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
    <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
    <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">new_fixed_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Now find the width of the panels to the right, and move them to the</span>
  <span class="c1">// left as needed.</span>
  <span class="n">total_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">total_width</span> <span class="o">+=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">avail_width</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">&gt;</span> <span class="n">avail_width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_fixed_index</span><span class="o">++</span><span class="p">;</span>
    <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">total_width</span> <span class="o">-=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Do the reordering again.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_fixed_index</span> <span class="o">!=</span> <span class="n">fixed_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
    <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
    <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">new_fixed_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Finally, push panels to the left and the right so they don't overlap.</span>
  <span class="kt">int</span> <span class="n">boundary</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">reverse_iterator</span> <span class="n">it</span> <span class="o">=</span>
       <span class="c1">// Start at the panel to the left of 'new_fixed_index'.</span>
       <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">new_fixed_index</span><span class="p">);</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">),</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">boundary</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span>
                  <span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">),</span>
                  <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="n">PanelBar</span><span class="o">::</span><span class="n">RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span>

  <span class="c1">// First, find the index of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span> <span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Next, check if the panel has moved to the left side of another panel.</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">)</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">),</span> <span class="n">f</span><span class="p">,</span> <span class="n">center_x</span><span class="p">,</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

  <span class="c1">// If it has, then we reorder the panels.</span>
  <span class="n">rotate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Code snippets borrowed from Sean Parent’s slides, I highly recommend watching the
whole talk.</p>
<p>The key takeaway here is that there could be a standard library implementation or
an external module that can greatly simplify your work and it’s a good practice
to always ask yourself <em>“do I really need to write this?”</em></p>
</div>
</div>
<div class="section" id="write-simple-code">
<h2>Write Simple Code</h2>
<p>First, a few notes on cyclomatic complexity from Wikipedia:</p>
<blockquote>
<div><p>Cyclomatic complexity is a software metric (measurement), used to indicate
the complexity of a program. It is a quantitative measure of the number of
linearly independent paths through a program’s source code.</p>
<dl class="docutils">
<dt>The complexity M is then defined as</dt>
<dd><em>M = E − N + 2P</em></dd>
<dt>where</dt>
<dd><em>E = the number of edges of the graph, N = the number of nodes of the
graph, P = the number of connected components.</em></dd>
</dl>
<div align="center" class="align-center"><img src="_images/cyclomatic_complexity.svg"/></div>
<p>A control flow graph of a simple program. The program begins executing at
the red node, then enters a loop (group of three nodes immediately below
the red node). On exiting the loop, there is a conditional statement (group
below the loop), and finally the program exits at the blue node. This graph
has 9 edges, 8 nodes, and 1 connected component, so the cyclomatic
complexity of the program is 9 - 8 + 2 * 1 = 3.</p>
<p><em>Source:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Wikipedia</a></p>
</div></blockquote>
<p>The cyclomatic complexity of any piece of code should be minimized. This can be
achieved by avoiding branching, namely, whenever possible, avoiding conditional
statements and loops. Linear code is easier to read and maintain, and provides
less opportunities for bugs.</p>
<div class="section" id="avoiding-conditional-statements">
<h3>Avoiding conditional statements</h3>
<p>One way to avoid conditional statements is to, whenever feasible, throw
exceptions instead of propagating errors through return values.</p>
<p>Here is an example of error code propagation through return values using the
Windows API’s <span class="docutils literal"><span class="pre">HRESULT</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">HRESULT</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">// Does some work and returns an HRESULT</span>
<span class="n">HRESULT</span> <span class="nf">bar</span><span class="p">();</span> <span class="c1">// Does some work and returns an HRESULT</span>

<span class="n">HRESULT</span> <span class="nf">baz</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">S_OK</span><span class="p">;</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="n">baz</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>

    <span class="p">...</span> <span class="c1">// Some more work here which might fail</span>

    <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">baz</span><span class="p">()))</span>
<span class="p">{</span>
    <span class="c1">// :)</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// :(</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This can be replaced with the more concise and much easier to read:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">// Does some work, might throw</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">();</span> <span class="c1">// Does some work, might throw</span>

<span class="kt">void</span> <span class="nf">baz</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
    <span class="n">baz</span><span class="p">();</span>

    <span class="p">...</span> <span class="c1">// Some more work here which might fail (and throw)</span>
<span class="p">}</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">baz</span><span class="p">();</span>
    <span class="c1">// :)</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span>
    <span class="c1">// :(</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Error code return values come from the old days when exceptions didn’t exist
and make code harder to read. That being said, for C++ specifically, you
should be careful about throwing exceptions across DLL boundaries. In practice
though, a lot of code in the shape of the above example appears within the
same executable for no good reason. If cross-DLL boundary is a problem, I would
actually recommend using exceptions internally and switching to return codes at
the public API boundary.</p>
<p>Another way to avoid conditional statements is to use the <a class="reference external" href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null Object pattern</a>
instead of checking for null. For example, take an <span class="docutils literal"><span class="pre">IActivity</span></span> interface on
which we can log success or failure, and an <span class="docutils literal"><span class="pre">ActivityScope</span></span> which can retrieve
the current activity from a context:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IActivity</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">LogSuccess</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">LogFailure</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActivityScope</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IActivity</span> <span class="nf">GetCurrentActivity</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this implementation, all clients of the API have to make sure <span class="docutils literal"><span class="pre">GetCurrentActivity()</span></span>
returns an object as opposed to null. All callers look like this:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="n">ActivityScope</span> <span class="n">activityScope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ActivityScope</span><span class="p">();</span>
<span class="n">activityScope</span><span class="p">.</span><span class="n">CreateActivity</span><span class="p">();</span>

<span class="p">...</span> <span class="c1">// Do a bunch of stuff</span>

<span class="kt">var</span> <span class="n">activity</span> <span class="p">=</span> <span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">activity</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">activity</span><span class="p">.</span><span class="n">LogSuccess</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While there is a single <span class="docutils literal"><span class="pre">ActivityScope</span></span> implementation, there are hundreds of
calls to <span class="docutils literal"><span class="pre">GetCurrentActivity</span></span>, all coming with a boilerplate null check. The
Null Object alternative for this is to provide a <span class="docutils literal"><span class="pre">NullActivity</span></span>, for which
<span class="docutils literal"><span class="pre">LogSuccess</span></span> and <span class="docutils literal"><span class="pre">LogFailure</span></span> don’t do anything. <span class="docutils literal"><span class="pre">ActivityScope</span></span> can return
<span class="docutils literal"><span class="pre">NullActivity</span></span> instead of null if there is no <span class="docutils literal"><span class="pre">Activity</span></span> in the context:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">NullActivity</span> <span class="p">:</span> <span class="n">IActivity</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LogSuccess</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LogFailure</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActivityScope</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">NullActivity</span> <span class="n">_nullActivity</span> <span class="p">=</span> <span class="k">new</span> <span class="n">NullActivity</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">IActivity</span> <span class="nf">GetCurrentActivity</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_nullActivity</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now callers don’t need to worry about getting back a null, and can use the API
like this:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">().</span><span class="n">LogSuccess</span><span class="p">();</span>
</pre></div>
</div>
<p>Yet another way to reduce branching is when it used for mapping between two types:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="p">=</span> <span class="s">"Foo string"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="p">=</span> <span class="s">"Bar string"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">...</span>
</pre></div>
</div>
<p>A pattern like this (which can also take the form of a big switch/case statement)
can usually be replaced with indexing into an array or looking up the
corresponding value in a hash map:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">IdTypeToStringMap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">,</span> <span class="s">"Foo"</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">,</span> <span class="s">"Bar"</span> <span class="p">},</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="n">b</span> <span class="p">=</span> <span class="n">IdTypeToStringMap</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
</pre></div>
</div>
<p>This is, again, easier to maintain, since it is declarative - the mapping is given as
data (<span class="docutils literal"><span class="pre">IdTypeToStringMap</span></span>), not as code (long series of if/else).</p>
</div>
<div class="section" id="avoid-loops">
<h3>Avoid loops</h3>
<p>This goes back to the C++ Seasoning talk, namely the <em>No Raw Loops</em> guideline. Here’s
a C# example: given a list of numbers, we want to get the square of all the odd
numbers in the list.</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="m">6</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">8</span> <span class="p">};</span>

<span class="c1">// Get the squares of all odd numbers</span>
</pre></div>
</div>
<p>One way to do this is to maintain a list of numbers, iterate over the list, check
if numbers are odd, and if so, square them and add them to the list:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">squares</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">squares</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
</pre></div>
</div>
<p>A neater way to do this is to use a generator instead of manually maintaining
the list of squares:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
</pre></div>
</div>
<p>That being said, what I would actually recommend is using Linq:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span>
                <span class="n">Where</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">).</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>Fewer lines of code and no branching whatsoever <a class="footnote-reference" href="#id2" id="id1">[*]</a>. <span class="docutils literal"><span class="pre">Where</span></span> and <span class="docutils literal"><span class="pre">Select</span></span>
are generic algorithms, and their arguments are the predicates we use. This makes
the intent of the code clear at a glance - we are filtering the collection with
a predicate (<span class="docutils literal"><span class="pre">number</span> <span class="pre">=&gt;</span> <span class="pre">number</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">!=</span> <span class="pre">0</span></span>) and applying a transformation to it
with another predicate (<span class="docutils literal"><span class="pre">number</span> <span class="pre">=&gt;</span> <span class="pre">number</span> <span class="pre">*</span> <span class="pre">number</span></span>). Also, the filtering and
transformation are library functions, so we can be fairly certain they work
well, and only need to worry about maintaining our predicates.</p>
<p>It might not look like a big deal in this simple made-up example, but as code
evolves, it becomes harder and harder to follow the iteration logic, as the
code gets littered with <span class="docutils literal"><span class="pre">break</span></span>, <span class="docutils literal"><span class="pre">continue</span></span>, and <span class="docutils literal"><span class="pre">return</span></span> statements (see
the Chrome example quoted in the Write Less Code section).</p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Try to keep functions linear (or as linear as possible)</li>
<li>Default to throwing instead of propagating errors up the call stack</li>
<li>Consider creating a null object when code is littered with null checks</li>
<li>Separate algorithm logic from predicates to make the intent of the code clear (in other words, no raw loops).</li>
</ul>
</div>
</div>
<div class="section" id="notes-on-performance">
<h2>Notes on performance</h2>
<p>The most interesting question I was asked is what are the performance
implications of using an STL algorithm or Linq.</p>
<p>The default answer is, of course, you have to measure for your particular case!
Blanket statements cannot be made about performance, as there are many factors
involved: compiler, runtime, standard library, OS, architecture, whether code is
on a hot path or not, and so on and so forth.</p>
<p>Still, my recommendation is to use the library algorithms and, only if they
become the bottleneck (which in most cases shouldn’t happen), look into replacing
them with handcrafted code. Another thing to keep in mind is that standard
library authors know what they’re doing, so it’s very likely that library code is
already pretty well optimized. I ran a simple wall clock benchmark for 1M
iterations for some of the examples I used throughout the presentation (both the
handcrafted and the library versions), and in all cases the code leveraging
library functions ran slightly faster.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[*]</a></td><td>Cyclomatic complexity of this is actually higher when computed by looking
at basic blocks (eg. from Visual Studio’s <span class="docutils literal"><span class="pre">Analyze</span></span> menu), since the compiler
will automatically add a finally block to dispose of the Linq-returned
IEnumerables in case of exception. That being said, I prefer
compiler-generated complexity to developer-generated complexity.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/01/04/clean-code-part-1.html#disqus_thread" data-disqus-identifier="2016/01/04/clean-code-part-1">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>December 28, 2015</span>
        </div>
        <div class="section">
            <h1><a href="2015/12/28/hello-world.html">Hello World</a></h1>
<div class="code python highlight-python"><div class="highlight"><pre><span/><span class="k">print</span><span class="p">(</span><span class="s2">"Hello World!"</span><span class="p">)</span>
</pre></div>
</div>

        </div>
        <div class="postmeta">
        
        
        
        </div><div class="archive_link">
        <a href="archive.html"> &mdash; Blog Archive &mdash; </a>
    </div></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><script type="text/javascript">    var disqus_shortname = "vladris";    disqus_count();</script><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
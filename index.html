<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Home &mdash; Blog</title>
            <link rel="stylesheet" href="_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="_static/main.css" type="text/css">
            <link rel="stylesheet" href="_static/flat.css" type="text/css">
            <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/main.js"></script>
        <link rel="search" title="Search" href="search.html" /><link rel="next" title="Older" href="page2.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script><script type="text/javascript" src="_static/disqus.js"></script><script type="text/javascript" src="_static/google_analytics.js"></script><link rel="stylesheet" href="_static/extra.css" type="text/css" /></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>February 25, 2017</span>
        </div>
        <div class="section">
            <h1><a href="2017/02/25/a-heterogeneous-event-store.html">A Heterogeneous Event Store</a></h1>
<p>I recently stumbled upon a heterogeneous event collection which turned out to
pose an interesting design problem. We are using library code (we can’t change)
that provides a templated <span class="docutils literal"><span class="pre">Event</span></span> to which we can register callbacks and
which we can raise later to invoke the callbacks. The interface looks like
this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cm">/* Library code */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">Event</span>
<span class="p">{</span>
    <span class="c1">// T is a callable object, like std::function</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Register a callback */</span> <span class="p">}</span>

    <span class="c1">// Raises the event and forwards the arguments to the callbacks</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Invoke all registered callbacks */</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A stub implementation that validates client code is typed properly would be:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">Event</span>
<span class="p">{</span>
    <span class="c1">// T is a callable object, like std::function</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Register a callback */</span>
        <span class="n">_callback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Raises the event and forwards the arguments to the callbacks</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Invoke all registered callbacks */</span>
        <span class="n">_callback</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">_callback</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that unlike the real implementation, this only stores the last registered
event, but that is irrelevant for the purpose of this post. I’m providing the
code just to have something to compile against (otherwise <span class="docutils literal"><span class="pre">Raise</span></span> would
happily swallow any combination of arguments passed to it). In reality, a more
complex implementation would maintain a list of callbacks, but this is
sufficient for framing the design problem.</p>
<p>The event collection which was wrapping a set of library events looked like
this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">using</span> <span class="n">LaunchCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">SaveCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ExitCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">OnLaunch</span><span class="p">(</span><span class="n">LaunchCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_launchEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">OnSave</span><span class="p">(</span><span class="n">SaveCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_saveEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">OnExit</span><span class="p">(</span><span class="n">ExitCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_exitEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseLaunch</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_launchEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseSave</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fileName</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_saveEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseExit</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_exitEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span> <span class="n">m_launchEvent</span><span class="p">;</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span> <span class="n">m_saveEvent</span><span class="p">;</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;</span> <span class="n">m_exitEvent</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sample usage of the <span class="docutils literal"><span class="pre">EventStore</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">OnLaunch</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">OnSave</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">RaiseSave</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>Looking at <span class="docutils literal"><span class="pre">EventStore</span></span>, it’s obvious that there is a lot of repetition
involved: hooking up a new event involves aliasing a new callback, adding a new
member to the class, and adding the corresponding registration and <span class="docutils literal"><span class="pre">Raise</span></span>
member functions which end up being copy/pastes of the other ones. There must
be a better way!</p>
<p>An initial idea would be to use some sort of associative container (hopefully
something <a class="reference external" href="http://vladris.com/blog/2016/04/24/abusing-maps.html">better than an unordered_map</a>),
but there is an interesting complication due to the fact that some of the
various events are actually of different types. <span class="docutils literal"><span class="pre">Event&lt;std::function&lt;void()&gt;&gt;</span></span>
has a different type than <span class="docutils literal"><span class="pre">Event&lt;std::function&lt;void(const</span> <span class="pre">string&amp;)&gt;&gt;</span></span>. There
are potential workarounds to explore, like standardizing on a single type and
requiring clients to, for example, only use callbacks that do not take any
arguments. Another option would be to pass in some base object to each event
and let each callback re-interpret it. This takes us down the wrong path though.
We don’t need to do any runtime lookup - the initial code doesn’t.</p>
<p>From the repetition in <span class="docutils literal"><span class="pre">EventStore</span></span>, it should become apparent that we need
some form of templated <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> that would work for each type
of event we care about. A quick sketch of our function signatures should look
something like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="cm">/* ??? */</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="cm">/* ??? */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Register callback to the appropriate event</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="cm">/* ??? */</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Raise the appropriate event, forwarding args to it</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is also clear that we need a way to store all of the events we need in our
class. Since they are of heterogeneous types, we can’t store them in a map or
equivalent, but we don’t need to. <span class="docutils literal"><span class="pre">std::tuple</span></span> was build exactly for this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>Now the only remaining question is how to templatize our two member functions to
enable a lookup in the tuple. One approach would be to use an enum:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">EventType</span> <span class="o">:</span> <span class="kt">size_t</span>
<span class="p">{</span>
    <span class="n">LaunchEvent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">SaveEvent</span><span class="p">,</span>
    <span class="n">ExitEvent</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Given this enum, we can templatize on its values:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">EventType</span> <span class="n">eventType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">eventType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">EventType</span> <span class="n">eventType</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">eventType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Callers can use this new implementation like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">LaunchEvent</span><span class="o">&gt;</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">Raise</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>With this implementation, we preserve the ability to have polymorphic events but
only need to implement the <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> functions. Adding a new
event type now only requires aliasing the callback, adding an enum member, and
extending our member tuple by adding the new <span class="docutils literal"><span class="pre">Event</span></span> to it.</p>
<p>The only drawback of this approach is the fact that we need to manually keep the
enum and the tuple in sync. This is not too bad, because if we try to call
<span class="docutils literal"><span class="pre">std::get</span></span> with a number higher than the size of the tuple, we get a compile
time error. If we accidentally swap two events, if they are of incompatible
types (for example <span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span> and <span class="docutils literal"><span class="pre">Event&lt;SaveCallback&gt;</span></span>, as one
expects callbacks of type <span class="docutils literal"><span class="pre">std::function&lt;void()&gt;</span></span> and the other expects
<span class="docutils literal"><span class="pre">std::function&lt;void(const</span> <span class="pre">std::string&amp;)&gt;</span></span>), we get a compile-time error
because <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> calls would fail to compile (attempting to
pass in callback/arguments of incompatible types). If we accidentally swap two
events of the same type, (<span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span> and <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span>,
since both <span class="docutils literal"><span class="pre">LaunchCallback</span></span> and <span class="docutils literal"><span class="pre">ExitCallback</span></span> are aliased to the same
<span class="docutils literal"><span class="pre">std::function&lt;void()&gt;</span></span>), runtime behavior is equivalent, it just makes
reading the code confusing. Now we end up storing launch callbacks inside what
we called <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span> and vice-versa. Runtime is not affected, as we
would also raise <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span> by calling
<span class="docutils literal"><span class="pre">Raise&lt;EventType::LaunchEvent&gt;</span></span>, but it’s not ideal. We could drop the aliases
altogether and simply have:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>This solves the above issues but is not very readable. There are other options,
like picking different names for the aliases - instead of naming the event, have
them name the type of callback. Either way, effectively what we are doing is a
mapping from an enum into a set of <span class="docutils literal"><span class="pre">Event</span></span> types. We can actually push more
information to the type system and get rid of the need to do this mapping. We do
that by making sure our events are always of different types, even if the
callback signatures are the same. One way of achieving this is wrapping
<span class="docutils literal"><span class="pre">Event</span></span> and defining different types for each of our events:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">EventWrapper</span>
<span class="p">{</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">m_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">LaunchEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nl">SaveEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nl">ExitEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
</pre></div>
</div>
<p>Note this is type information used only by the compiler and doesn’t bring any
runtime overhead to our code. Inheritance is used here just so we don’t have to
repeat declaring <span class="docutils literal"><span class="pre">m_event</span></span>, we could have just as well declared each struct
independently. Now we can update the member tuple to store an event of each of
these types:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="p">,</span> <span class="n">SaveEvent</span><span class="p">,</span> <span class="n">ExitEvent</span><span class="o">&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>Since they are of different types, we no longer need an enum to index into the
tuple, we can do it by type (note <span class="docutils literal"><span class="pre">std::get</span></span> indexed by type requires that the
tuple contains distinct types, which is not the case for <span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span>
and <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span>, but it is for <span class="docutils literal"><span class="pre">LaunchEvent</span></span> and <span class="docutils literal"><span class="pre">ExitEvent</span></span>):</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Callback</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">Callback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">Callback</span></span> template argument in <span class="docutils literal"><span class="pre">Register</span></span> can be deduced once <span class="docutils literal"><span class="pre">T</span></span> is
specified. The full implementation is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">EventWrapper</span>
<span class="p">{</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">m_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">LaunchEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nl">SaveEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nl">ExitEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Callback</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">Callback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="p">,</span> <span class="n">SaveEvent</span><span class="p">,</span> <span class="n">ExitEvent</span><span class="o">&gt;</span> <span class="n">m_events</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Callers can use it like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="o">&gt;</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">Raise</span><span class="o">&lt;</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, adding a new event requires declaring a new struct and adding it
to the tuple. Since we are retrieving the event by its type, no mapping is
involved.</p>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2017/02/25/a-heterogeneous-event-store.html#disqus_thread" data-disqus-identifier="2017/02/25/a-heterogeneous-event-store">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>February 20, 2017</span>
        </div>
        <div class="section">
            <div class="section" id="memory-management">
<h1><a href="2017/02/20/memory-management.html">Memory Management</a></h1>
<p>Memory management involves handling memory resources allocated for a certain
task, ensuring that the memory is freed once it is no longer needed so it can
be reused for some other task. If the memory is not freed in a timely manner,
the system might run out of resources or incur degraded performance. A memory
resource that is never freed once no longer needed is called a leak - the
resource becomes unusable, usually for the duration of the process. Another
issue is <em>use after free</em>, in which a memory resource that was already freed
is used as if it wasn’t. This usually causes unexpected behavior as the code
is trying to read, modify or wrongly interpret data at a memory location.
Memory management can be <em>manual</em> - with code explicitly handling
deallocation, or <em>automatic</em>, in which memory gets freed once no longer needed
by an automated process.</p>
<div class="section" id="manual-memory-management">
<h2>Manual Memory Management</h2>
<p>Manual memory management is efficient, since allocations and deallocations
don’t incur any overhead. In C:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_Foo</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span>

<span class="p">...</span>

<span class="n">free</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>The disadvantage of this approach, and the main reason automatic memory
management models were invented, is that this puts the developer in charge of
making sure memory doesn’t leak and that it is not used after it is freed. As
the complexity of the code increases, this becomes increasingly difficult. As
pointers are passed around the system and get stored in various data structures,
it becomes difficult to know given some pointer that is no longer needed
whether: a) this was the very last piece of code that actually needed to access
the location pointed to by this pointer, in which case the memory should be
freed, and b) whether the memory this pointer is pointing to is still valid and
hasn’t been freed previously.</p>
</div>
<div class="section" id="automatic-memory-management">
<h2>Automatic Memory Management</h2>
<p>Automatic memory management attempts to move the responsibility of tracking
when a memory resource is no longer needed (and handling its deallocation) from
the developer to the system. Such a system is called <em>garbage collected</em>, as
memory that is no longer needed (“garbage”) is reclaimed by the system
automatically. The two most popular methods used to automatically free memory
are <em>tracing garbage collectors</em> and <em>reference counting</em>.</p>
<div class="section" id="tracing-garbage-collector">
<h3>Tracing Garbage Collector</h3>
<p>Tracing garbage collectors work by tracing references to objects on the heap
and checking whether a given resource allocated on the heap has at least one
reference path to it from the stack. If such a path exists, it means that from
the stack (an argument to a function, a local variable), there is a way to
perform a set of dereference and access the memory resource. If such a path
doesn’t exist, it means the memory is unreachable, so regardless of how
executing code accesses other objects on the heap, there is no way to access
this resource - which means the memory can be safely deallocated.</p>
<p>For example, a naïve tracing garbage collection algorithm, <em>mark-and-sweep</em>,
involves adding an “in-use” bit to each memory resource allocated then, during
collection, following all references starting from the stack and marking each as
“in-use”. Once all used resources are marked, the sweep stage involves walking
the whole heap and for each memory resource, if not marked as “in-use”, freeing
it.</p>
<p>Tracing garbage collectors are used by many popular runtimes, like JVM and .NET.
In C#:</p>
<div class="highlight-C#"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Bar</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">struct</span> <span class="nc">Foo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">bar</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>

    <span class="c1">// there is no stack variable pointing to the Bar object, but it can</span>
    <span class="c1">// still be reached through foo (foo.bar), so there exists a path from</span>
    <span class="c1">// the stack to it, meaning code can still access it.</span>
<span class="p">}</span>

<span class="c1">// foo goes out of scope which means neither foo nor its member Bar can be</span>
<span class="c1">// accessed any longer, so they can be safely collected</span>
</pre></div>
</div>
<p>There are a couple of disadvantages with the tracing GC approach: first, the
system needs to ensure memory resources are not being allocated while a garbage
collection is taking place. This means code execution is paused during
collection, which obviously impacts performance. The second disadvantage of
this approach is that the system is not as lean as other memory management
models: memory resources are kept allocated longer than really needed, for the
time interval between the last reference to them goes out of scope until the
actual collection is performed.</p>
</div>
<div class="section" id="reference-counting">
<h3>Reference Counting</h3>
<p>An alternative to tracing garbage collectors is reference counting. As the name
implies, a memory resource in such a system has an associated reference count -
the number of references to it. As soon as the last reference goes out of scope,
when the reference count reaches zero, the memory can be safely deallocated.
Unlike tracing, reference counting is performed as code executes: the count of a
given memory resource is automatically increased with each assignment where the
resource is on the right-hand-side, and is automatically decreased whenever a
reference goes out of scope.</p>
<p>Python manages memory using reference counting:</p>
<div class="highlight-python"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>

<span class="c1"># allocate Foo, its reference count is 1</span>
<span class="n">foo1</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="c1"># reference count is 2 after assignment</span>
<span class="n">foo2</span> <span class="o">=</span> <span class="n">foo1</span>

<span class="o">...</span>
<span class="c1"># once foo1 and foo2 go out of scope, reference count becomes 0 and memory</span>
<span class="c1"># is automatically freed</span>
</pre></div>
</div>
<p>C++ smart pointers work in a similar manner:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="p">...</span>

<span class="c1">// foo1 is a shared_ptr pointing to a Foo stored on the heap. Reference</span>
<span class="c1">// count for the Foo object is 1</span>
<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// reference count becomes 2 after assignment</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>

<span class="p">...</span>
<span class="c1">// Once foo1 and foo2 go out of scope, reference count becomes 0 and memory</span>
<span class="c1">// is automatically freed</span>
</pre></div>
</div>
<p>The main advantages over tracing garbage collection are the fact that execution
doesn’t need to be paused in order to reclaim memory and that resources are
deallocated as soon as they are no longer used (once reference count becomes 0).
There are also several disadvantages with this approach: first, each memory
resource needs to store an additional reference count and updating the reference
count in a multi-threaded environment needs to be performed atomically. Second,
and most important, this memory management model does not handle <em>reference
cycles</em>.</p>
<p>Reference cycles occur when two heap objects hold references to each other even
after no longer being reachable from the stack. In this case, a tracing garbage
collector would mark the objects as being unreachable and deallocate them, but
simple reference counting would not be able to identify this - from that point
of view, each object is being referred to by another object thus it should not
be collected. Example of reference cycle in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(),</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">other</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
<span class="c1"># a.other holds a reference to b, b.other holds a reference to a</span>
<span class="c1"># even when a and b go out of scope, the "other" attributes still hold references</span>
<span class="c1"># to the objects so their reference count would not drop to 0</span>
</pre></div>
</div>
<p>A similar example in C++:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">foo1</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo2</span><span class="p">;</span>
<span class="n">foo2</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>
<span class="c1">// there are two references to each Foo object: foo1 and foo2-&gt;other for the first</span>
<span class="c1">// object, foo2 and foo1-&gt;other for the second object. Even if the foo1 and foo2</span>
<span class="c1">// variables go out of scope, neither of the objects would be collected due to the</span>
<span class="c1">// extra reference</span>
</pre></div>
</div>
<p>Python and C++ solve this problem in different ways: Python supplements reference
counting with a tracing garbage collector. So while most of the memory
management is done via reference counting, a tracing garbage collector is still
employed to clean up cycles like in the above example. This hybrid approach has
he pros and cons of both of the mechanisms discussed above. C++ avoids the
execution pauses a tracing garbage collectors would create by, instead,
leveraging <em>weak references</em>. Weak or non-owning references point to an object
but do not prevent it from being collected when all <em>strong</em> references go away.
There are several ways to express a non-owning reference, with different
advantages and drawbacks:</p>
<ul class="simple">
<li>A <span class="docutils literal"><span class="pre">&amp;</span></span> reference has to be assigned on construction and cannot be re-assigned
after being bound to an object. If used after the underlying object was
destroyed, it causes undefined behavior.</li>
<li>A <span class="docutils literal"><span class="pre">*</span></span> pointer can be <span class="docutils literal"><span class="pre">nullptr</span></span>-initialized and assigned later or
re-assigned. Similarly, if used after the pointed-to object was destroyed,
causes undefined behavior.</li>
<li>A <span class="docutils literal"><span class="pre">weak_ptr&lt;T&gt;</span></span> is a standard library type implementing a non-owning
reference. A <span class="docutils literal"><span class="pre">weak_ptr</span></span> can be converted to a <span class="docutils literal"><span class="pre">shared_ptr</span></span> (using  its
<span class="docutils literal"><span class="pre">lock()</span></span> method). If there is no strong (<span class="docutils literal"><span class="pre">shared_ptr</span></span>) reference to an
object it gets destroyed, regardless of how many <span class="docutils literal"><span class="pre">weak_ptr</span></span> instances point
to it. But once a <span class="docutils literal"><span class="pre">weak_ptr</span></span> successfully locks an object, it creates a
strong reference which ensures the object is kept alive. The drawback of
using <span class="docutils literal"><span class="pre">weak_ptr</span></span> is additional overhead: the control block of a smart
pointer needs to store both strong and weak reference count (with similar
atomic reference counting), and, even if an object gets destroyed because all
strong references went out of scope, the control block stays alive until all
weak references go away too.</li>
</ul>
<p>Updating the <span class="docutils literal"><span class="pre">Foo</span></span> struct in the example above to use a <span class="docutils literal"><span class="pre">weak_ptr</span></span> instead,
the reference cycle is avoided:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">foo1</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo2</span><span class="p">;</span>
<span class="n">foo2</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>
<span class="c1">// now the two Foo objects have only one strong reference to them through</span>
<span class="c1">// the foo1 and foo2 variables The other pointers are weak references which</span>
<span class="c1">// won't prevent the objects from being destroyed when foo1 and foo2 go out</span>
<span class="c1">// of scope</span>
</pre></div>
</div>
</div>
<div class="section" id="ownership-and-lifetimes">
<h3>Ownership and Lifetimes</h3>
<p>An alternative way to think about heap objects is in terms of <em>ownership</em> and
<em>lifetime</em>. In this model, a heap object is uniquely owned by some other object
and gets freed automatically when the owner is destructed. In C++, this is
achieved through <span class="docutils literal"><span class="pre">unique_ptr</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">Bar</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// this creates a Foo object on the heap, owned by bar</span>
<span class="p">}</span>
<span class="c1">// the heap object gets freed once bar gets freed</span>
</pre></div>
</div>
<p>Ownership of the object can be transferred by moving the <span class="docutils literal"><span class="pre">unique_ptr</span></span>. The
main advantage of this model is that it has no overhead - unlike tracing memory
which involves pausing execution or reference counting which involves atomic
count of references, a <span class="docutils literal"><span class="pre">unique_ptr</span></span> is just a wrapper over a pointer.</p>
<p>Unique pointers cannot be copied though (by definition, otherwise there would
no longer denote unique ownership), so when other code needs to access the heap
object, it would need to get a reference from the owning object:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">UseFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>

<span class="n">UseFoo</span><span class="p">(</span><span class="o">*</span><span class="n">bar</span><span class="p">.</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>The problem with this approach is that if another object ends up holding on to a
reference which outlives the owning object, the reference becomes dangling and
refers to an object which was already freed. This becomes the equivalent of a
<em>use after free</em>, so here is where the concept of <em>lifetime</em> becomes important:
none of the non-owning references of a uniquely owned heap object should outlive
the object.</p>
<p>Unfortunately in C++ this has to be handled through sensical design and is
mostly left up to the developer. Rust on the other hand provides strong static
analysis and lifetime annotations to ensure such issues do not occur. In fact,
the default in Rust is to have uniquely owned objects which can be “borrowed”
when needed and static analysis ensures no dangling references appear. In C++:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">Bar</span><span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">bar</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="o">*</span><span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// bar.foo is now a dangling pointer since Foo was freed</span>
</pre></div>
</div>
<p>The above example used a pointer for simplicity, since a <span class="docutils literal"><span class="pre">&amp;</span></span> reference
(<span class="docutils literal"><span class="pre">Foo&amp;</span></span>) needs to be bound at construction time, but same applies for
that type of reference: once an object gets freed, &amp; references and
non-owning pointers to it are left dangling. On the other hand, this does
not compile in Rust:</p>
<div class="highlight-rust"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="k">struct</span> <span class="nc">Bar</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="na">'a</span><span class="w"> </span><span class="n">Foo</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="p">...</span><span class="w"/>

<span class="kd">let</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"/>
<span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{};</span><span class="w"/>
<span class="w">    </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="nc">foo</span><span class="w"> </span><span class="p">};</span><span class="w"/>
<span class="p">}</span><span class="w"/>
<span class="c1">// compiler correctly shows `foo` dropped here while still borrowed</span>
</pre></div>
</div>
<p>In Rust, the compiler ensures dangling references (“borrowed” objects) do not
exist once owning object goes out of scope.</p>
<p>It seems that in most cases, the best approach to memory management is to use
the latter model of ownership and lifetimes which comes with no runtime
overhead and handle the dangling reference problem through static analysis.
The advantages of this approach extend beyond the runtime cost of other
automatic memory management techniques to a model which also works well in a
multi-threaded environment, eg. if we only allow the owner of an object to
modify it, we can eliminate certain data races. From a systems design
perspective it is also an advantage to have a clear understanding of ownership
throughout the system.</p>
</div>
</div>
</div>
<div class="section" id="summary">
<h1>Summary</h1>
<p>This post covered several memory management techniques, outlining their pros
and cons:</p>
<ul class="simple">
<li>Manual - human error prone</li>
<li>Automatic using a tracing garbage collector - safe but comes with runtime
overhead</li>
<li>Automatic using reference counting - smaller runtime cost than a tracing
garbage collector but needs additional mechanisms to deal with reference
cycles</li>
<li>Concepts of ownership and lifetime - no runtime overhead, but should be
supplemented by static analysis to avoid dangling references</li>
</ul>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2017/02/20/memory-management.html#disqus_thread" data-disqus-identifier="2017/02/20/memory-management">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>December 03, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/12/03/notes-on-error-handling.html">Notes on Error Handling</a></h1>
<p>I recently read Joe Duffy’s excellent blog post
<a class="reference external" href="http://joeduffyblog.com/2016/02/07/the-error-model/">The Error Model</a>. Joe
worked on Midori and has some great insights on error model design. I wanted to
write down a couple of personal notes on error handling.</p>
<div class="section" id="using-the-type-system">
<h2>Using the Type System</h2>
<p>Before even talking about error scenarios, it’s worth pointing out that there
are categories of errors where the type system helps if not to eliminate them,
at least to scope them and prevent them from propagating unchecked throughout
the system.</p>
<div class="section" id="arguments">
<h3>Arguments</h3>
<p>In many cases, an error means the value of some variable has an invalid value.
If this invalid value is passed down to called functions, it can manifests
itself deep in the stack when it could’ve been caught earlier. A simple example
would be move directions for a game - let’s say the player can move <span class="docutils literal"><span class="pre">Up</span></span>,
<span class="docutils literal"><span class="pre">Down</span></span>, <span class="docutils literal"><span class="pre">Left</span></span>, or <span class="docutils literal"><span class="pre">Right</span></span>. This can be encoded as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">int</span> <span class="n">UP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">LEFT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">DOWN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">RIGHT</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="p">...</span>

<span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="n">player</span> <span class="n">player</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">UP</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_up</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">LEFT</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_left</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">DOWN</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_down</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">RIGHT</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_right</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="c1">// direction should only be 0, 1, 2, 3</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but ultimately a caller can still pass any int value to this function which
would end up in the default branch as a direction the code doesn’t know how to
handle. The alternative is, of course:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">direction</span>
<span class="p">{</span>
    <span class="n">up</span><span class="p">,</span>
    <span class="n">left</span><span class="p">,</span>
    <span class="n">down</span><span class="p">,</span>
    <span class="n">right</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="n">direction</span> <span class="n">direction</span><span class="p">,</span> <span class="n">player</span> <span class="n">player</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, the type system ensures direction can only possibly hold one of
the allowed values. This is a trivial example but there are many more
interesting ones. Take for example some connection which, if opened, can receive
data and close and, if not opened, can be opened. This can be modelled like
this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">open</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection already opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="nf">close</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection not opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">receive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection not opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">is_opened</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we have to handle various cases where we try to perform an open-connection
operation on a connection that hasn’t been opened yet, and vice-versa. Another
way to model this (as of C++17) is using a variant and separate types for open
and closed connections:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">opened_connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">close</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="k">auto</span> <span class="n">receive</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">closed_connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">open</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">closed_connection</span><span class="p">,</span> <span class="n">opened_connection</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, as long as we have a <span class="docutils literal"><span class="pre">closed_connection</span></span> instance, we can only perform
closed-connection operations and as long as we have an <span class="docutils literal"><span class="pre">open_connection</span></span>
instance, we can only perform opened-connection operations. The error states we
had to handle above go away as the type system ensures we can never call
<span class="docutils literal"><span class="pre">receive</span></span> on a closed connection etc.</p>
</div>
<div class="section" id="return-values">
<h3>Return Values</h3>
<p>The type system can also be leveraged to embellish return types as an
alternative to using return codes. For example, assume we have a function which
parses a phone number provided by the user into some <span class="docutils literal"><span class="pre">phone_number_t</span></span> used
internally. There are a few ways to implement this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">phone_number_t</span> <span class="nf">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span> <span class="c1">// assume we can construct a phone_number_t from a valid string</span>
    <span class="k">else</span>
        <span class="k">throw</span> <span class="n">invalid_phone_number</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not ideal though, since exception should really be exceptional (more on
this below), and user providing invalid input should be a completely valid
scenario. The alternative would be to use a return code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">bool</span> <span class="nf">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">phone_number_t</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, but calling code is uglier:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">phone_number</span> <span class="o">=</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
</pre></div>
</div>
<p>now becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">phone_number_t</span> <span class="n">phone_number</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">phone_number</span><span class="p">);</span>
</pre></div>
</div>
<p>We can also end up in a bad state if we forget to check the return value. The
alternative is to encode the information that we either have a
<span class="docutils literal"><span class="pre">phone_number_t</span></span> or an invalid number in a type. In C++ we have (as of C++17)
<span class="docutils literal"><span class="pre">optional&lt;T&gt;</span></span> for this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">optional</span><span class="o">&lt;</span><span class="n">phone_number_t</span><span class="o">&gt;</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nullopt</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not quite a return error code and cannot really be ignored - there is no
implicit case from <span class="docutils literal"><span class="pre">optional&lt;T&gt;</span></span> to <span class="docutils literal"><span class="pre">T</span></span>, so callers need to explicitly
handle the case when the operation failed. Calling this is as natural as the
throwing version, but does not rely on exceptions <a class="footnote-reference" href="#id3" id="id1">[1]</a>. This is also called
<em>monadic error handling</em> and is widely employed by functional languages. I find
this a good alternative to throwing exceptions as long as it is well scoped and
error checks don’t have to pollute too many functions in the call stack.</p>
</div>
</div>
<div class="section" id="preconditions">
<h2>Preconditions</h2>
<p>Preconditions are conditions that should be satisfied upon entering a function
to ensure the function works as expected. When a function is called but the
preconditions are not met, it is not an error, it is a developer bug. The
recommended way of handling such a situation is, if possible, to crash
immediately. The reason for crashing is that calling a function with
preconditions not being met means the system is an invalid state and attempting
recovery is usually not worth it. Crashing on the other hand would provide
developers with dumps to help understand how the system got into this state and
fix the underlying bug.</p>
<p>The alternative to this is undefined behavior - calling a function without
meeting the preconditions cannot guarantee anything about the execution of the
function. Undefined behavior is used extensively throughout the C++ standard
<a class="footnote-reference" href="#id4" id="id2">[2]</a>. While failing fast is the preferred approach, sometimes it is unfeasible
to check preconditions at runtime: for example a precondition of binary search
is that it searches over an ordered range. Performing a binary search takes
logarithmic time but validating that a range is ordered takes linear time, so
adding this check would negatively impact the run time of the algorithm. In this
case, it is OK to say that we cannot provide any guarantees on what the function
will do. Debug-time asserts are a middle ground solution, since we can afford to
perform more expensive checks in debug builds to deterministically fail when
preconditions are not met. That being said, if the check is not prohibitively
expensive, it should be performed on all build flavors and immediately fail (via
<span class="docutils literal"><span class="pre">std::terminate</span></span> or equivalent).</p>
<p>What should not be done is treating such a state as an error - this is a bug in
the code and throwing an exception or returning some error result would just
leak the bug and make it impact more of the system. There really isn’t anything
useful to do with such an error - it only tells us that there is an issue in the
code and we are now in a state we should never be in. At this point we don’t
know which component originated the error and we cannot deterministically
recover - we might abort the current operation but there is no guarantee that
this would bring us back to a valid state. We are in undefined behavior land,
where crashing is the best option.</p>
</div>
<div class="section" id="recoverable-errors">
<h2>Recoverable Errors</h2>
<p>We covered several ways to handle errors by either eliminating invalid states at
compile-time or by failing fast when in an invalid state. There are, on the
other hand, classes of errors from which we can legitimately recover, which
brings us to exception and error codes.</p>
<div class="section" id="exceptions">
<h3>Exceptions</h3>
<p>I am a big fan of handling exceptional states using exceptions over returning
error codes. For one, the code is more readable: instead of reserving the return
type of a function to signal success or failure and resort to out parameters,
functions can be declared in a natural way. We also end up with less code
overall as instead of having to check error codes inside all functions in the
call stack in order to propagate back an error, we simply throw it from the top
of the stack and catch it where we can deal with it. This approach also composes
better - take, for example, a generic algorithm that takes some throwing
function. Since we supply the predicate, we know what exception it can throw and
we can catch it in the code that invokes the generic algorithm, keeping this
invisible to the algorithm:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryFunction</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryFunction</span> <span class="n">f</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">UnaryFunction</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
        <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If our predicate returns an error code instead, the generic algorithm must be
aware of this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryFunction</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryFunction</span> <span class="n">f</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that here we are also making an assumption that 0 means success, which is
an arbitrary decision for a plug-in function.</p>
<p>That being said, I want to reiterate that exceptions should only be used for
exceptional cases. The readability advantage gained with exceptions is lost if
they are abused. It’s great if the callee throws one or two exception types
which the caller catches and handles. On the other hand, if we have to resort to
catch-all <span class="docutils literal"><span class="pre">catch</span> <span class="pre">(...)</span></span> and we have so many possible exception types coming
out of a function that we can’t keep track of them, the code actually becomes
harder to reason about.</p>
<p>An example and a counter-example: when reading a file with a set schema
generated by our application, we expect it to be in a valid format. If it isn’t,
it means some data corruption occurred but this should really be an exceptional
case. If we encounter such data corruption, we can throw an exception and let
the caller handle the fact that we cannot interpret this file. On the other
hand, when reading user input, we should never throw an exception if input is
not conforming - this should be a much more common scenario of user error.</p>
</div>
<div class="section" id="return-codes">
<h3>Return Codes</h3>
<p>There are cases which are not exceptional enough to warrant an exception but
where some error information needs to be propagated through the call stack.
Take, for example, a compiler which encounters an invalid token while parsing a
file. Since this is user input, it should not be treated as an exception. On the
other hand, simply using an optional and failing to parse without providing
additional information is also not ideal. In this case we probably want to
return additional information around the encountered error.</p>
<p>In this case we would return the error rather than throw it, but I would still
prefer an embellished type like Rust’s <span class="docutils literal"><span class="pre">Result</span></span> and return an
<span class="docutils literal"><span class="pre">std::variant&lt;T,</span> <span class="pre">Error&gt;</span></span> (as of C++17). In general I consider bad practice
returning an <span class="docutils literal"><span class="pre">int</span></span> or an <span class="docutils literal"><span class="pre">HRESULT</span></span> which would afterwards have to be decoded
to understand the actual error. For simple cases, if no other information
besides success/failure has to be returned, a <span class="docutils literal"><span class="pre">bool</span></span> would suffice, or an
<span class="docutils literal"><span class="pre">enum</span></span> or <span class="docutils literal"><span class="pre">struct</span></span> which contains the expected error information. Such an
error type can be composed with a valid return type using a variant which brings
us back to monadic error-handling.</p>
<p>My general rule of thumb is to use exceptions for really exceptional situations,
which keeps the code cleaner as long as the number of exception types is
managable, and use monadic error handling when errors are expected, as long as
these can be scoped to a limited number of functions (repeated error checking
all over the place is messy, error-prone, and makes code hard to read).</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We went over various ways of handling errors:</p>
<ul class="simple">
<li>Declaring types that restrict the range of values a variable can take to
eliminate invalid states at compile-time</li>
<li>Monadic error handling using embelished return types</li>
<li>Failing fast when preconditions of a function are not met</li>
<li>Throwing exceptions in exceptional cases</li>
<li>Returning strongly typed errors when errors are not exceptional</li>
</ul>
<p>There is still a fair amount of controversy around what is <em>the right way</em> of
handling errors. My personal take on this is that there are tradeoffs that come
with each approach and rather than saying “always use exceptions” or “never use
exceptions”, it’s more a matter of choosing <em>the right tool for the job</em>. I
tried to list some of the possible approaches with their pros and cons, and how
I employ them. Your mileage may vary depending on your specific language,
runtime, problem domain, application type etc.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This is the recommended way of <a class="reference external" href="https://doc.rust-lang.org/book/error-handling.html">handling errors in Rust</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>See Chandler Carruth’s CppCon talk <a class="reference external" href="https://www.youtube.com/watch?v=yG1OZ69H_-o">Garbage In, Garbage Out</a>.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/12/03/notes-on-error-handling.html#disqus_thread" data-disqus-identifier="2016/12/03/notes-on-error-handling">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>October 16, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/10/16/notes-on-types.html">Notes on Types</a></h1>
<div class="section" id="type-systems">
<h2>Type Systems</h2>
<p>A good type system can eliminate entire categories of errors in a program and
simply make invalid code not compile. Before digging into types, below are a few
common distinctions between the type systems of various programming languages:</p>
<div class="section" id="dynamic-typing-vs-static-typing">
<h3>Dynamic Typing vs Static Typing</h3>
<p>In a statically typed language, the types are determined at compile time so if a
function was declared as only accepting a certain type <span class="docutils literal"><span class="pre">T</span></span> but we attempt to
pass it an unrelated type <span class="docutils literal"><span class="pre">U</span></span>, the program is considered invalid. This is
invalid C++:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">sqr</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">sqr</span><span class="p">(</span><span class="s">"not an int"</span><span class="p">);</span> <span class="c1">// does not compile</span>
</pre></div>
</div>
<p>On the other hand, in a dynamically typed language, we do not perform any
compile time checks and, if the data we get is of an unexpected type, we treat
it as a runtime error. Below is a Python function that squares a number:</p>
<div class="highlight-python"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">sqr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
<span class="o">...</span>
<span class="n">sqr</span><span class="p">(</span><span class="s2">"not an int"</span><span class="p">)</span>
<span class="c1"># runs but fails with TypeError: unsupported operand type(s)</span>
<span class="c1"># for ** or pow(): 'str' and 'int'</span>
</pre></div>
</div>
<p>Some of the interesting features of dynamic languages are <em>duck typing</em> (“if it
walks like a duck, and it quacks like a duck...”) and <em>monkey patching</em>. Duck
typing means that accessing a member of an object works as long as that object
has such a member, regardless of the type of the object. In Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"bar"</span><span class="p">)</span>

<span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Foo</span><span class="p">(),</span> <span class="n">Bar</span><span class="p">()]]</span> <span class="c1"># prints "foo" and "bar"</span>
</pre></div>
</div>
<p>This can’t work in a statically typed language where, at the bare minimum, we
would have to add some form of constraint for the types in the list to ensure
they contain a <span class="docutils literal"><span class="pre">func()</span></span> method we can call.</p>
<p>Monkey patching refers to the ability to change the structure of an object at
runtime. For example we can swap the <span class="docutils literal"><span class="pre">func</span></span> method from an instance of <span class="docutils literal"><span class="pre">foo</span></span>
with another function like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func_bar</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"bar"</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="c1"># prints "foo"</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func_bar</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="c1"># prints "bar"</span>
</pre></div>
</div>
<p>These are useful capabilities, but the tradeoff is a whole class of type errors
which a statically typed language would’ve caught.</p>
<p>As a side note, the fact that dynamic languages don’t need to specify types
makes them more terse. That being said, the
<a class="reference external" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner algorithm W</a>
can infer the types of a program in linear time with respect to the source size.
So while Python is starting to support type annotations for better static
analysis and TypeScript provides a way for writing type-safe JavaScript, C++ has
better and better type inference, while in Haskell (which has one of the
strongest static type systems) type annotations are mostly optional.</p>
</div>
<div class="section" id="strong-typing-vs-weak-typing">
<h3>Strong Typing vs Weak Typing</h3>
<p>At a high level, a strongly typed language does not implicitly convert between
unrelated types. This is good in most situations as implicit conversions are
often meaningless or have surprising effects - for example, adding a number to
a list of characters. This can either result in runtime errors or garbage data.
In contrast, a strongly typed language will not accept code that attempts to do
this.</p>
<p>In Python, which is strongly typed, this doesn’t work:</p>
<div class="highlight-python"><div class="highlight"><pre><span/><span class="n">foo</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="c1"># foo is "foo"</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="s2">" bar"</span> <span class="c1"># foo is "foo bar"</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1"># TypeError: Can't convert 'int' object to str implicitly</span>
</pre></div>
</div>
<p>It works just fine in JavaScript though:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span/><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s2">"foo"</span><span class="p">;</span> <span class="c1">// foo is "foo"</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">+</span> <span class="s2">" bar"</span><span class="p">;</span> <span class="c1">// foo is "foo bar"</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// foo is "foo bar5"</span>
</pre></div>
</div>
<p>Note type strength is not an either/or - C++, while considered strongly typed,
still allows several implicit casts between types (eg. pointer to bool). Some
languages are more strict about converting between types implicitly, others less
so.</p>
</div>
<div class="section" id="dynamic-polymorphism-vs-static-polymorphism">
<h3>Dynamic Polymorphism vs Static Polymorphism</h3>
<p>Another difference to note is between static and dynamic polymorphism. Dynamic
polymorphism happens at runtime, when calling a function on a base type gets
resolved to the actual function of the deriving type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">foo</span> <span class="p">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">bar</span> <span class="p">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">call_func</span><span class="p">(</span><span class="n">base</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">foo</span><span class="p">{});</span> <span class="c1">// prints "foo"</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">bar</span><span class="p">{});</span> <span class="c1">// prints "bar"</span>
</pre></div>
</div>
<p>In the above case, we effectively have a single function <span class="docutils literal"><span class="pre">call_func</span></span> which
takes a reference to a <span class="docutils literal"><span class="pre">base</span></span> struct. The compiler generates a v-table for
<span class="docutils literal"><span class="pre">struct</span> <span class="pre">base</span></span> and a call to <span class="docutils literal"><span class="pre">func()</span></span> on <span class="docutils literal"><span class="pre">base</span></span> involves a v-table jump to
the actual implementation of the function, which is different between the
inheriting types <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span>.</p>
<p>Contrast this with the static alternative:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foo</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bar</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">call_func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">foo</span><span class="p">{});</span> <span class="c1">// prints "foo"</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">bar</span><span class="p">{});</span> <span class="c1">// prints "bar"</span>
</pre></div>
</div>
<p>In this case there is no relationship between <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span> and no v-table
is needed. On the other hand, we no longer have a single <span class="docutils literal"><span class="pre">call_func</span></span>, we have
a templated function which is instantiated for both <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span> types.
This is all done at compile-time, the advantage being faster code, the drawback
being compiler needs to be aware of all the types involved - we can no longer
“inject” types implementing an interface at runtime. When calling <span class="docutils literal"><span class="pre">call_func</span></span>,
we need to have both the definition of the function and the declaration of the
type we’re passing in visible.</p>
</div>
</div>
<div class="section" id="types">
<h2>Types</h2>
<p>During the rest of this post, I will talk about types in the context of a
statically and strongly typed language, with a focus on static polymorphism.
This pushes as much as possible of the type checking to the compilation stage,
so many of the runtime issues of less strict languages become invalid syntax.</p>
<p>I will focus on C++ and cover some of the new C++17 feature which enable or make
some of these concepts easier to work with. That being said, since this post
focuses on types, I will also provide examples in Haskell, as Haskell can
express these concepts much more succinctly.</p>
<div class="section" id="type-basics">
<h3>Type Basics</h3>
<p>Let’s start with the definition of a type: <em>a type represents the set of
possible values</em>. For example, the C++ type <span class="docutils literal"><span class="pre">uint8_t</span></span> represents the set of
integers from 0 to 255. Effectively this means that a variable of a given type
can only have values from within that set.</p>
</div>
<div class="section" id="interesting-types">
<h3>Interesting Types</h3>
<p>Since we defined a type as a set of possible values, we can talk about the
cardinality of a type, in other words the number of values in the set. Based on
cardinality, there are a few interesting classes of types to talk about:</p>
</div>
<div class="section" id="empty-type">
<h3>Empty Type</h3>
<p>The first interesting type to talk about is the type that represents the empty
set, with <span class="docutils literal"><span class="pre">|T|</span> <span class="pre">=</span> <span class="pre">0</span></span>.</p>
<p>In Haskell, this type is named <span class="docutils literal"><span class="pre">Void</span></span>. Since Haskell is a functional language,
all functions must return a value, so it does not make sense to have a function
that returns <span class="docutils literal"><span class="pre">Void</span></span> - the same way it doesn’t make sense to define a
mathematical function with the empty set as its codomain. We do have an
<span class="docutils literal"><span class="pre">absurd</span></span> function though, which maps the empty set to any value:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="nf">absurd</span> <span class="ow">::</span> <span class="kt">Void</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>This function cannot be called though.</p>
<p>In C++, the absence of a value is represented as the <span class="docutils literal"><span class="pre">void</span></span> type. Since C++ is
not purely functional, we can define functions that don’t return anything. We
can even say that a function does not take any arguments by putting a <span class="docutils literal"><span class="pre">void</span></span>
between the parenthesis:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the equivalent of:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span>
</pre></div>
</div>
<p>Note though that we cannot have a <em>real</em> argument of type <span class="docutils literal"><span class="pre">void</span></span>, that is a
compile error as it doesn’t make any sense - we would be mandating the function
takes a value from the empty set. So we can say <span class="docutils literal"><span class="pre">foo(void)</span></span> but not
<span class="docutils literal"><span class="pre">foo(void</span> <span class="pre">arg)</span></span>, or even <span class="docutils literal"><span class="pre">foo(int</span> <span class="pre">arg,</span> <span class="pre">void)</span></span>.</p>
</div>
<div class="section" id="unit-type">
<h3>Unit Type</h3>
<p>The next interesting class consists of types with cardinality 1. A type <span class="docutils literal"><span class="pre">T</span></span>
with <span class="docutils literal"><span class="pre">|T|</span> <span class="pre">=</span> <span class="pre">1</span></span> is called a <em>unit</em> or <em>singleton type</em>. A variable of such a
type can only ever have a single possible value. In Haskell, the anonymous
representation is the empty tuple <span class="docutils literal"><span class="pre">()</span></span>. Here is an example of a function that
maps anything to this type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="nf">unit</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">unit</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Of course, we can declare our own singleton types. Below is a custom
<span class="docutils literal"><span class="pre">Singleton</span></span> type and an equivalent unit function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Singleton</span> <span class="ow">=</span> <span class="kt">Singleton</span>
<span class="nf">unit</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Singleton</span>
<span class="nf">unit</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Singleton</span>
</pre></div>
</div>
<p>In C++, the anonymous representation of a singleton is an empty <span class="docutils literal"><span class="pre">std::tuple</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As can be seen from the above, Haskell makes it easier to define a function that
takes an argument of any type, as it provides syntactic sugar for type
parameters (<span class="docutils literal"><span class="pre">a</span></span> in our example). In C++, the equivalent declaration involves a
template, but they boil down to the same thing. The non-anonymous C++
representation is a struct which doesn’t contain anything. All instances of such
a struct are equivalent:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">singleton</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">singleton</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sum-types">
<h3>Sum Types</h3>
<p>Here, things get a bit more interesting: a <span class="docutils literal"><span class="pre">sum</span> <span class="pre">type</span></span> is a type which can
represent a value from any of the types it sums. So given type <span class="docutils literal"><span class="pre">A</span></span> and type
<span class="docutils literal"><span class="pre">B</span></span>, the type <span class="docutils literal"><span class="pre">S</span></span> summing up <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> is <span class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:</span> <span class="pre">i</span> <span class="pre">∈</span> <span class="pre">A</span> <span class="pre">U</span> <span class="pre">B</span> <span class="pre">}</span></span>.
So a variable of type <span class="docutils literal"><span class="pre">S</span></span> could have any value in <span class="docutils literal"><span class="pre">A</span></span> or any value in <span class="docutils literal"><span class="pre">B</span></span>.
<span class="docutils literal"><span class="pre">S</span></span> is called a sum type because its cardinality is the sum of the
cardinalities of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span>, <span class="docutils literal"><span class="pre">|S|</span> <span class="pre">=</span> <span class="pre">|A|</span> <span class="pre">+</span> <span class="pre">|B|</span></span>.</p>
<p>Sum types are great, because they allow us to build up more complex types from
simpler ones. Once we have unit types, we can build up more complex types out
of them by summing them. For example, a boolean type which can be either
<span class="docutils literal"><span class="pre">true</span></span> or <span class="docutils literal"><span class="pre">false</span></span> can be thought of as the sum of the singleton <span class="docutils literal"><span class="pre">true</span></span>
type and the singleton <span class="docutils literal"><span class="pre">false</span></span> type. In Haskell, a boolean is defined as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">True</span> <span class="o">|</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Similarly, a <span class="docutils literal"><span class="pre">Weekday</span></span> type can be defined as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Weekday</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
</pre></div>
</div>
<p>Theoretically, numerical types could also be defined as huge sum types of every
possible value they can represent. Of course, this is impractical, but we can
reason about them the same way we reason about other sum types, we don’t have to
treat them as a special case.</p>
<p>In C++, an equivalent of the above is an <span class="docutils literal"><span class="pre">enum</span> <span class="pre">class</span></span>. <span class="docutils literal"><span class="pre">bool</span></span> is a built-in
type with special syntax, but we could define an equivalent as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">Boolean</span>
<span class="p">{</span>
    <span class="n">True</span><span class="p">,</span>
    <span class="n">False</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It’s easy to see how a <span class="docutils literal"><span class="pre">Weekday</span></span> definition would look like. Things get more
interesting when we throw type parameters into the mix. In Haskell, we have the
<span class="docutils literal"><span class="pre">Either</span></span> type, which is declared as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</pre></div>
</div>
<p>An instance of this could be either a <span class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></span>, where <span class="docutils literal"><span class="pre">a</span></span> is a type itself,
which means it can be any of the values of <span class="docutils literal"><span class="pre">a</span></span>, or it can be <span class="docutils literal"><span class="pre">Right</span> <span class="pre">b</span></span>, with
any of the values of <span class="docutils literal"><span class="pre">b</span></span>. In Haskell we use pattern-matching to operate on
such a type, so we can declare a simple function that tells us whether we were
given a <span class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></span> like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="nf">isLeft</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isLeft</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isLeft</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>This might not look like much, but of course we can compose more complex
functions. For example, say we have a function <span class="docutils literal"><span class="pre">foo</span></span> that takes an <span class="docutils literal"><span class="pre">a</span></span> and
returns an <span class="docutils literal"><span class="pre">a</span></span>, a function <span class="docutils literal"><span class="pre">bar</span></span> that takes a <span class="docutils literal"><span class="pre">b</span></span> and returns a <span class="docutils literal"><span class="pre">b</span></span>. We
can then write a <span class="docutils literal"><span class="pre">transform</span></span> function which takes an <span class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></span> and,
depending on the contained type, it applies the appropriate function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="c1">-- Implementation of foo and bar not provided in this example</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">bar</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">bar</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>This is way beyond the capabilities of a C++ <span class="docutils literal"><span class="pre">enum</span> <span class="pre">class</span></span>. The old way of
implementing something like this in C++ was using a union and a tag enum to keep
track of which is the actual type we’re working with:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Declaration of A and B not provided in this example</span>
<span class="k">struct</span> <span class="n">A</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Either</span>
<span class="p">{</span>
    <span class="n">Either</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ab</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">::</span><span class="n">isA</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Either</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ab</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">::</span><span class="n">isB</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">A</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">B</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">ab</span><span class="p">;</span>

    <span class="k">enum</span> <span class="k">class</span> <span class="nc">tag</span>
    <span class="p">{</span>
        <span class="n">isA</span><span class="p">,</span>
        <span class="n">isB</span>
    <span class="p">}</span> <span class="n">tag</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Our implementation of transform would look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Implementation of A and B not provided in this example</span>
<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">B</span> <span class="nf">bar</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>

<span class="n">Either</span> <span class="nf">transform</span><span class="p">(</span><span class="n">Either</span> <span class="n">either</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">Either</span><span class="o">::</span><span class="n">tag</span><span class="o">::</span><span class="nl">isA</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">ab</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">Either</span><span class="o">::</span><span class="n">tag</span><span class="o">::</span><span class="nl">isB</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bar</span><span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">ab</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our <span class="docutils literal"><span class="pre">Either</span></span> type definition is obviously much more verbose than what we had
in Haskell, and it doesn’t even support type parameters - at this point it only
works with <span class="docutils literal"><span class="pre">struct</span> <span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">struct</span> <span class="pre">B</span></span>, while the Haskell version works for
any <span class="docutils literal"><span class="pre">a</span></span> and <span class="docutils literal"><span class="pre">b</span></span> types. The other major problem is that, while unions provide
efficient storage for different types (the size of the union is the size of the
maximum contained type), it is up to the implementer to make sure we don’t try
to read an <span class="docutils literal"><span class="pre">A</span></span> as a <span class="docutils literal"><span class="pre">B</span></span> or vice-versa. That means we need to keep our tag in
sync with what we put in the type and respect it when accessing the value of the
union.</p>
<p>C++17 introduces a better, safer, parameterized type for this: <span class="docutils literal"><span class="pre">std::variant</span></span>.
Variant takes any number of types as template arguments and stores an instance
of any one of those types. Using variant, we can re-write the above as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">either</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">([](</span><span class="k">auto</span> <span class="n">e</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nf">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
    <span class="p">},</span> <span class="n">either</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a lot of new syntax, so let’s break it down: <span class="docutils literal"><span class="pre">std::variant&lt;A,</span> <span class="pre">B&gt;</span></span> is
the new C++17 sum type. In this case, we specify it holds either <span class="docutils literal"><span class="pre">A</span></span> or <span class="docutils literal"><span class="pre">B</span></span>
(but it can hold an arbitrary number of types).</p>
<p><span class="docutils literal"><span class="pre">std::visit</span></span> is a function that applies the visitor function given as its
first argument to the variants given as its subsequent arguments. In our
example, this effectively expands to applying the lambda to
<span class="docutils literal"><span class="pre">std::get&lt;0&gt;(either)</span></span> and <span class="docutils literal"><span class="pre">std::get&lt;1&gt;(either)</span></span>.</p>
<p><span class="docutils literal"><span class="pre">if</span> <span class="pre">constexpr</span></span> is also a new C++17 construct which evaluates the if expression
at compile time and discards the else branch from the final object code. So in
this example, we determine at compile time whether the type we are being called
with is <span class="docutils literal"><span class="pre">A</span></span> or <span class="docutils literal"><span class="pre">B</span></span> and apply the correct function based on that. Something
very similar can be achieved with templates and <span class="docutils literal"><span class="pre">enable_if</span></span>, but this syntax
makes for more readable code.</p>
<p>Note that with this version we can simply prepend a <span class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;typename</span> <span class="pre">A,</span>
<span class="pre">typename</span> <span class="pre">B&gt;</span></span> and make the whole function generic, as in the Haskell example. It
doesn’t read as pretty (because we don’t have good pattern matching syntax in
the language), but this is the new, type safe way of implementing and working
with sum types, which is a major improvement.</p>
</div>
<div class="section" id="product-types">
<h3>Product Types</h3>
<p>With sum types out of the way, the remaining interesting category is that of
<em>product types</em>. Product types combine the values of several other types into
one. For types <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span>, we have <span class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">(a,</span> <span class="pre">b)</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">∈</span> <span class="pre">A,</span> <span class="pre">b</span> <span class="pre">∈</span> <span class="pre">B</span> <span class="pre">}</span></span>, so
<span class="docutils literal"><span class="pre">|P|</span> <span class="pre">=</span> <span class="pre">|A|</span> <span class="pre">x</span> <span class="pre">|B|</span></span>.</p>
<p>In Haskell, the anonymous version of product types is represented by tuples,
while the named version is represented by records. An example of a <span class="docutils literal"><span class="pre">perimeter</span></span>
function which computes the perimeter of a rectangle defined by two points,
where each point is a tuple of numbers:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="nf">perimeter</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">n</span>
<span class="nf">perimeter</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span>
</pre></div>
</div>
<p>The named version would declare a <span class="docutils literal"><span class="pre">Point</span></span> type with <span class="docutils literal"><span class="pre">Int</span></span> coordinates and
use that instead:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="nf">perimeter</span> <span class="ow">::</span> <span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">perimeter</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span>
</pre></div>
</div>
<p>The C++ equivalents are <span class="docutils literal"><span class="pre">std::tuple</span></span> for anonymous product types and
<span class="docutils literal"><span class="pre">struct</span></span> for named types:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Anonymous</span>
<span class="kt">int</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span>
        <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// Named</span>
<span class="k">struct</span> <span class="n">point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">point</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While sum types allow us to express values from multiple types into one, product
types allow us to express values from several types together. Empty, unit, sum,
and product types are the building blocks of a type system.</p>
</div>
<div class="section" id="bonus-optional-types">
<h3>Bonus: Optional Types</h3>
<p>An optional type is a type that can hold any of the values of another type, or
not hold any value, which is usually represented as a singleton. So an optional
is effectively a sum type between a given type and a singleton representing
“doesn’t hold a value”. In other words, the cardinality of an optional for a
type <span class="docutils literal"><span class="pre">T</span></span> is <span class="docutils literal"><span class="pre">|O|</span> <span class="pre">=</span> <span class="pre">|T|</span> <span class="pre">+</span> <span class="pre">1</span></span>.</p>
<p>In Haskell, an optional is the famous <span class="docutils literal"><span class="pre">Maybe</span></span> type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>A function that operates on <span class="docutils literal"><span class="pre">Maybe</span></span> could say “only apply <span class="docutils literal"><span class="pre">foo</span></span> if the
optional contains an <span class="docutils literal"><span class="pre">a</span></span>”:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span/><span class="c1">-- Implementation of foo not provided in this example</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">transform</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>The new C++17 equivalent is the <span class="docutils literal"><span class="pre">optional</span></span> type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Implementation of foo not provided in this example</span>
<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">nullopt</span> <span class="o">?</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">nullopt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This might read a bit like the pointer implementation:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">A</span><span class="o">*</span> <span class="nf">transform</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">?</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a key difference though: the type contained in the optional is part of
the object, so it is not allocated dynamically the way we would allocate a
pointer. <span class="docutils literal"><span class="pre">nullopt</span></span> is a helper object of the singleton type <span class="docutils literal"><span class="pre">nullopt_t</span></span>.</p>
<p>Types are important because a big part of programming effectively consits of
designing and composing types. Having a good understanding of the fundamentals
leads to better, safer, and saner code.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We started by outlining some of the basic principles of type systems:</p>
<ul class="simple">
<li>Static and dynamic typing</li>
<li>Weak and strong typing</li>
<li>Static and dynamic polymorphism</li>
</ul>
<p>Then we went over the building block types of a type system, with Haskell and
C++ examples:</p>
<ul class="simple">
<li>Empty types (cardinality 0)</li>
<li>Unit types (cardinality 1)</li>
<li>Sum types (<span class="docutils literal"><span class="pre">S</span></span> of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></span>)</li>
<li>Product types (<span class="docutils literal"><span class="pre">P</span></span> of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">B</span></span>)</li>
<li>Optional types (<span class="docutils literal"><span class="pre">O</span></span> of <span class="docutils literal"><span class="pre">A</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">1</span></span>)</li>
</ul>
</div>
<div class="section" id="further-reading">
<h2>Further Reading</h2>
<p>Ben Dean had an excellent talk at CppCon this year, <a class="reference external" href="https://www.youtube.com/watch?v=ojZbFIQSdl8">Using Types Effectively</a>. Another great talk about type
design from CppCon is <a class="reference external" href="https://www.youtube.com/watch?v=632a-DMM5J0">C++, Abstract Algebra and Practical Applications</a> by Robert Ramey. And then there
is Bartosz Milewski <a class="reference external" href="https://bartoszmilewski.com/">blog</a> about Haskell,
C++, and category theory.</p>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/10/16/notes-on-types.html#disqus_thread" data-disqus-identifier="2016/10/16/notes-on-types">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>October 09, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/10/09/composable-generators.html">Composable Generators</a></h1>
<p>One of the most exciting features coming to C++ are coroutines. In this post,
I will give a quick overview of how they are used today in C# to support
generators and go over a few possible ways to bring the composability of Linq to
the C++ world.</p>
<div class="section" id="generators-in-c">
<h2>Generators in C#</h2>
<p>I will not go into the nitty-gritty details of coroutines, but in short, they
are resumable functions – functions that can be suspended/resumed. Coroutines
enable lazy evaluation, with two major applications: easy to read
multi-threading (with async/await syntax in C#) and generators (with yield
return syntax in C#). In this post, I will focus on generators and how they
compose.</p>
<p>I will start with a C# example since Linq is, in my opinion, the golden
standard for creating a processing pipeline, at least for non-functional
languages. Linq is implemented as a set of extension methods for
<span class="docutils literal"><span class="pre">IEnumerable</span></span>, and enables some very readable chaining of operations. For
example, let’s get the first 100 natural numbers, filter out the odds, then
square the remaining list.</p>
<p>The wrong way of doing this would be something like:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetNumbers</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">GetNumbers</span><span class="p">();</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main problem with the above is that all the logic is inlined into
<span class="docutils literal"><span class="pre">GetNumbers</span></span>, so things don’t decompose very well – for example what if we
also want a function that squares the odd numbers? We would either duplicate the
looping and squaring logic, or make the predicate we use to filter out things an
input to the function. Same goes for the iterating logic and for the squaring.
Luckily, we have Linq, which does just that:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span>
        <span class="n">Enumerable</span><span class="p">.</span><span class="n">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">).</span>
        <span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">).</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To illustrate the magic of generators, instead of relying on
<span class="docutils literal"><span class="pre">Enumerable.Range</span></span>, let’s introduce a function that generates numbers
forever:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">Count</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our code would then become:</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span>
        <span class="n">Count</span><span class="p">().</span>
        <span class="n">Take</span><span class="p">(</span><span class="m">100</span><span class="p">).</span>
        <span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">).</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While not strictly necessary in this particular case, infinite generators cannot
exist without lazy evaluation, a feature of many functional languages. Lazy
evaluation has some very practical applications as it allows processing of data
as it becomes available, instead of waiting for everything to be ready before
moving on to the next step. While the 100 natural numbers example might not
sound so useful, imagine rendering frames in a streaming video as they arrive
over the network. Linq is great because it provides a clean separation between
the generic algorithms (<span class="docutils literal"><span class="pre">Where</span></span>, <span class="docutils literal"><span class="pre">Select</span></span> etc.) and the problem-specific
operations which are passed in as arguments. Linq operations also compose well,
so they can be chained together to form pipelines.</p>
</div>
<div class="section" id="id1">
<h2>Generators in C++</h2>
<p>While coroutines haven’t made it into the C++17 standard itself, they are coming
as a technical specification, with MSVC already supporting them (code samples
below compile with VS 2015 Update 3). The main syntax additions are the new
<span class="docutils literal"><span class="pre">co_await</span></span>, <span class="docutils literal"><span class="pre">co_return</span></span>, and <span class="docutils literal"><span class="pre">co_yield</span></span> keywords. The first two are used
for creating and awaiting tasks (which I won’t cover in this post), while
<span class="docutils literal"><span class="pre">co_yield</span></span> is used in generators.</p>
<p>Here is a lazy counter in C++:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="nf">count_to</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">count_to</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the return type of <span class="docutils literal"><span class="pre">count_to</span></span> is a <span class="docutils literal"><span class="pre">generator&lt;int&gt;</span></span> (currently in the
experimental namespace). <span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span> is the type implicitly created by the
compiler when encountering a <span class="docutils literal"><span class="pre">co_yield</span></span>. Also worth noting that range-based
for loops work over generators, as they expose <span class="docutils literal"><span class="pre">begin()</span></span> and <span class="docutils literal"><span class="pre">end()</span></span>
methods. The type annotation for the <span class="docutils literal"><span class="pre">count_to</span></span> return type above is not
really needed, I added it just to clarify what the complier will generate in
this case.</p>
<p><span class="docutils literal"><span class="pre">generator</span></span> itself is pretty bare-boned, it doesn’t provide all the algorithms
that Linq adds to <span class="docutils literal"><span class="pre">IEnumerable</span></span>. So if we wanted to do something like the
above pipeline, we would need some algorithms. Here’s one way of implementing
some of them:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="nf">count</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here I switched from Linq’s <span class="docutils literal"><span class="pre">Select</span></span> and <span class="docutils literal"><span class="pre">Where</span></span> to the more commonly used
<span class="docutils literal"><span class="pre">map</span></span> and <span class="docutils literal"><span class="pre">filter</span></span>, but they effectively implement the same thing. While
this implementation is pretty-straight forward, it doesn’t compose well at all:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">map</span><span class="p">(</span>
            <span class="n">filter</span><span class="p">(</span>
                <span class="n">take_n</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="mi">100</span><span class="p">),</span>
                <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}),</span>
            <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Definitely not like the nice chaining of Linq. So what gives? Why doesn’t
generator come out-of-the-box with <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">map</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> and all the
other useful algorithms? Well, according to the
<a class="reference external" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>,
these algorithms don’t belong in <span class="docutils literal"><span class="pre">generator</span></span> – <span class="docutils literal"><span class="pre">generator</span></span> encapsulates the
lazy evaluation of the coroutine, it wouldn’t be the right place for algorithms.
It’s also worth noting that Linq methods are not part of <span class="docutils literal"><span class="pre">IEnumerable</span></span>, they
are <a class="reference external" href="https://msdn.microsoft.com/en-us/library/bb383977.aspx">extension methods</a>.
C++ doesn’t support extension methods, so we would need a slightly different
design to achieve better chaining.</p>
</div>
<div class="section" id="decorator">
<h2>Decorator</h2>
<p>The next idea comes from pure OOP - let’s create a decorator over <span class="docutils literal"><span class="pre">generator</span></span>
that exposes these algorithms. First, let’s declare our decorator as
<span class="docutils literal"><span class="pre">enumerable&lt;T&gt;</span></span> and change our algorithms to work with the new type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enumerable</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation looks pretty much like before, except that now we are getting
and returning <span class="docutils literal"><span class="pre">enumerable&lt;T&gt;</span></span> instead of <span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span>. In this case the
type annotation is mandatory, as by default the complier would create a
<span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span>.</p>
<p>We can then implement our enumerable to wrap a generator and expose member
functions which forward to the above algorithms:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enumerable</span>
<span class="p">{</span>
    <span class="c1">// Needed by compiler to create enumerable from co_yield</span>
    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>

    <span class="n">enumerable</span><span class="p">(</span><span class="n">promise_type</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">)</span> <span class="o">:</span> <span class="n">_gen</span><span class="p">(</span><span class="n">promise</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">enumerable</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_gen</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>

    <span class="n">enumerable</span><span class="p">(</span><span class="k">const</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_gen</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">auto</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_gen</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">take_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">pred</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_gen</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A few things to note: we declare a <span class="docutils literal"><span class="pre">promise_type</span></span> and have a constructor which
takes a promise as an argument. This is required by the compiler when creating
the object on <span class="docutils literal"><span class="pre">co_yield</span></span>. We follow the same semantics as generator, since
that is what we are wrapping – support only move-constructor, no
copy-constructor. All the member algorithms do a destructive move on <span class="docutils literal"><span class="pre">*this</span></span>.
This is intentional, as once we iterate over the encapsulated generator, it is
no longer valid. Since we don’t expose a copy-constructor, we move out of
<span class="docutils literal"><span class="pre">*this</span></span> when passing the generator to an algorithm. For completeness, we can
also provide a function which converts from a generator to an enumerable:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">to_enumerable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, and we can now compose algorithms by chaining the calls:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">to_enumerable</span><span class="p">(</span><span class="n">count</span><span class="p">()).</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}).</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Still, it is not ideal – first, we need to explicitly tell the compiler
everywhere to return our type with <span class="docutils literal"><span class="pre">co_yield</span></span> instead of the default
generator, and we need to handle conversions to and from the standard library
generator. The enumerable algorithms compose well, but we’ll have trouble
composing with functions that work with generators. Also, having a huge class
consisting solely of algorithms is not the best design, especially in a language
where free functions are first class citizens.</p>
</div>
<div class="section" id="pipe-operator">
<h2>Pipe Operator</h2>
<p>An alternative approach, which the
<a class="reference external" href="http://www.boost.org/doc/libs/1_62_0/libs/range/doc/html/index.html">Boost Ranges library</a>
takes, is to overload <span class="docutils literal"><span class="pre">|</span></span>, the “pipe” operator, so we can compose our calls
like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">count</span><span class="p">()</span> <span class="o">|</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">|</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span> <span class="o">|</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One way we can get this working is to first create a type that wraps an
algorithm and an <span class="docutils literal"><span class="pre">operator|</span></span> implementation between a lhs <span class="docutils literal"><span class="pre">generator</span></span> and a
rhs of our type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">filter_t</span>
<span class="p">{</span>
    <span class="n">filter_t</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Predicate</span> <span class="n">_pred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <span class="docutils literal"><span class="pre">filter_t</span></span> holds the <span class="docutils literal"><span class="pre">Predicate</span></span> we want to use, and <span class="docutils literal"><span class="pre">operator|</span></span>
applies it on the given <span class="docutils literal"><span class="pre">generator</span></span>. This works, but we wouldn’t be able to
instantiate <span class="docutils literal"><span class="pre">filter_t</span></span> with a lambda like in the above chaining example
without specifying the Predicate type in the call. If we want to leverage type
deduction, we can create a simple helper function that creates a <span class="docutils literal"><span class="pre">filter_t</span></span>
from a given argument:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this we can call <span class="docutils literal"><span class="pre">|</span> <span class="pre">filter(/*</span> <span class="pre">predicate</span> <span class="pre">*/)</span></span> on a generator and get back
a filtered generator. Full implementation for <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> and <span class="docutils literal"><span class="pre">map</span></span>
would be:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">take_n_t</span>
<span class="p">{</span>
    <span class="n">take_n_t</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">_n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">_n</span><span class="p">)</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">_n</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">take_n_t</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">take_n_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">filter_t</span>
<span class="p">{</span>
    <span class="n">filter_t</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Predicate</span> <span class="n">_pred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">map_t</span>
<span class="p">{</span>
    <span class="n">map_t</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="o">:</span> <span class="n">_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">_op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">BinaryOperation</span> <span class="n">_op</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">map_t</span><span class="o">&lt;</span><span class="n">BinaryOperation</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">map_t</span><span class="o">&lt;</span><span class="n">BinaryOperation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach, we can apply our algorithms over a generator without having
to introduce a different type. They also compose very nicely, the only slightly
odd thing being using the <span class="docutils literal"><span class="pre">|</span></span> operator (though as I mentioned, there is a
precedent for this in Boost and chances are it might show up in other places in
the future).</p>
</div>
<div class="section" id="unified-call-syntax">
<h2>Unified Call Syntax</h2>
<p>One thing that would’ve made things even easier but unfortunately was not
approved for C++17 is <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4165.pdf">unified call syntax</a>.
At a high level, unified call syntax would make the compiler try to resolve
<span class="docutils literal"><span class="pre">x.f()</span></span> to <span class="docutils literal"><span class="pre">f(x)</span></span> if <span class="docutils literal"><span class="pre">decltype(x)</span></span> doesn’t have an <span class="docutils literal"><span class="pre">f()</span></span> member function
but there is a free function <span class="docutils literal"><span class="pre">f(decltype(x))</span></span>. Similarly, if no
<span class="docutils literal"><span class="pre">f(decltype(x))</span></span> exists but <span class="docutils literal"><span class="pre">decltype(x)</span></span> has a member function <span class="docutils literal"><span class="pre">f()</span></span>,
<span class="docutils literal"><span class="pre">f(x)</span></span> would resolve to the member function call <span class="docutils literal"><span class="pre">x.f()</span></span>.</p>
<p>If it’s not obvious, unified call syntax would allow us to easily create
extension methods. We would be able to revert our algorithm code to the first
version:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But now this becomes very composable as calling <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> or
<span class="docutils literal"><span class="pre">map</span></span> on a generator would resolve to the free functions if the <span class="docutils literal"><span class="pre">generator</span></span>
itself does not have them as members:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">count</span><span class="p">().</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}).</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above currently does not compile but it should (disclaimer: slight tweaks
might be required) if unified call syntax becomes part of the standard.</p>
</div>
<div class="section" id="in-summary">
<h2>In Summary</h2>
<p>We went over a couple of alternatives to implement some common algorithms over
C++ generators with a focus on composability:</p>
<ul class="simple">
<li>Stand-alone functions are simple but don’t compose very well</li>
<li>Using a decorator works, but is not ideal from a design point of view and not
very idiomatic</li>
<li>Using the pipe operator for chaining and helper types for the algorithms is
the best approach today</li>
<li>Unified call syntax would simplify things a lot, enabling a mechanism to
implement these algorithms as extension methods</li>
</ul>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/10/09/composable-generators.html#disqus_thread" data-disqus-identifier="2016/10/09/composable-generators">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>August 17, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/08/17/concepts-and-modules.html">Concepts and Modules</a></h1>
<p>As a follow up to my previous post, I want to talk about two major new C++
features that keep not making it into the standard, namely <em>Concepts</em> and
<em>Modules</em>. These would have a significant impact on the code examples I
provided while discussing dependency injectiojn, so here’s a quick peek into the
future:</p>
<div class="section" id="concepts">
<h2>Concepts</h2>
<p>One way to think about concepts is that concepts are to templates what
interfaces are to classes. Similarly to how interfaces specify a contract which
implementing types must satisfy, concepts specify a contract which template
argument types must satisfy. The main difference is that interfaces/classes
enable runtime polymorphism while concepts/templates enable polymorphism at
compile-time.</p>
<p>Runtime polymorphism:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Our interface</span>
<span class="k">struct</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// One implementation</span>
<span class="k">class</span> <span class="nc">V6Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Another implementation</span>
<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A function that works against the interface</span>
<span class="kt">void</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StartEngines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">V6Engine</span> <span class="n">v6engine</span><span class="p">;</span>
    <span class="n">V8Engine</span> <span class="n">v8engine</span><span class="p">;</span>

    <span class="c1">// calls Start() on V6Engine instance passed as IEngine</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v6engine</span><span class="p">);</span>
    <span class="c1">// calls Start() on V8Engine instance passed as IEngine</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v8engine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we have a single <span class="docutils literal"><span class="pre">StartEngine</span></span> function which works against an
interface. Calling <span class="docutils literal"><span class="pre">Start()</span></span> for that interface involves a virtual function
call, which means that at runtime, given an object of a type implementing
<span class="docutils literal"><span class="pre">IEngine</span></span>, the code needs to figure out which function of the implementing
type to call. For <span class="docutils literal"><span class="pre">V6Engine</span></span>, <span class="docutils literal"><span class="pre">IEngine::Start()</span></span> is <span class="docutils literal"><span class="pre">V6Engine::Start();</span></span>
for <span class="docutils literal"><span class="pre">V8Engine</span></span>, <span class="docutils literal"><span class="pre">IEngine::Start()</span></span> is <span class="docutils literal"><span class="pre">V8Engine::Start()</span></span>. Our classes
have a vtable - a table containing this mapping, so a virtual call looks up the
actual function to call in the vtable.</p>
<p>This is the “classical” object-oriented way of dispatching calls. The advantage
of this approach is that it works across binaries <a class="footnote-reference" href="#id3" id="id1">[1]</a> (we can export
<span class="docutils literal"><span class="pre">StartEngine</span></span> from a shared library and pass in an external <span class="docutils literal"><span class="pre">IEngine</span></span>
implementation to it), the disadvantage is the extra redirection - implementing
classes must have a vtable and call resolution involves jumping through it.</p>
<p>Compile-time polymorphism:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// One implementation</span>
<span class="k">class</span> <span class="nc">V6Engine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Another implementation</span>
<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A generic function</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">TEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StartEngines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">V6Engine</span> <span class="n">v6engine</span><span class="p">;</span>
    <span class="n">V8Engine</span> <span class="n">v8engine</span><span class="p">;</span>

    <span class="c1">// calls Start() on V6Engine, this instantiates</span>
    <span class="c1">// StartEngine&lt;V6Engine&gt;(V6Engine&amp; engine)</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v6engine</span><span class="p">);</span>
    <span class="c1">// calls Start() on V8Engine, this instantiates</span>
    <span class="c1">// StartEngine&lt;V8Engine&gt;(V8Engine&amp; engine)</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v8engine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A few differences to note here: we don’t have an <span class="docutils literal"><span class="pre">IEngine</span></span> interface anymore
and the two types we use, <span class="docutils literal"><span class="pre">V6Engine</span></span> and <span class="docutils literal"><span class="pre">V8Engine</span></span>, no longer have virtual
functions. Calling <span class="docutils literal"><span class="pre">V6Engine::Start()</span></span> or <span class="docutils literal"><span class="pre">V8Engine::Start()</span></span> now no longer
involves a virtual call. The two <span class="docutils literal"><span class="pre">StartEngine</span></span> calls are actually made to
different functions now - at compile time, whenever the compiler encounters a
call to <span class="docutils literal"><span class="pre">StartEngine</span></span> with a new type, it instantiates the template, meaning
it creates a new function based on that template with the template type as the
provided type. We actually end up with one function that can start a
<span class="docutils literal"><span class="pre">V6Engine</span></span> and one that can start <span class="docutils literal"><span class="pre">V8Engine</span></span>, both produced from the same
template.</p>
<p>This is compile-time polymorphism, the advantage being that everything is
determined during build - no virtual calls etc., the disadvantage being that
the compiler needs to have a definition of the template available whenever it
needs to create a new instance <a class="footnote-reference" href="#id4" id="id2">[2]</a>. In this case we can’t encapsulate what
happens inside <span class="docutils literal"><span class="pre">StartEngine</span></span> if we want others to be able to call the
function.</p>
<div class="section" id="with-concepts">
<h3>With Concepts</h3>
<p>The above works just fine, the problem being that, in general, if you have
a templated function, it’s not obvious what contracts do the types it expects
need to satisfy. For example, our <span class="docutils literal"><span class="pre">StartEngine</span></span> expects that the given type
has a <span class="docutils literal"><span class="pre">Start()</span></span> function it can call. This isn’t obvious from the function
declaration though. Also, compiler errors when templates cannot be instantiated
are notoriously hard to decipher. The proposed solution to both of the above
are concepts. Here is how an engine concept would look like:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="kt">bool</span> <span class="n">Engine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">requires</span><span class="p">(</span><span class="n">TEngine</span> <span class="n">engine</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">()</span> <span class="p">};</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This defines the <span class="docutils literal"><span class="pre">Engine</span></span> concept to require any type satisfying it to have a
<span class="docutils literal"><span class="pre">Start()</span></span> function and a <span class="docutils literal"><span class="pre">Stop()</span></span> function. <span class="docutils literal"><span class="pre">StartEngine</span></span> would then be
able to explicitly say what kind of types it expects:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="n">Engine</span> <span class="n">TEngine</span><span class="o">&gt;</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">TEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is now clear from the function declaration that <span class="docutils literal"><span class="pre">StartEngine</span></span> expects a
type satisfying the <span class="docutils literal"><span class="pre">Engine</span></span> concept. We can look at the concept definition to
see what we need to implement on our type. The compiler would also be able to
issue much clearer errors when the type we pass in is missing one of the concept
requirements.</p>
<p>Unfortunately, while several proposals for concepts have been put forward in the
past years, they weren’t approved to be part of the C++17 standard. That being
said, it’s fairly certain that they will eventually make it into the standard.</p>
</div>
</div>
<div class="section" id="modules">
<h2>Modules</h2>
<p>Another noteworthy feature are modules: currently, the <span class="docutils literal"><span class="pre">#include</span></span> directive
textually includes the given file into the source file being compiled. This has
a lot of build-time overhead (same header files get compiled over and over as
they are included in various source files) and forces us to be extra-careful in
how we scope things: what goes in a header file vs. what goes in a source file
etc.</p>
<p>Modules aim to replace the header/source file split and provide a better way to
group components and expose functionality. For example, here is a header/source
file pair from my previous post:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// ICar.h</span>
<span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
<span class="n">Car</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span>

<span class="c1">// Car.cpp</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using modules, we would have:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">module</span> <span class="n">Car</span><span class="p">;</span>

<span class="n">import</span> <span class="n">Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is now a single file where we import the <span class="docutils literal"><span class="pre">Engine</span></span> module (instead of
<span class="docutils literal"><span class="pre">#include</span></span>), we provide the interface and concrete implementation, the factory
function, and we mark publicly-visible declarations with the <span class="docutils literal"><span class="pre">export</span></span> keyword.</p>
<p>Like Concepts, Modules haven’t made it into the C++17 standard, but MSVC has a
working implementation as of VS2015 Update 1.</p>
</div>
<div class="section" id="dependency-injection-in-the-future">
<h2>Dependency Injection in the Future</h2>
<p>So putting the above together, here is how dependency injection in C++ might
look like in the not too far future:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Engine.m</span>
<span class="n">module</span> <span class="n">Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="kt">bool</span> <span class="n">Engine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">requires</span><span class="p">(</span><span class="n">TEngine</span> <span class="n">engine</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">()</span> <span class="p">};</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// V8Engine.m</span>
<span class="n">module</span> <span class="n">V8Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// start the engine }</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// stop the engine }</span>
<span class="p">};</span>

<span class="c1">// Car.m</span>
<span class="n">module</span> <span class="n">Car</span><span class="p">;</span>

<span class="n">import</span> <span class="n">Engine</span><span class="p">;</span>
<span class="n">import</span> <span class="n">V8Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="n">Engine</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n">DefaultConstructible</span><span class="o">&lt;</span><span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Explicit instantiation exported from this module so clients</span>
<span class="c1">// won't have to re-instantiate the template for V8Engine type</span>
<span class="k">export</span> <span class="k">class</span> <span class="nc">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>This can be used as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">import</span> <span class="n">Car</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
<span class="n">car</span><span class="p">.</span><span class="n">Drive</span><span class="p">();</span>
</pre></div>
</div>
<p>This would be the equivalent of Dependency Injection with Templates I mentioned
in the previous post.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>As long as binaries are compiled with the same compiler. Otherwise the
code produced by different compilers might have different vtable layouts
and different name mangling.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Other disadvantages are slower compile times and potential code bloat,
as each template instantiation gets translated into a new function.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/08/17/concepts-and-modules.html#disqus_thread" data-disqus-identifier="2016/08/17/concepts-and-modules">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>July 06, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/07/06/dependency-injection-in-c.html">Dependency Injection in C++</a></h1>
<p>In this post, I will switch gears from functional C++ to object oriented C++ and
talk about dependency injection.</p>
<p>Let’s start with a simple example: take a <span class="docutils literal"><span class="pre">Car</span></span> class with a <span class="docutils literal"><span class="pre">Drive()</span></span>
method. Let’s say this class contains a <span class="docutils literal"><span class="pre">V8Engine</span></span> attribute with <span class="docutils literal"><span class="pre">Start()</span></span>
and <span class="docutils literal"><span class="pre">Stop()</span></span> methods. An initial implementation might look like this:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">V8Engine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="dependency-injection-with-interfaces">
<h2>Dependency Injection with Interfaces</h2>
<p>In the above example, <span class="docutils literal"><span class="pre">Car</span></span> is tightly coupled to <span class="docutils literal"><span class="pre">V8Engine</span></span>, meaning we
can’t create a car without a concrete engine implementation. If we want the
ability to swap various engines or use a mock engine during testing, we could
reverse the dependency by creating an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and decoupling
<span class="docutils literal"><span class="pre">Car</span></span> from the concrete <span class="docutils literal"><span class="pre">V8Engine</span></span> implementation. This way, we only expose
an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and a factory function. <span class="docutils literal"><span class="pre">Car</span></span> can work against that:</p>
<p><em>IEngine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">();</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* start the engine */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* stop the engine */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="notes">
<h2>Notes</h2>
<div class="section" id="a-note-on-headers">
<h3>A note on headers</h3>
<p>Headers simply get textually included in each compilation unit by the
<span class="docutils literal"><span class="pre">#include</span></span> directive. It is not mandatory to provide a header file for each
class declaration. If a class can be scoped to a single source file, then it
doesn’t need a header declaration (for example the <span class="docutils literal"><span class="pre">V8Engine</span></span> class above
does not need a V8Engine.h header corresponding to the V8Engine.cpp). It is also
a good idea to have public headers and internal headers: public headers contain
the public API surface and can be included by other parts of the system, while
internal headers are only used within the component and should not be included
by external code.</p>
<p>Default should be the least visible: try to keep everything inside the cpp file
(like V8Engine.cpp). If that is not enough, an internal header might do. A
declartion should be pulled into a public header only when external components
need to reference it.</p>
</div>
<div class="section" id="a-note-on-interfaces">
<h3>A note on interfaces</h3>
<p>It’s a good idea to declare a default virtual destructor: if a deriving type has
a destructor, it won’t get called if we store an upcast pointer to the interface
unless the interface declares a virtual destructor. Note a destructor does not
to be expicitly defined - compiler might generate a default one.</p>
<p>MSVC compiler provides a <span class="docutils literal"><span class="pre">__declspec(novtable)</span></span> <a class="footnote-reference" href="#id2" id="id1">[1]</a> custom attribute which
tells the compiler not to generate a vtable for pure abstract classes. This
reduces code size. Below is the <span class="docutils literal"><span class="pre">IEngine</span></span> declaration with this attribute:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">novtable</span><span class="p">)</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>I won’t include it in the code samples in this post, but it’s worth keeping in
mind when working with MSVC.</p>
</div>
<div class="section" id="a-note-on-factory-functions">
<h3>A note on factory functions</h3>
<p>When working with interfaces as opposed to concrete types, we use factory
functions to get object instances. Below is a possible naming convention, taking
object ownership into account:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">MakeFoo</span><span class="p">();</span>
<span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">GetFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>The first function, <span class="docutils literal"><span class="pre">MakeFoo</span></span>, returns a unique pointer, passing ownership to
the caller. Like in the example above, the <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> can be moved into the
object, which ends up owning it. Use a Make when each call creates a new
instance.</p>
<p>The second function implies there already exists an <span class="docutils literal"><span class="pre">IFoo</span></span> object which is
owned by someone else, with the guarantee that it will outlive the caller. In
that case, there is no need for pointers and we can simply return a reference to
the object. This can be used, for example, for singletons. Below is an example
of a singleton <span class="docutils literal"><span class="pre">Engine</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">UseEngine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The third function, <span class="docutils literal"><span class="pre">GetFoo</span></span>, implies shared ownership - we get an object that
other objects might hold a reference to, but we don’t have the lifetime
guarantee a singleton would give us, so we need to use a shared pointer to make
sure the object is kept alive long enough.</p>
</div>
</div>
<div class="section" id="mocking">
<h2>Mocking</h2>
<p>Since <span class="docutils literal"><span class="pre">Car</span></span> now works with an <span class="docutils literal"><span class="pre">IEngine</span></span> interface, in test code we can mock
the engine:</p>
<p><em>Test.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span> <span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also expose <span class="docutils literal"><span class="pre">Car</span></span> as a simple interface, hiding its implementation
details, in which case we would end up with the following:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would become:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">car</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test ICar without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note this allows the caller to pass in any <span class="docutils literal"><span class="pre">IEngine</span></span>. We provide an
out-of-the-box <span class="docutils literal"><span class="pre">V8Engine</span></span> but other engines can be injected when <span class="docutils literal"><span class="pre">Car</span></span> gets
constructed. The headers IEngine.h and ICar.h are public per our above
defintion.</p>
<p>In general, it’s great if we can get the rest of the component code and unit
tests to work against the interface. Sometimes though we might need to know more
about the actual implementation inside our component, even if externally we only
expose an interface. In that case, we can add an internal Car.h header:</p>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em> becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can include the internal header, and, while not necessarily recommended,
we can cast <span class="docutils literal"><span class="pre">ICar</span></span> to <span class="docutils literal"><span class="pre">Car</span></span> inside the component:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">icar</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">MakeV8Engine</span><span class="p">());</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">car</span><span class="p">);</span>
</pre></div>
</div>
<p>Another trick if needing access to internals (again, not something necessarily
recommended), is to make the unit test class testing <span class="docutils literal"><span class="pre">Car</span></span> a friend of the
<span class="docutils literal"><span class="pre">Car</span></span> class, in which case it can access its private members.</p>
<p>In summary, with this approach we are able to:</p>
<ul class="simple">
<li>Hide implementation details in the .cpp files</li>
<li>Work against abstract interfaces</li>
<li>Inject dependencies during object construction</li>
</ul>
</div>
<div class="section" id="dependecy-injection-with-templates">
<h2>Dependecy Injection with Templates</h2>
<p>An alternative to the above is to use templates. In this case, we would have to
provide the implementation inside the header file, as code needs to be available
when templates get instantiated:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note <span class="docutils literal"><span class="pre">Car</span></span> is implemented in the header and <span class="docutils literal"><span class="pre">V8Engine</span></span> is also a publicly
visible header. Now we can create an instance of <span class="docutils literal"><span class="pre">Car</span></span> like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="p">...</span>

<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
</pre></div>
</div>
<p>Mocking the engine in test code would look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach we are able to:</p>
<ul class="simple">
<li>Inject dependencies during template instantiation</li>
<li>No need for virtual calls (note <span class="docutils literal"><span class="pre">TEngine</span></span> is not an interface, so calls can
be resolved at compile-time)</li>
<li><span class="docutils literal"><span class="pre">Car&lt;T&gt;</span></span> can be default-constructed</li>
</ul>
<p>A drawback here is we expose the implementation details of <span class="docutils literal"><span class="pre">Car</span></span> inside the
header file and we have to make this publicly visible.</p>
</div>
<div class="section" id="hybrid-approach">
<h2>Hybrid Approach</h2>
<p>We can use a hybrid approach if we don’t need an externally injected <span class="docutils literal"><span class="pre">Engine</span></span>.
Say our component provides a <span class="docutils literal"><span class="pre">V8Engine</span></span>, a <span class="docutils literal"><span class="pre">V6Engine</span></span>, and we have a
<span class="docutils literal"><span class="pre">MockEngine</span></span> used during testing. We have the same componentization
requirements but don’t need to expose all the details to consumers. In that case
we could have something like this:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
</pre></div>
</div>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"V6Engine.h"</span><span class="cp"/>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V6Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would remain the same as in the example above, where we worked against a
<span class="docutils literal"><span class="pre">Car</span></span> type (not an <span class="docutils literal"><span class="pre">ICar</span></span>) which we instantiate with a <span class="docutils literal"><span class="pre">MockEngine</span></span>.</p>
<p>With this approach:</p>
<ul class="simple">
<li>Our external API is an interface</li>
<li>Internally we still inject the dependency using a template</li>
</ul>
<p>With this approach, we do have an interface and virtual calls for <span class="docutils literal"><span class="pre">Car</span></span> but
not for <span class="docutils literal"><span class="pre">TEngine</span></span> types. One drawback with this approach is that consumers
cannot inject their own Engine type: we can only create cars with engines that
are known within our component.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We decoupled <span class="docutils literal"><span class="pre">Car</span></span> from <span class="docutils literal"><span class="pre">V8Engine</span></span> and looked at three ways of injecting
the dependency:</p>
<ul class="simple">
<li>Using interfaces, where dependency is injected at runtime during object
creation</li>
<li>Using templates, where dependency is injected at compile-time during template
instantiation</li>
<li>A hybrid approach which uses templates internally but exposes only interfaces
publicly</li>
</ul>
<p>Each of these approaches has pros and cons, the tradeoffs mostly being around
encapsulation (how much of the component code we expose publicly), runtime
(templates are instantiated at compile-time so no virtual calls etc.), type
constraints (with templates we don’t require engines to implement a particular
<span class="docutils literal"><span class="pre">IEngine</span></span> interface), and flexibility (with the hybrid approach we can’t
inject an external engine, we can only use what the component has available
internally).</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For more details on <span class="docutils literal"><span class="pre">novtable</span></span>, see <a class="reference external" href="https://msdn.microsoft.com/en-us/library/k13k85ky.aspx">MSDN</a>.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/07/06/dependency-injection-in-c.html#disqus_thread" data-disqus-identifier="2016/07/06/dependency-injection-in-c">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>April 24, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/04/24/abusing-maps.html">(Ab)using Maps</a></h1>
<div class="section" id="mapping-pattern">
<h2>Mapping pattern</h2>
<p>Using hash maps (or dictionaries, or lookups) is a very natural way of coding in
some languages, especially dynamic languages, where usually an object can be
treated as a map itself, to which attributes and methods can be added or removed
at runtime.</p>
<p>In practice though, maps are often used to convert a value of one type into a
value of a different type. It is not uncommon to have very small maps like</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>Here it is useful to make a distinction between the pattern and the data
structure. The coding pattern itself is great - mapping a value from a type to
a value of another type should definitely be declarative. Below is a
counterexample of non-declarative mapping:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">Bar</span> <span class="nf">barFromFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar3</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is really ugly. As I mentioned in <a class="reference internal" href="2016/01/04/clean-code-part-1.html#clean-code-1"><span class="std std-ref">Clean Code - Part 1</span></a>, branching should be
avoided whenever possible, and this is a good opportunity to use a declarative
approach as opposed to a bunch of branching logic. That being said, while the
mapping pattern is great, in C++ the data structure most developers default to
is not the optimal one for this.</p>
</div>
<div class="section" id="the-problem-with-unordered-map">
<h2>The problem with unordered_map</h2>
<p>If you are coding in C++, odds are you care a little bit about the runtime
footprint of your code. In that case, you might be surprised to learn that,
while an <span class="docutils literal"><span class="pre">unordered_map</span></span> in C++ (or a lookup or hash map or dictionary in any
other language) has an average lookup cost of <span class="docutils literal"><span class="pre">O(1)</span></span>, there are better ways to
implement the above pattern.</p>
<p>A map in C++ is implemented as a red-black tree containing buckets of hashed
values. Calling <span class="docutils literal"><span class="pre">at()</span></span> on a map implies the given key has to be hashed and
the tree traversed to find the value. Calling <span class="docutils literal"><span class="pre">[]</span></span> on an inexistent key will
add it to the data structure, which might trigger a rebalancing of the tree.
There is a lot of work happening under the hood, and while this makes sense for
an <span class="docutils literal"><span class="pre">unordered_map</span></span> of arbitrarily large size, for small lookups it is a lot
of overhead.</p>
</div>
<div class="section" id="alternatives">
<h2>Alternatives</h2>
<p>An alternative to <span class="docutils literal"><span class="pre">unordered_map</span></span> provided by the boost library is
<span class="docutils literal"><span class="pre">flat_map</span></span> <a class="footnote-reference" href="#id3" id="id1">[1]</a>. This has similar semantics to an <span class="docutils literal"><span class="pre">unordered_map</span></span>, but the
key-values are stored in a contiguous data structure so traversing it is more
efficient than walking a tree.</p>
<p>In general, there are a couple of approaches for keeping a hash map in a linear
data structure:</p>
<ul class="simple">
<li>The keys can be kept sorted, which has <span class="docutils literal"><span class="pre">O(N)</span></span> worst case insertion since it
might require all elements to be moved to fit a new one and <span class="docutils literal"><span class="pre">O(logN)</span></span> lookup
(binary search)</li>
<li>The keys can be kept unsorted, which has <span class="docutils literal"><span class="pre">O(1)</span></span> insertion (simple append) but
<span class="docutils literal"><span class="pre">O(N)</span></span> lookup (linear search)</li>
</ul>
<p>For very small-sized lookups, the cost of hashing itself might out-weight a
linear traversal, so for a small N</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>performs worse than</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
    <span class="n">fooBarMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span>
    <span class="n">fooBarMap</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
    <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">foo</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
<p>On my machine (using MSVC 2015 STL implementation), for an N of 5, <span class="docutils literal"><span class="pre">find_if</span></span>
on a vector is about twice as fast as the equivalent <span class="docutils literal"><span class="pre">unordered_map</span></span> lookup.</p>
</div>
<div class="section" id="initialization-cost">
<h2>Initialization cost</h2>
<p>There’s event more hidden cost: <span class="docutils literal"><span class="pre">std::vector</span></span> manages a dynamic array which is
allocated on the heap. Having an <span class="docutils literal"><span class="pre">std::vector</span></span> initialized with key-values as
described above, even if more efficent than an <span class="docutils literal"><span class="pre">unordered_map</span></span>, still has
some associated cost in terms of heap allocations (albeit smaller than
<span class="docutils literal"><span class="pre">unordered_map</span></span>). <span class="docutils literal"><span class="pre">std::array</span></span> is a much better suited container for cases
when the key-values are known at compile time, as <span class="docutils literal"><span class="pre">std::array</span></span> simply wraps a
regular array which is not allocated on the heap. So a more efficient (in terms
of initialization cost) way of declaring such a look up is</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">arrray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>We can still apply the <span class="docutils literal"><span class="pre">std::find_if</span></span> algorithm on this array, but we skip a
heap allocation. Depending on the template types used, we might be able to skip
any allocations whatsoever (if both types are trivial <a class="footnote-reference" href="#id4" id="id2">[2]</a>). For example, note
that <span class="docutils literal"><span class="pre">std::string</span></span>, similarly to a vector, wraps a heap-allocated <span class="docutils literal"><span class="pre">char*</span></span>
and constructing it requires heap allocations. <span class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></span> to a string
literal on the other hand is just a pointer to the <span class="docutils literal"><span class="pre">.rodata</span></span> segment. So this</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="s">"foo1"</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo2"</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo3"</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>performs three heap allocations (for <span class="docutils literal"><span class="pre">"foo1"</span></span>, <span class="docutils literal"><span class="pre">"foo2"</span></span>, and <span class="docutils literal"><span class="pre">"foo3"</span></span>),
while the (mostly) equivalent</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="s">"foo1"</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo2"</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo3"</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>shouldn’t perform any allocations.</p>
</div>
<div class="section" id="associative-array">
<h2>associative_array</h2>
<p>Since in practice maps are often used to implement the above described pattern
of mapping a value from one type to a value of a different type for a small
set of known values, it would be great to combine the efficiency of an array
with the nice lookup semantics of an <span class="docutils literal"><span class="pre">unordered_map</span></span> conatiner.</p>
<p>I propose a generic container of the following shape:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">TKey</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">KeyEqual</span> <span class="o">=</span> <span class="n">key_equal</span><span class="o">&lt;</span><span class="n">TKey</span><span class="o">&gt;&gt;</span>
<span class="k">struct</span> <span class="n">associative_array</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">m_array</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">keq_equal</span></span> should simply resolve to <span class="docutils literal"><span class="pre">==</span></span> for most types, but be
specialized for strings types (to use <span class="docutils literal"><span class="pre">strcmp</span></span>, <span class="docutils literal"><span class="pre">wcscmp</span></span> etc.) and allow
clients to specialize their own <span class="docutils literal"><span class="pre">key_equal</span></span> when needed.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">key_equal</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">key_equal</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="c1">// specializations for wchar_t and const variations of the above</span>
</pre></div>
</div>
<p>Satisfying the container concept is fairly easy (eg. <span class="docutils literal"><span class="pre">size()</span></span> would return
<span class="docutils literal"><span class="pre">N</span></span>, iterators over the member array are trivial to implement etc.), the only
interesting methods are <span class="docutils literal"><span class="pre">find()</span></span>, <span class="docutils literal"><span class="pre">at()</span></span>, and <span class="docutils literal"><span class="pre">operator[]</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="p">...</span>
<span class="k">struct</span> <span class="n">associative_array</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
            <span class="n">begin</span><span class="p">(),</span>
            <span class="n">end</span><span class="p">(),</span>
            <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">KeyEqual</span><span class="p">{}(</span><span class="n">key</span><span class="p">,</span> <span class="n">elem</span><span class="p">.</span><span class="n">first</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">end</span><span class="p">())</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"..."</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">find()</span></span> wraps <span class="docutils literal"><span class="pre">std::find_if</span></span> leveraging <span class="docutils literal"><span class="pre">KeyEqual</span></span> (with default
implementation as <span class="docutils literal"><span class="pre">key_equal</span></span>), <span class="docutils literal"><span class="pre">at()</span></span> wraps a bounds-checked <span class="docutils literal"><span class="pre">find</span></span>,
while <span class="docutils literal"><span class="pre">operator[]</span></span> does not check bounds. <span class="docutils literal"><span class="pre">const</span></span> implementations of the
above are also needed (identical except returning <span class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></span>).</p>
<p>Such a container would have similar semantics to <span class="docutils literal"><span class="pre">std::unordered_map</span></span> (minus
the ability to add elements given a key not already present in the container)
and the same performance profile of <span class="docutils literal"><span class="pre">std::array</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">associative_array</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>Note the only syntax difference between above and <span class="docutils literal"><span class="pre">unordered_map</span></span> is the
container type, the extra size <span class="docutils literal"><span class="pre">N</span></span> which needs to be specified at
declaration time, and an extra pair of curly braces. In practice, this should
have a significantly better lookup time than an unordered_map for a small N
(linear time, but since N is small and no hashing or heap traversal occurs,
should clock better than a map lookup) and virtually zero initialization time
- depending on the <span class="docutils literal"><span class="pre">TKey</span></span> and <span class="docutils literal"><span class="pre">T</span></span> types used, it is possible to declare
an <span class="docutils literal"><span class="pre">associative_array</span></span> as a <span class="docutils literal"><span class="pre">constexpr</span></span> fully evaluated at compile-time.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Boost <span class="docutils literal"><span class="pre">flat_map</span></span> documentation is <a class="reference external" href="http://www.boost.org/doc/libs/1_56_0/doc/html/boost/container/flat_map.html">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>For more details on trivial types, see the <a class="reference external" href="http://www.cplusplus.com/reference/type_traits/is_trivial/">is_trivial type trait</a>.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/04/24/abusing-maps.html#disqus_thread" data-disqus-identifier="2016/04/24/abusing-maps">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>March 11, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/03/11/arguments-and-smart-pointers.html">Arguments and Smart Pointers</a></h1>
<p>For efficiency reasons, C++ had a myriad of ways to pass data around. A
function can take arguments in several forms:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>
</div>
<p>No to mention adding <span class="docutils literal"><span class="pre">const</span></span> and smart pointers into the mix.</p>
<p>And speaking of pointers, we have raw pointers, <span class="docutils literal"><span class="pre">unique_ptr</span></span>, <span class="docutils literal"><span class="pre">shared_ptr,</span></span>
<span class="docutils literal"><span class="pre">CComPtr</span></span>/<span class="docutils literal"><span class="pre">ComPtr</span></span> (for Windows COM objects), and, if you are working in
older codebases, <span class="docutils literal"><span class="pre">auto_ptr</span></span>, and maybe even some homebrewed refcounted
pointers.</p>
<p>All of this might seem a bit daunting and make C++ seem more complicated than
it really is. One way to think about it is from the ownership perspective:
objects are resources and the key question is “who owns this resource?”. This
should dictate both how a particular resource is allocated (and released) and
the shape function arguments should take. Lifetime is also an important
consideration - a resource shouldn’t be released while other components expect
it to be available, but it should be released as soon as it is no longer
needed.</p>
<p>In this post I will try to cover the various ways in which resources can be
allocated, owned, and passed around.</p>
<div class="section" id="stack-objects-and-passing-arguments">
<h2>Stack Objects and Passing Arguments</h2>
<p>The simplest, clearest thing to do is allocate objects on the stack. A stack
object doesn’t involve any pointers:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The variable <span class="docutils literal"><span class="pre">bar</span></span> of type <span class="docutils literal"><span class="pre">Bar</span></span> is created on the stack. Once the stack
frame is popped (once the function is done executing, either through a normal
return or due to an exception) the object goes away. This is the easiest, safest
thing to do. The only reasons we wouldn’t always do this are time and space
requirements: lifetime-wise, we might want to somehow use <span class="docutils literal"><span class="pre">bar</span></span> after
<span class="docutils literal"><span class="pre">foo()</span></span> returns - for example we might want to pass it around to some other
object that wants to use at a later time; in terms of space, stack memory is
more limited than the heap, so large objects are better kept on the heap to
avoid overflow.</p>
<div class="section" id="pass-by-value">
<h3>Pass by value</h3>
<p>One way to get around the lifetime requirement is to pass the object by value:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="n">Bar</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// hands bar off to some other object</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s assume for this example that <span class="docutils literal"><span class="pre">do_suff</span></span> takes the argument and sticks it
into some global object which will use it as some future time.</p>
<p>The above code will simply create a copy of the object, so whatever <span class="docutils literal"><span class="pre">do_suff</span></span>
gets won’t be the original resource which gets freed once the function returns,
rather a copy of it. Copying an object costs both run time and space, but if
neither are a big concern, this is a great, safe way of ensuring resources don’t
get released before we’re done with them.</p>
</div>
<div class="section" id="move">
<h3>Move</h3>
<p>C++11 introduces a cheaper way of achieving this, through move semantics:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;&amp;</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// hands bar off to some other object</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With move semantics, the resource is actually <em>moved</em> into the <span class="docutils literal"><span class="pre">do_suff</span></span>
function. Once this happens, the original object is left in an undefined state
and shouldn’t be used anymore. This approach is usually employed when we have a
sink argument - we <em>sink</em> <span class="docutils literal"><span class="pre">bar</span></span> to its final resting place somewhere and
<span class="docutils literal"><span class="pre">foo()</span></span> no longer cares about it after passing it down to <span class="docutils literal"><span class="pre">do_stuff</span></span>.</p>
<p>One thing to keep in mind is that <span class="docutils literal"><span class="pre">move</span></span> is not magic, so <span class="docutils literal"><span class="pre">Bar</span></span> needs to
declare a <a class="reference external" href="http://en.cppreference.com/w/cpp/language/move_constructor">move constructor</a>
in order for this to do what we expect it to do. If Bar doesn’t declare a move
constructor, the above becomes a simple copy <a class="footnote-reference" href="#id4" id="id1">[1]</a>.</p>
</div>
<div class="section" id="pass-by-reference">
<h3>Pass by reference</h3>
<p>On the flipside, when we care about the size, so that we don’t want to create a
copy of the object, but we aren’t worried about the lifetime - meaning the
object we pass to <span class="docutils literal"><span class="pre">do_stuff</span></span> won’t have to outlive the function call, we can
pass by reference:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// bar is only used within do_suff</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the <span class="docutils literal"><span class="pre">const</span></span> above - this means <span class="docutils literal"><span class="pre">do_suff</span></span> will use <span class="docutils literal"><span class="pre">bar</span></span> but won’t
modify it. By default, arguments should be marked as <span class="docutils literal"><span class="pre">const</span></span> unless the
function does indeed need to alter the object. Regardless of constness, in this
case we pass a reference to <span class="docutils literal"><span class="pre">bar</span></span> as an argument, which is very cheap (a
reference has the same size as a pointer). The only caveat is that <span class="docutils literal"><span class="pre">do_stuff</span></span>
should not pass this to some other object that outlives the function call (eg. a
global object which tries to use it later), because as soon as <span class="docutils literal"><span class="pre">foo</span></span> returns,
the reference becomes invalid.</p>
</div>
<div class="section" id="pass-by-pointer">
<h3>Pass by pointer</h3>
<p>A pointer argument would look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">*</span> <span class="n">bar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A good rule of thumb is to not do this. The difference between passing by
reference and by pointer in this case is that a pointer can be null, while a
reference can’t. So passing by pointer here automatically brings the need to
perform null checks to ensure bad things don’t happen. You would need to make a
very good argument to convince me during code review that using a pointer
instead of a reference is appropriate. Unless working against a legacy API which
can’t be changed, I highly discourage use of raw pointers.</p>
</div>
<div class="section" id="summary">
<h3>Summary</h3>
<p>In summary, when designing an API:</p>
<ol class="arabic simple">
<li>Take argument by value if copying it is not a concern</li>
<li>Take argument by <span class="docutils literal"><span class="pre">const&amp;</span></span> if it’s not a sink argument, meaning we don’t
need to refer to it passed the function call</li>
<li>Take argument by reference (<span class="docutils literal"><span class="pre">&amp;</span></span>) if 2) but the API needs to modify it</li>
<li>Take argument by <span class="docutils literal"><span class="pre">&amp;&amp;</span></span> if it’s a sink argument, the type has a move
constructor, and copying it is expensive</li>
<li>Don’t pass raw pointers around</li>
</ol>
</div>
</div>
<div class="section" id="heap-objects-and-smart-pointers">
<h2>Heap Objects and Smart Pointers</h2>
<p>In all of the examples above, <span class="docutils literal"><span class="pre">bar</span></span> was an object created on the stack. This
works great in some cases, but some objects are simply too big to fit on the
stack, or it doesn’t make sense for them to do so (if, for example, we want to
vary their size at runtime). In this case, we allocate the object on the heap
and keep a pointer to it.</p>
<p>Once we start working with heap objects, ownership becomes even more important:
unlike stack objects, which get automatically destroyed when their stack frame
gets popped, heap objects need to be explicitly deleted. This responsibility
should be with the <em>owner</em> of the object.</p>
<div class="section" id="unique-pointer">
<h3>Unique pointer</h3>
<p>A unique pointer (<span class="docutils literal"><span class="pre">std::unique_ptr</span></span>) is a wrapper around a raw pointer which
will automatically delete the heap object when it goes out of scope itself:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// ptrBar goes out of scope =&gt; heap object gets deleted</span>
</pre></div>
</div>
<p>The above call to <span class="docutils literal"><span class="pre">make_unique</span></span> allocates an instance of Bar on the heap and
wraps the pointer to it into the unique pointer <span class="docutils literal"><span class="pre">ptrBar</span></span>. Now <span class="docutils literal"><span class="pre">ptrBar</span></span>
<em>owns</em> the object and as soon as ptrBar goes out of scope, the heap object is
also deleted.</p>
<p>Unique pointers cannot be copied, so we can never accidentally have more than
one single <span class="docutils literal"><span class="pre">unique_ptr</span></span> pointing to the same heap object:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar2</span> <span class="o">=</span> <span class="n">ptrBar</span><span class="p">;</span> <span class="c1">// Won't compile</span>
</pre></div>
</div>
<p>Of course, if we <em>really</em> want to, we can get the raw pointer out of <span class="docutils literal"><span class="pre">ptrBar</span></span>
using <span class="docutils literal"><span class="pre">get()</span></span> and we can initialize a <span class="docutils literal"><span class="pre">unique_ptr</span></span> from a raw pointer -</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Please don't do this</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar2</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
</div>
<p>but this is very bad - now both pointers think they have sole ownership of the
resource, and as soon as one goes out of scope, using the other one leads to
undefined behavior. In general, the same way there are very few good reasons to
use raw pointers, there are very few good reasons to call <span class="docutils literal"><span class="pre">get()</span></span> on a smart
pointer.</p>
</div>
<div class="section" id="shared-pointer">
<h3>Shared pointer</h3>
<p>Sometimes, we do need to have several pointers pointing to the same heap object.
In this case, we can use shared pointers. Shared pointers pointing to the same
heap object keep a common reference count. Whenever a new shared pointer is
created for that particular heap object, the reference count is incremented.
Whenever a shared pointer for that heap object goes out of scope, the reference
count is decremented. Once the last shared pointer goes out of scope, the heap
object is deleted.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="c1">// one pointer to a Bar object on the heap (ref count = 1)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptrBar2</span><span class="p">(</span><span class="n">ptrBar1</span><span class="p">);</span>
        <span class="c1">// second shared pointer (ref count = 2)</span>
    <span class="p">}</span>
    <span class="c1">// ptrBar2 goes out of scope (ref count = 1)</span>
<span class="p">}</span>
<span class="c1">// ptrBar1 goes out of scope (ref count = 0) =&gt; heap object is deleted</span>
</pre></div>
</div>
<p>Shared pointers incur a bit more overhead than unique pointers - reference
counting needs to be atomic to account for multi-threaded environments, which
comes with a runtime cost. The reference count itself also needs to be stored
somewhere, which is a small space cost. Unique pointers don’t have these time
and space costs since they don’t need to count references - there is always only
one pointer to the object.</p>
<p>Costs aside, shared pointers also don’t make the ownership clear - there are
several instances “owning” the heap resource at the same time, which can
potentially alter it and step on each other’s toes. In general, prefer unique
pointers to shared pointers whenever possible.</p>
</div>
<div class="section" id="raw-pointer">
<h3>Raw pointer</h3>
<p>Avoid using raw pointers. Raw pointers don’t express ownership, so they don’t
offer the same guarantees that a) the resource pointed to gets properly cleaned
up and b) the resource pointed to is still valid at a given time. This leads to
dereferencing invalid memory and double-deletes (trying to free the same heap
object multiple times), which means undefined behavior. Also, don’t mix smart
and raw pointers - the smart pointers will keep doing their job happily, with
the potential of making the raw pointers invalid.</p>
</div>
<div class="section" id="com-pointers">
<h3>COM pointers</h3>
<p>On Windows, COM uses a different reference counting mechanism: the base
<span class="docutils literal"><span class="pre">IUnknown</span></span> interface declares <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> methods, which
implementations are expected to use to keep track of the reference count.
<span class="docutils literal"><span class="pre">CComPtr</span></span> (in ATL) and <span class="docutils literal"><span class="pre">ComPtr</span></span> (in WRL) are the COM smart pointers. They
call <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> on the owned object, and the owned object is
supposed to delete itself once its reference count drops to 0. Note that COM
uses a slightly different mechanism than the standard library shared pointers -
instead of the smart pointer keeping track of the reference count in the control
block and deleting the object once the last reference goes away, COM objects are
expected to keep track of their reference count themselves through the
<span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> methods and self-delete when the last reference goes
away (through <span class="docutils literal"><span class="pre">Release</span></span> call). The COM smart pointers only need to call
<span class="docutils literal"><span class="pre">Release</span></span> when they go out of scope.</p>
<p>It’s not a good idea to have both standard library and COM pointers point to the
same object, as each might decide to delete the object at different times -
<span class="docutils literal"><span class="pre">shared_ptr</span></span> looks at the <span class="docutils literal"><span class="pre">shared_ptr</span></span> refcount while COM objects look at
their internal reference count. So a <span class="docutils literal"><span class="pre">shared_ptr</span></span> might decide to delete an
object while a <span class="docutils literal"><span class="pre">ComPtr</span></span> still expects it to be valid or vice-versa. In
general, when working with COM objects, use COM smart pointers.</p>
</div>
<div class="section" id="auto-ptr">
<h3>auto_ptr</h3>
<p><span class="docutils literal"><span class="pre">auto_ptr</span></span> is a deprecated smart pointer. Unless working with an old compiler
and standard library, use <span class="docutils literal"><span class="pre">unique_ptr</span></span> or <span class="docutils literal"><span class="pre">shared_ptr</span></span> instead.</p>
</div>
<div class="section" id="other-smart-pointers">
<h3>Other smart pointers</h3>
<p>Old code bases might have custom smart pointer implementations, for the simple
fact that automatic memory management is always a good idea, and there is C++
code that predates the introduction of smart pointers into the standard library.
When interoperating with legacy code, use whatever works, but when writing new
code, do prefer standard library smart pointers to homebrewed ones.</p>
</div>
<div class="section" id="id2">
<h3>Summary</h3>
<p>In summary, when creating objects:</p>
<ol class="arabic simple">
<li>Create them on the stack if feasible (note that standard library types
like <span class="docutils literal"><span class="pre">std::vector</span></span> and <span class="docutils literal"><span class="pre">std::string</span></span> internally keep their data on
the heap, but they fit perfectly well on the stack, so you don’t need to
create an <span class="docutils literal"><span class="pre">std::vector</span></span> on the heap just because you are planning to
store a lot of elements in it - the vector manages a heap array
internally already).</li>
<li>Use a <span class="docutils literal"><span class="pre">unique_ptr</span></span> when creating them on the heap, to make ownership
obvious.</li>
<li>Use a <span class="docutils literal"><span class="pre">shared_ptr</span></span> only when <span class="docutils literal"><span class="pre">unique_ptr</span></span> isn’t sufficient (review
your design first, might be a design issue).</li>
<li>Use COM smart pointers like <span class="docutils literal"><span class="pre">CComPtr</span></span> when dealing with COM.</li>
<li>Don’t use <span class="docutils literal"><span class="pre">auto_ptr</span></span> or other old constructs unless working with legacy
code/compiler.</li>
<li>Don’t use raw pointers.</li>
</ol>
</div>
</div>
<div class="section" id="passing-smart-pointers-as-arguments">
<h2>Passing Smart Pointers as Arguments</h2>
<p>We covered passing arguments and smart pointers. Now combining the two, how do
we pass heap objects as arguments? Turns out Herb Sutter has
<a class="reference external" href="http://bit.ly/227Na5c">a great post</a> on this exact topic on his blog. I can’t
hope to explain better than him, so go read his post. I will try to summarize:</p>
<div class="section" id="pass-by-reference-the-pointed-to-type">
<h3>Pass by reference the pointed-to type</h3>
<p>Rather than forcing callers to use <span class="docutils literal"><span class="pre">unique_ptr</span></span> or <span class="docutils literal"><span class="pre">shared_ptr</span></span> by
specifying the smart pointer type (which makes assumptions about ownership),
just ask for a reference to the pointed-to-type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">*</span><span class="n">ptrBar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Herb also mentions raw pointer to the underlying type if the argument can be
null, but as I mentioned above, I’d rather stick to references and discourage
use of raw pointers as a general rule of thumb.</p>
</div>
<div class="section" id="pass-smart-pointer-by-value">
<h3>Pass smart pointer by value</h3>
<p>Passing a <span class="docutils literal"><span class="pre">unique_ptr</span></span> by value implies a sink argument - since a
<span class="docutils literal"><span class="pre">unique_ptr</span></span> cannot be copied, it has to be <span class="docutils literal"><span class="pre">std::move</span></span>‘d in. Interestingly,
Scott Meyers has <a class="reference external" href="http://bit.ly/1WgkvEh">a post</a> on his blog where he
disagrees with this and argues that arguments of move-only types should be
specified as <span class="docutils literal"><span class="pre">&amp;&amp;</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span> <span class="c1">// sink</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Passing a <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value implies the function wants to partake in the
ownership - in other words, will keep somewhere a reference to the object after
the function returns, but unlike the above <span class="docutils literal"><span class="pre">unique_ptr</span></span> example, it won’t have
exclusive ownership of the resource:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">);</span> <span class="c1">// copy-constructs another shared_ptr which shares ownership of the heap object</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pass-smart-pointer-by-reference">
<h3>Pass smart pointer by reference</h3>
<p>Only expect a smart pointer by non-const reference if the function is going to
modify the smart pointer itself (eg. by making it point to a different object).
In my experience, this is a rare occurrence.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Implies this function modifies the pointer itself.</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span>
</pre></div>
</div>
<p>There is no good reason to expect a <span class="docutils literal"><span class="pre">const&amp;</span></span> to a <span class="docutils literal"><span class="pre">unique_ptr</span></span>, just reference
the underlying type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// void do_stuff(const unique_ptr&lt;Bar&gt;&amp; ptrBar);</span>
<span class="c1">// No reason to use the above as opposed to</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>
</pre></div>
</div>
<p>Expect <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">shared_ptr</span></span> only if the function <em>might</em> create a copy
of the smart pointer. If the function would never create a copy of the pointer,
simply use <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type. If the function would always copy the
pointer, expect <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value.</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="c1">// Might or might not share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span>

<span class="c1">// Will never share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>

<span class="c1">// Will always share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>Summary</h3>
<p>A summary of the summary:</p>
<ol class="arabic simple">
<li>Take argument by <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type if you only care about the heap
object, not about the pointer.</li>
<li>Take <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> by <span class="docutils literal"><span class="pre">&amp;&amp;</span></span> to transfer ownership.</li>
<li>Take <span class="docutils literal"><span class="pre">shared_ptr</span></span> argument by value to partake in ownership.</li>
<li>Take smart pointer by (non-const) reference only if you are going to
modify the smart pointer itself.</li>
<li>No need for <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">unique_ptr</span></span> (just take <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type)</li>
<li>Take <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">shared_ptr</span></span> only if unknown whether function wants
ownership (take by <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type if function never wants
ownership, <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value if function always wants ownership).</li>
</ol>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Move constructors can be implicitly declared by the compiler if certain
conditions are met, see <a class="reference external" href="http://en.cppreference.com/w/cpp/language/move_constructor#Implicitly-declared_move_constructor">here</a>
for details.</td></tr>
</tbody>
</table>
</div>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/03/11/arguments-and-smart-pointers.html#disqus_thread" data-disqus-identifier="2016/03/11/arguments-and-smart-pointers">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>January 07, 2016</span>
        </div>
        <div class="section">
            <h1><a href="2016/01/07/clean-code-part-2.html">Clean Code - Part 2</a></h1>
<p>In <a class="reference external" href="2016/01/04/clean-code-part-1">Part 1</a> I talked about writing less code and
writing simple code. In this post I will cover writing stateless code and
writing readable code.</p>
<div class="section" id="write-stateless-code">
<h2>Write Stateless Code</h2>
<blockquote>
<div><p>A <strong>pure function</strong> is a <strong>function</strong> where the return value is only
determined by its input values, without observable side effects. This is
how <strong>functions</strong> in math work: <span class="docutils literal"><span class="pre">Math.cos(x)</span></span> will, for the same value
of <span class="docutils literal"><span class="pre">x</span></span>, always return the same result.</p>
<p><em>Source:</em> <a class="reference external" href="http://www.sitepoint.com/functional-programming-pure-functions/">SitePoint</a></p>
</div></blockquote>
<p>Things break when a program gets into a “bad state”. There are a couple of ways
to make this less likely to happen: making data immutable and writing functions
that don’t have side-effects (<em>pure</em> functions).</p>
<div class="section" id="immutable-data">
<h3>Immutable data</h3>
<p>If something shouldn’t change, mark it as immutable and let the compiler enforce
that. A good rule of thumb is to mark things as <span class="docutils literal"><span class="pre">const</span></span> (<span class="docutils literal"><span class="pre">const&amp;</span></span>,
<span class="docutils literal"><span class="pre">const*</span></span> etc.) and/or <span class="docutils literal"><span class="pre">readonly</span></span> by default, and make them mutable only when
truly needed <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>A simple example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">StringUtil</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Both <span class="docutils literal"><span class="pre">StringUtil::Concat1</span></span> and <span class="docutils literal"><span class="pre">StringUtil::Concat2</span></span> return the same thing
for the same input, the difference being that <span class="docutils literal"><span class="pre">Concat2</span></span>, as opposed to
<span class="docutils literal"><span class="pre">Concat1</span></span>, modifies its first argument. In a bigger function, such a change
might be introduced accidentally and have unexpected consequences down the line.</p>
<p>A simple way to address this is by explicitly marking the arguments as
<span class="docutils literal"><span class="pre">const</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">StringUtil</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat1</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat2</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span> <span class="c1">// Won't compile - can't call append on str1</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this case, <span class="docutils literal"><span class="pre">Concat2</span></span> won’t compile, so we can rely on the compiler to
eliminate this type of unintended behavior.</p>
<p>Another example: a simple <span class="docutils literal"><span class="pre">UpCase</span></span> function which calls <span class="docutils literal"><span class="pre">toupper</span></span> on each
character of the given string, upcasing it in place:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">UpCase</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">);</span>
        <span class="n">string</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Calling it with</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="kt">char</span><span class="o">*</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">UpCase</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>
</pre></div>
</div>
<p>will lead to a crash at runtime - the function will try to call <span class="docutils literal"><span class="pre">toupper</span></span> on
the characters of <span class="docutils literal"><span class="pre">myString</span></span>. The problem is that <span class="docutils literal"><span class="pre">myString</span></span> is a <span class="docutils literal"><span class="pre">char*</span></span>
to a string literal which gets compiled into the read-only data segment of the
binary. This cannot be modified.</p>
<p>To catch this type of errors at compile-time, we again only need to mark the
immutable data as such:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">UpCase</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span> <span class="c1">// Won't compile - can't call UpCase on myString</span>
</pre></div>
</div>
<p>In contrast with the previous example, the argument to <span class="docutils literal"><span class="pre">UpCase</span></span> is mutable by
design (the API is modifying the string in-place), but marking <span class="docutils literal"><span class="pre">myString</span></span> as
<span class="docutils literal"><span class="pre">const</span></span> tells the complier this is non-mutable data, so it can’t be used with
this API.</p>
</div>
<div class="section" id="pure-functions">
<h3>Pure functions</h3>
<p>Another way to reduce states is to use pure functions. Unfortunately there isn’t
a lot of syntax-level support for this in C++ and C# (C++ supports <span class="docutils literal"><span class="pre">const</span></span>
member functions, which guarantee at compile time that calling the member
function on an instance of the type won’t change the attributes of that
instance) <a class="footnote-reference" href="#id6" id="id2">[2]</a></p>
<p>This goes back to the recommendation from Part 1 of using generic algorithms and
predicates rather than implementing raw loops. In many cases, traversal state is
encapsulated in the library algorithm or in an iterator, and predicates ideally
don’t have side-effects.</p>
<div class="highlight-c#"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span>
                <span class="n">Where</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">).</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>Above code (also from Part 1) doesn’t hold any state: traversal is handled by
the Linq methods, the predicates are pure.</p>
<p>In general, try to encapsulate state in parts of the code built to manage state,
and keep the rest stateless. Note that immutable data and pure functions are
also an advantage in concurrent applications, since they can’t generate race
conditions.</p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Prefer pure functions to stateful functions and, if state is needed, keep it
contained</li>
<li>By default mark everything as <span class="docutils literal"><span class="pre">const</span></span> (or <span class="docutils literal"><span class="pre">readonly</span></span>), and only remove
the constraint when mutability is explicitly needed</li>
</ul>
</div>
</div>
<div class="section" id="write-readable-code">
<h2>Write Readable Code</h2>
<blockquote>
<div><p>In computer science, the <strong>expressive power</strong> (also called
<strong>expressiveness</strong> or expressivity) of a language is the breadth of ideas
that can be represented and communicated in that language [...]</p>
<ul class="simple">
<li>regardless of ease (theoretical expressivity)</li>
<li><strong>concisely and readily</strong> (practical expressivity)</li>
</ul>
<p><em>Source:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Expressive_power_(computer_science)">Wikipedia</a></p>
</div></blockquote>
<p>Code is read many more times than it is written/modified, so it should be
optimized for readability. What I mean by this is making the intent of the code
clear at a glance - this includes giving good descriptive names to variables,
functions, and types, adding useful comments where appropriate (a comment should
describe what the code does if it is non-obvious; a comment like <span class="docutils literal"><span class="pre">foo();</span> <span class="pre">//</span> <span class="pre">calls</span> <span class="pre">foo()</span></span>
is not a useful comment), and in general structure the code for easy reading.</p>
<p>For a counterexample, think back on a piece of code you read that elicited a
WTF. That’s the kind of code you don’t want to write.</p>
<p>I won’t insist much here, since there are countless books and industry best
practices for improving code readability.</p>
<p>Another way to make the code more readable is to have a good knowledge of the
language you are using. The strength of a language lies in its particularities,
so use them whenever appropriate. This means writing <a class="reference external" href="http://stackoverflow.com/questions/84102/what-is-idiomatic-code">idiomatic code</a>,
which implies knowledge of the language idioms. Don’t write C++ code like C
code, write it like C++ code. Don’t write C# code as C++, write it as C# etc.</p>
<p>Also, keep up to date on the language. Language syntax evolves to address needs,
so in general modern syntax introduces simpler, better ways to implement things
than old syntax. Take object allocation and initialization in C++ as an example:</p>
<div class="highlight-c"><div class="highlight"><pre><span/><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span>
<span class="n">init</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">deinit</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the C way of allocating and initializing a structure on the heap, then
deinitializing and freeing it. Allocation and initialization are separate steps,
with opportunity to leak both memory (by omitting the <span class="docutils literal"><span class="pre">free</span></span> call) and
managed resources (by omitting the <span class="docutils literal"><span class="pre">deinit</span></span> call). Not to mention opportunity
to end up with an initialized struct (by omitting the <span class="docutils literal"><span class="pre">init</span></span> call), or
accidental double-initialization, double-deinitialization, double-free etc.</p>
<p>C++ introduced classes, and the following syntax:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">...</span>
<span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">new</span></span> both allocates memory and calls the constructor, while <span class="docutils literal"><span class="pre">delete</span></span> calls
the destructor then releases the memory. Many of the problems in the C example
go away, but there is still the problem of leaking the resource by omitting the
<span class="docutils literal"><span class="pre">delete</span></span> call, and the issue of calling <span class="docutils literal"><span class="pre">delete</span></span> twice on the same memory
address.</p>
<p>To address these issues, smart pointers were introduced in the language:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">());</span>
</pre></div>
</div>
<p>Smart pointers encapsulate reference counting (how many <span class="docutils literal"><span class="pre">shared_ptr</span></span> objects
point to the same memory address), and automatically release the resource when
the last reference goes away. This gets rid of most problems, but there is an
even better way of allocating heap objects:</p>
<div class="highlight-c++"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">make_shared</span></span> has the advantage of improved performance, by allocating memory
in a single operation for both the object and the shared pointer’s own control
block <a class="footnote-reference" href="#id7" id="id3">[3]</a>. It also prevents leaks due to interleaving <a class="footnote-reference" href="#id8" id="id4">[4]</a>. So as the C++
language evolved, new constructs appeared to address potential problems. Keeping
up to date with these updates, and incorporating them into your code will reduce
the opportunity for bugs, make the code more concise, and thus more readable.</p>
<div class="section" id="beautiful-code">
<h3>Beautiful Code</h3>
<p>I encourage you to not stop at writing <em>working</em> code, rather strive to write
<em>beautiful</em> code. I have the following quote from <a class="reference external" href="http://www.goodreads.com/book/show/5608045-apprenticeship-patterns">Apprenticeship Patterns</a>
on the wall behind my monitors, so I can see it while I work:</p>
<blockquote>
<div>There’s always a better/faster/smarter way to do what you’re currently doing</div></blockquote>
<p>So don’t stop as soon as something works, ask yourself <em>is this the best way to
implement this?</em></p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Come up with good names</li>
<li>Write meaningful comments</li>
<li>Keep up to date with your language</li>
<li>Don’t just write working code, write beautiful code.</li>
</ul>
</div>
</div>
<div class="section" id="epilogue">
<h2>Epilogue</h2>
<p>As I was working on putting together the talk that inspired this post, I
realized there are a few more rules of thumb which I could cover. The current
working draft is:</p>
<ul class="simple">
<li>Write safe code</li>
<li>Write leakproof code</li>
<li>Write responsive code</li>
<li>Write testable code</li>
</ul>
<p>Sometime in the future I hope to continue the series with the above, in the
meantime, I’ll leave you with this one sentence summary:</p>
<blockquote>
<div><p>Always code as if the person who ends up maintaining your code is a violent psychopath who
knows where you live</p>
<p><em>Source:</em> <a class="reference external" href="http://blog.codinghorror.com/coding-for-violent-psychopaths/">Coding Horror</a></p>
</div></blockquote>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>At the time of this writing, there is an <a class="reference external" href="https://github.com/dotnet/roslyn/issues/7626">active proposals</a>
to extend the C# language with an <span class="docutils literal"><span class="pre">immutable</span></span> keyword.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>C# has a <span class="docutils literal"><span class="pre">PureAttribue</span></span> in the <span class="docutils literal"><span class="pre">System.Diagnostics.Contracts</span></span>
namespace (purity not compiler-enforced) and there is an <a class="reference external" href="https://github.com/dotnet/roslyn/issues/7561">active proposal</a>
to add a keyword for it too.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>This is a non-binding requirement in the standard, meaning a standard
library implementation doesn’t <em>have to</em> do this, but most implementations
will. You can read more about it <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Interleaving occurs since call order is not guaranteed. For example, in
<span class="docutils literal"><span class="pre">bar(std::share_ptr&lt;Foo&gt;(new</span> <span class="pre">foo()),</span> <span class="pre">baz())</span></span>, there is no guarantee that
call order will be <span class="docutils literal"><span class="pre">new</span> <span class="pre">foo()</span></span>, then the shared pointer’s constructor, then
<span class="docutils literal"><span class="pre">baz()</span></span>. Calls might get interleaved and executed as <span class="docutils literal"><span class="pre">new</span> <span class="pre">foo()</span></span>, then
<span class="docutils literal"><span class="pre">baz()</span></span>, then the shared pointer constructor, in which case an exception
thrown by <span class="docutils literal"><span class="pre">baz()</span></span> would leak the newly allocated <span class="docutils literal"><span class="pre">Foo</span></span> object, since the
shared pointer didn’t get ownership of it yet.</td></tr>
</tbody>
</table>
</div>

        </div>
        <div class="postmeta">
        
        
        
        <div class="comments">
            <a href="http://vladris.com/blog/2016/01/07/clean-code-part-2.html#disqus_thread" data-disqus-identifier="2016/01/07/clean-code-part-2">Leave a comment</a>
        </div></div><div class="archive_link">
        <a href="archive.html"> &mdash; Blog Archive &mdash; </a>
    </div><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="page2.html">Older</a> &raquo; </li>
        </ul></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><script type="text/javascript">    var disqus_shortname = "vladris";    disqus_count();</script><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
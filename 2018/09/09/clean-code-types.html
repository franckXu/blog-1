<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Clean Code: Types &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Implementing a Variant Type in C#" href="../../07/16/implementing-a-variant-type-in-csharp.html" /><link rel="prev" title="Arithmetic Overflow and Underflow" href="../../10/13/arithmetic-overflow-and-underflow.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>September 09, 2018</span>
        </div>
    <div class="section" id="clean-code-types">
<h1>Clean Code: Types</h1>
<p>I recently revived my Clean Code tech talk which I put together a couple of
years ago and with which I started this blog:
<a class="reference external" href="https://vladris.com/blog/2016/01/04/clean-code-part-1.html">Clean Code - Part 1</a>
and <a class="reference external" href="https://vladris.com/blog/2016/01/07/clean-code-part-2.html">Clean Code - Part 2</a>.
I took the opportunity to completely revamp the talk and ended up with 3 parts:
<em>Algorithms</em>, <em>Types</em>, and <em>State</em>. The <em>Algorithms</em> is mostly covered by the
<a class="reference external" href="https://vladris.com/blog/2018/02/11/fibonacci.html">Fibonacci</a> post, so in
this post we will talk about <em>Types</em>.</p>
<div class="section" id="mars-climate-orbiter">
<h2>Mars Climate Orbiter</h2>
<p>The Mars Climate Orbiter crashed and disintegrated in the Mars atmosphere
because a component developed by Lockheed provided momentum measured in
pound-force seconds, while another component developed by NASA expected momentum
as Newton seconds.</p>
<p>We can image the component developed by NASA being something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Will not disintegrate as long as momentum &gt;= 2 N s</span>
<span class="kt">void</span> <span class="nf">trajectory_correction</span><span class="p">(</span><span class="kt">double</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">momentum</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="cm">/* N s */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">disintegrate</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also imagine the Lockheed component calling into the above with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="mf">1.5</span> <span class="cm">/* lbf s */</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A pound-force second (lbfs) is about 4.448222 Newton seconds (Ns). So from
Lockheed’s perspective, passing in 1.5 lbfs to <span class="docutils literal"><span class="pre">trajectory_correction</span></span> should
be just fine: 1.5 lbfs is about 6.672333 Ns, way above the 2 Ns threshold.</p>
<p>The problem is the interpretation of the data. The NASA component ends up
comparing lbfs to Ns without conversion, misinterpreting the lbfs input as Ns.
Since 1.5 is less than 2, the orbiter disintegrates. This is a known
anti-pattern called “primitive obsession”.</p>
</div>
<div class="section" id="primitive-obsession">
<h2>Primitive Obsession</h2>
<p>Primitive obsession happens when we use a primitive data type to represent a
value in the problem’s domain and causes situations like the above. Representing
zip codes as numbers, telephone numbers as strings, Ns and lbfs as <span class="docutils literal"><span class="pre">double</span></span>
are all examples of this.</p>
<p>A more type safe solution would have defined a simple <span class="docutils literal"><span class="pre">Ns</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Ns</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Ns</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ns</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can similarly define a simple <span class="docutils literal"><span class="pre">lbfs</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">lbfs</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">lbfs</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">lbfs</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can implement a type safe <span class="docutils literal"><span class="pre">trajectory_correction</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Will not disintegrate as long as momentum &gt;= 2 N s</span>
<span class="kt">void</span> <span class="nf">trajectory_correction</span><span class="p">(</span><span class="n">Ns</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">momentum</span> <span class="o">&lt;</span> <span class="n">Ns</span><span class="p">{</span> <span class="mi">2</span> <span class="p">})</span>
    <span class="p">{</span>
        <span class="n">disintegrate</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Calling this with <span class="docutils literal"><span class="pre">lbfs</span></span> as below fails to compile as the types are
incompatible:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">lbfs</span><span class="p">{</span> <span class="mf">1.5</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note how the meaning of the values, which used to be specified in comments
(<span class="docutils literal"><span class="pre">2</span> <span class="pre">/*</span> <span class="pre">Ns</span> <span class="pre">*/</span></span>, <span class="docutils literal"><span class="pre">/*</span> <span class="pre">lbfs</span> <span class="pre">*/</span></span>) gets pulled into the type system and expressed
in code (<span class="docutils literal"><span class="pre">Ns{</span> <span class="pre">2</span> <span class="pre">}</span></span>, <span class="docutils literal"><span class="pre">lbfs{</span> <span class="pre">1.5</span> <span class="pre">}</span></span>).</p>
<p>We can, of course, provide casting from <span class="docutils literal"><span class="pre">lbfs</span></span> to <span class="docutils literal"><span class="pre">Ns</span></span> as an explicit
operator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">lbfs</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="k">operator</span> <span class="n">Ns</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="mf">4.448222</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Equipped with this, we can call <span class="docutils literal"><span class="pre">trajectory_correction</span></span> via a static cast:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Ns</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lbfs</span><span class="p">{</span> <span class="mf">1.5</span> <span class="p">}));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This does the right thing of multiplying by the ratio. The cast can also be
made implicit (by using the <span class="docutils literal"><span class="pre">implicit</span></span> keyword instead), in which case it is
applied automatically. As a rule of thumb, it’s best to follow the Zen of
Python:</p>
<blockquote>
<div>Explicit is better than implicit</div></blockquote>
<p>The moral of the story is that nowadays we have very sophisticated type checkers
but we do need to provide them enough information to catch this type of errors.
That information comes from declaring types to represent our problem domain.
<a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
</div>
<div class="section" id="state-space">
<h2>State Space</h2>
<p>Bad things happen when our programs end up in a <em>bad state</em>. Types help us
narrow down the possibility of such bad states. One way to think about this is
to look at types as sets of possible values. For example <span class="docutils literal"><span class="pre">bool</span></span> is the set
<span class="docutils literal"><span class="pre">{true,</span> <span class="pre">false}</span></span> where a variable of the type can be one of the two values.
Similarly, <span class="docutils literal"><span class="pre">uint32_t</span></span> is the set <span class="docutils literal"><span class="pre">{0</span> <span class="pre">...</span> <span class="pre">4294967295}</span></span>. Looking at types
like this, we can define the <em>state space</em> of our program as the product of
the types of all live variables at a given point in time.</p>
<p>If we have a <span class="docutils literal"><span class="pre">bool</span></span> and an <span class="docutils literal"><span class="pre">uint32_t</span></span>, our state space is <span class="docutils literal"><span class="pre">{true,</span> <span class="pre">false}</span> <span class="pre">X</span>
<span class="pre">{0</span> <span class="pre">...</span> <span class="pre">4294967295}</span></span>. This simply means that the two variables can be in any of
their possible states and since we have two of them, our program can be in any
of their combined states.</p>
<p>This gets more interesting when we look at functions that initialize values:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">get_momentum</span><span class="p">(</span><span class="n">Ns</span><span class="o">&amp;</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">some_condition</span><span class="p">())</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">momentum</span> <span class="o">=</span> <span class="n">Ns</span><span class="p">{</span> <span class="mi">3</span> <span class="p">};</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above example we take a <span class="docutils literal"><span class="pre">Ns</span></span> by reference and initialize it if some
condition is met. The function returns <span class="docutils literal"><span class="pre">true</span></span> if the value was properly
initialized. If the function cannot, for whatever reason, set the value, it
returns <span class="docutils literal"><span class="pre">false</span></span>.</p>
<p>Looking at this from the state space lens, our state space is the product
<span class="docutils literal"><span class="pre">bool</span> <span class="pre">X</span> <span class="pre">Ns</span></span>. If the function returns <span class="docutils literal"><span class="pre">true</span></span>, then <span class="docutils literal"><span class="pre">momentum</span></span> was set and
is in any one of the possible <span class="docutils literal"><span class="pre">Ns</span></span> values. The problem is that if the function
returns <span class="docutils literal"><span class="pre">false</span></span>, then <span class="docutils literal"><span class="pre">momentum</span></span> was not set. It is still in any one of the
possible <span class="docutils literal"><span class="pre">Ns</span></span> values, but it is not a valid value. Often times we have bugs
where we accidentally propagate such invalid state:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Ns</span> <span class="n">momenum</span><span class="p">;</span>

    <span class="n">get_momentum</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>

    <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What we should have done instead is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Ns</span> <span class="n">momentum</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">get_momentum</span><span class="p">(</span><span class="n">momentum</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a better way though, where this can be enforced:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Ns</span><span class="o">&gt;</span> <span class="n">get_momentum</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">some_condition</span><span class="p">())</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_optional</span><span class="p">(</span><span class="n">Ns</span><span class="p">{</span> <span class="mi">3</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using an <span class="docutils literal"><span class="pre">optional</span></span>, this version of the function has a significantly smaller
state space: instead of <span class="docutils literal"><span class="pre">bool</span> <span class="pre">X</span> <span class="pre">Ns</span></span>, we have <span class="docutils literal"><span class="pre">Ns</span> <span class="pre">+</span> <span class="pre">1</span></span>. The function either
returns a valid <span class="docutils literal"><span class="pre">Ns</span></span> value or <span class="docutils literal"><span class="pre">nullopt</span></span> to denote the absence of a value.
Now it becomes impossible to have an invalid <span class="docutils literal"><span class="pre">Ns</span></span> that gets propagated
throughout the system. We can also no longer <em>forget</em> to check the return value
as an <span class="docutils literal"><span class="pre">optional&lt;Ns&gt;</span></span> is not implicitly convertible to an <span class="docutils literal"><span class="pre">Ns</span></span> - we need to
explicitly unpack it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">maybeMomentum</span> <span class="o">=</span> <span class="n">get_momentum</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">maybeMomentum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">trajectory_correction</span><span class="p">(</span><span class="o">*</span><span class="n">maybeMomentum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In general, we want our functions to return <strong>result or error</strong> not
<strong>result and error</strong>. This way we eliminate the states in which we have an error
but also an invalid result which might make its way in further computation.</p>
<p>From this point of view, throwing exceptions is OK as this follows the same
pattern: a function either returns a result <strong>or</strong> throws an exception.</p>
</div>
<div class="section" id="raii">
<h2>RAII</h2>
<p>RAII stands for <em>Resource Acquisition Is Initialization</em> but has more to do
with releasing resources. The name originated from C++ but the pattern can be
implemented in any language (see, for example, .NET’s <span class="docutils literal"><span class="pre">IDisposable</span></span>). RAII
ensures automatic cleanup of resources.</p>
<p>What are resources? A few examples: heap memory, database connections, OS
handles. In general, a resource is something we acquire from the outside world
and we need to release when it is no longer needed. That means executing some
form of free, delete, close etc. on the resource.</p>
<p>Since these resources are external, they are not directly expressed into our
type system. For example if we allocate some heap memory, we get a pointer on
which we have to call <span class="docutils literal"><span class="pre">delete</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{};</span>

<span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>

    <span class="cm">/* Use foo */</span>

    <span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But what happens if we forget or something prevents us from calling <span class="docutils literal"><span class="pre">delete</span></span>?</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>

    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case we no longer call <span class="docutils literal"><span class="pre">delete</span></span> and we leak the resource. In general,
we don’t want to perform such manual cleanup. For heap memory, we actually have
<span class="docutils literal"><span class="pre">unique_ptr</span></span> to help us manage it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">unique_ptr</span></span> is a stack object so whenever it goes out of scope (when the
function throws or during stack unwinding if an exception was thrown) its
destructor gets called. It’s destructor implements the call to <span class="docutils literal"><span class="pre">delete</span></span>. This
way, we no longer have to manually manage the memory resource - we hand it off
to a wrapper which owns it and handles releasing it.</p>
<p>Similar wrappers exist or can be created for any of the other resources (for
example a Windows OS <span class="docutils literal"><span class="pre">HANDLE</span></span> can be wrapped in a type where its destructor
would call <span class="docutils literal"><span class="pre">CloseHandle</span></span>.</p>
<p>The key takeaway is never to do manual resource cleanup - either use an existing
wrapper or, if none exists for your particular scenario, implement one.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This post started with a famous example of why typing is important, and covered
three important aspects of leveraging types to write safer code:</p>
<ul class="simple">
<li>Declaring and using stronger types (as opposed to primitive obsession).</li>
<li>Reducing state space, returning result or error instead of result and error.</li>
<li>RAII and automatic resource management.</li>
</ul>
<p>Types are great tools for implementing safer, reusable code.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>There is a great series of posts on Fluent C++ on <a class="reference external" href="https://www.fluentcpp.com/category/strong-types/">Strong Typing</a>.</td></tr>
</tbody>
</table>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../../10/13/arithmetic-overflow-and-underflow.html">Arithmetic Overflow and Underflow</a></li>
            <li class="right"><a href="../../07/16/implementing-a-variant-type-in-csharp.html">Implementing a Variant Type in C#</a> &raquo; </li>
        </ul></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
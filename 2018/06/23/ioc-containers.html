<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>IoC Containers &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Kami 2" href="../../04/15/kami-2.html" /><link rel="prev" title="Implementing a Variant Type in C#" href="../../07/16/implementing-a-variant-type-in-csharp.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>June 23, 2018</span>
        </div>
    <div class="section" id="ioc-containers">
<h1>IoC Containers</h1>
<p>In this post I will go over the basics of IoC containers and walk through a very
simple C# implementation.</p>
<div class="section" id="motivation">
<h2>Motivation</h2>
<p>An inversion of control container is a component that encapsulates dependency
injection and lifetime management of other components <a class="footnote-reference" href="#id3" id="id1">[1]</a>. Assume we have some
well componentized code where classes work against interfaces:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">interface</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">DoFoo</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">:</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">DoFoo</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Bar</span>
<span class="p">{</span>
    <span class="c1">// Coded against IFoo interface, so decoupled from</span>
    <span class="c1">// concrete Foo implementation</span>
    <span class="k">public</span> <span class="nf">Bar</span><span class="p">(</span><span class="n">IFoo</span> <span class="n">foo</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">foo</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to create an instance of <span class="docutils literal"><span class="pre">Bar</span></span>, we need to pass it some <span class="docutils literal"><span class="pre">IFoo</span></span>
object. We could do it by <span class="docutils literal"><span class="pre">new</span></span>-ing up a <span class="docutils literal"><span class="pre">Foo</span></span> object at the call site of
<span class="docutils literal"><span class="pre">Bar</span></span>’s constructor:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">bar</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">());</span>
</pre></div>
</div>
<p>This doesn’t scale very well though. Most classes require more than one
dependency, so we can’t realistically litter the code with:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">(</span><span class="k">new</span> <span class="n">C</span><span class="p">(),</span> <span class="k">new</span> <span class="n">D</span><span class="p">()),</span> <span class="k">new</span> <span class="n">E</span><span class="p">(</span><span class="k">new</span> <span class="n">D</span><span class="p">()));</span>
</pre></div>
</div>
<p>Factory functions address part of the problem. We can have, for example:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="n">IA</span> <span class="nf">MakeIA</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="p">(</span><span class="n">MakeIB</span><span class="p">(),</span> <span class="n">MakeIE</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another advantage of using factory functions instead of directly calling
constructors is that a factory can encapsulate lifetime of objects. Changing
from a new instance on every call to a singleton can be encapsulated in the
factory so callers of <span class="docutils literal"><span class="pre">MakeIA</span></span> don’t need to change.</p>
<p>We would then call <span class="docutils literal"><span class="pre">MakeIA</span></span> whenever we needed an <span class="docutils literal"><span class="pre">IA</span></span> instance. But where
do these factories belong? They do not belong with the concrete types they are
implementing, because having a static <span class="docutils literal"><span class="pre">MakeIA</span></span> on class <span class="docutils literal"><span class="pre">A</span></span> would still
require callers to reference <span class="docutils literal"><span class="pre">A</span></span> (as in <span class="docutils literal"><span class="pre">A.MakeIA()</span></span>). Since these
factories become the only places in the system where knowledge of which type
resolves to which interface, it makes sense to keep them together:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">class</span> <span class="nc">Factories</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IA</span> <span class="nf">MakeIA</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="p">(</span><span class="n">MakeIB</span><span class="p">(),</span> <span class="n">MakeIE</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IB</span> <span class="nf">MakeIB</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="p">(</span><span class="n">MakeIC</span><span class="p">(),</span> <span class="n">MakeID</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IC</span> <span class="nf">MakeIC</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">C</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">ID</span> <span class="nf">MakeID</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">D</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IE</span> <span class="nf">MakeIE</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">E</span><span class="p">(</span><span class="n">MakeID</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works pretty well: changing which concrete type binds to an interface
becomes a changed scoped to one of the factories. But maintaining this by hand
can become tedious. The good news is it can be automated, which is what an IoC
container does.</p>
</div>
<div class="section" id="a-basic-ioc-container">
<h2>A Basic IoC Container</h2>
<p>A very basic container would be able to bind a concrete implementation against
an interface and return an instance of the concrete implementation when asked
for an interface:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The simplest possible thing to pass to <span class="docutils literal"><span class="pre">Register</span></span> is a factory function, in
which case our container would have to maintain a mapping from type to
factory:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">_registeredTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is how it can be used:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(),</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;()));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">B</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(),</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;()));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">C</span><span class="p">());</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">D</span><span class="p">());</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">E</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;()));</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>This is fine, but still requires a lot of hand-maintenance. One of the main
features of a container is the ability to use reflection and resolve some of
these dependencies automatically. Given a type, we can find its first public
constructor by calling <span class="docutils literal"><span class="pre">GetConstructor</span></span> on it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">param</span> <span class="k">in</span> <span class="k">typeof</span><span class="p">(</span><span class="n">A</span><span class="p">).</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">().</span><span class="n">GetParameters</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So given a type, we should be able to generate a factory function for it. A
simple way of doing it is by calling <span class="docutils literal"><span class="pre">Invoke</span></span> on the retrieved constructor
and attempting to retrieve all its arguments from the container:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">constructor</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span><span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
            <span class="n">param</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]()</span>
        <span class="p">).</span><span class="n">ToArray</span><span class="p">());</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now registering the interfaces becomes a lot easier:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">B</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">C</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">D</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">E</span><span class="p">));</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>It’s usually a good idea to support registration by both type and factory
function, for cases where the construction is more involved or the types of the
constructor arguments, for various reasons, are not registered with the
container.</p>
<div class="section" id="efficient-construction">
<h3>Efficient Construction</h3>
<p>Calling <span class="docutils literal"><span class="pre">Invoke</span></span> on a <span class="docutils literal"><span class="pre">ConstructorInfo</span></span> is notoriously slow <a class="footnote-reference" href="#id4" id="id2">[2]</a>. There are
several strategies to make this invocation faster. One of them is by using
<span class="docutils literal"><span class="pre">System.Linq.Expressions</span></span>, which are a set of types that help declare and
compile lambdas at runtime:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">(</span>
        <span class="n">Expression</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span> <span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
            <span class="n">param</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
                <span class="k">return</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span>
                    <span class="n">Expression</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">Expression</span><span class="p">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">resolve</span><span class="p">.</span><span class="n">Target</span><span class="p">),</span> <span class="n">resolve</span><span class="p">.</span><span class="n">Method</span><span class="p">),</span>
                    <span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">))).</span><span class="n">Compile</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above implementation compiles a lambda which is equivalent to the
<span class="docutils literal"><span class="pre">Invoke</span></span> logic. There are several other techniques to dynamically generate
functions, including <span class="docutils literal"><span class="pre">Reflection.Emit</span></span> and
<span class="docutils literal"><span class="pre">System.Runtime.CompilerServices</span></span>. Another decision point is whether
resolution is done lazily or not. The above implementation is lazy, resolving
each constructor parameter does not require an entry for it in the container
when this particular lambda is compiled. The relevant line is:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
</pre></div>
</div>
<p>If we were to replace this with:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">];</span>
</pre></div>
</div>
<p>it would fail to compile the lambda when registering <span class="docutils literal"><span class="pre">A</span></span> unless all other
dependencies are already in the container. This approach is flexible, in that
type bindings can be resolved at runtime, but can incur a bit more overhead. An
alternative would be to register all types with the container first, then
generate the factories in a separate step. In that case, for each type, we
could map out exactly what calls need to be made to set it up based on
information already available to the container. Such an implementation gets
more complex, so I won’t go into the details, but worth noting that it is
possible.</p>
</div>
</div>
<div class="section" id="lifetimes">
<h2>Lifetimes</h2>
<p>Containers also encapsulate lifetime management. The most basic non-instance
lifetime is singleton, which means a unique instance during the lifetime of the
app. Let’s extend our container to also support resolving singletons. First we
need a way to wrap a factory into a function that only calls it once, then
caches the result:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">factory</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This relies on <span class="docutils literal"><span class="pre">Lazy</span></span> to ensure uniqueness. Now we can enable singleton
registrations for factories and types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">MarkSingleton</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
<span class="p">{</span>
    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This effectively decorated the registered factory with the singleton logic.
There are various other lifetimes an object could require, for example:
threaded (where instances are cached per thread, so the same instance is always
returned on the same thread but not across threads), scoped (where there is an
API to mark beginning and end of a scope within which the same instance is
always returned, but another one gets created in another scope) etc.</p>
</div>
<div class="section" id="a-note-on-loading">
<h2>A Note on Loading</h2>
<p>One interesting observation made while profiling a .NET application is that a
container usually forces the loading of all referenced assembly. The .NET
runtime defers assembly loading until a method is called which references a
type in a not-yet-loaded assembly. This forces assembly loading as the runtime
needs the metadata of the type. When using an IoC container, all types are
usually registered as soon as the application boots, in which case all
assemblies get pulled in during registration time (as opposed to on-demand at a
later time).</p>
</div>
<div class="section" id="resources">
<h2>Resources</h2>
<p>The complete source code for the container in this blog post is:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">_registeredTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">(</span>
            <span class="n">Expression</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span> <span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
                <span class="n">param</span> <span class="p">=&gt;</span>
                <span class="p">{</span>
                    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
                    <span class="k">return</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span>
                        <span class="n">Expression</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">Expression</span><span class="p">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">resolve</span><span class="p">.</span><span class="n">Target</span><span class="p">),</span> <span class="n">resolve</span><span class="p">.</span><span class="n">Method</span><span class="p">),</span>
                        <span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">))).</span><span class="n">Compile</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">MarkSingleton</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">factory</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>I also recently open-sourced a minimal container <a class="reference external" href="https://github.com/microsoft/minioc">here</a>. That implementation includes support
for scoped lifetimes, but otherwise it is still very minimal. It was used in a
couple of small projects where constraints were around size/dependent assemblies
rather than feature richness.</p>
<p>For a popular open source container with many more features, check out <a class="reference external" href="https://autofac.org/">AutoFac</a>.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post we went over a few IoC container basics:</p>
<ul class="simple">
<li>Motivation for containers.</li>
<li>A primitive container supporting factory registration.</li>
<li>Using reflection to support type registration.</li>
<li>Approaches to implementing constructor calls: <span class="docutils literal"><span class="pre">Inove</span></span>, <span class="docutils literal"><span class="pre">Linq.Expressions</span></span>,
others. Lazy resolution vs. generating constructor calls in a separate step.</li>
<li>Lifetime management and a singleton implementation.</li>
</ul>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For a much more detailed treatment, see Martin Fowler’s
<a class="reference external" href="https://www.martinfowler.com/articles/injection.html">article</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>An interesting benchmark on <a class="reference external" href="https://stackoverflow.com/questions/35805609/performance-of-expression-compile-vs-lambda-direct-vs-virtual-calls">Stack Overflow</a></td></tr>
</tbody>
</table>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../../07/16/implementing-a-variant-type-in-csharp.html">Implementing a Variant Type in C#</a></li>
            <li class="right"><a href="../../04/15/kami-2.html">Kami 2</a> &raquo; </li>
        </ul></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Idris: Totality, Dependent Types, Proofs &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Singletons" href="../10/singletons.html" /><link rel="prev" title="24" href="../../08/13/24.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/disqus.js"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>July 20, 2017</span>
        </div>
    <div class="section" id="idris-totality-dependent-types-proofs">
<h1>Idris: Totality, Dependent Types, Proofs</h1>
<p>Idris is a programming language inspired by Haskell, with a set of innovative
features to facilitate type safety and program correctness.
<a class="reference external" href="https://www.manning.com/books/type-driven-development-with-idris">Type Driven Development with Idris</a>
is a great introductory book which I highly recommend. In this post, I will try
to cover the features I was most impressed with, providing some simple code
samples. I will not cover syntax since most should be familiar from Haskell. If
you are not familiar with Haskell syntax, here is a nice <a class="reference external" href="https://matela.com.br/pub/cheat-sheets/haskell-ucs-0.4.pdf">syntax cheat sheet</a>.
If you are not interested in either Haskell or Idris syntax, start with the last
section of this post, <a class="reference internal" href="#thoughts-about-the-future">Thoughts about the Future</a>.</p>
<div class="section" id="totality-checking">
<h2>Totality Checking</h2>
<p>A total function in Idris is a function which is defined for all possible inputs
and is guaranteed to produce a result in a finite amount of time <a class="footnote-reference" href="#id3" id="id1">[1]</a>. The
compiler obviously employs a heuristic, since the halting problem is
undecidable, but is usually close enough to the truth to guarantee correctness
from this point of view. It achieves this not by evaluating the function, but by
ensuring that every recursive branch converges to a halting branch.</p>
<p>Natural numbers are defined in Idris using Peano axioms, so it is easy to prove
things about them. Here is a minimal definition of natural numbers <a class="footnote-reference" href="#id4" id="id2">[2]</a>:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Nat&#39;</span> <span class="ow">=</span> <span class="kt">Z</span> <span class="ow">|</span> <span class="kt">S</span> <span class="kt">Nat&#39;</span>
</pre></div>
</div>
<p>This defines <span class="docutils literal"><span class="pre">Nat'</span></span> as a data type which can be constructed either as <span class="docutils literal"><span class="pre">Z</span></span>
(zero) or <span class="docutils literal"><span class="pre">S</span> <span class="pre">Nat'</span></span> (successor of another natural number). With this
definition, the compiler can easily determine the following function is total:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span> <span class="ow">:</span> <span class="kt">Nat&#39;</span> <span class="ow">-&gt;</span> <span class="ow">()</span>
f <span class="kt">Z</span> <span class="ow">=</span> <span class="ow">()</span>
f <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> <span class="ow">=</span> f k
</pre></div>
</div>
<p>This function return a unit given <span class="docutils literal"><span class="pre">Z</span></span>, otherwise it recursively takes the
predecessor of the argument. This converges to the <span class="docutils literal"><span class="pre">Z</span></span> case. The following
function, on the other hand, is correctly identified as potentially
non-terminating:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="nf">g</span> <span class="ow">:</span> <span class="kt">Nat&#39;</span> <span class="ow">-&gt;</span> <span class="ow">()</span>
g n <span class="ow">=</span> g <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span>
</pre></div>
</div>
<p>These are trivial examples, but in general, having a compile-time check for
termination is a very powerful tool.</p>
</div>
<div class="section" id="dependent-types">
<h2>Dependent Types</h2>
<p>Dependent types are types computed from other types. To put it another way,
Idris has first-order types, meaning functions can take types as arguments and
return types as their output. Functions that compute types are evaluated at
compile time. This is similar to C++ metaprogramming, but without employing a
different syntax.</p>
<p>Before an example, we first need to define addition on naturals as follows:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="ow">(+)</span> <span class="ow">:</span> <span class="kt">Nat&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Nat&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Nat&#39;</span>
<span class="ow">(+)</span> <span class="kt">Z</span> r <span class="ow">=</span> r
<span class="ow">(+)</span> <span class="ow">(</span><span class="kt">S</span> l<span class="ow">)</span> r <span class="ow">=</span> <span class="kt">S</span> <span class="ow">(</span>l <span class="ow">+</span> r<span class="ow">)</span>
</pre></div>
</div>
<p>Now we can declare a vector type consisting of a size (<span class="docutils literal"><span class="pre">Nat'</span></span>) and a type
argument:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vect&#39;</span> <span class="ow">:</span> <span class="kt">Nat&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
     <span class="nf">Nil</span> <span class="ow">:</span> <span class="kt">Vect&#39;</span> <span class="kt">Z</span> a
     <span class="ow">(::)</span> <span class="ow">:</span> <span class="ow">(</span>x <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>xs <span class="ow">:</span> <span class="kt">Vect&#39;</span> k a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Vect&#39;</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> a
</pre></div>
</div>
<p>Here <span class="docutils literal"><span class="pre">a</span></span> is a type argument. <span class="docutils literal"><span class="pre">Vect'</span></span> has two constructors: <span class="docutils literal"><span class="pre">Nil</span></span>,
creating a <span class="docutils literal"><span class="pre">Vect'</span></span> of size <span class="docutils literal"><span class="pre">Z</span></span> containing elements of type <span class="docutils literal"><span class="pre">a</span></span> (0
elements) and <span class="docutils literal"><span class="pre">(::)</span></span>, which concatenates an object of type <span class="docutils literal"><span class="pre">a</span></span> with a vector
of size <span class="docutils literal"><span class="pre">k</span></span> of <span class="docutils literal"><span class="pre">a</span></span> and produces a vector of size <span class="docutils literal"><span class="pre">S</span> <span class="pre">k</span></span> containing <span class="docutils literal"><span class="pre">a</span></span>.</p>
<p>Now to see dependent types in action, we can define <span class="docutils literal"><span class="pre">append'</span></span>, a function that
appends a vector to another vector:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="nf">append&#39;</span> <span class="ow">:</span> <span class="kt">Vect&#39;</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect&#39;</span> m a <span class="ow">-&gt;</span> <span class="kt">Vect&#39;</span> <span class="ow">(</span>n <span class="ow">+</span> m<span class="ow">)</span> a
append&#39; <span class="kt">Nil</span> ys <span class="ow">=</span> ys
append&#39; <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> ys <span class="ow">=</span> x <span class="ow">::</span> append&#39; xs ys
</pre></div>
</div>
<p>The interesting part is the function signature - given a vector of size <span class="docutils literal"><span class="pre">n</span></span>
and a vector of size <span class="docutils literal"><span class="pre">m</span></span>, the resulting vector will have size <span class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">m</span></span>. This
information is captured in the declaration and the compiler knows to apply the
<span class="docutils literal"><span class="pre">(+)</span></span> defined above and type-check that this is indeed true for a given pair
of arguments.</p>
</div>
<div class="section" id="proofs">
<h2>Proofs</h2>
<p>We can also attempt to define a <span class="docutils literal"><span class="pre">reverse'</span></span> function, which recursively appends
the head of the vector to the reversed tail:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="nf">reverse&#39;</span> <span class="ow">:</span> <span class="kt">Vect&#39;</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect&#39;</span> n a
reverse&#39; <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">Nil</span>
reverse&#39; <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> <span class="ow">=</span> append&#39; <span class="ow">(</span>reverse&#39; xs<span class="ow">)</span> <span class="ow">[</span>x<span class="ow">]</span>
</pre></div>
</div>
<p>This doesn’t compile though. We get the following error message:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>When checking right hand side of reverse&#39; with expected type
        Vect&#39; (S k) a

Type mismatch between
        Vect&#39; (k + S Z) a (Type of append&#39; (reverse&#39; xs) [x])
and
        Vect&#39; (S k) a (Expected type)

Specifically:
        Type mismatch between
                k + S Z
        and
                S k
</pre></div>
</div>
<p>We are claiming the function returns a vector of the same length as the input
vector, but we haven’t proven enough theorems about our definition of natural
numbers to convince the type checker. In this particular case, the problem is
that the compiler expects an <span class="docutils literal"><span class="pre">S</span> <span class="pre">k</span></span> but finds an <span class="docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span>. We need to prove
that these are indeed equal (<span class="docutils literal"><span class="pre">successor</span> <span class="pre">of</span> <span class="pre">k</span></span> is the same as
<span class="docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">successor</span> <span class="pre">of</span> <span class="pre">Z</span></span>). Here is the proof:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="nf">addOneProof</span> <span class="ow">:</span> <span class="ow">(</span>n <span class="ow">:</span> <span class="kt">Nat&#39;</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">S</span> n <span class="ow">=</span> n <span class="ow">+</span> <span class="kt">S</span> <span class="kt">Z</span>
addOneProof <span class="kt">Z</span> <span class="ow">=</span> <span class="kt">Refl</span>
addOneProof <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> <span class="ow">=</span> cong <span class="ow">(</span>addOneProof k<span class="ow">)</span>
</pre></div>
</div>
<p>Proofs are functions. There are a few things worth noting here: first, the
return type of this function is an equality (our theorem). Given a natural
<span class="docutils literal"><span class="pre">n</span></span>, the function proves that the equality holds. <span class="docutils literal"><span class="pre">Refl</span></span> is the built-in
reflexivity constructor, which constructs <span class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></span>. For the <span class="docutils literal"><span class="pre">Z</span></span> case, we can
use <span class="docutils literal"><span class="pre">Refl</span></span> to say that <span class="docutils literal"><span class="pre">S</span> <span class="pre">Z</span> <span class="pre">=</span> <span class="pre">Z</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span> which is true by the definition of
<span class="docutils literal"><span class="pre">(+)</span></span>. For the <span class="docutils literal"><span class="pre">(S</span> <span class="pre">k)</span></span> case, we use <span class="docutils literal"><span class="pre">cong</span></span>. <span class="docutils literal"><span class="pre">cong</span></span> is a built in
function that states that equality holds after function application. It’s
signature is <span class="docutils literal"><span class="pre">cong</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">=</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">b</span></span>, which basically means if <span class="docutils literal"><span class="pre">a</span></span> is
equal to <span class="docutils literal"><span class="pre">b</span></span>, then <span class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></span> is equal to <span class="docutils literal"><span class="pre">f</span> <span class="pre">b</span></span>. In our case, we are saying
that if <span class="docutils literal"><span class="pre">addOneProof</span> <span class="pre">k</span></span> holds, then so does <span class="docutils literal"><span class="pre">addOneProof</span> <span class="pre">(S</span> <span class="pre">k)</span></span>, which
allows us to converge on the <span class="docutils literal"><span class="pre">Z</span></span> case.</p>
<p>We now have a proof that <span class="docutils literal"><span class="pre">S</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span>. With this, we can prove that the
type <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(k</span> <span class="pre">+</span> <span class="pre">(S</span> <span class="pre">Z))</span> <span class="pre">a</span></span> can be rewritten as <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(S</span> <span class="pre">k)</span> <span class="pre">a</span></span>:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="nf">reverseProof</span> <span class="ow">:</span> <span class="kt">Vect&#39;</span> <span class="ow">(</span>k <span class="ow">+</span> <span class="ow">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="ow">))</span> a <span class="ow">-&gt;</span> <span class="kt">Vect&#39;</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> a
reverseProof <span class="ow">{</span>k<span class="ow">}</span> result <span class="ow">=</span> <span class="kr">rewrite</span> addOneProof k <span class="kr">in</span> result
</pre></div>
</div>
<p>There is some Idris-specific syntax here: <span class="docutils literal"><span class="pre">{k}</span></span> brings <span class="docutils literal"><span class="pre">k</span></span> from the function
declaration in scope, so we can refer to it in the function body even if it is
not passed in as an argument. The <span class="docutils literal"><span class="pre">rewrite</span> <span class="pre">...</span> <span class="pre">in</span></span> expression applies the
equality in the proof above to the input, in this case effectively rewriting
<span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(k</span> <span class="pre">+</span> <span class="pre">(S</span> <span class="pre">Z))</span> <span class="pre">a</span></span> to <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(S</span> <span class="pre">k)</span> <span class="pre">a</span></span>. Note these proofs are evaluated at
compile time and simply provide information to the type checker. With this
proof, we can implement reverse like this:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span></span><span class="nf">reverse&#39;</span> <span class="ow">:</span> <span class="kt">Vect&#39;</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect&#39;</span> n a
reverse&#39; <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">Nil</span>
reverse&#39; <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> <span class="ow">=</span> reverseProof <span class="ow">(</span>append&#39; <span class="ow">(</span>reverse&#39; xs<span class="ow">)</span> <span class="ow">[</span>x<span class="ow">])</span>
</pre></div>
</div>
<p>This is similar to the previous implementation, we just apply <span class="docutils literal"><span class="pre">reverseProof</span></span>
to the result of <span class="docutils literal"><span class="pre">append'</span></span>. This definition compiles.</p>
</div>
<div class="section" id="thoughts-about-the-future">
<h2>Thoughts About the Future</h2>
<p>Software development is generally driven by economics, where we more often than
not trade correctness for speed to market. But once the software is up and
running, correctness becomes an issue. As code increases in complexity, the
number of issues tends to increase, and the velocity with which changes can be
made without introducing regression drops dramatically. We have various
techniques that aim to maintain stability, like automated testing, but these are
not perfect: a test can prove that for a given input we get an expected output,
but cannot prove that for <em>any</em> input we would get the expected output.</p>
<p>On the other hand, we have solutions that do eliminate entire classes of issues.
An example is typing. Python, Ruby, and JavaScript, all dynamically typed, are
extremely expressive and make it very easy to whip up a proof of concept. But
there is an entire class of type errors which now turns into runtime issues. We
are notoriously bad at predicting what our code does, so the more help we get
from machines to ensure correctness, the better. In a strongly typed language,
even though it takes longer to convince the compiler that the code is type-safe,
this whole class of errors is eliminated. Language evolution over the years
tends to converge towards stronger typing: dynamic languages are augmented with
type checkers (Python has type hints, JavaScript has TypeScript etc.) and
statically typed languages are becoming less verbose as type inference evolves.
There will always be a need for a quick prototype, but code we want to deem
<em>reliable</em> should be typed. This includes a wide range of business-critical
applications where errors are very costly.</p>
<p>I see Idris as the next step beyond this. Totality checking allows the compiler
to guarantee termination, eliminating hangs from the code. First-order types
allows us to push more information to the type-checker, allowing for stricter
type-checking. Proofs, expressed as functions with regular syntax, allow the
compiler to provide formal verification of programs - here, as opposed to unit
tests, we are actually proving that we get the expected output for <em>any</em> input.
These are all tools for writing better, more correct code. As other functional
concepts got adopted over the years into more mainstream languages (for example
first-order functions, anonymous functions, algebraic types etc.), I expect (and
hope) these features to eventually be adopted too.</p>
<p>There is still a lot of room for improvement: writing proofs is tedious,
compiler errors are not always very clear, and, coming back to the speed to
market tradeoff, I doubt we will ever get to entire large applications formally
proven correct (barring some form of proof inference to speed things up by a
couple of orders of magnitude). That being said, I would love to have these
facilities as optional features in other languages and at least have the ability
to prove that the core functionality of a component does what it is supposed to
do, and get a compile break whenever a regression is introduced.</p>
<p>Programming languages are continuously evolving and the future looks exciting!</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Idris also supports functions that produce an infinite stream of values
which can be used with lazy evaluation. The full definition of totality
includes functions which don’t terminate but produce <span class="docutils literal"><span class="pre">Inf</span></span>. This
allows for non-terminating functions, but ensures non-termination is
intentional.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>I am using <span class="docutils literal"><span class="pre">'</span></span> to avoid naming conflicts with the built-in types and
functions. Idris already provides <span class="docutils literal"><span class="pre">Nat</span></span>, <span class="docutils literal"><span class="pre">Vect</span></span>, <span class="docutils literal"><span class="pre">append</span></span> and
<span class="docutils literal"><span class="pre">reverse</span></span>.</td></tr>
</tbody>
</table>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../../08/13/24.html">24</a></li>
            <li class="right"><a href="../10/singletons.html">Singletons</a> &raquo; </li>
        </ul><div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "vladris";    var disqus_identifier = "2017/07/20/idris-totality-dependent-types-proofs";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Evens before Odds &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Binary Relations" href="../10/binary-relations.html" /><link rel="prev" title="Notes on OOP" href="../../../2018/01/27/notes-on-oop.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>December 30, 2017</span>
        </div>
    <div class="section" id="evens-before-odds">
<h1>Evens before Odds</h1>
<p>One of my go-to interview questions goes like this:</p>
<blockquote>
<div><p>Given an array of numbers, make it so the even numbers come before the odd
ones.</p>
<p>For example, for <span class="docutils literal"><span class="pre">{</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8</span> <span class="pre">}</span></span>, a possible output would be
<span class="docutils literal"><span class="pre">{</span> <span class="pre">8,</span> <span class="pre">2,</span> <span class="pre">6,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">3,</span> <span class="pre">7,</span> <span class="pre">1</span> <span class="pre">}</span></span>.</p>
</div></blockquote>
<p>This is not a trick question by any means, it is a straightforward problem with
a couple of straightforward solutions. Note the <em>possible output</em> wording and
the fact that evens and odds in the output do not preserve the relative order
they had in the input.</p>
<div class="section" id="a-space-inefficient-solution">
<h2>A Space-Inefficient Solution</h2>
<p>An easy solution is to traverse the input once and store all even numbers
encountered during the traversal into a separate array, then traverse it again
and do the same for the odd numbers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This solves the problem in <span class="docutils literal"><span class="pre">O(n)</span></span> linear time (two traversals of the input
array) and <span class="docutils literal"><span class="pre">O(n)</span></span> linear space - result is as large as input, so additional
space required grows linearly with the size of the input.</p>
<p>There are more efficient way of doing this in linear time and constant space.</p>
</div>
<div class="section" id="two-algorithms">
<h2>Two Algorithms</h2>
<p>There are a couple of ways we can solve this. One algorithm goes like this:</p>
<blockquote>
<div><p>Find the first odd number. Stop if we reached the end of the array.</p>
<p>Find the first event number after that odd number. Stop if we reached the
end of the array.</p>
<p>Swap them.</p>
<p>Repeat.</p>
</div></blockquote>
<p>Our loop invariant is that all numbers before the first odd number (which we
update during each iteration) are already in the right place. With each
iteration, we find another even number that appears after the first odd number
so we swap them, putting the even in the right place. We stop when we run out of
numbers to swap, either odd or even. An implementation of this algorithm looks
like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="c1">// Find first odd number</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="c1">// If we reached the end we&#39;re done</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Find the first even number after the first odd one</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">j</span><span class="p">;</span>

        <span class="c1">// If we reached the end we&#39;re done</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Swap and continue</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While the algorithm is fairly straight-forward, the devil is in the details - we
need to perform multiple checks to make sure we don’t run off the end of the
array. While interviewing, I’ve seen many bugs come up due to missing some of
these checks.</p>
<p>An interesting observation we can make is that once we found the first pair of
odd and even numbers, after we swap them, the new first odd number is right
after the even we just swapped, so we can hoist the first while statement out of
the main loop - we only need to find the first odd once, then we just increment
after each swap:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="c1">// Find the first odd number</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>

    <span class="c1">// If we reached the end we’re done</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Start after the first odd and until we reach the end</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If it’s an even number</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Swap with the first odd</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="c1">// Increment first odd position</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another algorithm goes like this:</p>
<blockquote>
<div><p>Find the first odd number.</p>
<p>From the back, find the last even number.</p>
<p>Stop if the first odd number appears after the last even number.</p>
<p>Swap and repeat.</p>
</div></blockquote>
<p>Our loop invariant is that all numbers before the first odd and all numbers
after the last even are already in place. With each iteration, we move the first
odd and last even. We stop when the first odd appears after the last even, which
means all evens appear before the odds. Here is a possible implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="c1">// Find the first odd number</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="c1">// If the first odd occurs after the last even, stop</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Find the last even number</span>
        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="c1">// If the first odd occurs after the last even, stop</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Swap and continue</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both of the above algorithms solve the problem in linear time and constant
space.</p>
<div class="section" id="test-cases">
<h3>Test Cases</h3>
<p>Some interesting test cases to validate the implementations:</p>
<ul class="simple">
<li>Our example input <span class="docutils literal"><span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8</span> <span class="pre">}</span></span></li>
<li>An empty vector <span class="docutils literal"><span class="pre">{</span> <span class="pre">}</span></span></li>
<li>A vector with a single even number <span class="docutils literal"><span class="pre">{</span> <span class="pre">2</span> <span class="pre">}</span></span></li>
<li>A vector with a single odd number <span class="docutils literal"><span class="pre">{</span> <span class="pre">1</span> <span class="pre">}</span></span></li>
<li>A vector consisting of all even number <span class="docutils literal"><span class="pre">{</span> <span class="pre">2,</span> <span class="pre">4,</span> <span class="pre">6</span> <span class="pre">}</span></span></li>
<li>A vector consisting of all odd numbers <span class="docutils literal"><span class="pre">{</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">5</span> <span class="pre">}</span></span></li>
</ul>
</div>
<div class="section" id="follow-up-odds-before-evens">
<h3>Follow Up: Odds before Evens</h3>
<p>My follow up question is</p>
<blockquote>
<div>What if we also want the ability to put odd numbers before even ones? How
would we extend our code?</div></blockquote>
<p>An answer I’m <strong>not</strong> looking for is <em>we copy/paste the function, rename it to</em>
<span class="docutils literal"><span class="pre">odds_before_evens</span></span> <em>and update the checks</em>.</p>
<p>A clever answer (which I’m also not looking for) is <em>we provide an</em>
<span class="docutils literal"><span class="pre">odds_before_evens</span></span> <em>which internally calls</em> <span class="docutils literal"><span class="pre">evens_before_odds</span></span> <em>, then
reverses the output</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">odds_before_evens</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">evens_before_odds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A common answer is <em>we add a flag</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">evensFirst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This kind of works, but the condition becomes very complicated.</p>
</div>
<div class="section" id="follow-up-primes-before-non-primes">
<h3>Follow Up: Primes before Non-Primes</h3>
<p>What if we also want to move prime numbers before non-prime numbers, given some
<span class="docutils literal"><span class="pre">bool</span> <span class="pre">is_prime(int)</span></span> primality-testing function?</p>
<p>We can keep adding flags and extending the <span class="docutils literal"><span class="pre">if</span></span> conditions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Arrangement</span>
<span class="p">{</span>
    <span class="n">EvensBeforeOdds</span><span class="p">,</span>
    <span class="n">OddsBeforeEvens</span><span class="p">,</span>
    <span class="n">PrimesBeforeNonPrimes</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Arrangement</span> <span class="n">arrangement</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">EvensBeforeOdds</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">OddsBeforeEvens</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">PrimesBeforeNonPrimes</span> <span class="o">&amp;&amp;</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">EvensBeforeOdds</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">OddsBeforeEvens</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">PrimesBeforeNonPrimes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This doesn’t scale very well though. What we actually want to do here is
abstract away the predicate based on which we move elements around:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">odds_before_evens</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">primes_before_non_primes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">is_prime</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the algorithm remains the same: we have the exact same steps and loop
invariants, but we can parameterize the condition. With this abstraction, the
code actually becomes smaller and more readable.</p>
<p>This is about as far as I can get during an interview.</p>
</div>
</div>
<div class="section" id="partition">
<h2>Partition</h2>
<p>This is actually a well-known algorithm called a <em>partitioning algorithm</em>. A
partitioning algorithm moves elements that satisfy a predicate before elements
that don’t satisfy it. Let’s start with the above implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">partition</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works for vectors, but what if we want to partition a doubly-linked list?
Can we abstract away the data structure we are partitioning? The answer is
<em>yes</em>. We can use iterators to access the data structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">last</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">))</span>
            <span class="o">--</span><span class="n">last</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation is virtually the same. We get rid of <span class="docutils literal"><span class="pre">i</span></span> and <span class="docutils literal"><span class="pre">j</span></span>, as we
are using the iterators provided as arguments for traversal. The implementation
does not increase in complexity, but is now usable beyond vectors. For example
we can now partition a C-style array:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="useful-return">
<h3>Useful Return</h3>
<p>A useful return for our algorithm is the <em>partition point</em> - the position of the
first element that does not satisfy our predicate. We have this implicitly and
callers might be interested in it. To avoid making callers have to recompute it,
we should return it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

        <span class="o">--</span><span class="n">last</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">))</span>
            <span class="o">--</span><span class="n">last</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For example, <span class="docutils literal"><span class="pre">partition</span></span> is a key ingredient in quicksort:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Comp</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Comp</span> <span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Stop if we have no elements or one element</span>
    <span class="k">auto</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Swap pivot with last element</span>
    <span class="k">auto</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="o">--</span><span class="n">last</span><span class="p">);</span>

    <span class="c1">// Partition around pivot</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">comp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// Move pivot back in place</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

    <span class="c1">// Recursively sort left and right sides of the pivot</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">++</span><span class="n">last</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stl-implementations">
<h3>STL Implementations</h3>
<p>The <span class="docutils literal"><span class="pre">partition</span></span> algorithm we ended up with is fairly efficient, but it’s worth
taking a look at some of the highly-optimized STL implementations. This is the
MSVC STL implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span> <span class="o">++</span><span class="n">first</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="o">--</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">););</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="n">iter_swap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note this performs the least possible amount of operations. It also seems to
favor <span class="docutils literal"><span class="pre">for</span></span> loops. Contrast this with the LLVM libc++ implementation, which
seems to favor <span class="docutils literal"><span class="pre">while</span></span> loops:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">do</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="o">--</span><span class="n">last</span><span class="p">)</span> <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">));</span>
        <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iterator-requirements-and-complexity">
<h3>Iterator Requirements and Complexity</h3>
<p>We focused on the second algorithm presented, which finds the first odd, last
even, and swaps them. We had another algorithm which was looking for <em>the first
even after the first odd</em> during each iteration. Let’s provide a generic
implementation for it too:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">);</span> <span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What is the difference?</p>
<p>The difference is that this algorithm only ever increments the iterators. That
means it only requires a <span class="docutils literal"><span class="pre">ForwardIterator</span></span>, as opposed to the other algorithm,
which finds the <em>last even</em> number starting from the <span class="docutils literal"><span class="pre">last</span></span> iterator, which
requires a <span class="docutils literal"><span class="pre">BidirectionalIterator</span></span>.</p>
<p>In other words, the algorithm requiring only a <span class="docutils literal"><span class="pre">ForwardIterator</span></span> works on a
singly-linked list (<span class="docutils literal"><span class="pre">forward_list</span></span>), while the other one can’t (we can only
traverse a singly-linked list forward in <span class="docutils literal"><span class="pre">O(1)</span></span> time, not backwards).</p>
<p>The MSVC STL implementation of the forward-iterator algorithm is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">);</span> <span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
            <span class="n">iter_swap</span><span class="p">(</span><span class="n">first</span><span class="o">++</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The libc++ one is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="n">tpyename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The reason both implementations are provided is that the <span class="docutils literal"><span class="pre">ForwardIterator</span></span>
version, while more generally applicable, is slightly less efficient. The
<span class="docutils literal"><span class="pre">BidirectionalIterator</span></span> version moves any element at most once, and since the
move is a swap, it means it performs at most <span class="docutils literal"><span class="pre">N</span> <span class="pre">/</span> <span class="pre">2</span></span> swaps where <span class="docutils literal"><span class="pre">N</span></span> is the
number of elements. The <span class="docutils literal"><span class="pre">ForwardIterator</span></span> version might perform more swaps, up
to <span class="docutils literal"><span class="pre">N</span></span>. For example, for the input <span class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">4</span></span>, during the first step, it would
swap <span class="docutils literal"><span class="pre">1</span></span> with <span class="docutils literal"><span class="pre">2</span></span>, ending up with <span class="docutils literal"><span class="pre">2</span> <span class="pre">1</span> <span class="pre">4</span></span>, then during the next step it
would swap <span class="docutils literal"><span class="pre">1</span></span> with <span class="docutils literal"><span class="pre">4</span></span>, ending up with <span class="docutils literal"><span class="pre">2</span> <span class="pre">4</span> <span class="pre">1</span></span>.</p>
</div>
</div>
<div class="section" id="in-c">
<h2>In C#</h2>
<p>Partitioning is not specific to the C++ language. The same implementation can be
used, for example, in C#, up to abstracting away data structure traversal:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">IListPartition</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">Partition</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">pred</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">last</span> <span class="p">=</span> <span class="n">self</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(;;)</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="p">!=</span> <span class="n">last</span> <span class="p">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">]))</span>
                <span class="p">++</span><span class="n">first</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="p">==</span> <span class="n">last</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

            <span class="p">--</span><span class="n">last</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="p">!=</span> <span class="n">last</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">pred</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">]))</span>
                <span class="p">--</span><span class="n">last</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="p">==</span> <span class="n">last</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

            <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">];</span>
            <span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="p">=</span> <span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">];</span>
            <span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The .NET <span class="docutils literal"><span class="pre">IEnumerator</span></span> does not allow us to mutate the data structure we are
enumerating over, so we cannot provide a generic <span class="docutils literal"><span class="pre">IEnumerable&lt;T&gt;</span></span> partition
algorithm that works in-place. Otherwise the implementation is pretty much
identical to the C++ one, as the algorithm is the same.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Moving even numbers before odd ones in a given array of numbers is an instance
of partition.</li>
<li>The algorithm can be generalized to work with an arbitrary predicate.</li>
<li>The algorithm can be generalized to work across any data structure as long as
it can be traversed with at least a <span class="docutils literal"><span class="pre">ForwardIterator</span></span>.</li>
<li>A <span class="docutils literal"><span class="pre">BidirectionalIterator</span></span> version performs at most <span class="docutils literal"><span class="pre">N</span> <span class="pre">/</span> <span class="pre">2</span></span> swaps (and
<span class="docutils literal"><span class="pre">N</span></span> applications of the predicate).</li>
<li>A <span class="docutils literal"><span class="pre">ForwardIterator</span></span> version performs at most <span class="docutils literal"><span class="pre">N</span></span> swaps (and <span class="docutils literal"><span class="pre">N</span></span>
applications of the predicate).</li>
<li>Both versions of the algorithm are part of the standard library
(<span class="docutils literal"><span class="pre">std::partition</span></span> algorithm).</li>
<li>The same algorithm can be implemented in other languages, as generic as the
available abstractions allow.</li>
</ul>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../../../2018/01/27/notes-on-oop.html">Notes on OOP</a></li>
            <li class="right"><a href="../10/binary-relations.html">Binary Relations</a> &raquo; </li>
        </ul></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
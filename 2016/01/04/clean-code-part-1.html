<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Clean Code - Part 1 &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="next" title="Hello World" href="../../../2015/12/28/hello-world.html" /><link rel="prev" title="Clean Code - Part 2" href="../07/clean-code-part-2.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="../../../_static/disqus.js"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" /></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>January 04, 2016</span>
        </div>
    <div class="section" id="clean-code-part-1">
<h1>Clean Code - Part 1</h1>
<p>These posts are based on a Clean Code talk I did for my team a few months ago,
which, in turn, was inspired by the advice I gave to some of our summer
interns as four rules of thumb for writing cleaner code:</p>
<ul class="simple">
<li>Write less code</li>
<li>Write simple code</li>
<li>Write stateless code</li>
<li>Write readable code</li>
</ul>
<p>I will cover the first two points in this post and the remaining two in Part 2.
I&#8217;m talking about C++ and C# throughout, but most of this should be applicable
to any object-oriented or multi-paradigm language.</p>
<div class="section" id="write-less-code">
<h2>Write Less Code</h2>
<blockquote>
<div><p>The number of defects found in open source projects was 0.45 defects/1,000
lines of code, while the industry&#8217;s average is around 1 defect per&nbsp;1,000
lines of code for companies not using automated testing such as static
analysis.</p>
<p><em>Source:</em> <a class="reference external" href="http://www.infoq.com/news/2012/03/Defects-Open-Source-Commercial">http://www.infoq.com/news/2012/03/Defects-Open-Source-Commercial</a></p>
</div></blockquote>
<p>A great way to have fewer bugs is to have fewer lines of code! What I mean by
this is that churning out many lines of code is by no means a measure of
productivity yet, unfortunately, most developers still feel great when, at the
end of the day, we wrote <em>insert high number</em> LoC.</p>
<div class="section" id="how-to-write-less-code">
<h3>How to write less code?</h3>
<p>Two points to keep in mind: first, don&#8217;t reinvent the wheel - don&#8217;t write code
if there is an existing library, internal to your company or open-source, that
already does what needs to be done. Case in point, we refactored some code for
a project (C#), extracted some interfaces, componentized things, and wrote a
bunch of unit tests. All of this was great, except we ended up with a bunch of
handcrafted stub classes: for</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">interface</span> <span class="n">IMyComponent</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Foo</span><span class="p">();</span>
    <span class="kt">int</span> <span class="nf">Bar</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">Baz</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>we had</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyComponentStub</span> <span class="p">:</span> <span class="n">IMyComponent</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Baz</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">myComponentStub</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyComponentStub</span><span class="p">();</span>
</pre></div>
</div>
<p>and so on. Implementing these stubs was tedious, needless work - we integrated
<a class="reference external" href="https://github.com/Moq/moq4">Moq</a> , a mocking library, and the above code
turned into:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">using</span> <span class="nn">Moq</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">myComponentStub</span> <span class="p">=</span> <span class="n">Mock</span><span class="p">.</span><span class="n">Of</span><span class="p">&lt;</span><span class="n">IMyComponent</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Moq uses reflection to stub out interfaces at run-time, so simply adopting the
library helped us get rid of a lot of code.</p>
<p>The second way to write less code is to know the standard library of your
language of choice. Many times, a block of code can be replaced with a simple
library call. For C++, pay particular attention to the STL <span class="docutils literal"><span class="pre">&lt;algorithm&gt;</span></span> header
and for C#, <span class="docutils literal"><span class="pre">System.Linq</span></span>. Both contain many of useful algorithms which can
replace a lot of code.</p>
<p>I also recommend watching Sean Parent&#8217;s <a class="reference external" href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">C++ Seasoning</a>
talk, one of the best tech talks I&#8217;ve seen. The example he gives in the talk
(from the Chrome codebase) shows how a couple of lines of STL code can be used
instead of a whole convoluted function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PanelBar</span><span class="o">::</span><span class="n">RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span>

  <span class="c1">// First, find the index of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span> <span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Next, check if the panel has moved to the other side of another panel.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">center_x</span> <span class="o">=</span> <span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">center_x</span> <span class="o">&lt;=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span> <span class="o">||</span>
        <span class="n">i</span> <span class="o">==</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">panel</span> <span class="o">!=</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If it has, then we reorder the panels.</span>
        <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">];</span>
        <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Find the total width of the panels to the left of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">total_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fixed_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span> <span class="o">==</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">total_width</span> <span class="o">+=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">new_fixed_index</span> <span class="o">=</span> <span class="n">fixed_index</span><span class="p">;</span>

  <span class="c1">// Move panels over to the right of the fixed panel until all of the ones</span>
  <span class="c1">// on the left will fit.</span>
  <span class="kt">int</span> <span class="n">avail_width</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">&gt;</span> <span class="n">avail_width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_fixed_index</span><span class="o">--</span><span class="p">;</span>
    <span class="n">CHECK_GE</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">total_width</span> <span class="o">-=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Reorder the fixed panel if its index changed.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_fixed_index</span> <span class="o">!=</span> <span class="n">fixed_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
    <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
    <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">new_fixed_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Now find the width of the panels to the right, and move them to the</span>
  <span class="c1">// left as needed.</span>
  <span class="n">total_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">total_width</span> <span class="o">+=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">avail_width</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">&gt;</span> <span class="n">avail_width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_fixed_index</span><span class="o">++</span><span class="p">;</span>
    <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">total_width</span> <span class="o">-=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Do the reordering again.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_fixed_index</span> <span class="o">!=</span> <span class="n">fixed_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
    <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
    <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">new_fixed_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Finally, push panels to the left and the right so they don&#39;t overlap.</span>
  <span class="kt">int</span> <span class="n">boundary</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">reverse_iterator</span> <span class="n">it</span> <span class="o">=</span>
       <span class="c1">// Start at the panel to the left of &#39;new_fixed_index&#39;.</span>
       <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">new_fixed_index</span><span class="p">);</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">),</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">boundary</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span>
                  <span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">),</span>
                  <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PanelBar</span><span class="o">::</span><span class="n">RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span>

  <span class="c1">// First, find the index of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span> <span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Next, check if the panel has moved to the left side of another panel.</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">)</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">),</span> <span class="n">f</span><span class="p">,</span> <span class="n">center_x</span><span class="p">,</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

  <span class="c1">// If it has, then we reorder the panels.</span>
  <span class="n">rotate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Code snippets borrowed from Sean Parent&#8217;s slides, I highly recommend watching the
whole talk.</p>
<p>The key takeaway here is that there could be a standard library implementation or
an external module that can greatly simplify your work and it&#8217;s a good practice
to always ask yourself <em>“do I really need to write this?”</em></p>
</div>
</div>
<div class="section" id="write-simple-code">
<h2>Write Simple Code</h2>
<p>First, a few notes on cyclomatic complexity from Wikipedia:</p>
<blockquote>
<div><p>Cyclomatic complexity&nbsp;is a software metric (measurement), used to indicate
the&nbsp;complexity&nbsp;of a program. It is a quantitative measure of the number of
linearly independent paths through a program&#8217;s source code.</p>
<dl class="docutils">
<dt>The complexity M is then defined as</dt>
<dd><em>M = E − N + 2P</em></dd>
<dt>where</dt>
<dd><em>E = the number of edges of the graph, N = the number of nodes of the
graph, P = the number of connected components.</em></dd>
</dl>
<div align="center" class="align-center"><img src="../../../_images/cyclomatic_complexity.svg" /></div>
<p>A control flow graph of a simple program. The program begins executing at
the red node, then enters a loop (group of three nodes immediately below
the red node). On exiting the loop, there is a conditional statement (group
below the loop), and finally the program exits at the blue node. This graph
has 9 edges, 8 nodes, and 1 connected component, so the cyclomatic
complexity of the program is 9 - 8 + 2 * 1 = 3.</p>
<p><em>Source:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">https://en.wikipedia.org/wiki/Cyclomatic_complexity</a></p>
</div></blockquote>
<p>The cyclomatic complexity of any piece of code should be minimized. This can be
achieved by avoiding branching, namely, whenever possible, avoiding conditional
statements and loops. Linear code is easier to read and maintain, and provides
less opportunities for bugs.</p>
<div class="section" id="avoiding-conditional-statements">
<h3>Avoiding conditional statements</h3>
<p>One way to avoid conditional statements is to, whenever feasible, throw
exceptions instead of propagating errors through return values.</p>
<p>Here is an example of error code propagation through return values using the
Windows API&#8217;s <span class="docutils literal"><span class="pre">HRESULT</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">HRESULT</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">// Does some work and returns an HRESULT</span>
<span class="n">HRESULT</span> <span class="nf">bar</span><span class="p">();</span> <span class="c1">// Does some work and returns an HRESULT</span>

<span class="n">HRESULT</span> <span class="nf">baz</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">S_OK</span><span class="p">;</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="n">baz</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>

    <span class="p">...</span> <span class="c1">// Some more work here which might fail</span>

    <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">baz</span><span class="p">()))</span>
<span class="p">{</span>
    <span class="c1">// :)</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// :(</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This can be replaced with the more concise and much easier to read:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">// Does some work, might throw</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">();</span> <span class="c1">// Does some work, might throw</span>

<span class="kt">void</span> <span class="nf">baz</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
    <span class="n">baz</span><span class="p">();</span>

    <span class="p">...</span> <span class="c1">// Some more work here which might fail (and throw)</span>
<span class="p">}</span>

<span class="n">try</span>
<span class="p">{</span>
    <span class="n">baz</span><span class="p">();</span>
    <span class="c1">// :)</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span>
    <span class="c1">// :(</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Error code return values come from the old days when exceptions didn&#8217;t exist
and make code harder to read. That being said, for C++ specifically, you
should be careful about throwing exceptions across DLL boundaries. In practice
though, a lot of code in the shape of the above example appears within the
same executable for no good reason. If cross-DLL boundary is a problem, I would
actually recommend using exceptions internally and switching to return codes at
the public API boundary.</p>
<p>Another way to avoid conditional statements is to use the <a class="reference external" href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null Object pattern</a>
instead of checking for null. For example, take an <span class="docutils literal"><span class="pre">IActivity</span></span> interface on
which we can log success or failure, and an <span class="docutils literal"><span class="pre">ActivityScope</span></span> which can retrieve
the current activity from a context:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">interface</span> <span class="n">IActivity</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">LogSuccess</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">LogFailure</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActivityScope</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IActivity</span> <span class="nf">GetCurrentActivity</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this implementation, all clients of the API have to make sure <span class="docutils literal"><span class="pre">GetCurrentActivity()</span></span>
returns an object as opposed to null. All callers look like this:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">ActivityScope</span> <span class="n">activityScope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ActivityScope</span><span class="p">();</span>
<span class="n">activityScope</span><span class="p">.</span><span class="n">CreateActivity</span><span class="p">();</span>

<span class="p">...</span> <span class="c1">// Do a bunch of stuff</span>

<span class="kt">var</span> <span class="n">activity</span> <span class="p">=</span> <span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">activity</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">activity</span><span class="p">.</span><span class="n">LogSuccess</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While there is a single <span class="docutils literal"><span class="pre">ActivityScope</span></span> implementation, there are hundreds of
calls to <span class="docutils literal"><span class="pre">GetCurrentActivity</span></span>, all coming with a boilerplate null check. The
Null Object alternative for this is to provide a <span class="docutils literal"><span class="pre">NullActivity</span></span>, for which
<span class="docutils literal"><span class="pre">LogSuccess</span></span> and <span class="docutils literal"><span class="pre">LogFailure</span></span> don&#8217;t do anything. <span class="docutils literal"><span class="pre">ActivityScope</span></span> can return
<span class="docutils literal"><span class="pre">NullActivity</span></span> instead of null if there is no <span class="docutils literal"><span class="pre">Activity</span></span> in the context:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NullActivity</span> <span class="p">:</span> <span class="n">IActivity</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LogSuccess</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LogFailure</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActivityScope</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">NullActivity</span> <span class="n">_nullActivity</span> <span class="p">=</span> <span class="k">new</span> <span class="n">NullActivity</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">IActivity</span> <span class="nf">GetCurrentActivity</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_nullActivity</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now callers don&#8217;t need to worry about getting back a null, and can use the API
like this:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">().</span><span class="n">LogSuccess</span><span class="p">();</span>
</pre></div>
</div>
<p>Yet another way to reduce branching is when it used for mapping between two types:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="p">=</span> <span class="s">&quot;Foo string&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="p">=</span> <span class="s">&quot;Bar string&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">...</span>
</pre></div>
</div>
<p>A pattern like this (which can also take the form of a big switch/case statement)
can usually be replaced with indexing into an array or looking up the
corresponding value in a hash map:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">IdTypeToStringMap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">,</span> <span class="s">&quot;Foo&quot;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">,</span> <span class="s">&quot;Bar&quot;</span> <span class="p">},</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="n">b</span> <span class="p">=</span> <span class="n">IdTypeToStringMap</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
</pre></div>
</div>
<p>This is, again, easier to maintain, since it is declarative - the mapping is given as
data (<span class="docutils literal"><span class="pre">IdTypeToStringMap</span></span>), not as code (long series of if/else).</p>
</div>
<div class="section" id="avoid-loops">
<h3>Avoid loops</h3>
<p>This goes back to the C++ Seasoning talk, namely the <em>No Raw Loops</em> guideline. Here&#8217;s
a C# example: given a list of numbers, we want to get the square of all the odd
numbers in the list.</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="m">6</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">8</span> <span class="p">};</span>

<span class="c1">// Get the squares of all odd numbers</span>
</pre></div>
</div>
<p>One way to do this is to maintain a list of numbers, iterate over the list, check
if numbers are odd, and if so, square them and add them to the list:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">squares</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">squares</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
</pre></div>
</div>
<p>A neater way to do this is to use a generator instead of manually maintaining
the list of squares:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
</pre></div>
</div>
<p>That being said, what I would actually recommend is using Linq:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="c1">// Get the squares of all odd numbers</span>
<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span>
                <span class="n">Where</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">).</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>Fewer lines of code and no branching whatsoever <a class="footnote-reference" href="#id2" id="id1">[*]</a>. <span class="docutils literal"><span class="pre">Where</span></span> and <span class="docutils literal"><span class="pre">Select</span></span>
are generic algorithms, and their arguments are the predicates we use. This makes
the intent of the code clear at a glance - we are filtering the collection with
a predicate (<span class="docutils literal"><span class="pre">number</span> <span class="pre">=&gt;</span> <span class="pre">number</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">!=</span> <span class="pre">0</span></span>) and applying a transformation to it
with another predicate (<span class="docutils literal"><span class="pre">number</span> <span class="pre">=&gt;</span> <span class="pre">number</span> <span class="pre">*</span> <span class="pre">number</span></span>). Also, the filtering and
transformation are library functions, so we can be fairly certain they work
well, and only need to worry about maintaining our predicates.</p>
<p>It might not look like a big deal in this simple made-up example, but as code
evolves, it becomes harder and harder to follow the iteration logic, as the
code gets littered with <span class="docutils literal"><span class="pre">break</span></span>, <span class="docutils literal"><span class="pre">continue</span></span>, and <span class="docutils literal"><span class="pre">return</span></span> statements (see
the Chrome example quoted in the Write Less Code section).</p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Try to keep functions linear (or as linear as possible)</li>
<li>Default to throwing instead of propagating errors up the call stack</li>
<li>Consider creating a null object when code is littered with null checks</li>
<li>Separate algorithm logic from predicates to make the intent of the code clear (in other words, no raw loops).</li>
</ul>
</div>
</div>
<div class="section" id="notes-on-performance">
<h2>Notes on performance</h2>
<p>The most interesting question I was asked is what are the performance
implications of using an STL algorithm or Linq.</p>
<p>The default answer is, of course, you have to measure for your particular case!
Blanket statements cannot be made about performance, as there are many factors
involved: compiler, runtime, standard library, OS, architecture, whether code is
on a hot path or not, and so on and so forth.</p>
<p>Still, my recommendation is to use the library algorithms and, only if they
become the bottleneck (which in most cases shouldn&#8217;t happen), look into replacing
them with handcrafted code. Another thing to keep in mind is that standard
library authors know what they&#8217;re doing, so it&#8217;s very likely that library code is
already pretty well optimized. I ran a simple wall clock benchmark for 1M
iterations for some of the examples I used throughout the presentation (both the
handcrafted and the library versions), and in all cases the code leveraging
library functions ran slightly faster.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[*]</a></td><td>Cyclomatic complexity of this is actually higher when computed by looking
at basic blocks (eg. from Visual Studio&#8217;s <span class="docutils literal"><span class="pre">Analyze</span></span> menu), since the compiler
will automatically add a finally block to dispose of the Linq-returned
IEnumerables in case of exception. That being said, I prefer
compiler-generated complexity to developer-generated complexity.</td></tr>
</tbody>
</table>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../07/clean-code-part-2.html">Clean Code - Part 2</a></li>
            <li class="right"><a href="../../../2015/12/28/hello-world.html">Hello World</a> &raquo; </li>
        </ul><div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "vladris";    var disqus_identifier = "2016/01/04/clean-code-part-1";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://vladris.com/blog/rss">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
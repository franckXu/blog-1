<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Dependency Injection in C++ &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="(Ab)using Maps" href="../../04/24/abusing-maps.html" /><link rel="prev" title="Concepts and Modules" href="../../08/17/concepts-and-modules.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/disqus.js"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>July 06, 2016</span>
        </div>
    <div class="section" id="dependency-injection-in-c">
<h1>Dependency Injection in C++</h1>
<p>In this post, I will switch gears from functional C++ to object oriented C++ and
talk about dependency injection.</p>
<p>Let’s start with a simple example: take a <span class="docutils literal"><span class="pre">Car</span></span> class with a <span class="docutils literal"><span class="pre">Drive()</span></span>
method. Let’s say this class contains a <span class="docutils literal"><span class="pre">V8Engine</span></span> attribute with <span class="docutils literal"><span class="pre">Start()</span></span>
and <span class="docutils literal"><span class="pre">Stop()</span></span> methods. An initial implementation might look like this:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;V8Engine.h&quot;</span><span class="cp"></span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">&quot;V8Engine.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">V8Engine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;Car.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="dependency-injection-with-interfaces">
<h2>Dependency Injection with Interfaces</h2>
<p>In the above example, <span class="docutils literal"><span class="pre">Car</span></span> is tightly coupled to <span class="docutils literal"><span class="pre">V8Engine</span></span>, meaning we
can’t create a car without a concrete engine implementation. If we want the
ability to swap various engines or use a mock engine during testing, we could
reverse the dependency by creating an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and decoupling
<span class="docutils literal"><span class="pre">Car</span></span> from the concrete <span class="docutils literal"><span class="pre">V8Engine</span></span> implementation. This way, we only expose
an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and a factory function. <span class="docutils literal"><span class="pre">Car</span></span> can work against that:</p>
<p><em>IEngine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">();</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;IEngine.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* start the engine */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* stop the engine */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">&quot;IEngine.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;Car.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="notes">
<h2>Notes</h2>
<div class="section" id="a-note-on-headers">
<h3>A note on headers</h3>
<p>Headers simply get textually included in each compilation unit by the
<span class="docutils literal"><span class="pre">#include</span></span> directive. It is not mandatory to provide a header file for each
class declaration. If a class can be scoped to a single source file, then it
doesn’t need a header declaration (for example the <span class="docutils literal"><span class="pre">V8Engine</span></span> class above
does not need a V8Engine.h header corresponding to the V8Engine.cpp). It is also
a good idea to have public headers and internal headers: public headers contain
the public API surface and can be included by other parts of the system, while
internal headers are only used within the component and should not be included
by external code.</p>
<p>Default should be the least visible: try to keep everything inside the cpp file
(like V8Engine.cpp). If that is not enough, an internal header might do. A
declartion should be pulled into a public header only when external components
need to reference it.</p>
</div>
<div class="section" id="a-note-on-interfaces">
<h3>A note on interfaces</h3>
<p>It’s a good idea to declare a default virtual destructor: if a deriving type has
a destructor, it won’t get called if we store an upcast pointer to the interface
unless the interface declares a virtual destructor. Note a destructor does not
to be expicitly defined - compiler might generate a default one.</p>
<p>MSVC compiler provides a <span class="docutils literal"><span class="pre">__declspec(novtable)</span></span> <a class="footnote-reference" href="#id2" id="id1">[1]</a> custom attribute which
tells the compiler not to generate a vtable for pure abstract classes. This
reduces code size. Below is the <span class="docutils literal"><span class="pre">IEngine</span></span> declaration with this attribute:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">novtable</span><span class="p">)</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>I won’t include it in the code samples in this post, but it’s worth keeping in
mind when working with MSVC.</p>
</div>
<div class="section" id="a-note-on-factory-functions">
<h3>A note on factory functions</h3>
<p>When working with interfaces as opposed to concrete types, we use factory
functions to get object instances. Below is a possible naming convention, taking
object ownership into account:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">MakeFoo</span><span class="p">();</span>
<span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">GetFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>The first function, <span class="docutils literal"><span class="pre">MakeFoo</span></span>, returns a unique pointer, passing ownership to
the caller. Like in the example above, the <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> can be moved into the
object, which ends up owning it. Use a Make when each call creates a new
instance.</p>
<p>The second function implies there already exists an <span class="docutils literal"><span class="pre">IFoo</span></span> object which is
owned by someone else, with the guarantee that it will outlive the caller. In
that case, there is no need for pointers and we can simply return a reference to
the object. This can be used, for example, for singletons. Below is an example
of a singleton <span class="docutils literal"><span class="pre">Engine</span></span>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">UseEngine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The third function, <span class="docutils literal"><span class="pre">GetFoo</span></span>, implies shared ownership - we get an object that
other objects might hold a reference to, but we don’t have the lifetime
guarantee a singleton would give us, so we need to use a shared pointer to make
sure the object is kept alive long enough.</p>
</div>
</div>
<div class="section" id="mocking">
<h2>Mocking</h2>
<p>Since <span class="docutils literal"><span class="pre">Car</span></span> now works with an <span class="docutils literal"><span class="pre">IEngine</span></span> interface, in test code we can mock
the engine:</p>
<p><em>Test.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;Car.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span> <span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also expose <span class="docutils literal"><span class="pre">Car</span></span> as a simple interface, hiding its implementation
details, in which case we would end up with the following:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">&quot;IEngine.h&quot;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ICar.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would become:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ICar.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">car</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test ICar without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note this allows the caller to pass in any <span class="docutils literal"><span class="pre">IEngine</span></span>. We provide an
out-of-the-box <span class="docutils literal"><span class="pre">V8Engine</span></span> but other engines can be injected when <span class="docutils literal"><span class="pre">Car</span></span> gets
constructed. The headers IEngine.h and ICar.h are public per our above
defintion.</p>
<p>In general, it’s great if we can get the rest of the component code and unit
tests to work against the interface. Sometimes though we might need to know more
about the actual implementation inside our component, even if externally we only
expose an interface. In that case, we can add an internal Car.h header:</p>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">&quot;ICar.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em> becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;Car.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can include the internal header, and, while not necessarily recommended,
we can cast <span class="docutils literal"><span class="pre">ICar</span></span> to <span class="docutils literal"><span class="pre">Car</span></span> inside the component:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">icar</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">MakeV8Engine</span><span class="p">());</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">car</span><span class="p">);</span>
</pre></div>
</div>
<p>Another trick if needing access to internals (again, not something necessarily
recommended), is to make the unit test class testing <span class="docutils literal"><span class="pre">Car</span></span> a friend of the
<span class="docutils literal"><span class="pre">Car</span></span> class, in which case it can access its private members.</p>
<p>In summary, with this approach we are able to:</p>
<ul class="simple">
<li>Hide implementation details in the .cpp files</li>
<li>Work against abstract interfaces</li>
<li>Inject dependencies during object construction</li>
</ul>
</div>
<div class="section" id="dependecy-injection-with-templates">
<h2>Dependecy Injection with Templates</h2>
<p>An alternative to the above is to use templates. In this case, we would have to
provide the implementation inside the header file, as code needs to be available
when templates get instantiated:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;V8Engine.h&quot;</span><span class="cp"></span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note <span class="docutils literal"><span class="pre">Car</span></span> is implemented in the header and <span class="docutils literal"><span class="pre">V8Engine</span></span> is also a publicly
visible header. Now we can create an instance of <span class="docutils literal"><span class="pre">Car</span></span> like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;V8Engine.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;Car.h&quot;</span><span class="cp"></span>

<span class="p">...</span>

<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
</pre></div>
</div>
<p>Mocking the engine in test code would look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;Car.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">MockEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach we are able to:</p>
<ul class="simple">
<li>Inject dependencies during template instantiation</li>
<li>No need for virtual calls (note <span class="docutils literal"><span class="pre">TEngine</span></span> is not an interface, so calls can
be resolved at compile-time)</li>
<li><span class="docutils literal"><span class="pre">Car&lt;T&gt;</span></span> can be default-constructed</li>
</ul>
<p>A drawback here is we expose the implementation details of <span class="docutils literal"><span class="pre">Car</span></span> inside the
header file and we have to make this publicly visible.</p>
</div>
<div class="section" id="hybrid-approach">
<h2>Hybrid Approach</h2>
<p>We can use a hybrid approach if we don’t need an externally injected <span class="docutils literal"><span class="pre">Engine</span></span>.
Say our component provides a <span class="docutils literal"><span class="pre">V8Engine</span></span>, a <span class="docutils literal"><span class="pre">V6Engine</span></span>, and we have a
<span class="docutils literal"><span class="pre">MockEngine</span></span> used during testing. We have the same componentization
requirements but don’t need to expose all the details to consumers. In that case
we could have something like this:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
</pre></div>
</div>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">&quot;ICar.h&quot;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;Car.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;V8Engine.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;V6Engine.h&quot;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V6Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would remain the same as in the example above, where we worked against a
<span class="docutils literal"><span class="pre">Car</span></span> type (not an <span class="docutils literal"><span class="pre">ICar</span></span>) which we instantiate with a <span class="docutils literal"><span class="pre">MockEngine</span></span>.</p>
<p>With this approach:</p>
<ul class="simple">
<li>Our external API is an interface</li>
<li>Internally we still inject the dependency using a template</li>
</ul>
<p>With this approach, we do have an interface and virtual calls for <span class="docutils literal"><span class="pre">Car</span></span> but
not for <span class="docutils literal"><span class="pre">TEngine</span></span> types. One drawback with this approach is that consumers
cannot inject their own Engine type: we can only create cars with engines that
are known within our component.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We decoupled <span class="docutils literal"><span class="pre">Car</span></span> from <span class="docutils literal"><span class="pre">V8Engine</span></span> and looked at three ways of injecting
the dependency:</p>
<ul class="simple">
<li>Using interfaces, where dependency is injected at runtime during object
creation</li>
<li>Using templates, where dependency is injected at compile-time during template
instantiation</li>
<li>A hybrid approach which uses templates internally but exposes only interfaces
publicly</li>
</ul>
<p>Each of these approaches has pros and cons, the tradeoffs mostly being around
encapsulation (how much of the component code we expose publicly), runtime
(templates are instantiated at compile-time so no virtual calls etc.), type
constraints (with templates we don’t require engines to implement a particular
<span class="docutils literal"><span class="pre">IEngine</span></span> interface), and flexibility (with the hybrid approach we can’t
inject an external engine, we can only use what the component has available
internally).</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For more details on <span class="docutils literal"><span class="pre">novtable</span></span>, see <a class="reference external" href="https://msdn.microsoft.com/en-us/library/k13k85ky.aspx">MSDN</a>.</td></tr>
</tbody>
</table>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../../08/17/concepts-and-modules.html">Concepts and Modules</a></li>
            <li class="right"><a href="../../04/24/abusing-maps.html">(Ab)using Maps</a> &raquo; </li>
        </ul><div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "vladris";    var disqus_identifier = "2016/07/06/dependency-injection-in-c";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
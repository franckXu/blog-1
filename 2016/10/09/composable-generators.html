<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Composable Generators &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Concepts and Modules" href="../../08/17/concepts-and-modules.html" /><link rel="prev" title="Notes on Types" href="../16/notes-on-types.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/disqus.js"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>October 09, 2016</span>
        </div>
    <div class="section" id="composable-generators">
<h1>Composable Generators</h1>
<p>One of the most exciting features coming to C++ are coroutines. In this post,
I will give a quick overview of how they are used today in C# to support
generators and go over a few possible ways to bring the composability of Linq to
the C++ world.</p>
<div class="section" id="generators-in-c">
<h2>Generators in C#</h2>
<p>I will not go into the nitty-gritty details of coroutines, but in short, they
are resumable functions – functions that can be suspended/resumed. Coroutines
enable lazy evaluation, with two major applications: easy to read
multi-threading (with async/await syntax in C#) and generators (with yield
return syntax in C#). In this post, I will focus on generators and how they
compose.</p>
<p>I will start with a C# example since Linq is, in my opinion, the golden
standard for creating a processing pipeline, at least for non-functional
languages. Linq is implemented as a set of extension methods for
<span class="docutils literal"><span class="pre">IEnumerable</span></span>, and enables some very readable chaining of operations. For
example, let’s get the first 100 natural numbers, filter out the odds, then
square the remaining list.</p>
<p>The wrong way of doing this would be something like:</p>
<div class="highlight-c#"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetNumbers</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">GetNumbers</span><span class="p">();</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main problem with the above is that all the logic is inlined into
<span class="docutils literal"><span class="pre">GetNumbers</span></span>, so things don’t decompose very well – for example what if we
also want a function that squares the odd numbers? We would either duplicate the
looping and squaring logic, or make the predicate we use to filter out things an
input to the function. Same goes for the iterating logic and for the squaring.
Luckily, we have Linq, which does just that:</p>
<div class="highlight-c#"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span>
        <span class="n">Enumerable</span><span class="p">.</span><span class="n">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">).</span>
        <span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">).</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To illustrate the magic of generators, instead of relying on
<span class="docutils literal"><span class="pre">Enumerable.Range</span></span>, let’s introduce a function that generates numbers
forever:</p>
<div class="highlight-c#"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">Count</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our code would then become:</p>
<div class="highlight-c#"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span>
        <span class="n">Count</span><span class="p">().</span>
        <span class="n">Take</span><span class="p">(</span><span class="m">100</span><span class="p">).</span>
        <span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">).</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While not strictly necessary in this particular case, infinite generators cannot
exist without lazy evaluation, a feature of many functional languages. Lazy
evaluation has some very practical applications as it allows processing of data
as it becomes available, instead of waiting for everything to be ready before
moving on to the next step. While the 100 natural numbers example might not
sound so useful, imagine rendering frames in a streaming video as they arrive
over the network. Linq is great because it provides a clean separation between
the generic algorithms (<span class="docutils literal"><span class="pre">Where</span></span>, <span class="docutils literal"><span class="pre">Select</span></span> etc.) and the problem-specific
operations which are passed in as arguments. Linq operations also compose well,
so they can be chained together to form pipelines.</p>
</div>
<div class="section" id="id1">
<h2>Generators in C++</h2>
<p>While coroutines haven’t made it into the C++17 standard itself, they are coming
as a technical specification, with MSVC already supporting them (code samples
below compile with VS 2015 Update 3). The main syntax additions are the new
<span class="docutils literal"><span class="pre">co_await</span></span>, <span class="docutils literal"><span class="pre">co_return</span></span>, and <span class="docutils literal"><span class="pre">co_yield</span></span> keywords. The first two are used
for creating and awaiting tasks (which I won’t cover in this post), while
<span class="docutils literal"><span class="pre">co_yield</span></span> is used in generators.</p>
<p>Here is a lazy counter in C++:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">count_to</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">count_to</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the return type of <span class="docutils literal"><span class="pre">count_to</span></span> is a <span class="docutils literal"><span class="pre">generator&lt;int&gt;</span></span> (currently in the
experimental namespace). <span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span> is the type implicitly created by the
compiler when encountering a <span class="docutils literal"><span class="pre">co_yield</span></span>. Also worth noting that range-based
for loops work over generators, as they expose <span class="docutils literal"><span class="pre">begin()</span></span> and <span class="docutils literal"><span class="pre">end()</span></span>
methods. The type annotation for the <span class="docutils literal"><span class="pre">count_to</span></span> return type above is not
really needed, I added it just to clarify what the complier will generate in
this case.</p>
<p><span class="docutils literal"><span class="pre">generator</span></span> itself is pretty bare-boned, it doesn’t provide all the algorithms
that Linq adds to <span class="docutils literal"><span class="pre">IEnumerable</span></span>. So if we wanted to do something like the
above pipeline, we would need some algorithms. Here’s one way of implementing
some of them:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">count</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here I switched from Linq’s <span class="docutils literal"><span class="pre">Select</span></span> and <span class="docutils literal"><span class="pre">Where</span></span> to the more commonly used
<span class="docutils literal"><span class="pre">map</span></span> and <span class="docutils literal"><span class="pre">filter</span></span>, but they effectively implement the same thing. While
this implementation is pretty-straight forward, it doesn’t compose well at all:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">map</span><span class="p">(</span>
            <span class="n">filter</span><span class="p">(</span>
                <span class="n">take_n</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="mi">100</span><span class="p">),</span>
                <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}),</span>
            <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Definitely not like the nice chaining of Linq. So what gives? Why doesn’t
generator come out-of-the-box with <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">map</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> and all the
other useful algorithms? Well, according to the
<a class="reference external" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>,
these algorithms don’t belong in <span class="docutils literal"><span class="pre">generator</span></span> – <span class="docutils literal"><span class="pre">generator</span></span> encapsulates the
lazy evaluation of the coroutine, it wouldn’t be the right place for algorithms.
It’s also worth noting that Linq methods are not part of <span class="docutils literal"><span class="pre">IEnumerable</span></span>, they
are <a class="reference external" href="https://msdn.microsoft.com/en-us/library/bb383977.aspx">extension methods</a>.
C++ doesn’t support extension methods, so we would need a slightly different
design to achieve better chaining.</p>
</div>
<div class="section" id="decorator">
<h2>Decorator</h2>
<p>The next idea comes from pure OOP - let’s create a decorator over <span class="docutils literal"><span class="pre">generator</span></span>
that exposes these algorithms. First, let’s declare our decorator as
<span class="docutils literal"><span class="pre">enumerable&lt;T&gt;</span></span> and change our algorithms to work with the new type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enumerable</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation looks pretty much like before, except that now we are getting
and returning <span class="docutils literal"><span class="pre">enumerable&lt;T&gt;</span></span> instead of <span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span>. In this case the
type annotation is mandatory, as by default the complier would create a
<span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span>.</p>
<p>We can then implement our enumerable to wrap a generator and expose member
functions which forward to the above algorithms:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enumerable</span>
<span class="p">{</span>
    <span class="c1">// Needed by compiler to create enumerable from co_yield</span>
    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>

    <span class="n">enumerable</span><span class="p">(</span><span class="n">promise_type</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">)</span> <span class="o">:</span> <span class="n">_gen</span><span class="p">(</span><span class="n">promise</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">enumerable</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_gen</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>

    <span class="n">enumerable</span><span class="p">(</span><span class="k">const</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_gen</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">auto</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_gen</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">take_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">pred</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_gen</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A few things to note: we declare a <span class="docutils literal"><span class="pre">promise_type</span></span> and have a constructor which
takes a promise as an argument. This is required by the compiler when creating
the object on <span class="docutils literal"><span class="pre">co_yield</span></span>. We follow the same semantics as generator, since
that is what we are wrapping – support only move-constructor, no
copy-constructor. All the member algorithms do a destructive move on <span class="docutils literal"><span class="pre">*this</span></span>.
This is intentional, as once we iterate over the encapsulated generator, it is
no longer valid. Since we don’t expose a copy-constructor, we move out of
<span class="docutils literal"><span class="pre">*this</span></span> when passing the generator to an algorithm. For completeness, we can
also provide a function which converts from a generator to an enumerable:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">to_enumerable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, and we can now compose algorithms by chaining the calls:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">to_enumerable</span><span class="p">(</span><span class="n">count</span><span class="p">()).</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}).</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Still, it is not ideal – first, we need to explicitly tell the compiler
everywhere to return our type with <span class="docutils literal"><span class="pre">co_yield</span></span> instead of the default
generator, and we need to handle conversions to and from the standard library
generator. The enumerable algorithms compose well, but we’ll have trouble
composing with functions that work with generators. Also, having a huge class
consisting solely of algorithms is not the best design, especially in a language
where free functions are first class citizens.</p>
</div>
<div class="section" id="pipe-operator">
<h2>Pipe Operator</h2>
<p>An alternative approach, which the
<a class="reference external" href="http://www.boost.org/doc/libs/1_62_0/libs/range/doc/html/index.html">Boost Ranges library</a>
takes, is to overload <span class="docutils literal"><span class="pre">|</span></span>, the “pipe” operator, so we can compose our calls
like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">count</span><span class="p">()</span> <span class="o">|</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">|</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span> <span class="o">|</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One way we can get this working is to first create a type that wraps an
algorithm and an <span class="docutils literal"><span class="pre">operator|</span></span> implementation between a lhs <span class="docutils literal"><span class="pre">generator</span></span> and a
rhs of our type:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">filter_t</span>
<span class="p">{</span>
    <span class="n">filter_t</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Predicate</span> <span class="n">_pred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <span class="docutils literal"><span class="pre">filter_t</span></span> holds the <span class="docutils literal"><span class="pre">Predicate</span></span> we want to use, and <span class="docutils literal"><span class="pre">operator|</span></span>
applies it on the given <span class="docutils literal"><span class="pre">generator</span></span>. This works, but we wouldn’t be able to
instantiate <span class="docutils literal"><span class="pre">filter_t</span></span> with a lambda like in the above chaining example
without specifying the Predicate type in the call. If we want to leverage type
deduction, we can create a simple helper function that creates a <span class="docutils literal"><span class="pre">filter_t</span></span>
from a given argument:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this we can call <span class="docutils literal"><span class="pre">|</span> <span class="pre">filter(/*</span> <span class="pre">predicate</span> <span class="pre">*/)</span></span> on a generator and get back
a filtered generator. Full implementation for <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> and <span class="docutils literal"><span class="pre">map</span></span>
would be:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">take_n_t</span>
<span class="p">{</span>
    <span class="n">take_n_t</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">_n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">_n</span><span class="p">)</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">_n</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">take_n_t</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">take_n_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">filter_t</span>
<span class="p">{</span>
    <span class="n">filter_t</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Predicate</span> <span class="n">_pred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">map_t</span>
<span class="p">{</span>
    <span class="n">map_t</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="o">:</span> <span class="n">_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">_op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">BinaryOperation</span> <span class="n">_op</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">map_t</span><span class="o">&lt;</span><span class="n">BinaryOperation</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">map_t</span><span class="o">&lt;</span><span class="n">BinaryOperation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach, we can apply our algorithms over a generator without having
to introduce a different type. They also compose very nicely, the only slightly
odd thing being using the <span class="docutils literal"><span class="pre">|</span></span> operator (though as I mentioned, there is a
precedent for this in Boost and chances are it might show up in other places in
the future).</p>
</div>
<div class="section" id="unified-call-syntax">
<h2>Unified Call Syntax</h2>
<p>One thing that would’ve made things even easier but unfortunately was not
approved for C++17 is <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4165.pdf">unified call syntax</a>.
At a high level, unified call syntax would make the compiler try to resolve
<span class="docutils literal"><span class="pre">x.f()</span></span> to <span class="docutils literal"><span class="pre">f(x)</span></span> if <span class="docutils literal"><span class="pre">decltype(x)</span></span> doesn’t have an <span class="docutils literal"><span class="pre">f()</span></span> member function
but there is a free function <span class="docutils literal"><span class="pre">f(decltype(x))</span></span>. Similarly, if no
<span class="docutils literal"><span class="pre">f(decltype(x))</span></span> exists but <span class="docutils literal"><span class="pre">decltype(x)</span></span> has a member function <span class="docutils literal"><span class="pre">f()</span></span>,
<span class="docutils literal"><span class="pre">f(x)</span></span> would resolve to the member function call <span class="docutils literal"><span class="pre">x.f()</span></span>.</p>
<p>If it’s not obvious, unified call syntax would allow us to easily create
extension methods. We would be able to revert our algorithm code to the first
version:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But now this becomes very composable as calling <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> or
<span class="docutils literal"><span class="pre">map</span></span> on a generator would resolve to the free functions if the <span class="docutils literal"><span class="pre">generator</span></span>
itself does not have them as members:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">count</span><span class="p">().</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}).</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above currently does not compile but it should (disclaimer: slight tweaks
might be required) if unified call syntax becomes part of the standard.</p>
</div>
<div class="section" id="in-summary">
<h2>In Summary</h2>
<p>We went over a couple of alternatives to implement some common algorithms over
C++ generators with a focus on composability:</p>
<ul class="simple">
<li>Stand-alone functions are simple but don’t compose very well</li>
<li>Using a decorator works, but is not ideal from a design point of view and not
very idiomatic</li>
<li>Using the pipe operator for chaining and helper types for the algorithms is
the best approach today</li>
<li>Unified call syntax would simplify things a lot, enabling a mechanism to
implement these algorithms as extension methods</li>
</ul>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../16/notes-on-types.html">Notes on Types</a></li>
            <li class="right"><a href="../../08/17/concepts-and-modules.html">Concepts and Modules</a> &raquo; </li>
        </ul><div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "vladris";    var disqus_identifier = "2016/10/09/composable-generators";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
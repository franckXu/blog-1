<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Notes on Types &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="Composable Generators" href="../09/composable-generators.html" /><link rel="prev" title="Notes on Error Handling" href="../../12/03/notes-on-error-handling.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>October 16, 2016</span>
        </div>
    <div class="section" id="notes-on-types">
<h1>Notes on Types</h1>
<div class="section" id="type-systems">
<h2>Type Systems</h2>
<p>A good type system can eliminate entire categories of errors in a program and
simply make invalid code not compile. Before digging into types, below are a few
common distinctions between the type systems of various programming languages:</p>
<div class="section" id="dynamic-typing-vs-static-typing">
<h3>Dynamic Typing vs Static Typing</h3>
<p>In a statically typed language, the types are determined at compile time so if a
function was declared as only accepting a certain type <span class="docutils literal"><span class="pre">T</span></span> but we attempt to
pass it an unrelated type <span class="docutils literal"><span class="pre">U</span></span>, the program is considered invalid. This is
invalid C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">sqr</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">sqr</span><span class="p">(</span><span class="s">&quot;not an int&quot;</span><span class="p">);</span> <span class="c1">// does not compile</span>
</pre></div>
</div>
<p>On the other hand, in a dynamically typed language, we do not perform any
compile time checks and, if the data we get is of an unexpected type, we treat
it as a runtime error. Below is a Python function that squares a number:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sqr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
<span class="o">...</span>
<span class="n">sqr</span><span class="p">(</span><span class="s2">&quot;not an int&quot;</span><span class="p">)</span>
<span class="c1"># runs but fails with TypeError: unsupported operand type(s)</span>
<span class="c1"># for ** or pow(): &#39;str&#39; and &#39;int&#39;</span>
</pre></div>
</div>
<p>Some of the interesting features of dynamic languages are <em>duck typing</em> (“if it
walks like a duck, and it quacks like a duck…”) and <em>monkey patching</em>. Duck
typing means that accessing a member of an object works as long as that object
has such a member, regardless of the type of the object. In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>

<span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Foo</span><span class="p">(),</span> <span class="n">Bar</span><span class="p">()]]</span> <span class="c1"># prints &quot;foo&quot; and &quot;bar&quot;</span>
</pre></div>
</div>
<p>This can’t work in a statically typed language where, at the bare minimum, we
would have to add some form of constraint for the types in the list to ensure
they contain a <span class="docutils literal"><span class="pre">func()</span></span> method we can call.</p>
<p>Monkey patching refers to the ability to change the structure of an object at
runtime. For example we can swap the <span class="docutils literal"><span class="pre">func</span></span> method from an instance of <span class="docutils literal"><span class="pre">foo</span></span>
with another function like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func_bar</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="c1"># prints &quot;foo&quot;</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func_bar</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="c1"># prints &quot;bar&quot;</span>
</pre></div>
</div>
<p>These are useful capabilities, but the tradeoff is a whole class of type errors
which a statically typed language would’ve caught.</p>
<p>As a side note, the fact that dynamic languages don’t need to specify types
makes them more terse. That being said, the
<a class="reference external" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner algorithm W</a>
can infer the types of a program in linear time with respect to the source size.
So while Python is starting to support type annotations for better static
analysis and TypeScript provides a way for writing type-safe JavaScript, C++ has
better and better type inference, while in Haskell (which has one of the
strongest static type systems) type annotations are mostly optional.</p>
</div>
<div class="section" id="strong-typing-vs-weak-typing">
<h3>Strong Typing vs Weak Typing</h3>
<p>At a high level, a strongly typed language does not implicitly convert between
unrelated types. This is good in most situations as implicit conversions are
often meaningless or have surprising effects - for example, adding a number to
a list of characters. This can either result in runtime errors or garbage data.
In contrast, a strongly typed language will not accept code that attempts to do
this.</p>
<p>In Python, which is strongly typed, this doesn’t work:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span> <span class="c1"># foo is &quot;foo&quot;</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="s2">&quot; bar&quot;</span> <span class="c1"># foo is &quot;foo bar&quot;</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1"># TypeError: Can&#39;t convert &#39;int&#39; object to str implicitly</span>
</pre></div>
</div>
<p>It works just fine in JavaScript though:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">;</span> <span class="c1">// foo is &quot;foo&quot;</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">+</span> <span class="s2">&quot; bar&quot;</span><span class="p">;</span> <span class="c1">// foo is &quot;foo bar&quot;</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">+</span> <span class="mf">5</span><span class="p">;</span> <span class="c1">// foo is &quot;foo bar5&quot;</span>
</pre></div>
</div>
<p>Note type strength is not an either/or - C++, while considered strongly typed,
still allows several implicit casts between types (eg. pointer to bool). Some
languages are more strict about converting between types implicitly, others less
so.</p>
</div>
<div class="section" id="dynamic-polymorphism-vs-static-polymorphism">
<h3>Dynamic Polymorphism vs Static Polymorphism</h3>
<p>Another difference to note is between static and dynamic polymorphism. Dynamic
polymorphism happens at runtime, when calling a function on a base type gets
resolved to the actual function of the deriving type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">foo</span> <span class="o">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;foo&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">bar</span> <span class="o">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bar&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">call_func</span><span class="p">(</span><span class="n">base</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">foo</span><span class="p">{});</span> <span class="c1">// prints &quot;foo&quot;</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">bar</span><span class="p">{});</span> <span class="c1">// prints &quot;bar&quot;</span>
</pre></div>
</div>
<p>In the above case, we effectively have a single function <span class="docutils literal"><span class="pre">call_func</span></span> which
takes a reference to a <span class="docutils literal"><span class="pre">base</span></span> struct. The compiler generates a v-table for
<span class="docutils literal"><span class="pre">struct</span> <span class="pre">base</span></span> and a call to <span class="docutils literal"><span class="pre">func()</span></span> on <span class="docutils literal"><span class="pre">base</span></span> involves a v-table jump to
the actual implementation of the function, which is different between the
inheriting types <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span>.</p>
<p>Contrast this with the static alternative:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">foo</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;foo&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">bar</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bar&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">call_func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">foo</span><span class="p">{});</span> <span class="c1">// prints &quot;foo&quot;</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">bar</span><span class="p">{});</span> <span class="c1">// prints &quot;bar&quot;</span>
</pre></div>
</div>
<p>In this case there is no relationship between <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span> and no v-table
is needed. On the other hand, we no longer have a single <span class="docutils literal"><span class="pre">call_func</span></span>, we have
a templated function which is instantiated for both <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span> types.
This is all done at compile-time, the advantage being faster code, the drawback
being compiler needs to be aware of all the types involved - we can no longer
“inject” types implementing an interface at runtime. When calling <span class="docutils literal"><span class="pre">call_func</span></span>,
we need to have both the definition of the function and the declaration of the
type we’re passing in visible.</p>
</div>
</div>
<div class="section" id="types">
<h2>Types</h2>
<p>During the rest of this post, I will talk about types in the context of a
statically and strongly typed language, with a focus on static polymorphism.
This pushes as much as possible of the type checking to the compilation stage,
so many of the runtime issues of less strict languages become invalid syntax.</p>
<p>I will focus on C++ and cover some of the new C++17 feature which enable or make
some of these concepts easier to work with. That being said, since this post
focuses on types, I will also provide examples in Haskell, as Haskell can
express these concepts much more succinctly.</p>
<div class="section" id="type-basics">
<h3>Type Basics</h3>
<p>Let’s start with the definition of a type: <em>a type represents the set of
possible values</em>. For example, the C++ type <span class="docutils literal"><span class="pre">uint8_t</span></span> represents the set of
integers from 0 to 255. Effectively this means that a variable of a given type
can only have values from within that set.</p>
</div>
<div class="section" id="interesting-types">
<h3>Interesting Types</h3>
<p>Since we defined a type as a set of possible values, we can talk about the
cardinality of a type, in other words the number of values in the set. Based on
cardinality, there are a few interesting classes of types to talk about:</p>
</div>
<div class="section" id="empty-type">
<h3>Empty Type</h3>
<p>The first interesting type to talk about is the type that represents the empty
set, with <span class="docutils literal"><span class="pre">|T|</span> <span class="pre">=</span> <span class="pre">0</span></span>.</p>
<p>In Haskell, this type is named <span class="docutils literal"><span class="pre">Void</span></span>. Since Haskell is a functional language,
all functions must return a value, so it does not make sense to have a function
that returns <span class="docutils literal"><span class="pre">Void</span></span> - the same way it doesn’t make sense to define a
mathematical function with the empty set as its codomain. We do have an
<span class="docutils literal"><span class="pre">absurd</span></span> function though, which maps the empty set to any value:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">absurd</span> <span class="ow">::</span> <span class="kt">Void</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>This function cannot be called though.</p>
<p>In C++, the absence of a value is represented as the <span class="docutils literal"><span class="pre">void</span></span> type. Since C++ is
not purely functional, we can define functions that don’t return anything. We
can even say that a function does not take any arguments by putting a <span class="docutils literal"><span class="pre">void</span></span>
between the parenthesis:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the equivalent of:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span>
</pre></div>
</div>
<p>Note though that we cannot have a <em>real</em> argument of type <span class="docutils literal"><span class="pre">void</span></span>, that is a
compile error as it doesn’t make any sense - we would be mandating the function
takes a value from the empty set. So we can say <span class="docutils literal"><span class="pre">foo(void)</span></span> but not
<span class="docutils literal"><span class="pre">foo(void</span> <span class="pre">arg)</span></span>, or even <span class="docutils literal"><span class="pre">foo(int</span> <span class="pre">arg,</span> <span class="pre">void)</span></span>.</p>
</div>
<div class="section" id="unit-type">
<h3>Unit Type</h3>
<p>The next interesting class consists of types with cardinality 1. A type <span class="docutils literal"><span class="pre">T</span></span>
with <span class="docutils literal"><span class="pre">|T|</span> <span class="pre">=</span> <span class="pre">1</span></span> is called a <em>unit</em> or <em>singleton type</em>. A variable of such a
type can only ever have a single possible value. In Haskell, the anonymous
representation is the empty tuple <span class="docutils literal"><span class="pre">()</span></span>. Here is an example of a function that
maps anything to this type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">unit</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">unit</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Of course, we can declare our own singleton types. Below is a custom
<span class="docutils literal"><span class="pre">Singleton</span></span> type and an equivalent unit function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Singleton</span> <span class="ow">=</span> <span class="kt">Singleton</span>
<span class="nf">unit</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Singleton</span>
<span class="nf">unit</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Singleton</span>
</pre></div>
</div>
<p>In C++, the anonymous representation of a singleton is an empty <span class="docutils literal"><span class="pre">std::tuple</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As can be seen from the above, Haskell makes it easier to define a function that
takes an argument of any type, as it provides syntactic sugar for type
parameters (<span class="docutils literal"><span class="pre">a</span></span> in our example). In C++, the equivalent declaration involves a
template, but they boil down to the same thing. The non-anonymous C++
representation is a struct which doesn’t contain anything. All instances of such
a struct are equivalent:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">singleton</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">singleton</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sum-types">
<h3>Sum Types</h3>
<p>Here, things get a bit more interesting: a <span class="docutils literal"><span class="pre">sum</span> <span class="pre">type</span></span> is a type which can
represent a value from any of the types it sums. So given type <span class="docutils literal"><span class="pre">A</span></span> and type
<span class="docutils literal"><span class="pre">B</span></span>, the type <span class="docutils literal"><span class="pre">S</span></span> summing up <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> is <span class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:</span> <span class="pre">i</span> <span class="pre">∈</span> <span class="pre">A</span> <span class="pre">U</span> <span class="pre">B</span> <span class="pre">}</span></span>.
So a variable of type <span class="docutils literal"><span class="pre">S</span></span> could have any value in <span class="docutils literal"><span class="pre">A</span></span> or any value in <span class="docutils literal"><span class="pre">B</span></span>.
<span class="docutils literal"><span class="pre">S</span></span> is called a sum type because its cardinality is the sum of the
cardinalities of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span>, <span class="docutils literal"><span class="pre">|S|</span> <span class="pre">=</span> <span class="pre">|A|</span> <span class="pre">+</span> <span class="pre">|B|</span></span>.</p>
<p>Sum types are great, because they allow us to build up more complex types from
simpler ones. Once we have unit types, we can build up more complex types out
of them by summing them. For example, a boolean type which can be either
<span class="docutils literal"><span class="pre">true</span></span> or <span class="docutils literal"><span class="pre">false</span></span> can be thought of as the sum of the singleton <span class="docutils literal"><span class="pre">true</span></span>
type and the singleton <span class="docutils literal"><span class="pre">false</span></span> type. In Haskell, a boolean is defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">True</span> <span class="o">|</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Similarly, a <span class="docutils literal"><span class="pre">Weekday</span></span> type can be defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Weekday</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
</pre></div>
</div>
<p>Theoretically, numerical types could also be defined as huge sum types of every
possible value they can represent. Of course, this is impractical, but we can
reason about them the same way we reason about other sum types, we don’t have to
treat them as a special case.</p>
<p>In C++, an equivalent of the above is an <span class="docutils literal"><span class="pre">enum</span> <span class="pre">class</span></span>. <span class="docutils literal"><span class="pre">bool</span></span> is a built-in
type with special syntax, but we could define an equivalent as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Boolean</span>
<span class="p">{</span>
    <span class="n">True</span><span class="p">,</span>
    <span class="n">False</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It’s easy to see how a <span class="docutils literal"><span class="pre">Weekday</span></span> definition would look like. Things get more
interesting when we throw type parameters into the mix. In Haskell, we have the
<span class="docutils literal"><span class="pre">Either</span></span> type, which is declared as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</pre></div>
</div>
<p>An instance of this could be either a <span class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></span>, where <span class="docutils literal"><span class="pre">a</span></span> is a type itself,
which means it can be any of the values of <span class="docutils literal"><span class="pre">a</span></span>, or it can be <span class="docutils literal"><span class="pre">Right</span> <span class="pre">b</span></span>, with
any of the values of <span class="docutils literal"><span class="pre">b</span></span>. In Haskell we use pattern-matching to operate on
such a type, so we can declare a simple function that tells us whether we were
given a <span class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></span> like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">isLeft</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isLeft</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isLeft</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>This might not look like much, but of course we can compose more complex
functions. For example, say we have a function <span class="docutils literal"><span class="pre">foo</span></span> that takes an <span class="docutils literal"><span class="pre">a</span></span> and
returns an <span class="docutils literal"><span class="pre">a</span></span>, a function <span class="docutils literal"><span class="pre">bar</span></span> that takes a <span class="docutils literal"><span class="pre">b</span></span> and returns a <span class="docutils literal"><span class="pre">b</span></span>. We
can then write a <span class="docutils literal"><span class="pre">transform</span></span> function which takes an <span class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></span> and,
depending on the contained type, it applies the appropriate function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Implementation of foo and bar not provided in this example</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">bar</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">bar</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>This is way beyond the capabilities of a C++ <span class="docutils literal"><span class="pre">enum</span> <span class="pre">class</span></span>. The old way of
implementing something like this in C++ was using a union and a tag enum to keep
track of which is the actual type we’re working with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declaration of A and B not provided in this example</span>
<span class="k">struct</span> <span class="nc">A</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Either</span>
<span class="p">{</span>
    <span class="n">Either</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ab</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">::</span><span class="n">isA</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Either</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ab</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">::</span><span class="n">isB</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">A</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">B</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">ab</span><span class="p">;</span>

    <span class="k">enum</span> <span class="k">class</span> <span class="nc">tag</span>
    <span class="p">{</span>
        <span class="n">isA</span><span class="p">,</span>
        <span class="n">isB</span>
    <span class="p">}</span> <span class="n">tag</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Our implementation of transform would look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Implementation of A and B not provided in this example</span>
<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">B</span> <span class="nf">bar</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>

<span class="n">Either</span> <span class="nf">transform</span><span class="p">(</span><span class="n">Either</span> <span class="n">either</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">Either</span><span class="o">::</span><span class="n">tag</span><span class="o">::</span><span class="nl">isA</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">ab</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">Either</span><span class="o">::</span><span class="n">tag</span><span class="o">::</span><span class="nl">isB</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bar</span><span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">ab</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our <span class="docutils literal"><span class="pre">Either</span></span> type definition is obviously much more verbose than what we had
in Haskell, and it doesn’t even support type parameters - at this point it only
works with <span class="docutils literal"><span class="pre">struct</span> <span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">struct</span> <span class="pre">B</span></span>, while the Haskell version works for
any <span class="docutils literal"><span class="pre">a</span></span> and <span class="docutils literal"><span class="pre">b</span></span> types. The other major problem is that, while unions provide
efficient storage for different types (the size of the union is the size of the
maximum contained type), it is up to the implementer to make sure we don’t try
to read an <span class="docutils literal"><span class="pre">A</span></span> as a <span class="docutils literal"><span class="pre">B</span></span> or vice-versa. That means we need to keep our tag in
sync with what we put in the type and respect it when accessing the value of the
union.</p>
<p>C++17 introduces a better, safer, parameterized type for this: <span class="docutils literal"><span class="pre">std::variant</span></span>.
Variant takes any number of types as template arguments and stores an instance
of any one of those types. Using variant, we can re-write the above as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">either</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">([](</span><span class="k">auto</span> <span class="n">e</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
    <span class="p">},</span> <span class="n">either</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a lot of new syntax, so let’s break it down: <span class="docutils literal"><span class="pre">std::variant&lt;A,</span> <span class="pre">B&gt;</span></span> is
the new C++17 sum type. In this case, we specify it holds either <span class="docutils literal"><span class="pre">A</span></span> or <span class="docutils literal"><span class="pre">B</span></span>
(but it can hold an arbitrary number of types).</p>
<p><span class="docutils literal"><span class="pre">std::visit</span></span> is a function that applies the visitor function given as its
first argument to the variants given as its subsequent arguments. In our
example, this effectively expands to applying the lambda to
<span class="docutils literal"><span class="pre">std::get&lt;0&gt;(either)</span></span> and <span class="docutils literal"><span class="pre">std::get&lt;1&gt;(either)</span></span>.</p>
<p><span class="docutils literal"><span class="pre">if</span> <span class="pre">constexpr</span></span> is also a new C++17 construct which evaluates the if expression
at compile time and discards the else branch from the final object code. So in
this example, we determine at compile time whether the type we are being called
with is <span class="docutils literal"><span class="pre">A</span></span> or <span class="docutils literal"><span class="pre">B</span></span> and apply the correct function based on that. Something
very similar can be achieved with templates and <span class="docutils literal"><span class="pre">enable_if</span></span>, but this syntax
makes for more readable code.</p>
<p>Note that with this version we can simply prepend a <span class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;typename</span> <span class="pre">A,</span>
<span class="pre">typename</span> <span class="pre">B&gt;</span></span> and make the whole function generic, as in the Haskell example. It
doesn’t read as pretty (because we don’t have good pattern matching syntax in
the language), but this is the new, type safe way of implementing and working
with sum types, which is a major improvement.</p>
</div>
<div class="section" id="product-types">
<h3>Product Types</h3>
<p>With sum types out of the way, the remaining interesting category is that of
<em>product types</em>. Product types combine the values of several other types into
one. For types <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span>, we have <span class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">(a,</span> <span class="pre">b)</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">∈</span> <span class="pre">A,</span> <span class="pre">b</span> <span class="pre">∈</span> <span class="pre">B</span> <span class="pre">}</span></span>, so
<span class="docutils literal"><span class="pre">|P|</span> <span class="pre">=</span> <span class="pre">|A|</span> <span class="pre">x</span> <span class="pre">|B|</span></span>.</p>
<p>In Haskell, the anonymous version of product types is represented by tuples,
while the named version is represented by records. An example of a <span class="docutils literal"><span class="pre">perimeter</span></span>
function which computes the perimeter of a rectangle defined by two points,
where each point is a tuple of numbers:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">perimeter</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">n</span>
<span class="nf">perimeter</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span>
</pre></div>
</div>
<p>The named version would declare a <span class="docutils literal"><span class="pre">Point</span></span> type with <span class="docutils literal"><span class="pre">Int</span></span> coordinates and
use that instead:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="nf">perimeter</span> <span class="ow">::</span> <span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">perimeter</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span>
</pre></div>
</div>
<p>The C++ equivalents are <span class="docutils literal"><span class="pre">std::tuple</span></span> for anonymous product types and
<span class="docutils literal"><span class="pre">struct</span></span> for named types:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Anonymous</span>
<span class="kt">int</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span>
        <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// Named</span>
<span class="k">struct</span> <span class="nc">point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">point</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While sum types allow us to express values from multiple types into one, product
types allow us to express values from several types together. Empty, unit, sum,
and product types are the building blocks of a type system.</p>
</div>
<div class="section" id="bonus-optional-types">
<h3>Bonus: Optional Types</h3>
<p>An optional type is a type that can hold any of the values of another type, or
not hold any value, which is usually represented as a singleton. So an optional
is effectively a sum type between a given type and a singleton representing
“doesn’t hold a value”. In other words, the cardinality of an optional for a
type <span class="docutils literal"><span class="pre">T</span></span> is <span class="docutils literal"><span class="pre">|O|</span> <span class="pre">=</span> <span class="pre">|T|</span> <span class="pre">+</span> <span class="pre">1</span></span>.</p>
<p>In Haskell, an optional is the famous <span class="docutils literal"><span class="pre">Maybe</span></span> type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>A function that operates on <span class="docutils literal"><span class="pre">Maybe</span></span> could say “only apply <span class="docutils literal"><span class="pre">foo</span></span> if the
optional contains an <span class="docutils literal"><span class="pre">a</span></span>”:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Implementation of foo not provided in this example</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">transform</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>The new C++17 equivalent is the <span class="docutils literal"><span class="pre">optional</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Implementation of foo not provided in this example</span>
<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">nullopt</span> <span class="o">?</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">nullopt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This might read a bit like the pointer implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="o">*</span> <span class="nf">transform</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">?</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a key difference though: the type contained in the optional is part of
the object, so it is not allocated dynamically the way we would allocate a
pointer. <span class="docutils literal"><span class="pre">nullopt</span></span> is a helper object of the singleton type <span class="docutils literal"><span class="pre">nullopt_t</span></span>.</p>
<p>Types are important because a big part of programming effectively consits of
designing and composing types. Having a good understanding of the fundamentals
leads to better, safer, and saner code.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We started by outlining some of the basic principles of type systems:</p>
<ul class="simple">
<li>Static and dynamic typing</li>
<li>Weak and strong typing</li>
<li>Static and dynamic polymorphism</li>
</ul>
<p>Then we went over the building block types of a type system, with Haskell and
C++ examples:</p>
<ul class="simple">
<li>Empty types (cardinality 0)</li>
<li>Unit types (cardinality 1)</li>
<li>Sum types (<span class="docutils literal"><span class="pre">S</span></span> of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></span>)</li>
<li>Product types (<span class="docutils literal"><span class="pre">P</span></span> of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">B</span></span>)</li>
<li>Optional types (<span class="docutils literal"><span class="pre">O</span></span> of <span class="docutils literal"><span class="pre">A</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">1</span></span>)</li>
</ul>
</div>
<div class="section" id="further-reading">
<h2>Further Reading</h2>
<p>Ben Dean had an excellent talk at CppCon this year, <a class="reference external" href="https://www.youtube.com/watch?v=ojZbFIQSdl8">Using Types Effectively</a>. Another great talk about type
design from CppCon is <a class="reference external" href="https://www.youtube.com/watch?v=632a-DMM5J0">C++, Abstract Algebra and Practical Applications</a> by Robert Ramey. And then there
is Bartosz Milewski <a class="reference external" href="https://bartoszmilewski.com/">blog</a> about Haskell,
C++, and category theory.</p>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"> &laquo; <a href="../../12/03/notes-on-error-handling.html">Notes on Error Handling</a></li>
            <li class="right"><a href="../09/composable-generators.html">Composable Generators</a> &raquo; </li>
        </ul></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
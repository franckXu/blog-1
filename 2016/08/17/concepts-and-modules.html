<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Vlad's Tech Blog">
        <meta name="viewport" content="width=device-width">
        <title>Concepts and Modules &mdash; Blog</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/flat.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/tinkerer.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="next" title="Dependency Injection in C++" href="../../07/06/dependency-injection-in-c.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="../../../_static/disqus.js"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script><link rel="stylesheet" href="../../../_static/extra.css" type="text/css" /></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>August 17, 2016</span>
        </div>
    <div class="section" id="concepts-and-modules">
<h1>Concepts and Modules</h1>
<p>As a follow up to my previous post, I want to talk about two major new C++
features that keep not making it into the standard, namely <em>Concepts</em> and
<em>Modules</em>. These would have a significant impact on the code examples I
provided while discussing dependency injectiojn, so here&#8217;s a quick peek into the
future:</p>
<div class="section" id="concepts">
<h2>Concepts</h2>
<p>One way to think about concepts is that concepts are to templates what
interfaces are to classes. Similarly to how interfaces specify a contract which
implementing types must satisfy, concepts specify a contract which template
argument types must satisfy. The main difference is that interfaces/classes
enable runtime polymorphism while concepts/templates enable polymorphism at
compile-time.</p>
<p>Runtime polymorphism:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Our interface</span>
<span class="k">struct</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// One implementation</span>
<span class="k">class</span> <span class="nc">V6Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Another implementation</span>
<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A function that works against the interface</span>
<span class="kt">void</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StartEngines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">V6Engine</span> <span class="n">v6engine</span><span class="p">;</span>
    <span class="n">V8Engine</span> <span class="n">v8engine</span><span class="p">;</span>

    <span class="c1">// calls Start() on V6Engine instance passed as IEngine</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v6engine</span><span class="p">);</span>
    <span class="c1">// calls Start() on V8Engine instance passed as IEngine</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v8engine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we have a single <span class="docutils literal"><span class="pre">StartEngine</span></span> function which works against an
interface. Calling <span class="docutils literal"><span class="pre">Start()</span></span> for that interface involves a virtual function
call, which means that at runtime, given an object of a type implementing
<span class="docutils literal"><span class="pre">IEngine</span></span>, the code needs to figure out which function of the implementing
type to call. For <span class="docutils literal"><span class="pre">V6Engine</span></span>, <span class="docutils literal"><span class="pre">IEngine::Start()</span></span> is <span class="docutils literal"><span class="pre">V6Engine::Start();</span></span>
for <span class="docutils literal"><span class="pre">V8Engine</span></span>, <span class="docutils literal"><span class="pre">IEngine::Start()</span></span> is <span class="docutils literal"><span class="pre">V8Engine::Start()</span></span>. Our classes
have a vtable - a table containing this mapping, so a virtual call looks up the
actual function to call in the vtable.</p>
<p>This is the &#8220;classical&#8221; object-oriented way of dispatching calls. The advantage
of this approach is that it works across binaries <a class="footnote-reference" href="#id3" id="id1">[1]</a> (we can export
<span class="docutils literal"><span class="pre">StartEngine</span></span> from a shared library and pass in an external <span class="docutils literal"><span class="pre">IEngine</span></span>
implementation to it), the disadvantage is the extra redirection - implementing
classes must have a vtable and call resolution involves jumping through it.</p>
<p>Compile-time polymorphism:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// One implementation</span>
<span class="k">class</span> <span class="nc">V6Engine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Another implementation</span>
<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A generic function</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">TEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StartEngines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">V6Engine</span> <span class="n">v6engine</span><span class="p">;</span>
    <span class="n">V8Engine</span> <span class="n">v8engine</span><span class="p">;</span>

    <span class="c1">// calls Start() on V6Engine, this instantiates</span>
    <span class="c1">// StartEngine&lt;V6Engine&gt;(V6Engine&amp; engine)</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v6engine</span><span class="p">);</span>
    <span class="c1">// calls Start() on V8Engine, this instantiates</span>
    <span class="c1">// StartEngine&lt;V8Engine&gt;(V8Engine&amp; engine)</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v8engine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A few differences to note here: we don&#8217;t have an <span class="docutils literal"><span class="pre">IEngine</span></span> interface anymore
and the two types we use, <span class="docutils literal"><span class="pre">V6Engine</span></span> and <span class="docutils literal"><span class="pre">V8Engine</span></span>, no longer have virtual
functions. Calling <span class="docutils literal"><span class="pre">V6Engine::Start()</span></span> or <span class="docutils literal"><span class="pre">V8Engine::Start()</span></span> now no longer
involves a virtual call. The two <span class="docutils literal"><span class="pre">StartEngine</span></span> calls are actually made to
different functions now - at compile time, whenever the compiler encounters a
call to <span class="docutils literal"><span class="pre">StartEngine</span></span> with a new type, it instantiates the template, meaning
it creates a new function based on that template with the template type as the
provided type. We actually end up with one function that can start a
<span class="docutils literal"><span class="pre">V6Engine</span></span> and one that can start <span class="docutils literal"><span class="pre">V8Engine</span></span>, both produced from the same
template.</p>
<p>This is compile-time polymorphism, the advantage being that everything is
determined during build - no virtual calls etc., the disadvantage being that
the compiler needs to have a definition of the template available whenever it
needs to create a new instance <a class="footnote-reference" href="#id4" id="id2">[2]</a>. In this case we can&#8217;t encapsulate what
happens inside <span class="docutils literal"><span class="pre">StartEngine</span></span> if we want others to be able to call the
function.</p>
<div class="section" id="with-concepts">
<h3>With Concepts</h3>
<p>The above works just fine, the problem being that, in general, if you have
a templated function, it&#8217;s not obvious what contracts do the types it expects
need to satisfy. For example, our <span class="docutils literal"><span class="pre">StartEngine</span></span> expects that the given type
has a <span class="docutils literal"><span class="pre">Start()</span></span> function it can call. This isn&#8217;t obvious from the function
declaration though. Also, compiler errors when templates cannot be instantiated
are notoriously hard to decipher. The proposed solution to both of the above
are concepts. Here is how an engine concept would look like:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="kt">bool</span> <span class="n">Engine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">requires</span><span class="p">(</span><span class="n">TEngine</span> <span class="n">engine</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">()</span> <span class="p">};</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This defines the <span class="docutils literal"><span class="pre">Engine</span></span> concept to require any type satisfying it to have a
<span class="docutils literal"><span class="pre">Start()</span></span> function and a <span class="docutils literal"><span class="pre">Stop()</span></span> function. <span class="docutils literal"><span class="pre">StartEngine</span></span> would then be
able to explicitly say what kind of types it expects:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">Engine</span> <span class="n">TEngine</span><span class="o">&gt;</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">TEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is now clear from the function declaration that <span class="docutils literal"><span class="pre">StartEngine</span></span> expects a
type satisfying the <span class="docutils literal"><span class="pre">Engine</span></span> concept. We can look at the concept definition to
see what we need to implement on our type. The compiler would also be able to
issue much clearer errors when the type we pass in is missing one of the concept
requirements.</p>
<p>Unfortunately, while several proposals for concepts have been put forward in the
past years, they weren&#8217;t approved to be part of the C++17 standard. That being
said, it&#8217;s fairly certain that they will eventually make it into the standard.</p>
</div>
</div>
<div class="section" id="modules">
<h2>Modules</h2>
<p>Another noteworthy feature are modules: currently, the <span class="docutils literal"><span class="pre">#include</span></span> directive
textually includes the given file into the source file being compiled. This has
a lot of build-time overhead (same header files get compiled over and over as
they are included in various source files) and forces us to be extra-careful in
how we scope things: what goes in a header file vs. what goes in a source file
etc.</p>
<p>Modules aim to replace the header/source file split and provide a better way to
group components and expose functionality. For example, here is a header/source
file pair from my previous post:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// ICar.h</span>
<span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">&quot;IEngine.h&quot;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
<span class="n">Car</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span>

<span class="c1">// Car.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;ICar.h&quot;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using modules, we would have:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">Car</span><span class="p">;</span>

<span class="n">import</span> <span class="n">Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is now a single file where we import the <span class="docutils literal"><span class="pre">Engine</span></span> module (instead of
<span class="docutils literal"><span class="pre">#include</span></span>), we provide the interface and concrete implementation, the factory
function, and we mark publicly-visible declarations with the <span class="docutils literal"><span class="pre">export</span></span> keyword.</p>
<p>Like Concepts, Modules haven&#8217;t made it into the C++17 standard, but MSVC has a
working implementation as of VS2015 Update 1.</p>
</div>
<div class="section" id="dependency-injection-in-the-future">
<h2>Dependency Injection in the Future</h2>
<p>So putting the above together, here is how dependency injection in C++ might
look like in the not too far future:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Engine.m</span>
<span class="n">module</span> <span class="n">Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="kt">bool</span> <span class="n">Engine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">requires</span><span class="p">(</span><span class="n">TEngine</span> <span class="n">engine</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">()</span> <span class="p">};</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// V8Engine.m</span>
<span class="n">module</span> <span class="n">V8Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// start the engine }</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// stop the engine }</span>
<span class="p">};</span>

<span class="c1">// Car.m</span>
<span class="n">module</span> <span class="n">Car</span><span class="p">;</span>

<span class="n">import</span> <span class="n">Engine</span><span class="p">;</span>
<span class="n">import</span> <span class="n">V8Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="n">Engine</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n">DefaultConstructible</span><span class="o">&lt;</span><span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Explicit instantiation exported from this module so clients</span>
<span class="c1">// won&#39;t have to re-instantiate the template for V8Engine type</span>
<span class="k">export</span> <span class="k">class</span> <span class="nc">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>This can be used as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">import</span> <span class="n">Car</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
<span class="n">car</span><span class="p">.</span><span class="n">Drive</span><span class="p">();</span>
</pre></div>
</div>
<p>This would be the equivalent of Dependency Injection with Templates I mentioned
in the previous post.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>As long as binaries are compiled with the same compiler. Otherwise the
code produced by different compilers might have different vtable layouts
and different name mangling.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Other disadvantages are slower compile times and potential code bloat,
as each template instantiation gets translated into a new function.</td></tr>
</tbody>
</table>
</div>
</div>

    <div class="postmeta">
        
        
        
        </div><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="../../07/06/dependency-injection-in-c.html">Dependency Injection in C++</a> &raquo; </li>
        </ul><div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "vladris";    var disqus_identifier = "2016/08/17/concepts-and-modules";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></article></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><div style="text-align: center; color: #93a4ad">
    By Vlad Rișcuția | <a href="http://feeds.feedburner.com/vladris">Subscribe</a> | <a href="http://vladris.com/blog/archive">Archive</a>
</div></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>
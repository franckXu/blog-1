<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Blog</title>
        <link>http://vladris.com/blog/</link>
        <description></description>
        <language>en-us</language>
        <pubDate>Sun, 18 Nov 2018 00:00:00 -0800</pubDate>
        
        <item>
            <link>http://vladris.com/blog/2018/11/18/notes-on-encoding-text.html</link>
            <guid>http://vladris.com/blog/2018/11/18/notes-on-encoding-text.html</guid>
            <title><![CDATA[Notes on Encoding Text]]></title>
            <description><![CDATA[<h1>Notes on Encoding Text</h1>
<p>In this post we will look at text encoding, from the half-a-century old ASCII
and its extensions to Unicode and the common UTF-16 and UTF-8 encodings. We’ll
cover a few basic text encoding concepts like code points, graphemes, and
surrogate pairs and see how we can stack emojis and combine them into intricate
glyphs.</p>
<p>Disclaimer: since this blog post deals with text and provides several visual
examples, it might not render correctly on all operating systems. Everything
looks fine on Window 10 but iOS seems to have trouble combining all emojis.</p>
<div class="section" id="ascii">
<h2>ASCII</h2>
<p>The American Standard Code for Information Exchange, or ASCII, was developed in
the 60s. The standard encodes each character in 7 bits, so it has 128
characters. These include both the lowercase and uppercase letters of the
English alphabet, digits, punctuation, and a set of control characters like LF
(line feed, also known as <span class="docutils literal"><span class="pre">\n</span></span>), CR (carriage return, also known as <span class="docutils literal"><span class="pre">\r</span></span>) or
BEL (audible beep, or <span class="docutils literal"><span class="pre">\a</span></span>). The ASCII character set contains all characters
on a typewriter.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>0x00 to 0x1F - control characters
0x20 to 0x2F - symbols - SPACE ! " # $ % &amp; ' ( ) * + , - . /
0x30 to 0x39 - digits - 0 1 2 3 4 5 6 7 8 9
0x3A to 0x40 - symbols - : ; &lt; = &gt; ? @
0x41 to 0x5A - uppercase letters - A to Z
0x5B to 0x60 - symbols – [ \ ] ^ _ `
0x61 to 0x7A - lowercase letters - a to z
0x7B to 0x7E - symbols - { | } ~
0x7F - "delete" control character - DEL
</pre></div>
</div>
<div class="section" id="parity-bits">
<h3>Parity bits</h3>
<p>A byte is 8 bits wide, so the remaining bit was used as a <em>parity bit</em>. The
parity bit is 0 if the 7 bits encoding a character have an even number of 1s
and 1 if the bits encoding a character have an odd number of 1s. For example,
the letter <span class="docutils literal"><span class="pre">A</span></span> is encoded as <span class="docutils literal"><span class="pre">0x41</span></span>, or <span class="docutils literal"><span class="pre">1000001</span></span>. <span class="docutils literal"><span class="pre">1000001</span></span> has an even
number of bits so the parity bit is 0, thus <span class="docutils literal"><span class="pre">A</span></span> ends up being encoded on 8
bits as <span class="docutils literal"><span class="pre">01000001</span></span>. The letter <span class="docutils literal"><span class="pre">C</span></span> is encoded as <span class="docutils literal"><span class="pre">0x43</span></span>, or <span class="docutils literal"><span class="pre">1000011</span></span>,
so the parity bit is 1. <span class="docutils literal"><span class="pre">C</span></span> ends up being encoded on 8 bits as <span class="docutils literal"><span class="pre">11000011</span></span>.</p>
<p>The parity bit is used to check the consistency of the data: in a lossy
environment, a parity bit is a simple way to add extra validation. If the parity
bit does not have the expected value - for example it is 1 while the remaining 7
bits have an even number of bits set to 1 - it means that the data is corrupted.</p>
<p>This encoding was enough for English, but lacked other letters common in
European languages, for example accented letters like é or ć. It also could not
encode any other alphabets, like Arabic, Cyrillic, Hebrew and so on.</p>
</div>
</div>
<div class="section" id="extended-ascii-and-code-pages">
<h2>Extended ASCII and Code Pages</h2>
<p>The ASCII character set had numerous extensions which started to leverage the
8th bit to encode information instead of using it to check integrity. The
original 128 character stayed in the <span class="docutils literal"><span class="pre">0x0</span></span> - <span class="docutils literal"><span class="pre">0x7F</span></span> range, but with the
extra bit, an extended ASCII character set could encode 128 more characters
from <span class="docutils literal"><span class="pre">0x80</span></span> to <span class="docutils literal"><span class="pre">0xFF</span></span>.  Since ASCII received multiple such extensions,
these were distinguished by code pages. A code page defined what the <span class="docutils literal"><span class="pre">0x80</span></span> to
<span class="docutils literal"><span class="pre">0xFF</span></span> characters are.</p>
<p>IBM PC systems came with the popular <strong>code page 437</strong> which includes characters
for box-drawing like <span class="docutils literal"><span class="pre">║</span></span>, <span class="docutils literal"><span class="pre">╗</span></span>, and <span class="docutils literal"><span class="pre">╝</span></span>. Text-based user interface could
simulate windows, buttons and so on using these characters:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>╔════════════════════════════════════╗
║ Box-drawn window with progress bar ║
╟────────────────────────────────────╢
║  ██████████████████▓▒░░░░░░░░░░░░  ║
╚════════════════════════════════════╝
</pre></div>
</div>
<p>Another set of extensions was the <strong>ISO/IEC 8859</strong> standard consisting of 16
parts, each adding support for additional character and alphabets. For example,
part 1 was named <em>Latin-1 Western European</em> and added most characters required
by Western European languages (like accented letters), while part 5,
<em>Latin/Cyrillic</em> used the available 128 characters to encode the Cyrillic
alphabet.</p>
<p>While these code pages allowed new ranges of characters, each could only add
128 symbols, which didn’t scale well to the world’s written languages. For
perspective, Kanji has thousands of characters.</p>
</div>
<div class="section" id="unicode">
<h2>Unicode</h2>
<p>The Unicode standard aims to cover most of the world’s writing systems and
include additional symbols like emojis.</p>
<div class="section" id="code-points">
<h3>Code points</h3>
<p>Unicode introduces the notion of code points. Most code points are characters,
but some code points are used for formatting while some are unassigned as of
today and will be defined in future extensions of the standard. The total code
space of Unicode spans 1114112 code points, from <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0x10FFFF</span></span>.</p>
<p>The code space is divided into 17 planes, each consisting of a range of 65536
code points (from <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0xFFFF</span></span>, from <span class="docutils literal"><span class="pre">0x10000</span></span> to <span class="docutils literal"><span class="pre">0x1FFFF</span></span> and so
on until <span class="docutils literal"><span class="pre">0xF0000</span></span> to <span class="docutils literal"><span class="pre">0x10FFFF</span></span>). A Unicode code point is conventionally
referred to as <span class="docutils literal"><span class="pre">U+XXX</span></span> where <span class="docutils literal"><span class="pre">XXX</span></span> is the hexadecimal value of the code
point. For example the code point corresponding to the letter “a” which is
<span class="docutils literal"><span class="pre">0x61</span></span>, is referred to as <span class="docutils literal"><span class="pre">U+0061</span></span>.</p>
<p>Most programming languages allow strings to contain a Unicode escape sequence,
which gets interpreted as a Unicode code point. Such sequences start with <span class="docutils literal"><span class="pre">\x</span></span>
or <span class="docutils literal"><span class="pre">\u</span></span> followed by the hexadecimal value of the code point, for example in
JavaScript the Unicode escape for “a” is the string <span class="docutils literal"><span class="pre">"\u0061"</span></span>.</p>
<p>Not only does Unicode support a huge range of code points, it also defines
combining characters which, combined with other character, create new
characters. For example,  ́ (<span class="docutils literal"><span class="pre">U+0301</span></span>) is the combining acute accent. Combining
this with “a” (<span class="docutils literal"><span class="pre">U+0061</span></span>) by appending it after the letter (the string
<span class="docutils literal"><span class="pre">"\u0061\u0301"</span></span>) results in the character “á” while combining it with
“e” (<span class="docutils literal"><span class="pre">U+0065</span></span>) in the string <span class="docutils literal"><span class="pre">"\u0065\u0301"</span></span> results in the character
“é”.</p>
<p>Similarly, a skin tone modifier like dark skin tone, 🏿 (<span class="docutils literal"><span class="pre">U+1F3FF</span></span>) can be
appended to an emoji like the baby emoji 👶 (<span class="docutils literal"><span class="pre">U+1F476</span></span>) to get a baby with
a dark skin tone 👶🏿.</p>
</div>
<div class="section" id="graphemes">
<h3>Graphemes</h3>
<p>A grapheme is a graphical symbol that a user sees on the screen. Text rendering
is done through graphemes. Some graphemes correspond to a single code point,
like “a” corresponding to <span class="docutils literal"><span class="pre">U+0061</span></span>. Other graphemes correspond to a sequence
of code points, like 👶🏿, which corresponds to <span class="docutils literal"><span class="pre">U+1F476</span></span> then <span class="docutils literal"><span class="pre">U+1F3FF</span></span>.
There are also graphemes which can be obtained in multiple ways. The accented
“e” in the example above, “é”, can be obtained by combining the letter “e” with
the acute accent (<span class="docutils literal"><span class="pre">U+0065</span></span> then <span class="docutils literal"><span class="pre">U+0301</span></span>), but there is also an accented “e”
character “é” represented by the code point <span class="docutils literal"><span class="pre">U+00E9</span></span>. Both <span class="docutils literal"><span class="pre">U+0065</span> <span class="pre">U+0301</span></span>
and <span class="docutils literal"><span class="pre">U+00E9</span></span> resolve to the same grapheme.</p>
<p>Because of such equivalences, the standard defines a normalization procedure
which can convert equivalent texts to the same code point representation. There
are several ways to achieve this, which we’ll not cover in this blog post.</p>
<p>Combining and modifying characters can be stacked one after the other. For
example, the 👨🏿‍❤️‍👨🏻 emoji showing a dark-skinned man and a
light-skinned man with a heart above is a single grapheme but consists of the
following sequence of code points: <span class="docutils literal"><span class="pre">U+1F468</span> <span class="pre">U+1F3FF</span> <span class="pre">U+200D</span> <span class="pre">U+2764</span> <span class="pre">U+FE0F</span> <span class="pre">U+200D</span>
<span class="pre">U+1F468</span> <span class="pre">U+1F3FB</span></span>. This is a combination of:</p>
<ul class="simple">
<li>The man emoji 👨 (<span class="docutils literal"><span class="pre">U+1F468</span></span>)</li>
<li>The dark skin tone modifier 🏿 (<span class="docutils literal"><span class="pre">U+1F3FF</span></span>)</li>
<li>The zero-width joiner (<span class="docutils literal"><span class="pre">U+200D</span></span>) which does not have a stand-alone
representation but combines two emojis into a single one</li>
<li>The heavy black heart symbol ❤ (<span class="docutils literal"><span class="pre">U+2764</span></span>)</li>
<li>The Variation Selector-16 character (<span class="docutils literal"><span class="pre">U+2764</span></span>) which also doesn’t have a
stand-alone representation but can be applied to code points which have both
a text and an emoji representation to select the emoji representation. This
ensures the heavy black heart symbol gets the emoji representation ❤️.</li>
<li>Another zero-width joiner (<span class="docutils literal"><span class="pre">U+200D</span></span>)</li>
<li>Another man emoji 👨 (<span class="docutils literal"><span class="pre">U+1F468</span></span>)</li>
<li>The light skin tone modifier 🏻 (<span class="docutils literal"><span class="pre">U+1F3FB</span></span>)</li>
</ul>
<p>The whole sequence results in a single grapheme.</p>
<p>One interesting thing to note is that splitting a string without being aware of
how the code points combine can change the representation of the text. This can
happen when breaking a line of text to fit on screen. In the above example,
even though we have 8 code points, we end up with a single grapheme, so when
dealing with rendering, it’s usually best to operate on graphemes not code
points/characters.</p>
</div>
</div>
<div class="section" id="encodings">
<h2>Encodings</h2>
<p>We talked about code points and graphemes, but how are the code points actually
encoded as bytes? With ASCII and the simple extensions, the encoding was easy,
as each byte encoded a character. Unicode has over a million code points, so
let’s look at how these get translated into bytes.</p>
<div class="section" id="utf-32">
<h3>UTF-32</h3>
<p>The most obvious way is to find the minimum number of bytes that can encode any
code point. Since code points range from <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0x10FFFF</span></span>, we need 21
bits to store all possible values (<span class="docutils literal"><span class="pre">0x10FFFF</span></span> in binary is
<span class="docutils literal"><span class="pre">0b100001111111111111111</span></span>).</p>
<p>Because most CPUs nowadays have a word size of at least 32-bits, the UTF-32
encoding rounds up the number of required bits from 21 to 32, thus representing
a code point using 4 bytes.</p>
<p>This encoding is very straight-forward, as any 4 bytes store the value of a
code point in a string, but it is also very space-inefficient. The leading bits
are always 0 and not only that, the code points representing common characters
and alphabets appear in the lower planes, so while an emoji like the woman
emoji 👩 (<span class="docutils literal"><span class="pre">U+1F469</span></span>) in binary is <span class="docutils literal"><span class="pre">0b11111010001101001</span></span>, thus requiring at
least 17 bits to represent, the code point for the letter “a” is <span class="docutils literal"><span class="pre">U+0061</span></span>,
same as the old ASCII representation. That is <span class="docutils literal"><span class="pre">0b1100001</span></span> in binary, requiring
only 7 bits.</p>
<p>To take advantage of this, several <em>variable-length</em> encodings were developed,
which use fewer bytes for code points representable with a smaller number of
bits, and more bytes for higher code point values. The two most common
encodings are UTF-16 and UTF-8.</p>
</div>
<div class="section" id="utf-16">
<h3>UTF-16</h3>
<p>UTF-16 encodes code points in either one or two 16-bit wide code units. The
code points in the range <span class="docutils literal"><span class="pre">U+0000</span></span> to <span class="docutils literal"><span class="pre">U+FFFF</span></span> are encoded directly as a
16-bit code unit, except the subrange <span class="docutils literal"><span class="pre">U+D800</span></span> to <span class="docutils literal"><span class="pre">U+DFFF</span></span> which we’ll talk
about shortly. This range corresponds to Plane 0, the <em>Basic Multilingual
Plane</em>, with code points to represent almost all modern languages.</p>
<p>Code points from other planes are encoded in UTF-16 using two code units, so 32
bits. Any code point in the range <span class="docutils literal"><span class="pre">U+10000</span></span> to <span class="docutils literal"><span class="pre">U+10FFFF</span></span> (or <span class="docutils literal"><span class="pre">0x10000</span></span> to
<span class="docutils literal"><span class="pre">0x10FFFF</span></span>) is encoded by subtracting <span class="docutils literal"><span class="pre">0x10000</span></span> leaving a value between
<span class="docutils literal"><span class="pre">0x0</span></span> and <span class="docutils literal"><span class="pre">0xFFFFF</span></span>. Values in this range can be represented in 20 bits. A
sequence of 10 bits can represent values in the range <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0x3FF</span></span>. The
20 bits are split into the first (most significant) 10 bits and the last (least
significant) 10 bits. The first 10 bits are added to <span class="docutils literal"><span class="pre">0xD800</span></span>, resulting in a
value in the range <span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDBFF</span></span>. This is represented in the first
16-bit code point. The last 10 bits are added to <span class="docutils literal"><span class="pre">0xDC00</span></span>, resulting in a
value in the range <span class="docutils literal"><span class="pre">0xDC00</span></span> to <span class="docutils literal"><span class="pre">0xDFFF</span></span>. This is represented in the second
16-bit code point.</p>
<p>Let’s take as an example the woman emoji 👩 (<span class="docutils literal"><span class="pre">U+1F469</span></span>). The UTF-16 encoding
goes as follows:</p>
<ul class="simple">
<li>Subtract <span class="docutils literal"><span class="pre">0x10000</span></span> from <span class="docutils literal"><span class="pre">0x1F469</span></span>, resulting in <span class="docutils literal"><span class="pre">0xF469</span></span>, or
<span class="docutils literal"><span class="pre">0b00001111010001101001</span></span> in 20 bits.</li>
<li>The first 10 bits, <span class="docutils literal"><span class="pre">0b0000111101</span></span>, or <span class="docutils literal"><span class="pre">0x3D</span></span>, are added to <span class="docutils literal"><span class="pre">0xD800</span></span>
which gives us <span class="docutils literal"><span class="pre">0xD83D</span></span>.</li>
<li>The remaining 10 bits, <span class="docutils literal"><span class="pre">0b0001101001</span></span>, or <span class="docutils literal"><span class="pre">0x69</span></span>, are added to <span class="docutils literal"><span class="pre">0xDC00</span></span>,
giving <span class="docutils literal"><span class="pre">0xDC69</span></span>.</li>
</ul>
<p>The two 16-bit code units for 👩 are <span class="docutils literal"><span class="pre">0xD83D</span></span> and <span class="docutils literal"><span class="pre">0xDC69</span></span>, or the byte
sequence <span class="docutils literal"><span class="pre">0xD8</span> <span class="pre">0x3D</span> <span class="pre">0xDC</span> <span class="pre">0x69</span></span>.</p>
<p><strong>Surrogate pairs</strong></p>
<p>We said that UTF-16 encodes all code points in Plane 0 using a single 16-bit
code unit, except the range <span class="docutils literal"><span class="pre">U+D800</span></span> to <span class="docutils literal"><span class="pre">U+DFFF</span></span>. That particular range is
reserved in the Unicode standard for UTF-16 surrogate pairs, so code points in
that range are unassigned and will never be assigned.</p>
<p>If we review the way UTF-16 encodes code points in code units, a 16-bit code
unit can be either:</p>
<ul class="simple">
<li>A value in the range <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0xFFFF</span></span>, except the reserved range
<span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDFFF</span></span>. This value is a valid code point in Plane 0.</li>
<li>A value in the range <span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDBFF</span></span>, which represents the first 10
bits of a code point in another plane after subtracting <span class="docutils literal"><span class="pre">0x10000</span></span> and adding
<span class="docutils literal"><span class="pre">0xD800</span></span> to the first 10 bits</li>
<li>A value in the range <span class="docutils literal"><span class="pre">0xDC00</span></span> to <span class="docutils literal"><span class="pre">0xDFFF</span></span>, which represents the remaining
10 bits of a code point in another plane after subtracting <span class="docutils literal"><span class="pre">0x10000</span></span> and
adding <span class="docutils literal"><span class="pre">0xDC00</span></span> to the last 10 bits.</li>
</ul>
<p>Note that these ranges are disjoint - a value can appear in only one of them, so
each 16-bit code unit can unambiguously be identified, in isolation. For code
points like 👩, encoded as two 16-bit code units, the code units are called a
<em>surrogate pair</em>. The first code unit, in the range <span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDBFF</span></span> is
called the <em>high surrogate</em> while the second code unit, in the range <span class="docutils literal"><span class="pre">0xDC00</span></span>
to <span class="docutils literal"><span class="pre">0xDFFF</span></span> is called the <em>low surrogate</em>.</p>
<p>Since the Unicode standard and UTF-16 encoding evolved together, the range
<span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDFFF</span></span> needed by the surrogate pairs was reserved in Plane 0
and the code points were kept unassigned. Without this, UTF-16 would have had
trouble encoding a code point in that range as it would become undistinguishable
from a surrogate.</p>
<p>UTF-16 is the default encoding used by Windows, Java, the .NET runtime, and
JavaScript. Another popular way to encode text is UTF-8.</p>
</div>
</div>
<div class="section" id="utf-8">
<h2>UTF-8</h2>
<p>UTF-8 uses 8-bit code units, so it encodes code points using one to four bytes.
To recap, Unicode code points can be represented in 21 bits, as their valid
range is between <span class="docutils literal"><span class="pre">0x0</span></span> and <span class="docutils literal"><span class="pre">0x10FFFF</span></span>.</p>
<p>UTF-8 encodes code points as follows:</p>
<ul class="simple">
<li>Code points in the range <span class="docutils literal"><span class="pre">U+0000</span></span> to <span class="docutils literal"><span class="pre">U+007F</span></span> are represented with a
single byte with the 8th (most significant) bit being 0: <span class="docutils literal"><span class="pre">0b0xxxxxxx</span></span>.</li>
<li>Code points in the range <span class="docutils literal"><span class="pre">U+0080</span></span> to <span class="docutils literal"><span class="pre">U+07FF</span></span> are represented with two
bytes. The first byte starts with the bits <span class="docutils literal"><span class="pre">0b110xxxxx</span></span>, the second byte is
<span class="docutils literal"><span class="pre">0x10xxxxxx</span></span>. Without the prefixes, there are 11 bits used to encode the
code point (count the number of <span class="docutils literal"><span class="pre">x</span></span>s ).</li>
<li>Code points in the range <span class="docutils literal"><span class="pre">U+0800</span></span> to <span class="docutils literal"><span class="pre">U+FFFF</span></span> are represented with three
bytes. The first byte starts with the prefix <span class="docutils literal"><span class="pre">0b1110xxxx</span></span>, the following two
bytes with <span class="docutils literal"><span class="pre">0b10xxxxxx</span></span>. This leaves 16 bits to encode the code point.</li>
<li>Code points in the range <span class="docutils literal"><span class="pre">U+10000</span></span> to <span class="docutils literal"><span class="pre">U+10FFFF</span></span> are represented with four
bytes. The first byte starts with the prefix <span class="docutils literal"><span class="pre">0b11110xxx</span></span>, the following
three bytes with <span class="docutils literal"><span class="pre">0b10xxxxxx</span></span>. This leaves 21 bits to encode the code point.</li>
</ul>
<p>This encoding has several interesting properties: for code points in lower
planes, it is more compact than UTF-16. UTF-16 requires either one or two
16-bit code units, while UTF-8 can use 8, 16, 24, or 32 bits depending on the
code point. Commonly used alphabets are in the lower planes, so usually fewer
bits are needed.</p>
<p>UTF-8 is also ASCII-compatible: the first 128 characters (<span class="docutils literal"><span class="pre">U+0000</span></span> to
<span class="docutils literal"><span class="pre">U+007F</span></span>), represented in 7 bits, are the same as the old ASCII encoding. An
ASCII string can be used directly as UTF-8 encoded text without any
transformations required.</p>
<p>Unlike UTF-16, which can uniquely distinguish each code unit as either a code
point, a high surrogate, or a low surrogate, with UTF-8 we cannot always
determine what a code unit is in isolation: <span class="docutils literal"><span class="pre">0b10110011</span></span> could be the second,
third, or fourth byte in a code point. This is a consequence of the more
compact encoding. On the other hand, with UTF-8 we can look at the bit prefix
and determine the length of the sequence:</p>
<ul class="simple">
<li>If the prefix of the byte is <span class="docutils literal"><span class="pre">0b0xxxxxxx</span></span>, we have an ASCII character</li>
<li>If the prefix is <span class="docutils literal"><span class="pre">0b110xxxxx</span></span>, we are looking at the first byte of a code
point encoded in 2 bytes</li>
<li>If the prefix is <span class="docutils literal"><span class="pre">0b1110xxxx</span></span>, we are expecting a sequence of 3 bytes</li>
<li>If the prefix is <span class="docutils literal"><span class="pre">0b11110xxx</span></span>, we are expecting a sequence of 4 bytes</li>
<li>If the prefix is <span class="docutils literal"><span class="pre">0b10xxxxxx</span></span>, we know we aren’t looking at the first byte
in a sequence, rather at a byte inside a sequence</li>
</ul>
<p>Note the bit patterns do not overlap. Beyond ASCII, the number of 1 bits in the
prefix coincides with the number of bytes used to encode the code point.</p>
<p>As an example, let’s take the same 👩 emoji and see how its encoding looks like
in UTF-8. 👩 is the code point <span class="docutils literal"><span class="pre">U+1F469</span></span>, so it requires 4 bytes. <span class="docutils literal"><span class="pre">0x1F469</span></span>
represented in binary with 21 bits is <span class="docutils literal"><span class="pre">0b000011111010001101001</span></span>.</p>
<p>We fill this into <span class="docutils literal"><span class="pre">0b11110xxx</span> <span class="pre">0b10xxxxxx</span> <span class="pre">0b10xxxxxx</span> <span class="pre">0b10xxxxxx</span></span>, which gives
us <span class="docutils literal"><span class="pre">0b11110000</span> <span class="pre">0b10011111</span> <span class="pre">0b10010001</span> <span class="pre">0b10101001</span></span>. In hexadecimal, this is
<span class="docutils literal"><span class="pre">0xF0</span> <span class="pre">0x9F</span> <span class="pre">0x91</span> <span class="pre">0xA9</span></span>. This is the encoding of our emoji in UTF-8.</p>
<p>UTF-8 is the default encoding used by Linux and macOS. It is also the standard
for the internet, with a majority of web pages using this encoding.</p>
<p>Another important thing to keep in mind when manipulating text is how it is
encoded. When reading a sequence of bytes from a file or a network connection,
we need to make sure we don’t mistakenly try to interpret UTF-8 encoded text as
UTF-16 encoded text or vice-versa. Since different systems default to different
encodings, this is a very plausible scenario.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post we looked at some common text encoding standards and concepts:</p>
<ul class="simple">
<li>ASCII, which encodes 128 characters</li>
<li>Extended ASCII, which encodes 256 characters<ul>
<li>Code page 437, with box-drawing characters</li>
<li>The ISO/IEC 8859 16-part standard with code pages for various alphabets</li>
</ul>
</li>
<li>Unicode<ul>
<li>Code points and planes</li>
<li>Graphemes and combining characters</li>
</ul>
</li>
<li>Encodings<ul>
<li>The inefficient UTF-32</li>
<li>UTF-16 and surrogate pairs</li>
<li>Popular UTF-8</li>
</ul>
</li>
</ul>
</div>
]]></description>
             <pubDate>Sun, 18 Nov 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/10/13/arithmetic-overflow-and-underflow.html</link>
            <guid>http://vladris.com/blog/2018/10/13/arithmetic-overflow-and-underflow.html</guid>
            <title><![CDATA[Arithmetic Overflow and Underflow]]></title>
            <description><![CDATA[<h1>Arithmetic Overflow and Underflow</h1>
<p>Arithmetic overflow happens when an arithmetic operation results in a value that
is outside the range of values representable by the expression’s type. For
example, the following C++ code prints <span class="docutils literal"><span class="pre">0</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">uint16_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">65535</span><span class="p">;</span>
<span class="n">x</span><span class="o">++</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">x</span></span> is an unsigned 16 bit integer, which can represent values between 0 and
65535. If <span class="docutils literal"><span class="pre">x</span></span> is 65535 and we increment it, the value becomes 65536 but that
value cannot be represented by a <span class="docutils literal"><span class="pre">uint16_t</span></span>. This is an overflow. In this
case, C++ wraps the value around and <span class="docutils literal"><span class="pre">x</span></span> becomes 0.</p>
<p>Similarly, an underflow occurs when an arithmetic operation generates a result
that is below the smallest representable value of the expression’s type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">uint16_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">x</span><span class="o">--</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p>The above prints 65535, as the result of decrementing 0 is -1, which cannot be
represented by an <span class="docutils literal"><span class="pre">uint16_t</span></span>.</p>
<p>Before we digging into overflow behavior, we need to understand how computers
represent numbers.</p>
<div class="section" id="number-representations">
<h2>Number Representations</h2>
<div class="section" id="arbitrarily-large-integers">
<h3>Arbitrarily large integers</h3>
<p>Python provides support for arbitrarily large integers: unlike C++, where the
bit width (number of bits used to represent a number) is fixed, we can have
integers of any size:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">print</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Prints</p>
<blockquote style="word-wrap:break-word">
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
</blockquote><p>Why don’t all languages provide such support? The answer is performance. The
underlying hardware the code runs on uses fixed-width integers, so performing
arithmetic on fixed-width integer types becomes a single CPU instruction. On
the other hand, supporting arbitrarily large integers usually involves writing
code to determine how many bits a given value or the result of an arithmetic
operation needs and convert that into an array of fixed-width integers large
enough to hold that value. The added overhead of this is non-trivial, so unlike
Python, most other mainstream languages offer only fixed-width integers and
support arbitrarily large integers only explicitly, via libraries.</p>
</div>
<div class="section" id="unsigned-integers">
<h3>Unsigned integers</h3>
<p>Unsigned integers are represented as a sequence of <span class="docutils literal"><span class="pre">N</span></span> bits, thus being able
to represent numbers between 0 and 2<sup>N</sup>-1. An unsigned 8-bit integer can
store any value between 0 and 255, an unsigned 16-bit integer can store any
value between 0 and 65535, an unsigned 32-bit integer between 0 and 4294967295,
and an unsigned 64-bit integer between 0 and 18446744073709551615.</p>
<p>Unsigned integer representation is trivial.</p>
</div>
<div class="section" id="signed-integers">
<h3>Signed integers</h3>
<p>Signed integers are usually represented in two’s complement.</p>
<p>Positive numbers are encoded the same as unsigned binary numbers described
above. Negative numbers are encoded as two’s complement of their absolute
value. For example, an 8-bit representation of -3 is 2<sup>8</sup>-3.</p>
<p>The most significant bit is always 1 for negative numbers and 0 for positive
numbers or 0.</p>
<p>With this representation, <span class="docutils literal"><span class="pre">N</span></span> bits can encode a signed integer between
2<sup>N-1</sup>-1 and -2<sup>N</sup>. So 8 bits can encode an integer between -128
and 127.</p>
</div>
</div>
<div class="section" id="handling-overflow">
<h2>Handling Overflow</h2>
<p>If the result of an arithmetic operation cannot fit the type, there are several
approaches we can take and different programming languages employ different
strategies. These are:</p>
<ul class="simple">
<li>Exceptions</li>
<li>Wrap-around</li>
<li>Saturation</li>
</ul>
<p>All of these approaches have their pros and cons.</p>
<div class="section" id="exceptions">
<h3>Exceptions</h3>
<p>The safest approach is to treat an arithmetic overflow as an exception. This
usually gets rid of security vulnerabilities and treats any overflow as an
exceptional scenario. In this case an exception is thrown (or an error returned)
whenever an arithmetic operation overflows or underflows.</p>
<p>This is usually desirable from a security/safety perspective, but the trade-off
is in performance: the downside of this approach is that all arithmetic
operations need to be checked for overflow (underlying hardware usually does not
do this natively) and exceptions need to be handled by callers.</p>
</div>
<div class="section" id="wrap-around">
<h3>Wrap-around</h3>
<p>The default behavior in C++, wrap-around simply continues from the smallest
possible value in case of overflow or from the largest possible value in case
of underflow. For unsigned integers, this is equivalent to modulo arithmetic.
For example, for an <span class="docutils literal"><span class="pre">int8_t</span></span>, which can represent values between -128 and 127,
wrap-around would make 127 + 1 be -128 and similarly -128 - 1 be 127.</p>
<p>This is usually the most efficient way to perform arithmetic as no checking is
involved. Most hardware uses wrap-around as it can simply discard overflowing
bits to achieve the result. The two’s complement representation of 127 is
<span class="docutils literal"><span class="pre">01111111</span></span>. The two’s complement representation of 128 is <span class="docutils literal"><span class="pre">10000000</span></span>. With
this representation, adding 1 to 127 naturally makes it 128.</p>
<p>This is also the most unsafe implementation as it can lead to unexpected
behavior and exploitable security holes<a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
</div>
<div class="section" id="saturation">
<h3>Saturation</h3>
<p>Saturation means clamping the value within the allowed range, so on overflow, we
would simply stop at the largest representable value. On underflow, we would
stop at the smallest representable value. In our 8-bit signed integer example,
we would now have 127 + 1 be 127 and -128 - 1 be -128. There are several
advantages with this approach: for one, the resulting values on overflow and
underflow are the closest to the “real” values we would get if operating without
constraints. A lot of physical systems naturally lend themselves to saturation.
Imagine, for example, a thermostat which can only operate within a range of
temperature.</p>
<p>The downsides of this approach are results which might be surprising and the
fact that properties of arithmetic operations like associativity no longer hold:
(120 + 10) + (-10) is 117, but 120 + (10 + (-10)) is 120.</p>
</div>
</div>
<div class="section" id="detecting-overflow-and-underflow">
<h2>Detecting Overflow and Underflow</h2>
<p>Let’s now see how we can tell whether an arithmetic operation overflow while
operating only within the range of values representable by a given type.</p>
<p>For a type which can represent any value between some <span class="docutils literal"><span class="pre">MIN</span></span> and <span class="docutils literal"><span class="pre">MAX</span></span>, we
observe that an addition overflow means <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span>, while an underflow
means <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">MIN</span></span> (note <span class="docutils literal"><span class="pre">a</span></span> and <span class="docutils literal"><span class="pre">b</span></span> can be negative, so adding them
could produce a value that would be under our minimum representable value).</p>
<p>We can detect overflow and underflow by checking, if <span class="docutils literal"><span class="pre">b</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, that
<span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MAX</span> <span class="pre">-</span> <span class="pre">b</span></span>, otherwise with <span class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>, that <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MIN</span> <span class="pre">-</span> <span class="pre">b</span></span>.</p>
<p>The reason this works is that, if <span class="docutils literal"><span class="pre">b</span></span> is greater than or equal to 0, we can
safely subtract it from <span class="docutils literal"><span class="pre">MAX</span></span> (if it were negative, subtracting it would cause
an overflow). So with this in mind, we are simply saying that <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span>
is equivalent to <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MAX</span> <span class="pre">-</span> <span class="pre">b</span></span> (subtracting <span class="docutils literal"><span class="pre">b</span></span> on both sides). We also
observe that <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></span> can never underflow if <span class="docutils literal"><span class="pre">b</span></span> is greater than or equal to
0 because, regardless how small <span class="docutils literal"><span class="pre">a</span></span> is, adding a positive number to it will
make it larger not smaller.</p>
<p>If <span class="docutils literal"><span class="pre">b</span></span> is less than 0, then by the same logic we cannot possibly overflow -
regardless how large <span class="docutils literal"><span class="pre">a</span></span> is, adding <span class="docutils literal"><span class="pre">b</span></span> to it would make it smaller. In this
case we only need to check for underflow. Here we observe that subtracting a
negative number from <span class="docutils literal"><span class="pre">MIN</span></span> is safe - it will increase <span class="docutils literal"><span class="pre">MIN</span></span>. So by
subtracting <span class="docutils literal"><span class="pre">b</span></span> on both sides of <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">MIN</span></span>, we get <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MIN</span> <span class="pre">-</span> <span class="pre">b</span></span>.</p>
<p>The following code implements these two checks:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"/>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">AdditionOverflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">AdditionUnderflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Detecting overflow or underflow for subtraction is very similar, as subtracting
<span class="docutils literal"><span class="pre">b</span></span> from <span class="docutils literal"><span class="pre">a</span></span> is the equivalent of adding <span class="docutils literal"><span class="pre">-b</span></span> to <span class="docutils literal"><span class="pre">a</span></span>, thus we only need
to adjust the checks. <span class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span> means <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MAX</span> <span class="pre">+</span> <span class="pre">b</span></span> if <span class="docutils literal"><span class="pre">b</span></span> is negative
(so we don’t cause an overflow during the check), while <span class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">MIN</span></span> means
<span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MIN</span> <span class="pre">+</span> <span class="pre">b</span></span> if <span class="docutils literal"><span class="pre">b</span></span> is greater than or equal to 0:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">SubtractionOverflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">SubtractionUnderflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Detecting overflow for multiplication is more interesting. <span class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span> can
happen if <span class="docutils literal"><span class="pre">b</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, and <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MAX</span> <span class="pre">/</span> <span class="pre">b</span></span> or when <span class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>,
<span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>, and <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MAX</span> <span class="pre">/</span> <span class="pre">b</span></span> (dividing <span class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span> on both sides by <span class="docutils literal"><span class="pre">b</span></span>,
a negative number, flips the sign of the inequality).</p>
<p>Underflow can happen only when one of the numbers is negative and the other one
isn’t. So if <span class="docutils literal"><span class="pre">b</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>, and <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MIN</span> <span class="pre">/</span> <span class="pre">b</span></span> or if <span class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>,
<span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, and <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MIN</span> <span class="pre">/</span> <span class="pre">b</span></span>.</p>
<p>We can implement the checks as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">MultiplicationOverflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="p">))</span>
        <span class="o">||</span> <span class="p">((</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">MultiplicationUnderflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="p">))</span>
        <span class="o">||</span> <span class="p">((</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note integer division cannot possibly underflow. The single overflow that can
happen is due to the fact that in two’s complement representation, we can
represent one more negative number than positives, as 0 is, in a sense, positive
with this representation (the sign bit is not set for 0). An 8-bit signed
integer can represent 128 positive values (0 to 127) and 128 negative values
(-1 to -128). Overflow can only happen when we change the sign of the smallest
possible value we can represent by dividing it with -1. -128 / -1 becomes 128,
which is an overflow. This is the only case we need to check for:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">DivisionOverflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that unsigned integers can never overflow, so once we confirm that <span class="docutils literal"><span class="pre">a</span></span>
is the smallest possible value and <span class="docutils literal"><span class="pre">b</span></span> is -1, we also check to ensure <span class="docutils literal"><span class="pre">a</span></span> is
not <span class="docutils literal"><span class="pre">0</span></span>.</p>
<p>We are explicitly not looking at division by 0, which is part of the same safe
arithmetic topic. This post focuses on overflow and underflow only.</p>
</div>
<div class="section" id="handling-overflow-and-underflow">
<h2>Handling Overflow and Underflow</h2>
<p>Now that we can detect overflows and underflows, we can implement a couple of
policies to handle them. Wrap-around is the default behavior in C++, so let’s
look at the other two possibilities. We will implement a couple of types
templated on an integer type <span class="docutils literal"><span class="pre">T</span></span>, with overflow and underflow handlers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Policy</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnOverflow</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The throwing policy looks like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nl">ArithmeticException</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">ArithmeticOverflowException</span> <span class="p">:</span> <span class="n">ArithmeticException</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">ArithmeticUnderflowException</span> <span class="p">:</span> <span class="n">ArithmeticException</span> <span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ThrowingPolicy</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnOverflow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArithmeticOverflowException</span><span class="p">{};</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArithmeticUnderflowException</span><span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The saturation policy is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">SaturationPolicy</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnOverflow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="safe-arithmetic">
<h2>Safe Arithmetic</h2>
<p>Now that we have all the required pieces, we can create a type that wraps an
integer type and implements all the arithmetic operations checking for overflow
or underflow. The type is templated on a policy for handling overflows and
underflows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">Policy</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Integer</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">AdditionOverflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnOverflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">AdditionUnderflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">return</span> <span class="p">{</span> <span class="n">value</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">constexpr</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">SubtractionOverflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnOverflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">SubtractionUnderflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">return</span> <span class="p">{</span> <span class="n">value</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">constexpr</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">MultiplicationOverflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnOverflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">MultiplicationUnderflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">return</span> <span class="p">{</span> <span class="n">value</span> <span class="o">*</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">constexpr</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">DivisionOverflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnOverflow</span><span class="p">();</span> <span class="p">}</span>

        <span class="k">return</span> <span class="p">{</span> <span class="n">value</span> <span class="o">/</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now we can wrap an integer type with this and perform safe arithmetic:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">Integer</span><span class="o">&lt;</span><span class="kt">int8_t</span><span class="p">,</span> <span class="n">ThrowingPolicy</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span> <span class="mi">64</span> <span class="p">};</span>
<span class="n">Integer</span><span class="o">&lt;</span><span class="kt">int8_t</span><span class="p">,</span> <span class="n">ThrowingPolicy</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span> <span class="mi">2</span> <span class="p">};</span>

<span class="c1">// Throws</span>
<span class="n">Integer</span><span class="o">&lt;</span><span class="kt">int8_t</span><span class="p">,</span> <span class="n">ThrowingPolicy</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a simple implementation for illustrative purposes. The <span class="docutils literal"><span class="pre">Integer</span></span> type
currently only defines addition, subtraction, multiplication, and division. A
complete implementation would handle multiple other operators, like pre and post
increment, implicit casting from <span class="docutils literal"><span class="pre">T</span></span> etc.</p>
<p>The generic overflow and underflow checks can be specialized for unsigned types
so that we don’t redundantly check for <span class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">0</span></span> for a type which cannot
represent negative numbers. Similarly, we wouldn’t worry, for example, about
addition underflowing for an unsigned type.</p>
<p>We can also extend our safe arithmetic to not only rely on the standard
<span class="docutils literal"><span class="pre">numeric_limits</span></span>, but also allow users to clamp values between user-defined
minimum and maximum values.</p>
<p>For a production-ready safe arithmetic library, I recommend you check out David
LeBlanc’s <a class="reference external" href="https://github.com/dcleblanc/SafeInt">SafeInt</a>.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This post covered arithmetic overflow and underflow, and ways to handle it. We
looked at:</p>
<ul class="simple">
<li>What arithmetic overflow and underflow are</li>
<li>Integer representations:<ul>
<li>Unsigned</li>
<li>Two’s complement</li>
</ul>
</li>
<li>Ways to deal with overflow/underflow:<ul>
<li>Exceptions</li>
<li>Wrap-around</li>
<li>Saturation</li>
</ul>
</li>
<li>How to detect overflow/underflow</li>
<li>Implementing a simple <span class="docutils literal"><span class="pre">Integer</span></span> wrapper that performs safe arithmetic</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>An example of how an attacker can exploit integer overflow is the
following <a class="reference external" href="https://www.kb.cert.org/vuls/id/945216">SSH1 vulnerability</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sat, 13 Oct 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/09/09/clean-code-types.html</link>
            <guid>http://vladris.com/blog/2018/09/09/clean-code-types.html</guid>
            <title><![CDATA[Clean Code: Types]]></title>
            <description><![CDATA[<h1>Clean Code: Types</h1>
<p>I recently revived my Clean Code tech talk which I put together a couple of
years ago and with which I started this blog:
<a class="reference external" href="https://vladris.com/blog/2016/01/04/clean-code-part-1.html">Clean Code - Part 1</a>
and <a class="reference external" href="https://vladris.com/blog/2016/01/07/clean-code-part-2.html">Clean Code - Part 2</a>.
I took the opportunity to completely revamp the talk and ended up with 3 parts:
<em>Algorithms</em>, <em>Types</em>, and <em>State</em>. The <em>Algorithms</em> is mostly covered by the
<a class="reference external" href="https://vladris.com/blog/2018/02/11/fibonacci.html">Fibonacci</a> post, so in
this post we will talk about <em>Types</em>.</p>
<div class="section" id="mars-climate-orbiter">
<h2>Mars Climate Orbiter</h2>
<p>The Mars Climate Orbiter crashed and disintegrated in the Mars atmosphere
because a component developed by Lockheed provided momentum measured in
pound-force seconds, while another component developed by NASA expected momentum
as Newton seconds.</p>
<p>We can image the component developed by NASA being something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Will not disintegrate as long as momentum &gt;= 2 N s</span>
<span class="kt">void</span> <span class="nf">trajectory_correction</span><span class="p">(</span><span class="kt">double</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">momentum</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="cm">/* N s */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">disintegrate</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also imagine the Lockheed component calling into the above with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="mf">1.5</span> <span class="cm">/* lbf s */</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A pound-force second (lbfs) is about 4.448222 Newton seconds (Ns). So from
Lockheed’s perspective, passing in 1.5 lbfs to <span class="docutils literal"><span class="pre">trajectory_correction</span></span> should
be just fine: 1.5 lbfs is about 6.672333 Ns, way above the 2 Ns threshold.</p>
<p>The problem is the interpretation of the data. The NASA component ends up
comparing lbfs to Ns without conversion, misinterpreting the lbfs input as Ns.
Since 1.5 is less than 2, the orbiter disintegrates. This is a known
anti-pattern called “primitive obsession”.</p>
</div>
<div class="section" id="primitive-obsession">
<h2>Primitive Obsession</h2>
<p>Primitive obsession happens when we use a primitive data type to represent a
value in the problem’s domain and causes situations like the above. Representing
zip codes as numbers, telephone numbers as strings, Ns and lbfs as <span class="docutils literal"><span class="pre">double</span></span>
are all examples of this.</p>
<p>A more type safe solution would have defined a simple <span class="docutils literal"><span class="pre">Ns</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Ns</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Ns</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ns</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can similarly define a simple <span class="docutils literal"><span class="pre">lbfs</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">lbfs</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">lbfs</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">lbfs</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can implement a type safe <span class="docutils literal"><span class="pre">trajectory_correction</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Will not disintegrate as long as momentum &gt;= 2 N s</span>
<span class="kt">void</span> <span class="nf">trajectory_correction</span><span class="p">(</span><span class="n">Ns</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">momentum</span> <span class="o">&lt;</span> <span class="n">Ns</span><span class="p">{</span> <span class="mi">2</span> <span class="p">})</span>
    <span class="p">{</span>
        <span class="n">disintegrate</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Calling this with <span class="docutils literal"><span class="pre">lbfs</span></span> as below fails to compile as the types are
incompatible:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">lbfs</span><span class="p">{</span> <span class="mf">1.5</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note how the meaning of the values, which used to be specified in comments
(<span class="docutils literal"><span class="pre">2</span> <span class="pre">/*</span> <span class="pre">Ns</span> <span class="pre">*/</span></span>, <span class="docutils literal"><span class="pre">/*</span> <span class="pre">lbfs</span> <span class="pre">*/</span></span>) gets pulled into the type system and expressed
in code (<span class="docutils literal"><span class="pre">Ns{</span> <span class="pre">2</span> <span class="pre">}</span></span>, <span class="docutils literal"><span class="pre">lbfs{</span> <span class="pre">1.5</span> <span class="pre">}</span></span>).</p>
<p>We can, of course, provide casting from <span class="docutils literal"><span class="pre">lbfs</span></span> to <span class="docutils literal"><span class="pre">Ns</span></span> as an explicit
operator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">lbfs</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">Ns</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="mf">4.448222</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Equipped with this, we can call <span class="docutils literal"><span class="pre">trajectory_correction</span></span> via a static cast:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Ns</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lbfs</span><span class="p">{</span> <span class="mf">1.5</span> <span class="p">}));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This does the right thing of multiplying by the ratio. The cast can also be
made implicit (by using the <span class="docutils literal"><span class="pre">implicit</span></span> keyword instead), in which case it is
applied automatically. As a rule of thumb, it’s best to follow the Zen of
Python:</p>
<blockquote>
<div>Explicit is better than implicit</div></blockquote>
<p>The moral of the story is that nowadays we have very sophisticated type checkers
but we do need to provide them enough information to catch this type of errors.
That information comes from declaring types to represent our problem domain.
<a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
</div>
<div class="section" id="state-space">
<h2>State Space</h2>
<p>Bad things happen when our programs end up in a <em>bad state</em>. Types help us
narrow down the possibility of such bad states. One way to think about this is
to look at types as sets of possible values. For example <span class="docutils literal"><span class="pre">bool</span></span> is the set
<span class="docutils literal"><span class="pre">{true,</span> <span class="pre">false}</span></span> where a variable of the type can be one of the two values.
Similarly, <span class="docutils literal"><span class="pre">uint32_t</span></span> is the set <span class="docutils literal"><span class="pre">{0</span> <span class="pre">...</span> <span class="pre">4294967295}</span></span>. Looking at types
like this, we can define the <em>state space</em> of our program as the product of
the types of all live variables at a given point in time.</p>
<p>If we have a <span class="docutils literal"><span class="pre">bool</span></span> and an <span class="docutils literal"><span class="pre">uint32_t</span></span>, our state space is <span class="docutils literal"><span class="pre">{true,</span> <span class="pre">false}</span> <span class="pre">X</span>
<span class="pre">{0</span> <span class="pre">...</span> <span class="pre">4294967295}</span></span>. This simply means that the two variables can be in any of
their possible states and since we have two of them, our program can be in any
of their combined states.</p>
<p>This gets more interesting when we look at functions that initialize values:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">bool</span> <span class="nf">get_momentum</span><span class="p">(</span><span class="n">Ns</span><span class="o">&amp;</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">some_condition</span><span class="p">())</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">momentum</span> <span class="o">=</span> <span class="n">Ns</span><span class="p">{</span> <span class="mi">3</span> <span class="p">};</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above example we take a <span class="docutils literal"><span class="pre">Ns</span></span> by reference and initialize it if some
condition is met. The function returns <span class="docutils literal"><span class="pre">true</span></span> if the value was properly
initialized. If the function cannot, for whatever reason, set the value, it
returns <span class="docutils literal"><span class="pre">false</span></span>.</p>
<p>Looking at this from the state space lens, our state space is the product
<span class="docutils literal"><span class="pre">bool</span> <span class="pre">X</span> <span class="pre">Ns</span></span>. If the function returns <span class="docutils literal"><span class="pre">true</span></span>, then <span class="docutils literal"><span class="pre">momentum</span></span> was set and
is in any one of the possible <span class="docutils literal"><span class="pre">Ns</span></span> values. The problem is that if the function
returns <span class="docutils literal"><span class="pre">false</span></span>, then <span class="docutils literal"><span class="pre">momentum</span></span> was not set. It is still in any one of the
possible <span class="docutils literal"><span class="pre">Ns</span></span> values, but it is not a valid value. Often times we have bugs
where we accidentally propagate such invalid state:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Ns</span> <span class="n">momenum</span><span class="p">;</span>

    <span class="n">get_momentum</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>

    <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What we should have done instead is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Ns</span> <span class="n">momentum</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">get_momentum</span><span class="p">(</span><span class="n">momentum</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a better way though, where this can be enforced:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Ns</span><span class="o">&gt;</span> <span class="n">get_momentum</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">some_condition</span><span class="p">())</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_optional</span><span class="p">(</span><span class="n">Ns</span><span class="p">{</span> <span class="mi">3</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using an <span class="docutils literal"><span class="pre">optional</span></span>, this version of the function has a significantly smaller
state space: instead of <span class="docutils literal"><span class="pre">bool</span> <span class="pre">X</span> <span class="pre">Ns</span></span>, we have <span class="docutils literal"><span class="pre">Ns</span> <span class="pre">+</span> <span class="pre">1</span></span>. The function either
returns a valid <span class="docutils literal"><span class="pre">Ns</span></span> value or <span class="docutils literal"><span class="pre">nullopt</span></span> to denote the absence of a value.
Now it becomes impossible to have an invalid <span class="docutils literal"><span class="pre">Ns</span></span> that gets propagated
throughout the system. We can also no longer <em>forget</em> to check the return value
as an <span class="docutils literal"><span class="pre">optional&lt;Ns&gt;</span></span> is not implicitly convertible to an <span class="docutils literal"><span class="pre">Ns</span></span> - we need to
explicitly unpack it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">maybeMomentum</span> <span class="o">=</span> <span class="n">get_momentum</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">maybeMomentum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">trajectory_correction</span><span class="p">(</span><span class="o">*</span><span class="n">maybeMomentum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In general, we want our functions to return <strong>result or error</strong> not
<strong>result and error</strong>. This way we eliminate the states in which we have an error
but also an invalid result which might make its way in further computation.</p>
<p>From this point of view, throwing exceptions is OK as this follows the same
pattern: a function either returns a result <strong>or</strong> throws an exception.</p>
</div>
<div class="section" id="raii">
<h2>RAII</h2>
<p>RAII stands for <em>Resource Acquisition Is Initialization</em> but has more to do
with releasing resources. The name originated from C++ but the pattern can be
implemented in any language (see, for example, .NET’s <span class="docutils literal"><span class="pre">IDisposable</span></span>). RAII
ensures automatic cleanup of resources.</p>
<p>What are resources? A few examples: heap memory, database connections, OS
handles. In general, a resource is something we acquire from the outside world
and we need to release when it is no longer needed. That means executing some
form of free, delete, close etc. on the resource.</p>
<p>Since these resources are external, they are not directly expressed into our
type system. For example if we allocate some heap memory, we get a pointer on
which we have to call <span class="docutils literal"><span class="pre">delete</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{};</span>

<span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>

    <span class="cm">/* Use foo */</span>

    <span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But what happens if we forget or something prevents us from calling <span class="docutils literal"><span class="pre">delete</span></span>?</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>

    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case we no longer call <span class="docutils literal"><span class="pre">delete</span></span> and we leak the resource. In general,
we don’t want to perform such manual cleanup. For heap memory, we actually have
<span class="docutils literal"><span class="pre">unique_ptr</span></span> to help us manage it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">unique_ptr</span></span> is a stack object so whenever it goes out of scope (when the
function throws or during stack unwinding if an exception was thrown) its
destructor gets called. It’s destructor implements the call to <span class="docutils literal"><span class="pre">delete</span></span>. This
way, we no longer have to manually manage the memory resource - we hand it off
to a wrapper which owns it and handles releasing it.</p>
<p>Similar wrappers exist or can be created for any of the other resources (for
example a Windows OS <span class="docutils literal"><span class="pre">HANDLE</span></span> can be wrapped in a type where its destructor
would call <span class="docutils literal"><span class="pre">CloseHandle</span></span>.</p>
<p>The key takeaway is never to do manual resource cleanup - either use an existing
wrapper or, if none exists for your particular scenario, implement one.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This post started with a famous example of why typing is important, and covered
three important aspects of leveraging types to write safer code:</p>
<ul class="simple">
<li>Declaring and using stronger types (as opposed to primitive obsession).</li>
<li>Reducing state space, returning result or error instead of result and error.</li>
<li>RAII and automatic resource management.</li>
</ul>
<p>Types are great tools for implementing safer, reusable code.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>There is a great series of posts on Fluent C++ on <a class="reference external" href="https://www.fluentcpp.com/category/strong-types/">Strong Typing</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sun, 09 Sep 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/07/16/implementing-a-variant-type-in-csharp.html</link>
            <guid>http://vladris.com/blog/2018/07/16/implementing-a-variant-type-in-csharp.html</guid>
            <title><![CDATA[Implementing a Variant Type in C#]]></title>
            <description><![CDATA[<h1>Implementing a Variant Type in C#</h1>
<p>A variant, or discriminated union type <a class="footnote-reference" href="#id2" id="id1">[1]</a>, is a type that can hold a value of
any of a finite set of types. For example, a <span class="docutils literal"><span class="pre">Variant&lt;int,</span> <span class="pre">string&gt;</span></span> can hold
either an <span class="docutils literal"><span class="pre">int</span></span> or a <span class="docutils literal"><span class="pre">string</span></span> value. This is also known as a <em>sum type</em>, as
its domain is the sum of the <span class="docutils literal"><span class="pre">int</span></span> and <span class="docutils literal"><span class="pre">string</span></span> domains. Contrast this with
a <span class="docutils literal"><span class="pre">Tuple&lt;int,</span> <span class="pre">string&gt;</span></span>, also known as a <em>product type</em>, which holds <em>both</em> an
<span class="docutils literal"><span class="pre">int</span></span> and a <span class="docutils literal"><span class="pre">string</span></span> (so its domain is the product of the <span class="docutils literal"><span class="pre">int</span></span> and
<span class="docutils literal"><span class="pre">string</span></span> domains).</p>
<p>First, let’s look at how something like this would be achieved without a
<span class="docutils literal"><span class="pre">Variant</span></span> type. Let’s take an expression tree where a node can be either an
<span class="docutils literal"><span class="pre">int</span></span> value or an expression consisting of an operation (let’s say addition
and multiplication) and two operands which are in turn nodes. We could implement
this by starting with an <span class="docutils literal"><span class="pre">INode</span></span> base interface and deriving our types from
that:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="n">Op</span> <span class="p">{</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span> <span class="p">}</span>

<span class="k">interface</span> <span class="n">INode</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">ExpressionNode</span> <span class="p">:</span> <span class="n">INode</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Op</span> <span class="n">Op</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">INode</span> <span class="n">Left</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">INode</span> <span class="n">Right</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ValueNode</span> <span class="p">:</span> <span class="n">INode</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, but has a couple of drawbacks – first, to discriminate between the
types allowed to be part of the tree and the types that aren’t, we need to
establish a typing relationship and force every type of node in our tree to
implement a dummy <span class="docutils literal"><span class="pre">INode</span></span> interface. In the case of a value, even though we
just need an <span class="docutils literal"><span class="pre">int</span></span>, we must wrap it into a <span class="docutils literal"><span class="pre">ValueNode</span></span> class because
<span class="docutils literal"><span class="pre">int</span></span> itself does not implement <span class="docutils literal"><span class="pre">INode</span></span>.</p>
<p>Another drawback is that in many cases we want to restrict the types that can
participate in our system (in this case our expression tree). This is harder to
enforce via an interface, as one could always implement some other <span class="docutils literal"><span class="pre">class</span>
<span class="pre">FooNode</span> <span class="pre">:</span> <span class="pre">INode</span></span> and there is no compile-time way to prevent this node from
becoming part of our tree.</p>
<p>This is how the above tree would be declared if we had a <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="n">Op</span> <span class="p">{</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">Expression</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Op</span> <span class="n">Op</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">Left</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">Right</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>First, we no longer need an <span class="docutils literal"><span class="pre">INode</span></span>, as it would get replaced by
<span class="docutils literal"><span class="pre">Variant&lt;Expression,</span> <span class="pre">int&gt;</span></span>, which effectively translates to <em>it’s either an
Expression or an int</em>. There is also no room to sneak in another type without
being explicit about it. We do not need to wrap <span class="docutils literal"><span class="pre">int</span></span> into another class
either just to make it conform to our hierarchy, as a <span class="docutils literal"><span class="pre">Variant</span></span> can handle it
directly.</p>
<p>So how would we go about designing such a generic variant in C#?</p>
<div class="section" id="design-considerations">
<h2>Design Considerations</h2>
<p>Our variant implementation should satisfy a few requirements:</p>
<ul>
<li><p class="first">Since C# does not support variadic generic arguments, we want implementations
from <span class="docutils literal"><span class="pre">Variant&lt;T1&gt;</span></span>, holding a value of a single type, up to
<span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2,</span> <span class="pre">T3,</span> <span class="pre">T4,</span> <span class="pre">T5,</span> <span class="pre">T6,</span> <span class="pre">T7,</span> <span class="pre">T8&gt;</span></span>, holding a value of any of 8
types. This is in line with how other library types like <span class="docutils literal"><span class="pre">Tuple</span></span> are
implemented.</p>
</li>
<li><p class="first">We want to support implicit casting from one of the generic types to the
variant, as this enables assignment:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">We want to support explicit casting from a variant to any of its generic
types. Since a variant might hold a value of a different type, we should be
explicit in this case, as a mismatch between the actual held value and the
cast-to type would throw an <span class="docutils literal"><span class="pre">InvalidCastException</span></span>.</p>
</li>
<li><p class="first">We need an API to get the value of the variant as a given type. A type
mismatch between the given type and the one actually held by the variant would
result in an <span class="docutils literal"><span class="pre">InvalidCastException</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>

<span class="kt">int</span> <span class="k">value</span> <span class="p">=</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
<span class="kt">string</span> <span class="k">value</span> <span class="p">=</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span> <span class="c1">// throws InvalidCastException</span>
</pre></div>
</div>
</li>
<li><p class="first">We need an API to check if the value of the variant is of a certain type:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>

<span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span> <span class="c1">// false</span>
<span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span> <span class="c1">// true</span>
</pre></div>
</div>
</li>
<li><p class="first">We need to support variants where the same type appears several times, like
<span class="docutils literal"><span class="pre">Variant&lt;int,</span> <span class="pre">int&gt;</span></span>. There are legitimate use cases for this, for example an
API that would return either an error code or a value, both being of the same
type. For such cases, we need another way to explicitly set a value as the
first, second, and so on type, and an <span class="docutils literal"><span class="pre">Index</span></span> property that would tell us
which occurrence of the type it is (as <span class="docutils literal"><span class="pre">Get&lt;int&gt;()</span> <span class="pre">called</span> <span class="pre">on</span> <span class="pre">a</span> <span class="pre">Variant&lt;int,</span>
<span class="pre">int&gt;</span></span> would succeed in returning us an <span class="docutils literal"><span class="pre">int</span></span>, but we wouldn’t be able to
tell whether it got in there as a <span class="docutils literal"><span class="pre">T1</span> <span class="pre">or</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">T2</span></span>.</p>
</li>
<li><p class="first">We would also provide a non-generic <span class="docutils literal"><span class="pre">Get()</span></span> which returns an <span class="docutils literal"><span class="pre">object</span></span>, so
we can use pattern matching on a variant:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="kt">string</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"It's a string: "</span> <span class="p">+</span> <span class="n">s</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="kt">int</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"It's an int: "</span> <span class="p">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">We need to override equality: two variants are equivalent if they are the
same type (same generic parameters), they contain values of the same type at
the same index, and the contained values are equivalent:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant1</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>
<span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant2</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>

<span class="n">variant1</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="n">variant2</span><span class="p">);</span> <span class="c1">// true</span>
</pre></div>
</div>
</li>
</ul>
<p>Given these requirements, let’s see how an implementation would look like.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<div class="section" id="api">
<h3>API</h3>
<p>We’ll start with a <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span> and build up from there. Adding more
generic arguments becomes easy once this implementation is figured out. Starting
from the simpler <span class="docutils literal"><span class="pre">Variant&lt;T1&gt;</span></span> would not uncover some of the issues mentioned
above, like the need for an index and ability to handle <span class="docutils literal"><span class="pre">T1</span></span> and  <span class="docutils literal"><span class="pre">T2</span></span> being
the same type. Let’s define our API based on the requirements:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="c1">// Variant API</span>
    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Index</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="c1">// T1 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="c1">// T2 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="c1">// Equality</span>
    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have the <span class="docutils literal"><span class="pre">Index</span></span> property which should be <span class="docutils literal"><span class="pre">0</span></span> if the variant is holding
a <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">1</span></span> if the variant is holding a <span class="docutils literal"><span class="pre">T2</span></span>. We’re using 0-based
indexing for this, though it is a bit awkward that generic arguments start, by
convention, from 1. This is in line with what other .NET types do, for example
<span class="docutils literal"><span class="pre">Tuple</span></span> provides a 0-based indexer.</p>
<p><span class="docutils literal"><span class="pre">It&lt;T&gt;()</span></span> allows callers to check if the variant is currently holding a
<span class="docutils literal"><span class="pre">T</span></span>, while <span class="docutils literal"><span class="pre">Get&lt;T&gt;()</span></span> should return a <span class="docutils literal"><span class="pre">T</span></span> or throw an
<span class="docutils literal"><span class="pre">InvalidCastException</span></span>. The non-generic version <span class="docutils literal"><span class="pre">Get()</span></span> simply returns an
<span class="docutils literal"><span class="pre">object</span></span>.</p>
<p>Below that, for both <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> we provide a constructor which takes a
<span class="docutils literal"><span class="pre">T1</span></span> (or <span class="docutils literal"><span class="pre">T2</span></span>) and places it in the variant, implicit casts from <span class="docutils literal"><span class="pre">T1</span></span> and
<span class="docutils literal"><span class="pre">T2</span></span> to <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span>, and explicit casts the other way around.</p>
<p>Finally, we override <span class="docutils literal"><span class="pre">Equals(object)</span></span> and <span class="docutils literal"><span class="pre">GetHashCode()</span></span> (it’s always a
good idea to override <span class="docutils literal"><span class="pre">GetHashCode</span></span> when overriding <span class="docutils literal"><span class="pre">Equals</span></span>).</p>
</div>
<div class="section" id="type-erasure">
<h3>Type erasure</h3>
<p>Let’s look at how we would store a value. Unlike a <span class="docutils literal"><span class="pre">Tuple&lt;T1,</span> <span class="pre">T2&gt;</span></span>, we don’t
want to store both a <span class="docutils literal"><span class="pre">T1</span></span> <em>and</em> a <span class="docutils literal"><span class="pre">T2</span></span>, rather we want either a <span class="docutils literal"><span class="pre">T1</span></span> <em>or</em>
a <span class="docutils literal"><span class="pre">T2</span></span>. In order to generalize this, we need a way to perform type-erasure,
which means a way to store any type (as we want a generic implementation), while
at the same type we need to keep track of the stored type so we can answer
<span class="docutils literal"><span class="pre">Is&lt;T&gt;()</span></span> properly. Let’s create a <span class="docutils literal"><span class="pre">VariantHolder</span></span> to handle this.</p>
<p>We could achieve this by storing everything as an <span class="docutils literal"><span class="pre">object</span></span>
(type-erasure) and a <span class="docutils literal"><span class="pre">Type</span></span> (for type information), like this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">sealed</span> <span class="k">class</span> <span class="nc">VariantHolder</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">private</span> <span class="n">Type</span> <span class="n">_itemType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">==</span> <span class="n">_itemType</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">VariantHolder</span><span class="p">(</span><span class="kt">object</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Item</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">_itemType</span> <span class="p">=</span> <span class="n">item</span><span class="p">.</span><span class="n">GetType</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can then implement our variant in terms of this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">VariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VariantHolder</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="cm">/* ...</span>
<span class="cm">       Same for T2, ignoring Equals() and GetHashCode() for now */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This implementation is not quite correct, as it stores too much type
information:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="p">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span>

<span class="cm">/* ... */</span>

<span class="n">Variant</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
<span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">&gt;();</span> <span class="c1">// == false!</span>
</pre></div>
</div>
<p>We are comparing the actual type of the item, though we should store it as one
of the generic types of the variant declaration. A better idea is to make our
<span class="docutils literal"><span class="pre">VariantHolder</span></span> itself generic:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">sealed</span> <span class="k">class</span> <span class="nc">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">VariantHolder</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Item</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This gets us rid of the extra <span class="docutils literal"><span class="pre">_itemType</span></span> member (we can use <span class="docutils literal"><span class="pre">typeof(T)</span></span> on
the generic parameter), but we have another problem: how do we declare this in
our <span class="docutils literal"><span class="pre">Variant</span></span>? If we make it a <span class="docutils literal"><span class="pre">VariantHolder&lt;T1&gt;</span></span>, then we won’t be able
to store a <span class="docutils literal"><span class="pre">T2</span></span> value and vice-versa. There is a way around this - we can
extract an interface:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IVariantHolder</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="kt">object</span> <span class="nf">Get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can declare that our <span class="docutils literal"><span class="pre">VariantHolder&lt;T&gt;</span></span> implements this interface (it
already does, as it has both a generic <span class="docutils literal"><span class="pre">Is</span></span> and a non-generic <span class="docutils literal"><span class="pre">Get</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">sealed</span> <span class="k">class</span> <span class="nc">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IVariantHolder</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">VariantHolder</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Item</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And now we can implement our <span class="docutils literal"><span class="pre">Variant</span></span> in terms of an <span class="docutils literal"><span class="pre">IVariantHolder</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">IVariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">((</span><span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">variant</span><span class="p">).</span><span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="c1">// T1 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="c1">// T2 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;();</span>

    <span class="cm">/* ...</span>
<span class="cm">       Ignoring Equals() and GetHashCode() for now */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">Get&lt;T&gt;()</span></span> we use a cast to <span class="docutils literal"><span class="pre">VariantHolder&lt;T&gt;</span></span> as opposed to
<span class="docutils literal"><span class="pre">(T)_variantHolder.Get()</span></span> as this avoids an extra boxing operation if <span class="docutils literal"><span class="pre">T</span></span>
is a value type. This correctly throws <span class="docutils literal"><span class="pre">InvalidCastException</span></span> if called with
the wrong type. If we wanted to throw a different exception or add more details
to the exception, we could either wrap this cast in a try/catch and catch an
<span class="docutils literal"><span class="pre">InvalidCastException</span></span> or we could check the type using <span class="docutils literal"><span class="pre">Is&lt;T&gt;()</span></span> before
performing the cast.</p>
</div>
<div class="section" id="index-and-disambiguation">
<h3>Index and disambiguation</h3>
<p>The only problem with this implementation is that we cannot instantiate a
variant if <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> are the same:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>
</pre></div>
</div>
<p>yields a compiler error: “Ambiguous user defined conversions”. If we try calling
the constructor:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;(</span><span class="m">42</span><span class="p">);</span>
</pre></div>
</div>
<p>we get “The call is ambiguous between the following methods…”. If <span class="docutils literal"><span class="pre">T1</span></span> and
<span class="docutils literal"><span class="pre">T2</span></span> are the same type, there is no way to disambiguate between constructors
and casts. Because of this, we need to add our <span class="docutils literal"><span class="pre">Index</span></span> property and provide a
way to explicitly construct the variant with an index. First, let’s add
<span class="docutils literal"><span class="pre">Index</span></span> to our current implementation:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">IVariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Index</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">((</span><span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">variant</span><span class="p">).</span><span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">private</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">variant</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">Index</span> <span class="p">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;();</span>

    <span class="cm">/* ...</span>
<span class="cm">       Ignoring Equals() and GetHashCode() for now */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We added a read-only <span class="docutils literal"><span class="pre">Index</span></span> property, a private constructor that not only
sets the <span class="docutils literal"><span class="pre">IVariantHolder</span></span> but also the <span class="docutils literal"><span class="pre">Index</span></span>, and we updated our two
constructors, <span class="docutils literal"><span class="pre">Variant(T1</span> <span class="pre">item)</span></span> and <span class="docutils literal"><span class="pre">Variant(T2</span> <span class="pre">item)</span></span> to internally call
this private constructor with the correct index.</p>
<p>Now we have an <span class="docutils literal"><span class="pre">Index</span></span> property which accurately keeps track of the index of
the type stored, so for a <span class="docutils literal"><span class="pre">Variant&lt;int,</span> <span class="pre">int&gt;</span></span> we would be able to tell
whether we set the first or second <span class="docutils literal"><span class="pre">int</span></span>, but we still can’t disambiguate
between constructor calls if <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> are the same. We can solve this
by adding a couple of explicit factory methods:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make1</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">);</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make2</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">);</span>
</pre></div>
</div>
<p>We could have provided a way for the callers to explicitly provide an index,
but it becomes hard to enforce that the index is in sync with the type. If
<span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> are the same, then the caller ultimately decides the index,
but if <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> are different, then <span class="docutils literal"><span class="pre">Variant</span></span> needs to decide the
index.</p>
<p>Providing <span class="docutils literal"><span class="pre">Make1</span></span> and <span class="docutils literal"><span class="pre">Make2</span></span> works, since <span class="docutils literal"><span class="pre">Make1</span></span> only accepts a <span class="docutils literal"><span class="pre">T1</span></span>
argument while <span class="docutils literal"><span class="pre">Make2</span></span> only accepts a <span class="docutils literal"><span class="pre">T2</span></span> argument. Thus, if they are the
same, the caller disambiguates by calling one of the methods and there is no
compilation issue. If they are different, calling one of them is the equivalent
of calling one of the constructors (there is no way to call <span class="docutils literal"><span class="pre">Make1</span></span> with a
<span class="docutils literal"><span class="pre">T2</span></span> argument).</p>
</div>
<div class="section" id="equality">
<h3>Equality</h3>
<p>Now the only remaining bit is overriding <span class="docutils literal"><span class="pre">Equals</span></span>, as we want two variants
containing equivalent values to be equivalent. In other words, given another
object, we would consider it equivalent if it has the same type as this object,
has the value <em>at the same index</em>, and the value of the other object is
equivalent to the value of this object:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="p">!(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;))</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">other</span> <span class="p">=</span> <span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;)</span><span class="n">obj</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">Index</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Index</span> <span class="p">&amp;&amp;</span> <span class="n">Get</span><span class="p">().</span><span class="n">Equals</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Overriding <span class="docutils literal"><span class="pre">Equals</span></span> usually means overriding <span class="docutils literal"><span class="pre">GetHashCode</span></span> in such a way
that equivalent objects hash to the same value. In our case, we can rely on the
value stored in the variant to implement this by simply delegating hashing to
it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
    <span class="p">=&gt;</span> <span class="n">Get</span><span class="p">().</span><span class="n">GetHashCode</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="multiple-generic-arguments">
<h3>Multiple generic arguments</h3>
<p>We have an implementation for a <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span> but we are looking at
providing variants from <span class="docutils literal"><span class="pre">Variant&lt;T1&gt;</span></span> all the way to <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2,</span> <span class="pre">T3,</span> <span class="pre">T4,</span>
<span class="pre">T5,</span> <span class="pre">T6,</span> <span class="pre">T7,</span> <span class="pre">T8&gt;</span></span>.</p>
<p>First, let’s look at what would be common to all of these. The API (<span class="docutils literal"><span class="pre">Is&lt;T&gt;</span></span>,
<span class="docutils literal"><span class="pre">Get&lt;T&gt;</span></span> etc.) is implemented in terms of <span class="docutils literal"><span class="pre">IVariantHolder</span></span>. Let’s extract
this into a base class. Since we are going to make all our variants derive from
it, it must be <span class="docutils literal"><span class="pre">public</span></span>, but we probably don’t want clients to derive from it
as it is an implementation detail, so we will provide an <span class="docutils literal"><span class="pre">internal</span></span>
constructor. This will make this class instantiable only within the assembly
declaring it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">VariantBase</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IVariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Index</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">((</span><span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">variant</span><span class="p">).</span><span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">internal</span> <span class="nf">VariantBase</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">variant</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">Index</span> <span class="p">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span> ends up containing only the constructors, casts, and
equality:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">VariantBase</span>
<span class="p">{</span>
    <span class="c1">// Calls base constructor</span>
    <span class="k">private</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// T1 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make1</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">);</span>

    <span class="c1">// T2 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make2</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">);</span>

    <span class="c1">// Equality</span>
    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="p">!(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;))</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">other</span> <span class="p">=</span> <span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;)</span><span class="n">obj</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">Index</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Index</span> <span class="p">&amp;&amp;</span> <span class="n">Get</span><span class="p">().</span><span class="n">Equals</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="n">Get</span><span class="p">().</span><span class="n">GetHashCode</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can even hoist <span class="docutils literal"><span class="pre">Equals</span></span> to our base class, since we can replace the <span class="docutils literal"><span class="pre">is</span></span>
check <span class="docutils literal"><span class="pre">!(obj</span> <span class="pre">is</span> <span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;)</span></span> with <span class="docutils literal"><span class="pre">GetType()</span> <span class="pre">!=</span> <span class="pre">obj.GetType()</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">VariantBase</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IVariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Index</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">((</span><span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">variant</span><span class="p">).</span><span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">internal</span> <span class="nf">VariantBase</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">variant</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">Index</span> <span class="p">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">GetType</span><span class="p">()</span> <span class="p">!=</span> <span class="n">obj</span><span class="p">.</span><span class="n">GetType</span><span class="p">())</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">other</span> <span class="p">=</span> <span class="p">(</span><span class="n">VariantBase</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">Index</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Index</span> <span class="p">&amp;&amp;</span> <span class="n">Get</span><span class="p">().</span><span class="n">Equals</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="n">Get</span><span class="p">().</span><span class="n">GetHashCode</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now our <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span> contains only constructors and casts:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">VariantBase</span>
<span class="p">{</span>
    <span class="c1">// Calls base constructor</span>
    <span class="k">private</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// T1 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make1</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">);</span>

    <span class="c1">// T2 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make2</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While C# doesn’t provide a way to implement variable number of generic
arguments, constructors and casts for all types are identical, so we can use a
<a class="reference external" href="https://docs.microsoft.com/en-us/visualstudio/modeling/design-time-code-generation-by-using-t4-text-templates">T4 text template</a>
to generate all this code. Our template would iterate for each type and emit the
C# code for these:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>&lt;#
for (int types = 1; types &lt;= 8; types++)
{
    // Comma-delimited string of types (eg. "T1, T2, T3")
    var args = String.Join(", ",
        Enumerable.Range(1, types).Select(i =&gt; "T" + i));

    // Type we are generating code for (eg. "Variant&lt;T1, T2, T3&gt;")
    var type = $"Variant&lt;{args}&gt;";
#&gt;

    public sealed class &lt;#= type #&gt; : VariantBase
    {
        private Variant(IVariantHolder item, byte index)
            : base(item, index)
        {}

&lt;#
    // For each type argument T1, T2, T3 etc.
    for (int i = 1; i &lt;= types; i++)
    {
#&gt;
        public Variant(T&lt;#= i #&gt; item)
            : base(new VariantHolder&lt;T&lt;#= i #&gt;&gt;(item), &lt;#= i - 1 #&gt;)
        {}

        public static implicit operator &lt;#= type #&gt;(T&lt;#= i #&gt; item)
            =&gt; new &lt;#= type #&gt;(item);

        public static explicit operator T&lt;#= i #&gt;(&lt;#= type #&gt; variant)
            =&gt; variant.Get&lt;T&lt;#= i #&gt;&gt;();

        public static &lt;#= type #&gt; Make&lt;#= i #&gt;(T&lt;#= i #&gt; item)
            =&gt; new &lt;#= type #&gt;(new VariantHolder&lt;T&lt;#= i #&gt;&gt;(item), &lt;#= i - 1 #&gt;);
&lt;#
    }
#&gt;
    }

&lt;#
}
#&gt;
</pre></div>
</div>
<p>I will not cover T4 templates in this blog post, just highlight that the
template above does generate all the <span class="docutils literal"><span class="pre">Variant&lt;&gt;</span></span> variations with the
appropriate constructors and cats.</p>
<p>I am currently working on a type library which includes this variant and some
other useful types: <a class="reference external" href="https://github.com/vladris/Maki">https://github.com/vladris/Maki</a>.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post we implemented a generic variant type in C#, going over:</p>
<ul class="simple">
<li>Variant types and how they are useful.</li>
<li>Requirements for a variant type.</li>
<li>Implementation:<ul>
<li>API.</li>
<li>Type erasure.</li>
<li>Disambiguating between similar generic arguments.</li>
<li>Overrides for <span class="docutils literal"><span class="pre">Equals</span></span> and <span class="docutils literal"><span class="pre">GetHashCode</span></span>.</li>
<li>Implementations for various numbers of generic arguments.</li>
</ul>
</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>See <a class="reference external" href="https://en.wikipedia.org/wiki/Tagged_union">“tagged union” on Wikipedia</a></td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Mon, 16 Jul 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/06/23/ioc-containers.html</link>
            <guid>http://vladris.com/blog/2018/06/23/ioc-containers.html</guid>
            <title><![CDATA[IoC Containers]]></title>
            <description><![CDATA[<h1>IoC Containers</h1>
<p>In this post I will go over the basics of IoC containers and walk through a very
simple C# implementation.</p>
<div class="section" id="motivation">
<h2>Motivation</h2>
<p>An inversion of control container is a component that encapsulates dependency
injection and lifetime management of other components <a class="footnote-reference" href="#id3" id="id1">[1]</a>. Assume we have some
well componentized code where classes work against interfaces:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">DoFoo</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">:</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">DoFoo</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Bar</span>
<span class="p">{</span>
    <span class="c1">// Coded against IFoo interface, so decoupled from</span>
    <span class="c1">// concrete Foo implementation</span>
    <span class="k">public</span> <span class="nf">Bar</span><span class="p">(</span><span class="n">IFoo</span> <span class="n">foo</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">foo</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to create an instance of <span class="docutils literal"><span class="pre">Bar</span></span>, we need to pass it some <span class="docutils literal"><span class="pre">IFoo</span></span>
object. We could do it by <span class="docutils literal"><span class="pre">new</span></span>-ing up a <span class="docutils literal"><span class="pre">Foo</span></span> object at the call site of
<span class="docutils literal"><span class="pre">Bar</span></span>’s constructor:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">bar</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">());</span>
</pre></div>
</div>
<p>This doesn’t scale very well though. Most classes require more than one
dependency, so we can’t realistically litter the code with:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">(</span><span class="k">new</span> <span class="n">C</span><span class="p">(),</span> <span class="k">new</span> <span class="n">D</span><span class="p">()),</span> <span class="k">new</span> <span class="n">E</span><span class="p">(</span><span class="k">new</span> <span class="n">D</span><span class="p">()));</span>
</pre></div>
</div>
<p>Factory functions address part of the problem. We can have, for example:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="n">IA</span> <span class="nf">MakeIA</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="p">(</span><span class="n">MakeIB</span><span class="p">(),</span> <span class="n">MakeIE</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another advantage of using factory functions instead of directly calling
constructors is that a factory can encapsulate lifetime of objects. Changing
from a new instance on every call to a singleton can be encapsulated in the
factory so callers of <span class="docutils literal"><span class="pre">MakeIA</span></span> don’t need to change.</p>
<p>We would then call <span class="docutils literal"><span class="pre">MakeIA</span></span> whenever we needed an <span class="docutils literal"><span class="pre">IA</span></span> instance. But where
do these factories belong? They do not belong with the concrete types they are
implementing, because having a static <span class="docutils literal"><span class="pre">MakeIA</span></span> on class <span class="docutils literal"><span class="pre">A</span></span> would still
require callers to reference <span class="docutils literal"><span class="pre">A</span></span> (as in <span class="docutils literal"><span class="pre">A.MakeIA()</span></span>). Since these
factories become the only places in the system where knowledge of which type
resolves to which interface, it makes sense to keep them together:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">class</span> <span class="nc">Factories</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IA</span> <span class="nf">MakeIA</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="p">(</span><span class="n">MakeIB</span><span class="p">(),</span> <span class="n">MakeIE</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IB</span> <span class="nf">MakeIB</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="p">(</span><span class="n">MakeIC</span><span class="p">(),</span> <span class="n">MakeID</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IC</span> <span class="nf">MakeIC</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">C</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">ID</span> <span class="nf">MakeID</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">D</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IE</span> <span class="nf">MakeIE</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">E</span><span class="p">(</span><span class="n">MakeID</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works pretty well: changing which concrete type binds to an interface
becomes a changed scoped to one of the factories. But maintaining this by hand
can become tedious. The good news is it can be automated, which is what an IoC
container does.</p>
</div>
<div class="section" id="a-basic-ioc-container">
<h2>A Basic IoC Container</h2>
<p>A very basic container would be able to bind a concrete implementation against
an interface and return an instance of the concrete implementation when asked
for an interface:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The simplest possible thing to pass to <span class="docutils literal"><span class="pre">Register</span></span> is a factory function, in
which case our container would have to maintain a mapping from type to
factory:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">_registeredTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is how it can be used:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(),</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;()));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">B</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(),</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;()));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">C</span><span class="p">());</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">D</span><span class="p">());</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">E</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;()));</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>This is fine, but still requires a lot of hand-maintenance. One of the main
features of a container is the ability to use reflection and resolve some of
these dependencies automatically. Given a type, we can find its first public
constructor by calling <span class="docutils literal"><span class="pre">GetConstructor</span></span> on it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">param</span> <span class="k">in</span> <span class="k">typeof</span><span class="p">(</span><span class="n">A</span><span class="p">).</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">().</span><span class="n">GetParameters</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So given a type, we should be able to generate a factory function for it. A
simple way of doing it is by calling <span class="docutils literal"><span class="pre">Invoke</span></span> on the retrieved constructor
and attempting to retrieve all its arguments from the container:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">constructor</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span><span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
            <span class="n">param</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]()</span>
        <span class="p">).</span><span class="n">ToArray</span><span class="p">());</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now registering the interfaces becomes a lot easier:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">B</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">C</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">D</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">E</span><span class="p">));</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>It’s usually a good idea to support registration by both type and factory
function, for cases where the construction is more involved or the types of the
constructor arguments, for various reasons, are not registered with the
container.</p>
<div class="section" id="efficient-construction">
<h3>Efficient Construction</h3>
<p>Calling <span class="docutils literal"><span class="pre">Invoke</span></span> on a <span class="docutils literal"><span class="pre">ConstructorInfo</span></span> is notoriously slow <a class="footnote-reference" href="#id4" id="id2">[2]</a>. There are
several strategies to make this invocation faster. One of them is by using
<span class="docutils literal"><span class="pre">System.Linq.Expressions</span></span>, which are a set of types that help declare and
compile lambdas at runtime:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">(</span>
        <span class="n">Expression</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span> <span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
            <span class="n">param</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
                <span class="k">return</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span>
                    <span class="n">Expression</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">Expression</span><span class="p">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">resolve</span><span class="p">.</span><span class="n">Target</span><span class="p">),</span> <span class="n">resolve</span><span class="p">.</span><span class="n">Method</span><span class="p">),</span>
                    <span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">))).</span><span class="n">Compile</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above implementation compiles a lambda which is equivalent to the
<span class="docutils literal"><span class="pre">Invoke</span></span> logic. There are several other techniques to dynamically generate
functions, including <span class="docutils literal"><span class="pre">Reflection.Emit</span></span> and
<span class="docutils literal"><span class="pre">System.Runtime.CompilerServices</span></span>. Another decision point is whether
resolution is done lazily or not. The above implementation is lazy, resolving
each constructor parameter does not require an entry for it in the container
when this particular lambda is compiled. The relevant line is:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
</pre></div>
</div>
<p>If we were to replace this with:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">];</span>
</pre></div>
</div>
<p>it would fail to compile the lambda when registering <span class="docutils literal"><span class="pre">A</span></span> unless all other
dependencies are already in the container. This approach is flexible, in that
type bindings can be resolved at runtime, but can incur a bit more overhead. An
alternative would be to register all types with the container first, then
generate the factories in a separate step. In that case, for each type, we
could map out exactly what calls need to be made to set it up based on
information already available to the container. Such an implementation gets
more complex, so I won’t go into the details, but worth noting that it is
possible.</p>
</div>
</div>
<div class="section" id="lifetimes">
<h2>Lifetimes</h2>
<p>Containers also encapsulate lifetime management. The most basic non-instance
lifetime is singleton, which means a unique instance during the lifetime of the
app. Let’s extend our container to also support resolving singletons. First we
need a way to wrap a factory into a function that only calls it once, then
caches the result:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">private</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">factory</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This relies on <span class="docutils literal"><span class="pre">Lazy</span></span> to ensure uniqueness. Now we can enable singleton
registrations for factories and types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">MarkSingleton</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
<span class="p">{</span>
    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This effectively decorated the registered factory with the singleton logic.
There are various other lifetimes an object could require, for example:
threaded (where instances are cached per thread, so the same instance is always
returned on the same thread but not across threads), scoped (where there is an
API to mark beginning and end of a scope within which the same instance is
always returned, but another one gets created in another scope) etc.</p>
</div>
<div class="section" id="a-note-on-loading">
<h2>A Note on Loading</h2>
<p>One interesting observation made while profiling a .NET application is that a
container usually forces the loading of all referenced assembly. The .NET
runtime defers assembly loading until a method is called which references a
type in a not-yet-loaded assembly. This forces assembly loading as the runtime
needs the metadata of the type. When using an IoC container, all types are
usually registered as soon as the application boots, in which case all
assemblies get pulled in during registration time (as opposed to on-demand at a
later time).</p>
</div>
<div class="section" id="resources">
<h2>Resources</h2>
<p>The complete source code for the container in this blog post is:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">_registeredTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">(</span>
            <span class="n">Expression</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span> <span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
                <span class="n">param</span> <span class="p">=&gt;</span>
                <span class="p">{</span>
                    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
                    <span class="k">return</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span>
                        <span class="n">Expression</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">Expression</span><span class="p">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">resolve</span><span class="p">.</span><span class="n">Target</span><span class="p">),</span> <span class="n">resolve</span><span class="p">.</span><span class="n">Method</span><span class="p">),</span>
                        <span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">))).</span><span class="n">Compile</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">MarkSingleton</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">factory</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>I also recently open-sourced a minimal container <a class="reference external" href="https://github.com/microsoft/minioc">here</a>. That implementation includes support
for scoped lifetimes, but otherwise it is still very minimal. It was used in a
couple of small projects where constraints were around size/dependent assemblies
rather than feature richness.</p>
<p>For a popular open source container with many more features, check out <a class="reference external" href="https://autofac.org/">AutoFac</a>.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post we went over a few IoC container basics:</p>
<ul class="simple">
<li>Motivation for containers.</li>
<li>A primitive container supporting factory registration.</li>
<li>Using reflection to support type registration.</li>
<li>Approaches to implementing constructor calls: <span class="docutils literal"><span class="pre">Inove</span></span>, <span class="docutils literal"><span class="pre">Linq.Expressions</span></span>,
others. Lazy resolution vs. generating constructor calls in a separate step.</li>
<li>Lifetime management and a singleton implementation.</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For a much more detailed treatment, see Martin Fowler’s
<a class="reference external" href="https://www.martinfowler.com/articles/injection.html">article</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>An interesting benchmark on <a class="reference external" href="https://stackoverflow.com/questions/35805609/performance-of-expression-compile-vs-lambda-direct-vs-virtual-calls">Stack Overflow</a></td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sat, 23 Jun 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/04/15/kami-2.html</link>
            <guid>http://vladris.com/blog/2018/04/15/kami-2.html</guid>
            <title><![CDATA[Kami 2]]></title>
            <description><![CDATA[<h1>Kami 2</h1>
<p><a class="reference external" href="https://itunes.apple.com/us/app/kami-2/id1133161444">Kami 2</a> is an iOS game
where the player folds colored paper with the goal of making the whole screen
have the same color. Each level has a set of colors and the player can pick any
of them, color a section, then repeat for a limited number of steps:</p>
<img alt="../../../_images/kami-animation.gif" class="align-center" src="http://vladris.com/blog/_images/kami-animation.gif"/>
<p>Some levels are fairly tricky. For example I got stuck on this one:</p>
<img alt="../../../_images/kami-screenshot.png" class="align-center" src="http://vladris.com/blog/_images/kami-screenshot.png"/>
<p>While the app can provide hints, a more interesting exercise is to see if we can
solve this with an algorithm. We can look at this as a graph problem. Each
colored section represents a node in the graph and we consider adjacent areas as
connected by edges:</p>
<img alt="../../../_images/kami-graph.png" class="align-center" src="http://vladris.com/blog/_images/kami-graph.png"/>
<p>Here is a more abstract representation of the same level:</p>
<img alt="../../../_images/graph.png" class="align-center" src="http://vladris.com/blog/_images/graph.png"/>
<p>The only information we care about is the color of each node and what other
nodes it is connected with.</p>
<p>A step in the game consists of choosing a color, picking a node to get colored
with the chosen colore, then merging the colored node with adjacent nodes of
the same (new) color. The game is won if the nodes get merged down to a single
node within the step limit.</p>
<p>A Python representation of the graph would look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">edges</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
</pre></div>
</div>
<p>We represent nodes as a dictionary where the key is the node id and the value is
the color of the node, and edge as a list of pairs of ids. The level diagramed above would be represented as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="s2">"Red"</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">5</span><span class="p">:</span> <span class="s2">"White"</span><span class="p">,</span>
            <span class="mi">6</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">7</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">8</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">9</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">10</span><span class="p">:</span> <span class="s2">"Red"</span><span class="p">,</span>
            <span class="mi">11</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">12</span><span class="p">:</span> <span class="s2">"White"</span><span class="p">,</span>
            <span class="mi">13</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">14</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">15</span><span class="p">:</span> <span class="s2">"White"</span><span class="p">,</span>
            <span class="mi">16</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">17</span><span class="p">:</span> <span class="s2">"Red"</span><span class="p">,</span>
            <span class="mi">18</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span>
        <span class="p">])</span>
</pre></div>
</div>
<p>We need a function that, for a given node id, enumerates all the connected
nodes. This is a member function of the graph:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>We also need a function that colors a node and merges it with adjacent nodes of
the same color. We can make this function return a new graph instance with the
applied updates. Its signature would be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
</pre></div>
</div>
<p>First it would have to determine the set of nodes that need to be merged after
coloring. That is the node that just got colored and adjacent nodes which have
the same color as its new color. By convention, when we merge nodes we keep the
smallest id:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
<span class="n">to_merge</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">]</span>
<span class="n">new_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">to_merge</span><span class="p">)</span>
</pre></div>
</div>
<p>The nodes of the new graph would be the same nodes as the old one, minus any
node in <span class="docutils literal"><span class="pre">to_merge</span></span>. Nodes in the <span class="docutils literal"><span class="pre">to_merge</span></span> list would be represented by the
node <span class="docutils literal"><span class="pre">new_n</span></span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">new_nodes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">new_n</span><span class="p">:</span> <span class="n">color</span> <span class="p">}</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
        <span class="n">new_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
</pre></div>
</div>
<p>We also need to build the new list of edges. We do this as follows: for each
edge, if both nodes are in <span class="docutils literal"><span class="pre">to_merge</span></span>, the edge does not exist in the new
graph so we discard it. If one node is in <span class="docutils literal"><span class="pre">to_merge</span></span>, we create a new edge
where the node in <span class="docutils literal"><span class="pre">to_merge</span></span> is replaced by <span class="docutils literal"><span class="pre">new_n</span></span>. If none of the nodes
is in <span class="docutils literal"><span class="pre">to_merge</span></span>, we keeep the edge:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">new_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
        <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">new_n</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))))</span>
    <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
        <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_n</span><span class="p">))))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
</pre></div>
</div>
<p>We keep the edge tuples sorted by node id to avoid duplication (for example
having both a <span class="docutils literal"><span class="pre">(1,</span> <span class="pre">3)</span></span> and a <span class="docutils literal"><span class="pre">(3,</span> <span class="pre">1)</span></span>). We return a graph consiting of
<span class="docutils literal"><span class="pre">new_nodes</span></span> and <span class="docutils literal"><span class="pre">new_edges</span></span>. The full implementation of <span class="docutils literal"><span class="pre">color</span></span> is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
    <span class="n">to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="n">to_merge</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">]</span>
    <span class="n">new_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">to_merge</span><span class="p">)</span>

    <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">new_n</span><span class="p">:</span> <span class="n">color</span> <span class="p">}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
            <span class="n">new_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

    <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
            <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">new_n</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))))</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
            <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_n</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">)</span>
</pre></div>
</div>
<p>To solve a level we try coloring all of the nodes then recursively solve for the
new graph. If our graph has one node, we found a solution. If we run out of
steps, our candidate solution is not good so we backtrack:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
        <span class="nb">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node</span><span class="p">)]))</span>
        <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">steps</span> <span class="o">+</span> <span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">)],</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <span class="docutils literal"><span class="pre">graph</span></span> is the graph we are trying to solve, <span class="docutils literal"><span class="pre">steps</span></span> is the list of
actions in our solution, consisting of pairs of node id and color, and <span class="docutils literal"><span class="pre">n</span></span> is
the remaining number of steps.</p>
<p>Note that we don’t attempt to color a node with any random color, rather we want
to color it with the color of one of its adjacent nodes. The reason for this is
that such a coloring guarantees <em>some</em> nodes will get merged so we reduce the
total number of nodes with this step. If we were to color a node with a color
none of its adjacent nodes has, there would be nothing to merge so we would
waste a step without reducing the graph.</p>
<p>This solution works but is rather slow. One optimization we can do is to more
aggressively prune our search space: if at any point our graph has more colors
than the number of remaining steps + 1, we know we are down the wrong path and
need to backtrack. As an example, if we have four colors on the board: blue,
red, yellow, white, but we only have 2 steps left, no matter how the areas are
connected, we can never end up with a single color in 2 steps as we need to
recolor 3 areas.</p>
<p>We can implement this optimization by updating the <span class="docutils literal"><span class="pre">Graph</span></span> constructor to
keep track of the number of unique colors and update our <span class="docutils literal"><span class="pre">solve</span></span> function to
backtrack if we have more colors than steps + 1:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">edges</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
</pre></div>
</div>
<p>The update is the last line, which maintains the count of unique values in the
<span class="docutils literal"><span class="pre">nodes</span></span> dictionary. Updated <span class="docutils literal"><span class="pre">solve</span></span> looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
        <span class="nb">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">colors</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node</span><span class="p">)]))</span>
        <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">steps</span> <span class="o">+</span> <span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">)],</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We introduced a new <span class="docutils literal"><span class="pre">if</span></span> statement that returns if <span class="docutils literal"><span class="pre">graph.colors</span> <span class="pre">&gt;</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></span>.</p>
<p>Running this yields the following solution for the level:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">'Purple'</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s1">'White'</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">'Yellow'</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Purple'</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Red'</span><span class="p">)]</span>
</pre></div>
</div>
<p>So coloring node 10 with purple, then node 8 with white and so on solves the
level.</p>
<p>Another potential optimization which I did not implement could improve pruning
further by relying on the fact that coloring a node and merging it with adjacent
nodes removes at most two edges from a path. So if the shortest path between two
nodes in the graph is longer than twice the number of remaining steps, we would
again not be able to find a solution from the current state.</p>
<p>The full source code is available <a class="reference external" href="https://gist.github.com/vladris/c283de5d8a3289303c7aca258e9cbdb1">on GitHub</a>.</p>
]]></description>
             <pubDate>Sun, 15 Apr 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/02/11/fibonacci.html</link>
            <guid>http://vladris.com/blog/2018/02/11/fibonacci.html</guid>
            <title><![CDATA[Fibonacci]]></title>
            <description><![CDATA[<h1>Fibonacci</h1>
<p>This blog post looks at a few algorithms to generate Fibonacci numbers. For a
much better treatment of these algorithms, I recommend <a class="reference external" href="https://www.goodreads.com/book/show/23498372-from-mathematics-to-generic-programming">From Mathematics to
Generic Programming</a>.
The implementations are provided in poorly written Rust, as I’m just
learning the language.</p>
<p>Learning Rust and going through <a class="reference external" href="https://doc.rust-lang.org/book/second-edition/">The Rust Programming Language</a>,
I got to <a class="reference external" href="https://doc.rust-lang.org/book/second-edition/ch03-05-control-flow.html#summary">the end of chapter 3</a>,
where there are a few simple exercises. One of them is <em>Generate the nth
Fibonacci number</em>.</p>
<div class="section" id="the-fibonacci-sequence">
<h2>The Fibonacci Sequence</h2>
<p>The Fibonacci sequence is defined as the sequence <span class="math notranslate">\(F_n = F_{n-1} + F_{n-2}\)</span>
with the seed values <span class="math notranslate">\(F_0 = 0\)</span> and <span class="math notranslate">\(F_1 = 1\)</span>.</p>
<p>The first few values of the sequence are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,
89, 144, ….</p>
</div>
<div class="section" id="a-naive-algorithm">
<h2>A Naïve Algorithm</h2>
<p>Directly translating the definition above into an algorithm to compute the n-th
Fibonacci number yields:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>This algorithm works for very small <span class="docutils literal"><span class="pre">n</span></span> values but it is extremely inefficient
as it has exponential time complexity and linear space complexity (based on
stack depth). Since <span class="docutils literal"><span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">+</span> <span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">3)</span></span>, a call like
<span class="docutils literal"><span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">2)</span></span> is equivalent to <span class="docutils literal"><span class="pre">(fib(n</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">+</span> <span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">3))</span> <span class="pre">+</span>
<span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">2)</span></span>, so the same elements of the sequence end up being computed over
and over again.</p>
</div>
<div class="section" id="bottom-up-approach">
<h2>Bottom-Up Approach</h2>
<p>A better way to generate the nth Fibonacci number is to build it bottom-up,
starting from <span class="math notranslate">\(F_0\)</span> and <span class="math notranslate">\(F_1\)</span>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"/>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"/>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"/>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">b</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>Here we start with <span class="math notranslate">\(a = F_0, b = F_1\)</span> and with each iteration of the loop
we advance from <span class="math notranslate">\(a = F_k, b = F_{k+1}\)</span> to <span class="math notranslate">\(a = F_{k+1}, b = F_{k+2}\)</span>
until <span class="docutils literal"><span class="pre">b</span></span> becomes <span class="math notranslate">\(F_n\)</span>.</p>
<p>Compared to the first algorithm, this is highly efficient, as it has linear
complexity and requires constant space. There are faster ways to compute the nth
Fibonacci number though.</p>
</div>
<div class="section" id="matrix-form">
<h2>Matrix Form</h2>
<p>The Fibonacci sequence can also be described in matrix form as follows:</p>
<div class="math notranslate">
\[\begin{split}\begin{bmatrix}
    F_{k+2} \\
    F_{k+1}
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}
*
\begin{bmatrix}
    F_{k+1} \\
    F_k
\end{bmatrix}\end{split}\]</div>
<p>Note that the next pair of numbers in the sequence, <span class="math notranslate">\(F_{k+3}, F_{k+2}\)</span> can
be expressed as:</p>
<div class="math notranslate">
\[\begin{split}\begin{bmatrix}
    F_{k+3} \\
    F_{k+2}
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}
*
\begin{bmatrix}
    F_{k+2} \\
    F_{k+1}
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}
*
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}
*
\begin{bmatrix}
    F_{k+1} \\
    F_k
\end{bmatrix}\end{split}\]</div>
<p>Thus we have the formula:</p>
<div class="math notranslate">
\[\begin{split}\begin{bmatrix}
    F_n \\
    F_n - 1
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}^{n-1}
*
\begin{bmatrix}
    F_1 \\
    F_0
\end{bmatrix}\end{split}\]</div>
<p>Since <span class="math notranslate">\(F_0 = 0\)</span> and <span class="math notranslate">\(F_1 = 1\)</span>, <span class="math notranslate">\(F_n\)</span> is the element at index
<span class="math notranslate">\((0, 0)\)</span> in:</p>
<div class="math notranslate">
\[\begin{split}\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}^{n-1}\end{split}\]</div>
<p>Assuming we have a function for exponentiating 2x2 matrices <span class="docutils literal"><span class="pre">exp2x2</span></span>, we can
implement an algorithm to compute the nth Fibonacci number like this:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fib3</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w"/>
<span class="w">    </span><span class="p">];</span><span class="w"/>

<span class="w">    </span><span class="n">exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>The complexity of this algorithm is given by the complexity of <span class="docutils literal"><span class="pre">exp2x2</span></span>. A
simple implementation of matrix exponentiation given a matrix multiplication
function <span class="docutils literal"><span class="pre">mul2x2</span></span> is:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">exp2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"/>
<span class="w">    </span><span class="p">];</span><span class="w"/>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul2x2</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>This function computes <span class="docutils literal"><span class="pre">a^n</span></span> by starting with the identity matrix and
multiplying it with a n times. The function for multiplying two 2x2 matrices is
trivial:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">mul2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="w"/>
<span class="w">    </span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>With <span class="docutils literal"><span class="pre">mul2x2</span></span> and <span class="docutils literal"><span class="pre">exp2x2</span></span>, our <span class="docutils literal"><span class="pre">fib3</span></span> algorithm has linear complexity,
which is determined by the number of times we call <span class="docutils literal"><span class="pre">mul2x2</span></span> in our
exponentiation function. There is a faster way to do exponentiation though:
observe that <span class="math notranslate">\(x^7 = x^4 * x^2 * x\)</span>. In general, any number <span class="docutils literal"><span class="pre">n</span></span> and can
be decomposed as a series of powers of two. So we can implement a
<span class="docutils literal"><span class="pre">fast_exp2x2</span></span> which works as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>if n == 1, return a
if n is even, return fast_exp2x2(a * a, n / 2)
if n is odd, return fast_exp2x2(a * a, (n - 1) / 2) * a
</pre></div>
</div>
<p>We stop when our exponent is 1 and return <span class="docutils literal"><span class="pre">a</span></span>. If <span class="docutils literal"><span class="pre">n</span></span> is even, we square the
base and halve the exponent (for example <span class="math notranslate">\(x^8 = (x*x)^4\)</span>). If <span class="docutils literal"><span class="pre">n</span></span> is
odd, we do the same but multiply by the base (for example <span class="math notranslate">\(x^9 = (x*x)^4 *
x\)</span>). This is a recursive algorithm which halves <span class="docutils literal"><span class="pre">n</span></span> at each step, so we have
logarithmic time and space complexity.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fast_exp2x2</span><span class="p">(</span><span class="n">mul2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"/>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>This is a very efficient way to compute the nth Fibonacci number. But where does
this fast exponentiation algorithm come from?</p>
</div>
<div class="section" id="ancient-egyptian-multiplication">
<h2>Ancient Egyptian Multiplication</h2>
<p>The ancient Egyptian multiplication algorithm comes from the <a class="reference external" href="RhindMathematicalPapyrus">Rhind Papyrus</a>
from around 1500 BC. The idea is very similar to our fast exponentiation
algorithm: we can implement a fast multiplication algorithm by relying on
addition and doubling (eg. <span class="math notranslate">\(x * 7 = x * 4 + x * 2 + x\)</span>).  The steps or our
<span class="docutils literal"><span class="pre">egyptian_mul</span></span> algorithm are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>if n == 1, return a
if n is even, return egyptian_mul(a + a, n / 2)
if n is odd, return egyptian_mul(a + a, (n - 1) / 2) + a
</pre></div>
</div>
<p>An implementation in Rust is:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">egyptian_mul</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">egyptian_mul</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"/>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>This multiplication algorithm relies only on addition, and multiplies <span class="docutils literal"><span class="pre">a</span></span> by
<span class="docutils literal"><span class="pre">n</span></span> in <span class="math notranslate">\(log(n)\)</span> steps.</p>
<p><span class="docutils literal"><span class="pre">egyptian_mul</span></span> and <span class="docutils literal"><span class="pre">fast_exp2x2</span></span> algorithms have the same structure since
they are fundamentally the same: they provide an efficient way to implement an
operation defined as applying another operation n times. Multiplication is, by
definition, repeated addition. Similarly, exponentiation is, by definition,
repeated multiplication. We can generalize these to an algorithm that given an
initial value <span class="docutils literal"><span class="pre">a</span></span> of any type <span class="docutils literal"><span class="pre">T</span></span>, an operation <span class="docutils literal"><span class="pre">op(T,</span> <span class="pre">T)</span> <span class="pre">-&gt;</span> <span class="pre">T</span></span>, and
<span class="docutils literal"><span class="pre">n</span></span>, the number of times to apply <span class="docutils literal"><span class="pre">op</span></span>, provides an efficient computation
using doubling and halving:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">op_n_times</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">op</span>: <span class="kp">&amp;</span><span class="nc">Op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"/>
<span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Copy</span><span class="p">,</span><span class="w"/>
<span class="w">          </span><span class="n">Op</span>: <span class="nb">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op_n_times</span>::<span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>We can express Egyptian multiplication (<span class="docutils literal"><span class="pre">egyptian_mul</span></span>) as addition applied
<span class="docutils literal"><span class="pre">n</span></span> times:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">egyptian_mul</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span>::<span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>Similarly, we can express fast matrix exponentiation (<span class="docutils literal"><span class="pre">fast_exp2x2</span></span>) as matrix
multiplication applied <span class="docutils literal"><span class="pre">n</span></span> times:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mul2x2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
</div>
<div class="section" id="industrial-strength-fibonacci">
<h2>Industrial Strength Fibonacci</h2>
<p>I wanted to benchmark the two interesting implementations: <span class="docutils literal"><span class="pre">fib2</span></span> and
<span class="docutils literal"><span class="pre">fib4</span></span>. The first exponential complexity implementation is highly inefficient
and even for small values of <span class="docutils literal"><span class="pre">N</span></span> (eg. <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">50</span></span>) it takes a long time to
complete. <span class="docutils literal"><span class="pre">fib3</span></span> has linear complexity like <span class="docutils literal"><span class="pre">fib2</span></span>, but while <span class="docutils literal"><span class="pre">fib2</span></span> just
performs additions and assignments on each iteration, <span class="docutils literal"><span class="pre">fib3</span></span> performs matrix
multiplication, which is more expensive. So <span class="docutils literal"><span class="pre">fib2</span></span> and <span class="docutils literal"><span class="pre">fib4</span></span> are more
interesting to look at.</p>
<p>Turns out that the Fibonacci sequence grows quite fast, the 100th Fibonacci
number is <span class="docutils literal"><span class="pre">354224848179261915075</span></span>, which does not fit in an <span class="docutils literal"><span class="pre">i32</span></span>. So let’s
update the implementations to use <span class="docutils literal"><span class="pre">num::BigUint</span></span>, an arbitrary precision
number. First is <span class="docutils literal"><span class="pre">fib2</span></span>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"/>

<span class="k">use</span><span class="w"> </span><span class="n">num</span>::<span class="n">bigint</span>::<span class="p">{</span><span class="n">BigUint</span><span class="p">,</span><span class="w"> </span><span class="n">ToBigUint</span><span class="p">};</span><span class="w"/>

<span class="k">fn</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BigUint</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"/>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span><span class="w"/>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"/>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">b</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">fib4</span></span>, we need to update <span class="docutils literal"><span class="pre">mul2x2</span></span> to work with <span class="docutils literal"><span class="pre">BigUint</span></span> array
references, so we don’t copy <span class="docutils literal"><span class="pre">BigUint</span></span> arrays:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">mul2x2</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="w"/>
<span class="w">    </span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>We also need to update our <span class="docutils literal"><span class="pre">op_n_times</span></span> so the operation now takes <span class="docutils literal"><span class="pre">&amp;T</span></span>
instead of <span class="docutils literal"><span class="pre">T</span></span>. Note this version still works with <span class="docutils literal"><span class="pre">i32</span></span> arrays and numbers,
but now the operation is expected to take two references instead of two values.
On the other hand we no longer require that <span class="docutils literal"><span class="pre">T</span></span> has the <span class="docutils literal"><span class="pre">Copy</span></span> trait:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">op_n_times</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">op</span>: <span class="kp">&amp;</span><span class="nc">Op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"/>
<span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">Op</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op_n_times</span>::<span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>Then we can update our <span class="docutils literal"><span class="pre">fib4</span></span> implementation to use <span class="docutils literal"><span class="pre">BigUint</span></span>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mul2x2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="k">fn</span> <span class="nf">fib4</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BigUint</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()],</span><span class="w"/>
<span class="w">    </span><span class="p">];</span><span class="w"/>

<span class="w">    </span><span class="n">fast_exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">clone</span><span class="p">()</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>These two implementations work with arbitrarily large numbers, for example
<span class="docutils literal"><span class="pre">fib4(10_000)</span></span> is:</p>
<blockquote style="word-wrap:break-word">
33644764876431783266621612005107543310302148460680063906564769974680081442166662368155595513633734025582065332680836159373734790483865268263040892463056431887354544369559827491606602099884183933864652731300088830269235673613135117579297437854413752130520504347701602264758318906527890855154366159582987279682987510631200575428783453215515103870818298969791613127856265033195487140214287532698187962046936097879900350962302291026368131493195275630227837628441540360584402572114334961180023091208287046088923962328835461505776583271252546093591128203925285393434620904245248929403901706233888991085841065183173360437470737908552631764325733993712871937587746897479926305837065742830161637408969178426378624212835258112820516370298089332099905707920064367426202389783111470054074998459250360633560933883831923386783056136435351892133279732908133732642652633989763922723407882928177953580570993691049175470808931841056146322338217465637321248226383092103297701648054726243842374862411453093812206564914032751086643394517512161526545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562430701794976171121233066073310059947366875
</blockquote><p>We can benchmark these implementations using Rust’s built-in benchmarking:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="cp">#[bench]</span><span class="w"/>
<span class="k">fn</span> <span class="nf">fib4_bench</span><span class="p">(</span><span class="n">b</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">fib4</span><span class="p">(</span><span class="n">N</span><span class="p">));</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="cp">#[bench]</span><span class="w"/>
<span class="k">fn</span> <span class="nf">fib2_bench</span><span class="p">(</span><span class="n">b</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">fib2</span><span class="p">(</span><span class="n">N</span><span class="p">));</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>On my Surface Book, for <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">100</span></span>, we have:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>test tests::fib2_bench ... bench:       7,805 ns/iter (+/- 3,042)
test tests::fib4_bench ... bench:       6,140 ns/iter (+/- 356)
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1_000</span></span>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>test tests::fib2_bench ... bench:      89,131 ns/iter (+/- 28,346)
test tests::fib4_bench ... bench:      16,307 ns/iter (+/- 2,087)
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">10_000</span></span>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>test tests::fib2_bench ... bench:   2,121,140 ns/iter (+/- 132,448)
test tests::fib4_bench ... bench:     184,625 ns/iter (+/- 12,184)
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">100_000</span></span>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>test tests::fib2_bench ... bench: 128,769,418 ns/iter (+/- 5,198,789)
test tests::fib4_bench ... bench:   7,176,026 ns/iter (+/- 364,400)
</pre></div>
</div>
<p>While <span class="docutils literal"><span class="pre">fib2</span></span> and <span class="docutils literal"><span class="pre">fib4</span></span> start with about the same performance at
<span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">100</span></span>, for <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">100_000</span></span>, <span class="docutils literal"><span class="pre">fib4</span></span> is significantly faster. The
benchmark results don’t seem to reflect the algorithmic complexity of <span class="docutils literal"><span class="pre">fib2</span></span>
(linear) and <span class="docutils literal"><span class="pre">fib4</span></span> (logarithmic), I suspect because of the introduction of
<span class="docutils literal"><span class="pre">BigUint</span></span> and operations on large numbers. Still, the algorithm relying on
fast exponentiation performs many times faster on large Ns.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This blog post covered:</p>
<ul class="simple">
<li>Algorithms to generate Fibonacci numbers: naïve recursive (exponential),
bottom-up (linear), matrix exponentiation (linear or logarithmic, depending on
the matrix exponentiation algorithm).</li>
<li>Ancient Egyptian multiplication and fast matrix exponentiation are the same
algorithm applied to different operations.</li>
<li>A generic algorithm of efficiently applying an operation n times.</li>
<li>Algorithms to generate Fibonacci numbers implemented with <span class="docutils literal"><span class="pre">BigUint</span></span> for
arbitrary precision numbers.</li>
<li>Benchmarking the <span class="docutils literal"><span class="pre">fib2</span></span> and <span class="docutils literal"><span class="pre">fib4</span></span> algorithms shows <span class="docutils literal"><span class="pre">fib4</span></span> to be much
better as <span class="docutils literal"><span class="pre">N</span></span> increases.</li>
</ul>
<p>My humble conclusion is that generating Fibonacci numbers is more than an
introductory exercise.</p>
</div>
]]></description>
             <pubDate>Sun, 11 Feb 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/01/27/notes-on-oop.html</link>
            <guid>http://vladris.com/blog/2018/01/27/notes-on-oop.html</guid>
            <title><![CDATA[Notes on OOP]]></title>
            <description><![CDATA[<h1>Notes on OOP</h1>
<p>I am not a huge fan of “pure” OOP. In this post I will cover a few non-pure OOP
concepts: subtyping wihtout inheritance, mixins, free functions, and types
without invariants. I will make a case for why multi-paradigm is needed and how
using a wider variety of concepts enables us to build simpler systems.</p>
<div class="section" id="duck-typing">
<h2>Duck typing</h2>
<blockquote>
<div>If it walks like a duck and it quacks like a duck, then it must be a duck.</div></blockquote>
<p>Let’s say we have a <span class="docutils literal"><span class="pre">Duck</span></span> class. A <span class="docutils literal"><span class="pre">Duck</span></span> quacks and waddles:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Duck</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Quack</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We have a function that uses a duck:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">Duck</span><span class="o">&amp;</span> <span class="n">duck</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">duck</span><span class="p">.</span><span class="n">Quack</span><span class="p">();</span>
    <span class="n">duck</span><span class="p">.</span><span class="n">Waddle</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The object-oriented way to implement subtyping is to inherit from the base
class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">UglyDuckling</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Duck</span> <span class="p">{</span> <span class="p">};</span>

<span class="c1">// ...</span>

<span class="n">UglyDuckling</span> <span class="n">uglyDuckling</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">uglyDuckling</span><span class="p">);</span>
</pre></div>
</div>
<p>We can call <span class="docutils literal"><span class="pre">foo</span></span> on an <span class="docutils literal"><span class="pre">UglyDuckling</span></span> since <span class="docutils literal"><span class="pre">UglyDuckling</span></span> inherits from
<span class="docutils literal"><span class="pre">Duck</span></span>. We have an <em>is-a</em> relationship, so we can substitute an
<span class="docutils literal"><span class="pre">UglyDuckling</span></span> for a <span class="docutils literal"><span class="pre">Duck</span></span>. The problem with this approach is that whenever
we want something that quacks and waddles, we need to inherit from <span class="docutils literal"><span class="pre">Duck</span></span>.
More generally, this type of polymorphism is achieved by implementing a set of
interfaces like, for example, <span class="docutils literal"><span class="pre">IComparable</span></span>, <span class="docutils literal"><span class="pre">IClonebale</span></span>, <span class="docutils literal"><span class="pre">IDisposable</span></span>
and so on. This makes things slightly complicated: what if we need something
that waddles, but we don’t care about quacking? Do we separate our duck into two
different interfaces? In general, do we add an interface for each behavior and
then pull groups of interfaces together to form more refined types?</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">IQuack</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Quack</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">IWaddle</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Duck</span> <span class="o">:</span> <span class="n">IQuack</span><span class="p">,</span> <span class="n">IWaddle</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Quack</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span> <span class="o">:</span> <span class="n">IWaddle</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This works, but has combinatorial complexity and we end up with deep hierarchies
which are difficult to reason about. There is another way to achieve this
though, using generic programming:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">UglyDuckling</span> <span class="c1">// No inheritance</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Quack</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Duck</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">Duck</span><span class="o">&amp;</span> <span class="n">duck</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">duck</span><span class="p">.</span><span class="n">Quack</span><span class="p">();</span>
    <span class="n">duck</span><span class="p">.</span><span class="n">Waddle</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="n">UglyDuckling</span> <span class="n">uglyDuckling</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">uglyDuckling</span><span class="p">);</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">foo</span></span> here is a templated function which only cares that the type passed in
has a <span class="docutils literal"><span class="pre">Quack</span></span> and a <span class="docutils literal"><span class="pre">Waddle</span></span> member function. There is no inheritance
involved, but we can still substitute an <span class="docutils literal"><span class="pre">UglyDuckling</span></span> for a <span class="docutils literal"><span class="pre">Duck</span></span>. This
gets us rid of all the interfaces (we don’t need our <span class="docutils literal"><span class="pre">Penguin</span></span> to explicitly
implement an <span class="docutils literal"><span class="pre">IWaddle</span></span> interface, we just need it to provide a <span class="docutils literal"><span class="pre">Waddle</span></span>
member function). Our model becomes simpler - as long as a type supports the
behavior required by a function, it can be used with that function.</p>
</div>
<div class="section" id="mixins">
<h2>Mixins</h2>
<p>Lore has it that multiple inheritance is bad and it is by design not supported
in Java, C#, and such. On the other hand, mixins are extremely useful, and it
is a pity that we usually have to express them via inheritance. A mixin is a
type that provides some behavior which is <em>mixed in</em> or <em>included</em> into another
type. For example, if we use intrusive reference counting, we can isolate the
reference-counting behavior into its own type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">RefCounted</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">AddRef</span><span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">m_refCount</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Release</span><span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">m_refCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">RefCounted</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_refCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Then we can have other types for which we want intrusive reference counting
simply mixing in this behavior:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RefCounted</span> <span class="p">{</span> <span class="p">};</span>
</pre></div>
</div>
<p>Now <span class="docutils literal"><span class="pre">Foo</span></span> has <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> functions which can be called by a
generic smart pointer that expects managed types to expose these member
functions. While technically <span class="docutils literal"><span class="pre">Foo</span></span> inherits from <span class="docutils literal"><span class="pre">RefCounted</span></span>, conceptually
we only care that it includes the reference counting behavior. In such cases it
is perfectly fine to mix and match and include behavior defined across multiple
other types.</p>
</div>
<div class="section" id="the-case-for-free-functions">
<h2>The Case for Free Functions</h2>
<p>What is the difference between the following two <span class="docutils literal"><span class="pre">Print</span></span> functions?</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Data</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="p">.</span><span class="n">Data</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first is a member function, called with an implicit <span class="docutils literal"><span class="pre">this</span></span> argument which
points to the object instance, while the second is a free function called with
an explicit reference to a <span class="docutils literal"><span class="pre">Foo</span></span> object.</p>
<p>The member function approach leads to bloated objects as whenever we need some
additional processing of the type, we would have to add new member functions.
This contradicts the <em>Single Responsibility Principle</em> which states that each
class should have a single responsibility. Adding member functions like
<span class="docutils literal"><span class="pre">ToString</span></span>, <span class="docutils literal"><span class="pre">Serialize</span></span> etc. needlessly bloats a class.</p>
<p>In general, we only need member functions when these functions access private
members of the type. If <span class="docutils literal"><span class="pre">Data</span></span> was private in the above example, then the
free-function version wouldn’t have worked. As long as we can implement a
function that operates on a type without having to access its private member,
that function should not belong to the type. Depending on the language, we have
several options. We could put such functions in “helper” types:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">FooPrinter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C# provides extension methods as syntax sugar for this, which allow us to call
<span class="docutils literal"><span class="pre">foo.Print()</span></span> even though we implement the <span class="docutils literal"><span class="pre">Print</span></span> function as an extension
method:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">class</span> <span class="nc">FooPrinter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">this</span> <span class="n">Foo</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Still, the simplest thing to do is have a free function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
</div>
<p>Being forced to group everything inside classes yields messy code. Steve Yegge’s
<a class="reference external" href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Kingdom of Nouns</a>
is a classic on the topic.</p>
<div class="section" id="managers-and-utils">
<h3>Managers and Utils</h3>
<p>Because a purely object-oriented language forces developers to think in classes,
we more often than not end up with managers and utility classes, both being
horrible replacements for free-standing functions.</p>
<p>Managers usually show up once we have a nice object model for the problem space
but we need to implement a set of operations on said object model. Managers tend
to be singletons. For example, we have a <cite>Connection</cite> type that models a
connection to a peer:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Connection</span>
<span class="p">{</span>
    <span class="c1">// Open, Close, Send, Receive etc.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We also want someone to open new connections and close all opened connections.
Here is a purely object oriented <span class="docutils literal"><span class="pre">ConnectionManager</span></span>:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">ConnectionManager</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">ConnectionManager</span> <span class="n">_instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConnectionManager</span><span class="p">();</span>
    <span class="k">private</span> <span class="nf">ConnectionManager</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">ConnectionManager</span> <span class="nf">GetInstance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_instance</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Connection</span><span class="p">&gt;</span> <span class="n">_connections</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Connection</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">Connection</span> <span class="nf">Make</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">connection</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Connection</span><span class="p">();</span>
        <span class="n">_connections</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">connection</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">CloseAll</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_connections</span><span class="p">.</span><span class="n">ForEach</span><span class="p">(</span><span class="n">connection</span> <span class="p">=&gt;</span> <span class="n">connection</span><span class="p">.</span><span class="n">Close</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This maintains the list of connections and can close all of them with a call to
<span class="docutils literal"><span class="pre">CloseAll()</span></span>. Besides being verbose to use (<span class="docutils literal"><span class="pre">ConnectionManager.GetInstance().Make()</span></span>, <span class="docutils literal"><span class="pre">ConnectionManager.GetInstance().Close()</span></span>),
this class does not make much sense. A non-OOP implementation would look like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// In .h file</span>
<span class="k">class</span> <span class="nc">Connection</span>
<span class="p">{</span>
    <span class="c1">// Open, Close, Send, Receive etc.</span>
<span class="p">};</span>

<span class="n">Connection</span><span class="o">&amp;</span> <span class="n">Make</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">CloseAll</span><span class="p">();</span>

<span class="c1">// In .cpp file</span>
<span class="k">namespace</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">connections</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Connection</span><span class="o">&amp;</span> <span class="n">Make</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">connections</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Connection</span><span class="p">{});</span>
    <span class="k">return</span> <span class="n">connections</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">CloseAll</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">connection</span> <span class="p">:</span> <span class="n">connections</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">connection</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">Make()</span></span> and <span class="docutils literal"><span class="pre">CloseAll()</span></span> do not need to be group in some manager. They can
be free functions living next to the <span class="docutils literal"><span class="pre">Connection</span></span> type, which is the only
context within which they make sense. The list of connections can be stored in a
variable scoped to the implementation .cpp file. “Managers” rarely make sense.</p>
<p>Utility classes are even worse: while a manager is usually tightly coupled to
the type it “manages”, “Utils” classes end up being dumping grounds of functions
that don’t seem to belong anywhere else. The biggest problem is that each of
these functions usually depends on some other component:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">FooUtils</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DoBar</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Dependency on Bar */</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DoBaz</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Dependency on Baz */</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now whoever takes a dependency on <span class="docutils literal"><span class="pre">FooUtils</span></span>, transitively takes a dependency
on both <span class="docutils literal"><span class="pre">Bar</span></span> and <span class="docutils literal"><span class="pre">Baz</span></span> too, even if they only really needed one of them.
If <span class="docutils literal"><span class="pre">DoBar()</span></span> and <span class="docutils literal"><span class="pre">DoBaz()</span></span> were free functions, taking a dependency on
<span class="docutils literal"><span class="pre">DoBar()</span></span> would transitively take a dependency on <span class="docutils literal"><span class="pre">Bar</span></span> only. “Utility”
types make layering a nightmare.</p>
</div>
</div>
<div class="section" id="when-to-use-classes">
<h2>When To Use Classes</h2>
<p>I am a big believer in multi-paradigm. If our only tool is a hammer, we can only
hammer things. While pure functional languages are elegant, they are too far
removed from the machine they run on (for example we can’t implement an in-place
<span class="docutils literal"><span class="pre">reverse</span></span> if all data is immutable). Similarly, if everything is an object, we
end up with too many classes and too many complicated relationships. Procedural
languages usually provide some way to group data via <span class="docutils literal"><span class="pre">struct</span></span> or <span class="docutils literal"><span class="pre">record</span></span>
types, so when are classes useful?</p>
<p>The answer is <em>for encapsulating</em> - classes enable us to declare private data
and control access to it. This is useful when the class needs to maintain
invariants, which could potentially be broken if external entities would be able
to change an object’s state. Let’s use a <span class="docutils literal"><span class="pre">Date</span></span> type as a made up example.
Made up because dates are usually implemented as a number representing a tick
count since some set start date, and information like <em>day</em>, <em>month</em>, and <em>year</em>
is derived from that. But let’s assume we have separate <em>day</em>, <em>month</em>, and
<em>year</em> fields. This type should maintain an invariant that it represents a valid
date, so we can’t have, for example, a June 31st. It’s hard to enforce the
invariant with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Date</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">day</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">month</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">year</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Alternately, we can implement a class with a constructor which ensures only
valid dates can be created:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Date</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Date</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">year</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">month</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">day</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">month</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">month</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="k">throw</span> <span class="cm">/* ... */</span>
        <span class="cm">/* Additional checks to ensure a valid date... */</span>
    <span class="p">}</span>

    <span class="kt">uint8_t</span> <span class="n">year</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_year</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint8_t</span> <span class="n">month</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_month</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint8_t</span> <span class="n">day</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_day</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">uint8_t</span> <span class="n">m_day</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">m_month</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">m_year</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If we want to add an <span class="docutils literal"><span class="pre">AddDays</span></span> function, we would create a member function
<a class="footnote-reference" href="#id2" id="id1">[1]</a> which would implement the algorithm that would know when adding a number of
days would increment the month and when incrementing the month would increment
the year, such that the invariant of always having a valid date is enforced.</p>
<p>On the other hand, a type which doesn’t need to maintain an invariant, say a
point in the plane, should not be implemented as a class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>Inheritance is rarely warranted, and when used, it should mostly be used in the
context of mixins - with the intention of including behavior rather than
deriving and extending. Interfaces are sometimes useful at a component boundary,
though static, template-based polymorphism is preferred. A good design consists
of a set of independent classes which maintain invariants, and free functions
that operate on them. Structure (or record) types should be used when there is
no invariant to be maintained. Generic functions should be used when algorithms
can be generalized to multiple types as long as they satisfy some requirements
(as in the Duck Typing section above). This encourages reusable code and systems
of loosely-coupled components which can be more easily reasoned about in
isolation and reused when needed.</p>
<ul class="simple">
<li>Generic programming/compile-time polymorphism yields less complex models than
inheritance</li>
<li>While multiple inheritance is frowned upon, mixins provide a great way to add
behavior to a type. The problem is including this behavior is usually
syntactically equivalent with inheritance.</li>
<li>Free functions are great. Managers and Utils are bad and should be avoided.</li>
<li>Classes are useful when invariants need to be enforced. Encapsulation and
member functions maintain invariants.</li>
<li>A good design consists of loosely-coupled components and generic functions,
which can be reasoned about in isolation and freely combined to create complex
behavior.</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Or better yet a free function which takes a <span class="docutils literal"><span class="pre">Date</span></span> and returns a new
instance - immutability seems like a good idea in this case.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sat, 27 Jan 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/12/30/evens-before-odds.html</link>
            <guid>http://vladris.com/blog/2017/12/30/evens-before-odds.html</guid>
            <title><![CDATA[Evens before Odds]]></title>
            <description><![CDATA[<h1>Evens before Odds</h1>
<p>One of my go-to interview questions goes like this:</p>
<blockquote>
<div><p>Given an array of numbers, make it so the even numbers come before the odd
ones.</p>
<p>For example, for <span class="docutils literal"><span class="pre">{</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8</span> <span class="pre">}</span></span>, a possible output would be
<span class="docutils literal"><span class="pre">{</span> <span class="pre">8,</span> <span class="pre">2,</span> <span class="pre">6,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">3,</span> <span class="pre">7,</span> <span class="pre">1</span> <span class="pre">}</span></span>.</p>
</div></blockquote>
<p>This is not a trick question by any means, it is a straightforward problem with
a couple of straightforward solutions. Note the <em>possible output</em> wording and
the fact that evens and odds in the output do not preserve the relative order
they had in the input.</p>
<div class="section" id="a-space-inefficient-solution">
<h2>A Space-Inefficient Solution</h2>
<p>An easy solution is to traverse the input once and store all even numbers
encountered during the traversal into a separate array, then traverse it again
and do the same for the odd numbers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This solves the problem in <span class="docutils literal"><span class="pre">O(n)</span></span> linear time (two traversals of the input
array) and <span class="docutils literal"><span class="pre">O(n)</span></span> linear space - result is as large as input, so additional
space required grows linearly with the size of the input.</p>
<p>There are more efficient way of doing this in linear time and constant space.</p>
</div>
<div class="section" id="two-algorithms">
<h2>Two Algorithms</h2>
<p>There are a couple of ways we can solve this. One algorithm goes like this:</p>
<blockquote>
<div><p>Find the first odd number. Stop if we reached the end of the array.</p>
<p>Find the first event number after that odd number. Stop if we reached the
end of the array.</p>
<p>Swap them.</p>
<p>Repeat.</p>
</div></blockquote>
<p>Our loop invariant is that all numbers before the first odd number (which we
update during each iteration) are already in the right place. With each
iteration, we find another even number that appears after the first odd number
so we swap them, putting the even in the right place. We stop when we run out of
numbers to swap, either odd or even. An implementation of this algorithm looks
like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="c1">// Find first odd number</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="c1">// If we reached the end we're done</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Find the first even number after the first odd one</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">j</span><span class="p">;</span>

        <span class="c1">// If we reached the end we're done</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Swap and continue</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While the algorithm is fairly straight-forward, the devil is in the details - we
need to perform multiple checks to make sure we don’t run off the end of the
array. While interviewing, I’ve seen many bugs come up due to missing some of
these checks.</p>
<p>An interesting observation we can make is that once we found the first pair of
odd and even numbers, after we swap them, the new first odd number is right
after the even we just swapped, so we can hoist the first while statement out of
the main loop - we only need to find the first odd once, then we just increment
after each swap:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="c1">// Find the first odd number</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>

    <span class="c1">// If we reached the end we’re done</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Start after the first odd and until we reach the end</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If it’s an even number</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Swap with the first odd</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="c1">// Increment first odd position</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another algorithm goes like this:</p>
<blockquote>
<div><p>Find the first odd number.</p>
<p>From the back, find the last even number.</p>
<p>Stop if the first odd number appears after the last even number.</p>
<p>Swap and repeat.</p>
</div></blockquote>
<p>Our loop invariant is that all numbers before the first odd and all numbers
after the last even are already in place. With each iteration, we move the first
odd and last even. We stop when the first odd appears after the last even, which
means all evens appear before the odds. Here is a possible implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="c1">// Find the first odd number</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="c1">// If the first odd occurs after the last even, stop</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Find the last even number</span>
        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="c1">// If the first odd occurs after the last even, stop</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Swap and continue</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both of the above algorithms solve the problem in linear time and constant
space.</p>
<div class="section" id="test-cases">
<h3>Test Cases</h3>
<p>Some interesting test cases to validate the implementations:</p>
<ul class="simple">
<li>Our example input <span class="docutils literal"><span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8</span> <span class="pre">}</span></span></li>
<li>An empty vector <span class="docutils literal"><span class="pre">{</span> <span class="pre">}</span></span></li>
<li>A vector with a single even number <span class="docutils literal"><span class="pre">{</span> <span class="pre">2</span> <span class="pre">}</span></span></li>
<li>A vector with a single odd number <span class="docutils literal"><span class="pre">{</span> <span class="pre">1</span> <span class="pre">}</span></span></li>
<li>A vector consisting of all even number <span class="docutils literal"><span class="pre">{</span> <span class="pre">2,</span> <span class="pre">4,</span> <span class="pre">6</span> <span class="pre">}</span></span></li>
<li>A vector consisting of all odd numbers <span class="docutils literal"><span class="pre">{</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">5</span> <span class="pre">}</span></span></li>
</ul>
</div>
<div class="section" id="follow-up-odds-before-evens">
<h3>Follow Up: Odds before Evens</h3>
<p>My follow up question is</p>
<blockquote>
<div>What if we also want the ability to put odd numbers before even ones? How
would we extend our code?</div></blockquote>
<p>An answer I’m <strong>not</strong> looking for is <em>we copy/paste the function, rename it to</em>
<span class="docutils literal"><span class="pre">odds_before_evens</span></span> <em>and update the checks</em>.</p>
<p>A clever answer (which I’m also not looking for) is <em>we provide an</em>
<span class="docutils literal"><span class="pre">odds_before_evens</span></span> <em>which internally calls</em> <span class="docutils literal"><span class="pre">evens_before_odds</span></span> <em>, then
reverses the output</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">odds_before_evens</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">evens_before_odds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A common answer is <em>we add a flag</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">evensFirst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This kind of works, but the condition becomes very complicated.</p>
</div>
<div class="section" id="follow-up-primes-before-non-primes">
<h3>Follow Up: Primes before Non-Primes</h3>
<p>What if we also want to move prime numbers before non-prime numbers, given some
<span class="docutils literal"><span class="pre">bool</span> <span class="pre">is_prime(int)</span></span> primality-testing function?</p>
<p>We can keep adding flags and extending the <span class="docutils literal"><span class="pre">if</span></span> conditions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">Arrangement</span>
<span class="p">{</span>
    <span class="n">EvensBeforeOdds</span><span class="p">,</span>
    <span class="n">OddsBeforeEvens</span><span class="p">,</span>
    <span class="n">PrimesBeforeNonPrimes</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Arrangement</span> <span class="n">arrangement</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">EvensBeforeOdds</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">OddsBeforeEvens</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">PrimesBeforeNonPrimes</span> <span class="o">&amp;&amp;</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">EvensBeforeOdds</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">OddsBeforeEvens</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">PrimesBeforeNonPrimes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This doesn’t scale very well though. What we actually want to do here is
abstract away the predicate based on which we move elements around:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">odds_before_evens</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">primes_before_non_primes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">is_prime</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the algorithm remains the same: we have the exact same steps and loop
invariants, but we can parameterize the condition. With this abstraction, the
code actually becomes smaller and more readable.</p>
<p>This is about as far as I can get during an interview.</p>
</div>
</div>
<div class="section" id="partition">
<h2>Partition</h2>
<p>This is actually a well-known algorithm called a <em>partitioning algorithm</em>. A
partitioning algorithm moves elements that satisfy a predicate before elements
that don’t satisfy it. Let’s start with the above implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">partition</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works for vectors, but what if we want to partition a doubly-linked list?
Can we abstract away the data structure we are partitioning? The answer is
<em>yes</em>. We can use iterators to access the data structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">last</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">))</span>
            <span class="o">--</span><span class="n">last</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation is virtually the same. We get rid of <span class="docutils literal"><span class="pre">i</span></span> and <span class="docutils literal"><span class="pre">j</span></span>, as we
are using the iterators provided as arguments for traversal. The implementation
does not increase in complexity, but is now usable beyond vectors. For example
we can now partition a C-style array:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="useful-return">
<h3>Useful Return</h3>
<p>A useful return for our algorithm is the <em>partition point</em> - the position of the
first element that does not satisfy our predicate. We have this implicitly and
callers might be interested in it. To avoid making callers have to recompute it,
we should return it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

        <span class="o">--</span><span class="n">last</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">))</span>
            <span class="o">--</span><span class="n">last</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For example, <span class="docutils literal"><span class="pre">partition</span></span> is a key ingredient in quicksort:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Comp</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Comp</span> <span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Stop if we have no elements or one element</span>
    <span class="k">auto</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Swap pivot with last element</span>
    <span class="k">auto</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="o">--</span><span class="n">last</span><span class="p">);</span>

    <span class="c1">// Partition around pivot</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">comp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// Move pivot back in place</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

    <span class="c1">// Recursively sort left and right sides of the pivot</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">++</span><span class="n">last</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stl-implementations">
<h3>STL Implementations</h3>
<p>The <span class="docutils literal"><span class="pre">partition</span></span> algorithm we ended up with is fairly efficient, but it’s worth
taking a look at some of the highly-optimized STL implementations. This is the
MSVC STL implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span> <span class="o">++</span><span class="n">first</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="o">--</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">););</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="n">iter_swap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note this performs the least possible amount of operations. It also seems to
favor <span class="docutils literal"><span class="pre">for</span></span> loops. Contrast this with the LLVM libc++ implementation, which
seems to favor <span class="docutils literal"><span class="pre">while</span></span> loops:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">do</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="o">--</span><span class="n">last</span><span class="p">)</span> <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">));</span>
        <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iterator-requirements-and-complexity">
<h3>Iterator Requirements and Complexity</h3>
<p>We focused on the second algorithm presented, which finds the first odd, last
even, and swaps them. We had another algorithm which was looking for <em>the first
even after the first odd</em> during each iteration. Let’s provide a generic
implementation for it too:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">);</span> <span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What is the difference?</p>
<p>The difference is that this algorithm only ever increments the iterators. That
means it only requires a <span class="docutils literal"><span class="pre">ForwardIterator</span></span>, as opposed to the other algorithm,
which finds the <em>last even</em> number starting from the <span class="docutils literal"><span class="pre">last</span></span> iterator, which
requires a <span class="docutils literal"><span class="pre">BidirectionalIterator</span></span>.</p>
<p>In other words, the algorithm requiring only a <span class="docutils literal"><span class="pre">ForwardIterator</span></span> works on a
singly-linked list (<span class="docutils literal"><span class="pre">forward_list</span></span>), while the other one can’t (we can only
traverse a singly-linked list forward in <span class="docutils literal"><span class="pre">O(1)</span></span> time, not backwards).</p>
<p>The MSVC STL implementation of the forward-iterator algorithm is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">);</span> <span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
            <span class="n">iter_swap</span><span class="p">(</span><span class="n">first</span><span class="o">++</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The libc++ one is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="p">,</span> <span class="n">tpyename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The reason both implementations are provided is that the <span class="docutils literal"><span class="pre">ForwardIterator</span></span>
version, while more generally applicable, is slightly less efficient. The
<span class="docutils literal"><span class="pre">BidirectionalIterator</span></span> version moves any element at most once, and since the
move is a swap, it means it performs at most <span class="docutils literal"><span class="pre">N</span> <span class="pre">/</span> <span class="pre">2</span></span> swaps where <span class="docutils literal"><span class="pre">N</span></span> is the
number of elements. The <span class="docutils literal"><span class="pre">ForwardIterator</span></span> version might perform more swaps, up
to <span class="docutils literal"><span class="pre">N</span></span>. For example, for the input <span class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">4</span></span>, during the first step, it would
swap <span class="docutils literal"><span class="pre">1</span></span> with <span class="docutils literal"><span class="pre">2</span></span>, ending up with <span class="docutils literal"><span class="pre">2</span> <span class="pre">1</span> <span class="pre">4</span></span>, then during the next step it
would swap <span class="docutils literal"><span class="pre">1</span></span> with <span class="docutils literal"><span class="pre">4</span></span>, ending up with <span class="docutils literal"><span class="pre">2</span> <span class="pre">4</span> <span class="pre">1</span></span>.</p>
</div>
</div>
<div class="section" id="in-c">
<h2>In C#</h2>
<p>Partitioning is not specific to the C++ language. The same implementation can be
used, for example, in C#, up to abstracting away data structure traversal:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">IListPartition</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">Partition</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">pred</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">last</span> <span class="p">=</span> <span class="n">self</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(;;)</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="p">!=</span> <span class="n">last</span> <span class="p">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">]))</span>
                <span class="p">++</span><span class="n">first</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="p">==</span> <span class="n">last</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

            <span class="p">--</span><span class="n">last</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="p">!=</span> <span class="n">last</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">pred</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">]))</span>
                <span class="p">--</span><span class="n">last</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="p">==</span> <span class="n">last</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

            <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">];</span>
            <span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="p">=</span> <span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">];</span>
            <span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The .NET <span class="docutils literal"><span class="pre">IEnumerator</span></span> does not allow us to mutate the data structure we are
enumerating over, so we cannot provide a generic <span class="docutils literal"><span class="pre">IEnumerable&lt;T&gt;</span></span> partition
algorithm that works in-place. Otherwise the implementation is pretty much
identical to the C++ one, as the algorithm is the same.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Moving even numbers before odd ones in a given array of numbers is an instance
of partition.</li>
<li>The algorithm can be generalized to work with an arbitrary predicate.</li>
<li>The algorithm can be generalized to work across any data structure as long as
it can be traversed with at least a <span class="docutils literal"><span class="pre">ForwardIterator</span></span>.</li>
<li>A <span class="docutils literal"><span class="pre">BidirectionalIterator</span></span> version performs at most <span class="docutils literal"><span class="pre">N</span> <span class="pre">/</span> <span class="pre">2</span></span> swaps (and
<span class="docutils literal"><span class="pre">N</span></span> applications of the predicate).</li>
<li>A <span class="docutils literal"><span class="pre">ForwardIterator</span></span> version performs at most <span class="docutils literal"><span class="pre">N</span></span> swaps (and <span class="docutils literal"><span class="pre">N</span></span>
applications of the predicate).</li>
<li>Both versions of the algorithm are part of the standard library
(<span class="docutils literal"><span class="pre">std::partition</span></span> algorithm).</li>
<li>The same algorithm can be implemented in other languages, as generic as the
available abstractions allow.</li>
</ul>
</div>
]]></description>
             <pubDate>Sat, 30 Dec 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/12/10/binary-relations.html</link>
            <guid>http://vladris.com/blog/2017/12/10/binary-relations.html</guid>
            <title><![CDATA[Binary Relations]]></title>
            <description><![CDATA[<h1>Binary Relations</h1>
<div class="section" id="definitions">
<h2>Definitions</h2>
<p>Given a set of objects <span class="docutils literal"><span class="pre">A</span></span>, a binary relation <span class="docutils literal"><span class="pre">R</span></span> on the set is defined as a
subset of <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">A</span></span>. The <em>characteristic function</em> <span class="docutils literal"><span class="pre">r</span></span> for <span class="docutils literal"><span class="pre">R</span></span> is the
function <span class="docutils literal"><span class="pre">r</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span> such that <span class="docutils literal"><span class="pre">r(x,</span> <span class="pre">y)</span></span> is <span class="docutils literal"><span class="pre">true</span></span> if
<span class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">in</span> <span class="pre">R</span></span>, and <span class="docutils literal"><span class="pre">false</span></span> if <span class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">R</span></span>. For a more natural
notation, we can use <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span> to denote <span class="docutils literal"><span class="pre">r(x,</span> <span class="pre">y)</span></span>.</p>
<p>More generally, a binary relation can be defined on a pair of sets <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">B</span></span> but
to keep things simple, we’ll only cover binary relations over a single set.</p>
<p>Binary relations may have several properties. A few interesting ones are:</p>
<ul class="simple">
<li>A binary relation is <em>reflexive</em> if for any <span class="docutils literal"><span class="pre">x</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span></li>
<li>A binary relation is <em>strict</em> or <em>irreflexive</em> if there is no <span class="docutils literal"><span class="pre">x</span></span> in <span class="docutils literal"><span class="pre">A</span></span>
for which <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span></li>
<li>A binary relation is <em>symmetric</em> if for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>
implies <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span></li>
<li>A binary relation is <em>antisymmetric</em> if for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>
and <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span> implies <span class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></span></li>
<li>A binary relation is <em>transitive</em> if for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, if
<span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span> and <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">z</span></span>, then <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">z</span></span></li>
<li>A binary relation is <em>total</em> if for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, either <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>,
<span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span>, or both (in other words, for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></span>, <span class="docutils literal"><span class="pre">~</span></span> imposes some
relation between them)</li>
</ul>
<div class="section" id="examples">
<h3>Examples</h3>
<p>The relation <em>is in the subtree rooted at</em> is a reflexive relation where <span class="docutils literal"><span class="pre">A</span></span>
is the set of nodes of a tree. For any pair of nodes <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span>, we can
establish whether <span class="docutils literal"><span class="pre">x</span></span> is in the subtree rooted at <span class="docutils literal"><span class="pre">y</span></span> or not, and for any
<span class="docutils literal"><span class="pre">x</span></span>, <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span> is <span class="docutils literal"><span class="pre">true</span></span>.</p>
<p>The relation <em>is parent of</em> in a tree is a strict relation: for any <span class="docutils literal"><span class="pre">x</span></span> in the
set of tree nodes <span class="docutils literal"><span class="pre">A</span></span>, <span class="docutils literal"><span class="pre">x</span></span> cannot be a parent of itself.</p>
<p>The relation <em>edge between</em> over the vertices of a non-directed graph is a
symmetric relation: for any <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span> vertices of the graph, if there is
an edge from <span class="docutils literal"><span class="pre">x</span></span> to <span class="docutils literal"><span class="pre">y</span></span>, the same edge exists from <span class="docutils literal"><span class="pre">y</span></span> to <span class="docutils literal"><span class="pre">x</span></span>, in other
words, if <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span> then <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span>.</p>
<p>The <em>is in the subtree rooted at</em> relation above is also antisymmetric: if for
a pair of nodes we can say <span class="docutils literal"><span class="pre">x</span></span> is in the subtree rooted at <span class="docutils literal"><span class="pre">y</span></span> and also
<span class="docutils literal"><span class="pre">y</span></span> is in the subtree rooted at <span class="docutils literal"><span class="pre">x</span></span>, it’s obvious that both <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span>
are, in fact, the root of the subtree, thus <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>.</p>
<p>The relation <em>is reachable from</em> over the vertices of a directed graph is a
transitive relation: if <span class="docutils literal"><span class="pre">x</span></span> is reachable from <span class="docutils literal"><span class="pre">y</span></span> and <span class="docutils literal"><span class="pre">y</span></span> is reachable
from <span class="docutils literal"><span class="pre">z</span></span>, then <span class="docutils literal"><span class="pre">x</span></span> is reachable from <span class="docutils literal"><span class="pre">z</span></span>.</p>
<p>All of the above examples are of total relations. An example of a non-total
relation is <em>is ancestor of</em> in a tree. <span class="docutils literal"><span class="pre">x</span></span> can be an ancestor of <span class="docutils literal"><span class="pre">y</span></span>, in
which case <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>, or <span class="docutils literal"><span class="pre">y</span></span> can be an ancestor of <span class="docutils literal"><span class="pre">x</span></span>, in which case
<span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span>, but it could also be that <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span> are in different subtrees,
so neither <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span> nor <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span> holds.</p>
</div>
</div>
<div class="section" id="preorder">
<h2>Preorder</h2>
<p>A <em>preorder</em> is a relation which is reflexive and transitive.</p>
<p>A preorder which is also symmetric is an <em>equivalence</em>. A preorder which is
antisymmetric is a <em>partial order</em>. More on those below.</p>
<p>An example of preorder is the <em>is reachable from</em> relation over a directed
graph in the example above. This relation is obviously reflexive and transitive,
but it is neither symmetric nor antisymmetric. If <span class="docutils literal"><span class="pre">x</span></span> is reachable from <span class="docutils literal"><span class="pre">y</span></span>,
it doesn’t mean that <span class="docutils literal"><span class="pre">y</span></span> is reachable from <span class="docutils literal"><span class="pre">x</span></span>, so symmetry is not
guaranteed. Similarly, if <span class="docutils literal"><span class="pre">x</span></span> is reachable from <span class="docutils literal"><span class="pre">y</span></span> and <span class="docutils literal"><span class="pre">y</span></span> is reachable
from <span class="docutils literal"><span class="pre">x</span></span>, it does not mean that <span class="docutils literal"><span class="pre">y</span></span> equals <span class="docutils literal"><span class="pre">x</span></span>.</p>
</div>
<div class="section" id="equivalence-and-equality">
<h2>Equivalence and Equality</h2>
<p>An <em>equivalence</em> relation <span class="docutils literal"><span class="pre">~</span></span> is a binary relation that is reflexive,
symmetric, and transitive. In other words, it is a preorder which also has the
symmetric property.</p>
<p>Such a relation partitions the set over which it is
defined into <em>equivalence classes</em> - groups of objects that are equivalent
based on the relation.</p>
<p>An example of equivalence is <em>same month</em> over a set of dates. This relation
is reflexive, since a date <span class="docutils literal"><span class="pre">d</span></span> has the same month as itself (<span class="docutils literal"><span class="pre">d</span> <span class="pre">~</span> <span class="pre">d</span></span>); is
symmetric, since if <span class="docutils literal"><span class="pre">d1</span></span> has the same month as <span class="docutils literal"><span class="pre">d2</span></span>, then <span class="docutils literal"><span class="pre">d2</span></span> has the
same month as <span class="docutils literal"><span class="pre">d1</span></span> (<span class="docutils literal"><span class="pre">d1</span> <span class="pre">~</span> <span class="pre">d2</span> <span class="pre">=&gt;</span> <span class="pre">d2</span> <span class="pre">~</span> <span class="pre">d1</span></span>); and transitive, since if <span class="docutils literal"><span class="pre">d1</span> <span class="pre">~</span>
<span class="pre">d2</span> <span class="pre">and</span> <span class="pre">d2</span> <span class="pre">~</span> <span class="pre">d3</span> <span class="pre">=&gt;</span> <span class="pre">d1</span> <span class="pre">~</span> <span class="pre">d3</span></span>.</p>
<p>This relation partitions our set of dates in the equivalence classes
corresponding to <em>dates in January</em>, <em>dates in February</em>, and so on. Note that
the dates for which the relation holds are equivalent, but not necessarily equal.</p>
<p>An <em>equality</em> relation is an equivalence relation which partitions the set <span class="docutils literal"><span class="pre">A</span></span>
consisting of <span class="docutils literal"><span class="pre">n</span></span> objects into exactly <span class="docutils literal"><span class="pre">n</span></span> equivalence classes. In other
words, for any <span class="docutils literal"><span class="pre">x</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, only <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span> is <span class="docutils literal"><span class="pre">true</span></span>.</p>
</div>
<div class="section" id="partial-order-and-total-order">
<h2>Partial Order and Total Order</h2>
<p>A <em>partial order</em> relation <span class="docutils literal"><span class="pre">&lt;=</span></span> is a binary relation that is reflexive,
antisymmetric, and transitive. In other words, it is a preorder which also has
the antisymmetric property.</p>
<p>An example of a partial order is the <em>is subset of</em> relation. It is reflexive
(<span class="docutils literal"><span class="pre">A</span></span> is a subset of <span class="docutils literal"><span class="pre">A</span></span>), antisymmetric (if <span class="docutils literal"><span class="pre">A</span></span> is a subset of <span class="docutils literal"><span class="pre">B</span></span> and
<span class="docutils literal"><span class="pre">B</span></span> is a subset of <span class="docutils literal"><span class="pre">A</span></span>, then <span class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">B</span></span>), and transitive (if <span class="docutils literal"><span class="pre">A</span></span> is a
subset of <span class="docutils literal"><span class="pre">B</span></span> and <span class="docutils literal"><span class="pre">B</span></span> is a subset of <span class="docutils literal"><span class="pre">C</span></span>, then <span class="docutils literal"><span class="pre">A</span></span> is a subset of
<span class="docutils literal"><span class="pre">C</span></span>).</p>
<p>A <em>total order</em> relation is a partial order that is also total. The above
example relation <em>is subset of</em> is not total - there could be a pair of sets
<span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> such that neither is the subset of the other.</p>
<p>An example of a total order relation is <em>less than or equal to</em> for integers.</p>
</div>
<div class="section" id="weak-order-and-strict-weak-order">
<h2>Weak Order and Strict Weak Order</h2>
<p>A <em>weak order</em> relation <span class="docutils literal"><span class="pre">~</span></span> is a binary relation that is transitive and total.
This implies reflexivity (for any <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span>, either <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>, <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span>,
or both, so for <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">x</span></span> we have <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span>). In other words, it is a
preorder which is also total.</p>
<p>An example of a weak order is <em>less than or equal absolute value</em> for complex
numbers. For any two complex numbers <span class="docutils literal"><span class="pre">c1</span></span> and <span class="docutils literal"><span class="pre">c2</span></span>, either <span class="docutils literal"><span class="pre">c1</span> <span class="pre">~</span> <span class="pre">c2</span></span> (
<span class="docutils literal"><span class="pre">|c1|</span> <span class="pre">&lt;=</span> <span class="pre">|c2|</span></span>), <span class="docutils literal"><span class="pre">c2</span> <span class="pre">~</span> <span class="pre">c1</span></span> (<span class="docutils literal"><span class="pre">|c2|</span> <span class="pre">&lt;=</span> <span class="pre">|c1|</span></span>), or both, so <span class="docutils literal"><span class="pre">~</span></span> is total.
We also have <span class="docutils literal"><span class="pre">c1</span> <span class="pre">~</span> <span class="pre">c2</span></span> and <span class="docutils literal"><span class="pre">c2</span> <span class="pre">~</span> <span class="pre">c3</span></span> implies <span class="docutils literal"><span class="pre">c1</span> <span class="pre">~</span> <span class="pre">c3</span></span> (<span class="docutils literal"><span class="pre">|c1|</span> <span class="pre">&lt;=</span> <span class="pre">|c2|</span></span>
and <span class="docutils literal"><span class="pre">|c2|</span> <span class="pre">&lt;=</span> <span class="pre">|c3|</span></span> implies <span class="docutils literal"><span class="pre">|c1|</span> <span class="pre">&lt;=</span> <span class="pre">|c3|</span></span>). Unlike a total order though, the
relation is not antisymmetric. We can have <span class="docutils literal"><span class="pre">c1</span> <span class="pre">~</span> <span class="pre">c2</span></span>, <span class="docutils literal"><span class="pre">c2</span> <span class="pre">~</span> <span class="pre">c1</span></span>, with
<span class="docutils literal"><span class="pre">c1</span></span> and <span class="docutils literal"><span class="pre">c2</span></span> distinct complex numbers (any two numbers with the same
absolute value but different components).</p>
<p>A <em>strict weak order</em> relation <span class="docutils literal"><span class="pre">&lt;</span></span> is a binary relation that is transitive and
strict (irreflexive).</p>
<p>An example of strict weak order is <em>less than</em> for integers.</p>
</div>
<div class="section" id="applications">
<h2>Applications</h2>
<p>Most programming languages provide a way to customize equality, inequality, and
comparison operators (<span class="docutils literal"><span class="pre">==</span></span>, <span class="docutils literal"><span class="pre">!=</span></span>, <span class="docutils literal"><span class="pre">&lt;</span></span>, <span class="docutils literal"><span class="pre">&lt;=</span></span>, <span class="docutils literal"><span class="pre">&gt;</span></span>, <span class="docutils literal"><span class="pre">&gt;=</span></span>). There is an
interesting point to be made about what equality <em>means</em> in this context. For
some types, this can simply mean comparing the bits and if they are the same,
the objects are equal. But we also have <em>logical equality</em> - two objects can
have different bitwise values but still be considered equal. Even more so for
comparing objects - comparing bit representations usually does not translate to
a meaningful comparison of objects.</p>
<p>Note though that any other function <span class="docutils literal"><span class="pre">bool</span> <span class="pre">r(const</span> <span class="pre">T&amp;</span> <span class="pre">m1,</span> <span class="pre">const</span> <span class="pre">T&amp;</span> <span class="pre">m2)</span></span> or
member function <span class="docutils literal"><span class="pre">bool</span> <span class="pre">r(const</span> <span class="pre">T&amp;</span> <span class="pre">other)</span></span> of <span class="docutils literal"><span class="pre">T</span></span> denotes a binary relation
on <span class="docutils literal"><span class="pre">T</span></span>.</p>
<p>Different algorithms require different types of relations to exist between
objects.</p>
<p>For example, we need at least a partial order relation to perform a topological
sort. That is, in an directed acyclic graph, we can sort the vertices such that
for every edge from <span class="docutils literal"><span class="pre">a</span></span> to <span class="docutils literal"><span class="pre">b</span></span>, <span class="docutils literal"><span class="pre">a</span></span> precedes <span class="docutils literal"><span class="pre">b</span></span> in the order. This can
be used, for example, on the dependency graph in a makefile to determine how to
sequence work.</p>
<p>Having an equivalence relation (eg. <span class="docutils literal"><span class="pre">==</span></span>), we can implement a linear search
algorithm to traverse a data structure and find an object equivalent to a given
object. The C++ standard library algorithm <span class="docutils literal"><span class="pre">find</span></span> is an example of such an
algorithm.</p>
<p>Having a total order relation (eg. <span class="docutils literal"><span class="pre">&lt;=</span></span>) or a strict weak order (eg. <span class="docutils literal"><span class="pre">&lt;</span></span>),
allows us to implement binary search over an ordered set of objects. A total
order or strict weak order relation also enables comparison sort algorithms.</p>
<p>Similarly, we need a total oreder or strict weak order to be able to determine a
minimum or a maximum element from a set of objects (<span class="docutils literal"><span class="pre">min_element</span></span> and
<span class="docutils literal"><span class="pre">max_element</span></span> algorithms in C++).</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>A binary relation <span class="docutils literal"><span class="pre">R</span></span> on a set <span class="docutils literal"><span class="pre">A</span></span> is a subset of <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">A</span></span>, denoted by a
characterisitc function <span class="docutils literal"><span class="pre">r</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span>.</li>
<li>A binary relation on a type <span class="docutils literal"><span class="pre">T</span></span> is denoted by either a free function of the
the form <span class="docutils literal"><span class="pre">bool</span> <span class="pre">r(const</span> <span class="pre">T&amp;,</span> <span class="pre">const</span> <span class="pre">T&amp;)</span></span> or a member function <span class="docutils literal"><span class="pre">bool</span>
<span class="pre">r(const</span> <span class="pre">T&amp;)</span></span>.</li>
<li>A binary relations may have several properties: it can be reflexive or strict,
symmetric or antisymmetric, transitive, total etc.</li>
<li>Depending on the properties it has, a relation can be, for example:<ul>
<li>A preorder (reflexive and transitive)</li>
<li>An equivalence (reflexive, symmetric, and transitive)</li>
<li>A partial order (reflexive, antisymmetric, and transitive)</li>
<li>A weak order (reflexive, transitive, and total)</li>
<li>A strict weak order (irreflexive, transitive, and total)</li>
</ul>
</li>
<li>Certain algorithms require the types they operate on to have relations with
certain properties.</li>
</ul>
</div>
]]></description>
             <pubDate>Sun, 10 Dec 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/11/09/notes-on-unit-testing.html</link>
            <guid>http://vladris.com/blog/2017/11/09/notes-on-unit-testing.html</guid>
            <title><![CDATA[Notes on Unit Testing]]></title>
            <description><![CDATA[<h1>Notes on Unit Testing</h1>
<p>This post covers my view on unit testing, why they are important, how to make
time for them, how much to test, and why I don’t believe in TDD. It draws from
my personal experience working on multiple software projects, small and large,
both on new code and legacy code, practices I tried to apply, what worked
well and not so well. While it is more highlevel and I do not provide code
snippets, this is by no means a purely theoretical essay.</p>
<div class="section" id="the-not-enough-time-fallacy">
<h2>The “not enough time” fallacy</h2>
<p>Engineers and engineering teams who are not “bought” on unit testing use the
excuse that there is not enough time to write unit tests. There is always a
deadline or pressure to ship and unit tests, not being “product” code, get lower
priority.</p>
<p>The problem is that we never get it right the first time - as we get a better
understanding of our problem space, we need to refine our solution, which
includes refactoring to better structure the code and redesign to accommodate
for new requirements. This is where unit tests become invaluable in ensuring
that such radical alterations of the codebase can be made safely and easily.</p>
<p>What I noticed first hand is that a team who is not disciplined about testing
starts by churning out a significant amount of code but over surprisingly little
time development slows down to a crawl because there is a lot of manual testing
involved in validating any change, nasty bugs come up, and since refactoring is
now scary (who knows what will break?), engineering debt keeps building up. On
the other hand, teams that author unit tests from the very beginning can
maintain a steady development pace indefinitely.</p>
<p>The funny thing is that engineers who worked in a code base with good test
coverage could never go back - they immediately see the benefits and are sold on
the practice - while engineers who haven’t done it know the theory, pay lip
service to it, but never have time to actually implement tests.</p>
</div>
<div class="section" id="making-time">
<h2>Making time</h2>
<p>There is, unfortunately, never enough time to do the right thing. My advice is
to make time: unit tests are part of feature development, so they should be
accounted for as such. Do not have separate tasks for implementing the feature
and writing the unit tests - these unit testing tasks are prime candidates to be
deprioritized and cut, after all, the feature <em>works</em>, right? Instead consider
testing as part of implementation, create a single task, and adjust estimates
accordingly. There is always pressure to ship, the job of a good engineer is to
not cave under this pressure, set expectations, and deliver a robust solution.
As mentioned above, the ability to keep a steady development pace makes the
average cost of authoring tests over time seem like nothing compared to the
alternative - a steady drop in development agility.</p>
<p>Advice to managers is to encourage a culture of quality and best practices.
Strategically, shipping next week vs the week after is not as important as
shipping in a couple of months vs shipping in a year, which is where the
brittleness of the codebase becomes a major factor. Reward good engineering
practices and you end up with well-engineered code.</p>
<p>That being, sometimes we <em>do</em> need to ship next week.</p>
</div>
<div class="section" id="mqs">
<h2>MQs</h2>
<p>In the old waterfall development days, we had several major milestones, each
spanning months of development: M1, M2 etc. As ship date came near, pressure
increased, and shortcuts were taken more often. In the end, ship dates were met,
but with a lot of compromises. What followed right after, when the team was
burned out after the final stretch, was the so call “quality milestone” or MQ.
Here, engineers were free to reduce debt while project managers went to define
the future version of the product.</p>
<p>I personally love the concept of MQ. While I don’t doubt the existence of
<em>purely agile</em> teams where everything is delivered after week-long sprints with
high quality, most businesses make promises to customers and must meet
deadlines. Sometimes the pressure increases enough that we knowingly take
engineering shortcuts:</p>
<blockquote>
<div><p>If I had a week, I’d do it the right way, but this works for now. I’ll come
back and fix it later.</p>
<p><em>- Every programmer in the world at some point</em></p>
</div></blockquote>
<p>After a hard deadline it’s the perfect time to schedule a mini-MQ - spend a week
or two recovering from burnout and reducing debt.</p>
<p>This expands beyond unit tests to things like refactoring and rearchitecting
code, automating manual processes, writing documentation etc.</p>
</div>
<div class="section" id="the-test-driven-development-fallacy">
<h2>The Test-Driven Development fallacy</h2>
<p>The other extreme is test-driven development. The premise of test-driven
development is that turning requirements into unit tests, then writing code to
make those tests pass is a solid approach to engineering. This sounds great in
theory but falls flat in practice.</p>
<p>Good software is correct, efficient, and maintainable. These qualities come from
a good understanding of the problem being solved and a thought-through solution,
not by making a set of test cases pass. An anecdote I like to reference when
discussing this is the Sudoku solver. Ron Jeffries, one of the founders of
extreme programming, wrote several blog posts in which he attempted to implement
a Sudoku solver using test-driven development <a class="reference external" href="http://xprogramming.com/articles/sudokumusings">here</a>,
<a class="reference external" href="http://xprogramming.com/articles/oksudoku">here</a>, <a class="reference external" href="http://xprogramming.com/articles/sudoku2">here</a>,
<a class="reference external" href="http://xprogramming.com/articles/sudoku4">here</a>, <a class="reference external" href="http://xprogramming.com/articles/sudoku5">here</a>,
and <a class="reference external" href="http://xprogramming.com/articles/roroncemore/">here</a>. The attempt failed.
Around the same time, Peter Norvig implemented a Sudoku solver and wrote a <a class="reference external" href="http://norvig.com/sudoku.html">blog
post</a> with a beautiful explanation of a
thorough approach to analyzing the problem and coming up with a good algorithm
to solve it. The point here is that a set of unit tests, no matter how
comprehensive, will not design an algorithm for you. The algorithm comes from
stepping back and thinking about the problem, which a test-centric approach
actively discourages.</p>
<p>The one good thing that TDD encourages is writing tests which initially fail,
then providing the implementation to make them pass, which ensures the tests
themselves are correct. We can always create a test that exercises a function
and then asserts a tautology (<span class="docutils literal"><span class="pre">Assert.IsTrue(true)</span></span>), which covers the code,
makes the test pass, but provides zero value. Having a test that fails when
invoked with a stub and passes when invoked with the real implementation avoids
this issue.</p>
</div>
<div class="section" id="tests-are-about-behavior-not-design">
<h2>Tests are about behavior, not design</h2>
<p>Almost forgotten across the industry nowadays is that software can be formally
proven correct. A given number of passing tests can only guarantee that for that
particular set of inputs, we get the expected output - which, in case of test
bugs, might not mean anything. The way to be 100% confident that the code does
what we think it does is to prove this fact formally. This is not always
feasible at scale, but for critical pieces of functionality, formalism is better
than test cases.</p>
<p>That doesn’t mean tests are not needed - as soon as a line of code changes (bug
fix, optimization, etc.), the formalism must be re-evaluated, and, outside
fringe programming languages, we can’t automatically detect when a proof no
longer holds. The point is that tests are about behavior not about design - we
design to solve the problem, we test to make sure that our solution does what we
expect it to do. <strong>Design comes first, tests come second, implementation is
third.</strong></p>
<p>Unit tests become valuable when we can make deep changes within our code and
ensure there is no observable change in output. This is invaluable to
engineering velocity.</p>
</div>
<div class="section" id="how-much-is-enough">
<h2>How much is enough?</h2>
<p>In terms of code coverage, I believe something around 90% can easily be achieved
with a minimum of effort. Full coverage is unrealistic because the code always
has some interaction with the world - making network calls, relying on time,
random numbers, IO etc. These are all interactions that can sporadically fail
and unit tests, by definition, must be 100% reliable. A testable design
abstracts all the world interactions under interfaces that can be mocked during
testing. This way, we end up with a thin layer that implements these interfaces
and forwards to the real OS/library functions. This thin layer should not
contain any logic beyond forwarding arguments since it is not really testable
and attempting to write unit tests against it ends up with an ongoing cost of
analyzing random test breaks due to failures in components outside of our
control. The other place where ROI is small is testing trivial code like
getters/setters. This is wasted engineering effort and provides questionably
little value. That being said, this layer should be at most 10% of the code
base, more likely somewhere in the 1-2% range for larger projects. Everything
else should be covered by unit tests.</p>
<p>There is also an interesting distinction between explicit vs implicit testing -
a function can be covered explicitly, by writing unit tests against it, or
implicitly, by writing unit tests against other functions that end up calling
this function. A good rule of thumb is to test against the interface not against
the private implementation. If you can’t reach the same amount of code coverage
by testing the public interface as you can by testing the implementation
details, it means you have dead code in the implementation - code that cannot be
reached from the public interface for any possible input. This code should be
removed not tested. Unit tests have a cost themselves - if we have tests
exercising a function and, during a refactoring, we change the signature of that
function, we have to go update all these tests. If any refactoring we make
breaks unit tests and requires us to fix them, engineering cost of maintaining
test coverage is increased needlessly.</p>
<p>Ideally, we should break and have to update tests when we break the interface
(the unit’s contract to the outside world). We should be able to freely move the
implementation guts around, as keeping tests green in this case is the ultimate
purpose of unit testing - ensuring output through the contract doesn’t break
during internal changes. A couple of gotchas here: if we feel we need to test an
implementation detail because it’s scarily complex, we have a code smell - that
implementation detail should be split into multiple, less scary pieces; if we
have a lot of implementation logic underneath a thin interface, we have another
smell - the component (unit) is too clever and should be split into multiple
components, which would necessarily pull some of the code to the interface
level.</p>
<p>The bottom line is that we can achieve +90% test coverage without taking
dependencies on implementation details.</p>
</div>
<div class="section" id="ease-of-testing">
<h2>Ease of testing</h2>
<p>Unit testing must be easy.</p>
<p>Authoring unit tests should be cheap. Running unit tests should be fast and 100%
reliable. Unit tests should be part of the engineering inner-loop -
code/compile/unit test. Code coverage should be easy to measure. Mocking should
be easy. If any of these points fall short, test coverage suffers. Good
infrastructure makes it easy to author and execute unit tests. This is key in
encouraging a team to use good engineering practices.</p>
<p>The other aspect of testing cost is design - code that is well componentized is
easily testable. Monolithic code, code that implements lots of branching for
various conditions, code that directly calls components outside of our control
(network, UI etc.), are all hard to test. This is not an excuse to bypass
testing, it’s a smell of the code itself.</p>
</div>
<div class="section" id="learned-hopelessness">
<h2>Learned hopelessness</h2>
<p>It’s easy to agree with all of the above but resign yourself to the fact that in
your organization things are different - the infrastructure is not there, the
culture is not there, there is no time. I believe that the most successful and
long-lived software projects have a codebase ridden with compromises and
outdated software practices, which is not a symptom of any problem, it’s the
result of implementing a successful business. It is our duty as software
craftsman to remove the compromises and update the outdated practices, question
the status quo and strive to make things better. Write unit tests!</p>
</div>
]]></description>
             <pubDate>Thu, 09 Nov 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/08/13/24.html</link>
            <guid>http://vladris.com/blog/2017/08/13/24.html</guid>
            <title><![CDATA[24]]></title>
            <description><![CDATA[<h1>24</h1>
<p>I recently learned about the <a class="reference external" href="https://en.wikipedia.org/wiki/24_Game">24 game</a>.
There are several variants of it, but the version I learned goes like this:</p>
<blockquote>
<div><p>Take out the face cards and jokers from a deck and deal four cards (aces or
number cards). Aces can be used either as 1 or as 11. Using addition,
subtraction, multiplication, and division, with any grouping of operations
(paranthesis can be added anywhere), try to come up with an expression that
uses all four cards once and equals 24. Division is fractional, so <span class="docutils literal"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">2</span></span>
is <span class="docutils literal"><span class="pre">2.5</span></span>.</p>
<p>For example for <span class="docutils literal"><span class="pre">A</span> <span class="pre">4</span> <span class="pre">5</span> <span class="pre">8</span></span> we have <span class="math notranslate">\((1 + 5) * (8 - 4)\)</span>.</p>
</div></blockquote>
<p>There is the problem of implementing an algorithm to find a solution given the
cards as input.</p>
<div class="section" id="brute-force">
<h2>Brute force</h2>
<p>A simple solution is to try all permutations of cards, all possible operations,
and all possible groupings.</p>
<p>In the general case, there are 24 ways to arrange the cards - permutations of 4
which is <span class="docutils literal"><span class="pre">4!</span></span>. Each ace doubles this number as we need to consider the case in
which we use it as 1 and the case in which we use it as 11.</p>
<p>There are 64 ways to combine operations, since we have 4 operations in 3
possitions, which means <span class="math notranslate">\(4^3\)</span> total.</p>
<p>We also have 5 possible groupings:</p>
<div class="math notranslate">
\[ \begin{align}\begin{aligned}(x_0 \odot x_1) \oplus (x_2 \otimes x_3)\\((x_0 \odot x_1) \oplus x_2) \otimes x_3\\(x_0 \odot (x_1 \oplus x_2)) \otimes x_3\\x_0 \odot ((x_1 \oplus x_2) \otimes x_3)\\x_0 \odot (x_1 \oplus (x_2 \otimes x_3))\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate">\(\odot, \oplus, \otimes\)</span> are placeholders for any operators (they
could potentially be the same operator).</p>
<p>A simple solver implementation looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">argv</span>

<span class="c1"># Transform arguments to numbers, replace 'A' and 'a' with [1, 11]</span>
<span class="n">args</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="s1">'aA'</span> <span class="k">else</span>
    <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]],</span> <span class="p">[])</span>

<span class="c1"># For every permutation of 4 arguments</span>
<span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="c1"># If we have more 1s and 11s then aces ignore this permutation</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">11</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">continue</span>

    <span class="c1"># For every possible combination of 3 operators</span>
    <span class="k">for</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="s1">'+-*/'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="c1"># For every possible grouping</span>
        <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'({} {} {}) {} ({} {} {})'</span><span class="p">,</span>
                    <span class="s1">'(({} {} {}) {} {}) {} {}'</span><span class="p">,</span>
                    <span class="s1">'({} {} ({} {} {})) {} {}'</span><span class="p">,</span>
                    <span class="s1">'{} {} ({} {} ({} {} {}))'</span><span class="p">,</span>
                    <span class="s1">'{} {} (({} {} {}) {} {})'</span><span class="p">]:</span>

            <span class="c1"># Place operands and operators in expression</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">ops</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If expression evaluates to 24, we found a solution</span>
                <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
                    <span class="nb">exit</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="c1"># Ignore division by zero errors</span>
                <span class="k">pass</span>

<span class="c1"># If we get here we tried all combinations and couldn't</span>
<span class="c1"># find any solution</span>
<span class="k">print</span><span class="p">(</span><span class="s1">'No solution'</span><span class="p">)</span>
</pre></div>
</div>
<p>We have ten possible cards (ace and number cards), and taking combination with
repetition of 4 cards, we have <span class="math notranslate">\(\frac{(n + r - 1)!}{r! * (n - 1)!}\)</span> for
<span class="math notranslate">\(n = 10, r = 4\)</span>, so a total of <span class="math notranslate">\(\frac{(10 + 4 - 1)!}{4! * (10 - 1)!}
= 715\)</span> possible games.</p>
<p>Feeding all possible games to the code above, we can see that there are 117
games which have no solution. The remaining 598 games are solvable.</p>
<p>We can optimize the above solution further by observing that we only need three
of the five groupings to cover all cases. Take, for example,
<span class="math notranslate">\(x_0 \odot ((x_1 \oplus x_2) \otimes x_3)\)</span>. Now if <span class="math notranslate">\(\odot\)</span> is a
commutative operation (addition or multiplication), we can rewrite this to the
equivalent <span class="math notranslate">\(((x_1 \oplus x_2) \otimes x_3) \odot x_0\)</span>, and since we any
way take all permuations of arguments and operators, this ends up getting
covered by the <span class="math notranslate">\(((x_0 \odot x_1) \oplus x_2) \otimes x_3\)</span> case. For
non-commutative operations, for example subtraction, notice that if we do have
a solution <span class="math notranslate">\(x_0 - ((x_1 \oplus x_2) \otimes x_3) = 24\)</span>, since <span class="math notranslate">\(x_0\)</span>
is at most 11, it means we need to subtract a negative number from it in order
to get 24. This implies that at least <span class="math notranslate">\(\oplus\)</span> or <span class="math notranslate">\(\otimes\)</span> is also
a subtraction. If <span class="math notranslate">\(\otimes\)</span> is a subtraction, we can rewrite the
expression <span class="math notranslate">\(x_0 - ((x_1 \oplus x_2) - x_3)\)</span> as <span class="math notranslate">\((x_0 + x_3) -
(x_1 \oplus x_2)\)</span>. If <span class="math notranslate">\(\otimes\)</span> is not a subtraction but <span class="math notranslate">\(\oplus\)</span>
is, we have <span class="math notranslate">\(x_0 - ((x_1 - x_2) \otimes x_3)\)</span> which is equivalent with
<span class="math notranslate">\(x_0 - (- (x_2 - x_1) \otimes x_3)\)</span>. If <span class="math notranslate">\(\otimes\)</span> is addition, this
becomes <span class="math notranslate">\(x_0 - (x_3 - (x_2 - x_1))\)</span> = <span class="math notranslate">\((x_0 - x_3) + (x_2 - x_1)\)</span>.
If <span class="math notranslate">\(\otimes\)</span> is multiplication or division, this becomes <span class="math notranslate">\(x_0 - (-
(x_2 - x_1) \otimes x_3)\)</span> = <span class="math notranslate">\(x_0 + ((x_2 - x_1) \otimes x_3)\)</span> =
<span class="math notranslate">\(((x_2 - x_1) \otimes x_3) + x_0\)</span>.</p>
<p>Similar rewrites can be done if <span class="math notranslate">\(\odot\)</span> is division by observing that we
would have to divide with a fractional number in order to get 24, so at least
one of <span class="math notranslate">\(\oplus\)</span> or <span class="math notranslate">\(\otimes\)</span> is also a division. This means we only
need the groupings</p>
<div class="math notranslate">
\[ \begin{align}\begin{aligned}(x_0 \odot x_1) \oplus (x_2 \otimes x_3)\\((x_0 \odot x_1) \oplus x_2) \otimes x_3\\(x_0 \odot (x_1 \oplus x_2)) \otimes x_3\end{aligned}\end{align} \]</div>
<p>to find all possible solutions. Our solution becomes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">argv</span>

<span class="n">args</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="s1">'aA'</span> <span class="k">else</span>
    <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]],</span> <span class="p">[])</span>

<span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">11</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">continue</span>

    <span class="k">for</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="s1">'+-*/'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'({} {} {}) {} ({} {} {})'</span><span class="p">,</span>
                    <span class="s1">'(({} {} {}) {} {}) {} {}'</span><span class="p">,</span>
                    <span class="s1">'({} {} ({} {} {})) {} {}'</span><span class="p">]:</span>

            <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">ops</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
                    <span class="nb">exit</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="k">pass</span>

<span class="k">print</span><span class="p">(</span><span class="s1">'No solution'</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that for games without aces, we need to check 24 (<span class="math notranslate">\(4!\)</span>)
permutations of cards, 64 (<span class="math notranslate">\(4^3\)</span>) combinations of operators, and 3
groupings. That is <span class="math notranslate">\(4! * 4^3 * 3 = 4608\)</span> tests. For games with aces, we
double this number for each ace to account for both the 1 and 11 cases.</p>
</div>
<div class="section" id="minimizing-number-of-tests">
<h2>Minimizing Number of Tests</h2>
<p>A more interesting question is what is the minimum number of tests we need to
perform in order to correctly find a solution for all solvable games.</p>
<p>It is obvious that there are expressions which can never evaluate to 24 for any
game. For example <span class="math notranslate">\((x_0 - x_1) - x_2) - x_3\)</span>, since <span class="math notranslate">\(x_i \in \{1,
2, ... 11\}\)</span>.</p>
<p>It is also obvious that we perform a lot of redundant tests, since, for example,
all of the below expressions are equivalent for all possible inputs:</p>
<div class="math notranslate">
\[ \begin{align}\begin{aligned}(x_0 + x_1) + (x_2 + x_3)\\((x_0 + x_1) + x_2) + x_3\\(x_0 + (x_1 + x_2)) + x_3\\(x_0 + x_1) + (x_3 + x_2)\\((x_0 + x_1) + x_3) + x_2\\(x_0 + (x_1 + x_3)) + x_2\\...\end{aligned}\end{align} \]</div>
<p>and so on for all permutations of <span class="math notranslate">\(x_0, x_1, x_2, x_3\)</span>.</p>
<p>Let’s generate all possible permutations of cards, combinations of operators,
and groupings as above:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">itertools</span>

<span class="n">operands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span> <span class="c1"># 24 of these</span>
<span class="n">operators</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="s1">'+-*/'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># 64 of these</span>
<span class="n">groupings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'({} {} {}) {} ({} {} {})'</span><span class="p">,</span>
             <span class="s1">'(({} {} {}) {} {}) {} {}'</span><span class="p">,</span>
             <span class="s1">'({} {} ({} {} {})) {} {}'</span><span class="p">]</span> <span class="c1"># 3 of these</span>
</pre></div>
</div>
<p>Note that here we are looking at all possible games so operands are permutations
of indexes from 0 to 3, not actual cards. We can also take all possible games as
combinations of 4 numbers from 1 to 11. Here we generate 1 and 11 games for each
ace, so we end up with 1001 possible games instead of 715:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># 1001 of these</span>
</pre></div>
</div>
<p>We can now write a function that, for a given game, generates all possible
expressions which evaluate to 24:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">solutions_for</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">operators</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">groupings</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">inp</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inp</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                            <span class="n">ops</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">inp</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">3</span><span class="p">]]))</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">exp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="s1">'x{xs[0]}'</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">f</span><span class="s1">'x{xs[1]}'</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="s1">'x{xs[2]}'</span><span class="p">,</span>
                            <span class="n">ops</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="s1">'x{xs[3]}'</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                    <span class="k">pass</span>
</pre></div>
</div>
<p>This is very similar with the initial solution, except that we don’t have to
worry about aces (we assume they are already converted to either 1 or 11), and
we use the permutations of indexes to determine the order of terms as input is
going to always be in increasing order (as generated by
<span class="docutils literal"><span class="pre">itertools.combinations_with_replacement</span></span>). So instead of placing <span class="docutils literal"><span class="pre">inp[0],</span>
<span class="pre">op[0],</span> <span class="pre">inp[1],</span> <span class="pre">op[1],</span> <span class="pre">inp[2],</span> <span class="pre">op[2],</span> <span class="pre">inp[3]</span></span> in the expression to be evaluated
as we did in the initial solution, since <span class="docutils literal"><span class="pre">inp</span></span> is fixed, we come up with
permutations of operands from <span class="docutils literal"><span class="pre">operands</span></span>, so we are placing <span class="docutils literal"><span class="pre">inp[xs[0]],</span>
<span class="pre">op[0],</span> <span class="pre">inp[xs[1]],</span> <span class="pre">op[1],</span> <span class="pre">inp[xs[2]],</span> <span class="pre">op[2],</span> <span class="pre">inp[xs[3]]</span></span> in the expression
instead. We also return the expression replacing the operands with <span class="docutils literal"><span class="pre">x0,</span> <span class="pre">x1,</span> <span class="pre">x2,</span>
<span class="pre">x3</span></span> since we don’t care about their particular values, rather the expression
we are using.</p>
<p>For example calling:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="nb">list</span><span class="p">(</span><span class="n">solutions_for</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]))</span>
</pre></div>
</div>
<p>yields</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>['((x0 * x2) - x3) * x1', '(x1 * x2) - (x3 / x0)',
 '((x2 * x0) - x3) * x1', '((x2 / x0) * x3) - x1',
 '(x2 / (x0 / x3)) - x1', '(x2 * x1) - (x3 / x0)',
 '((x2 * x3) / x0) - x1', '(x2 * (x3 / x0)) - x1',
 '((x3 / x0) * x2) - x1', '(x3 / (x0 / x2)) - x1',
 '((x3 * x2) / x0) - x1', '(x3 * (x2 / x0)) - x1']
</pre></div>
</div>
<p>These are all possible expression which evaluate to 24 for the game <span class="docutils literal"><span class="pre">2</span> <span class="pre">4</span> <span class="pre">7</span> <span class="pre">8</span></span>.</p>
<p>We can compute the list of all expressions which evaluate to 24 for every
possible game:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">solutions_for</span><span class="p">(</span><span class="n">inp</span><span class="p">))</span>

    <span class="c1"># Only append the set of expressions to the list if</span>
    <span class="c1"># non-empty (if game has at least one solution)</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>We can take the union of the sets in <span class="docutils literal"><span class="pre">results</span></span> and get the set of all
expressions that evaluate to 24 for at least one game:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">expressions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="n">expressions</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>The size of this set is 1809. We are guaranteed that for any possible game, no
other expression evaluates to 24 since we generated all possible solutions for
all possible games. Which means we can test just these 1809 expression for any
game and determine whether it is solvable or not, which is better than our
original 4608 (or more for games with aces).</p>
<p>Here we eliminated all expressions which never evaluate to 24, but we still have
all the redundant tests in our set of expressions. It is also possible to have
an expression <span class="math notranslate">\(E_0\)</span> which solves all games some expression <span class="math notranslate">\(E_1\)</span>
solves, plus some other games. In which case we wouldn’t ever need to test using
<span class="math notranslate">\(E_1\)</span> since <span class="math notranslate">\(E_0\)</span> would still solve all games that <span class="math notranslate">\(E_1\)</span> would
solve.</p>
<p>More formally, <span class="docutils literal"><span class="pre">expressions</span></span> is our universe <span class="math notranslate">\(\mathcal{U}\)</span> of tests and
<span class="docutils literal"><span class="pre">results</span></span> is a set of sets <span class="math notranslate">\(R = \{ R_0, R_1 ... R_n \}\)</span> where
<span class="math notranslate">\(R_i \subset \mathcal{U} \space \forall i \in \{ 0, 1 ... n \}\)</span>. We want
to find the smallest set <span class="math notranslate">\(H \subset \mathcal{U}\)</span> such that <span class="math notranslate">\(H \cap
R_i \neq \varnothing \space \forall i \in \{ 0, 1 ... n \}\)</span>.</p>
<p>The good news is that this is actually a well known problem called <strong>the hitting
set problem</strong> <a class="footnote-reference" href="#id3" id="id2">[1]</a>. The bad news is this problem is NP-hard. Even with clever
pruning, trying out combinations of expressions to find the smallest <span class="math notranslate">\(H\)</span>
has factorial complexity and even for small sets it quickly reaches astronomical
numbers.</p>
</div>
<div class="section" id="approximation">
<h2>Approximation</h2>
<p>Since finding an optimal solution is too computationally expensive, we can at
least attempt to find a <em>good enough</em> solution.</p>
<p>The greedy algorithm which solves the hitting set problem works as follows:
build up the solution by selecting at each step the element which hits the
highest number of sets which were not hit so far.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># Start with an empty set</span>
<span class="n">min_expressions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># While we have unhit sets</span>
<span class="k">while</span> <span class="n">results</span><span class="p">:</span>
    <span class="n">min_expression</span><span class="p">,</span> <span class="n">max_hitting</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="mi">0</span>

    <span class="c1"># For each expression in our universe</span>
    <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
        <span class="n">hitting</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">result</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">hitting</span> <span class="o">&gt;</span> <span class="n">max_hitting</span><span class="p">:</span>
            <span class="n">min_expression</span><span class="p">,</span> <span class="n">max_hitting</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="n">hitting</span>

    <span class="c1"># We found the expression hitting most unhit sets</span>
    <span class="n">min_expressions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">min_expression</span><span class="p">)</span>

    <span class="c1"># Remove hit sets from results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span>
        <span class="n">min_expression</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
</pre></div>
</div>
<p>Interestingly enough, since we are working with sets and hashing is randomized
in Python, I got different results across different runs of this algorithm. For
cases where there are multiple max hitting sets (sets intersecting the same
number of other sets), we non-deterministically select one, since iteration over
sets is based on the randomized key order. I got solutions ranging from 110 to
114 expressions. This gives us an upper bound of 110 - we must perform at most
110 tests to find a solution for a game.</p>
<p>We can use the above code to generate a set of expressions and dump it into a
source file, together with the code to test input:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">argv</span>

<span class="n">expressions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">"(x3 + x1) * (x2 - x0)"</span><span class="p">,</span> <span class="s2">"((x2 * x3) - x0) / x1"</span><span class="p">,</span>
    <span class="s2">"(x3 + (x1 + x0)) * x2"</span><span class="p">,</span> <span class="s2">"(x0 - x3) * (x1 - x2)"</span><span class="p">,</span>
    <span class="s2">"(x1 * x0) + (x2 - x3)"</span><span class="p">,</span> <span class="s2">"((x2 * x0) * x3) - x1"</span><span class="p">,</span>
    <span class="s2">"(x3 + (x1 + x2)) + x0"</span><span class="p">,</span> <span class="s2">"(x2 * x0) + (x3 - x1)"</span><span class="p">,</span>
    <span class="s2">"((x0 / x1) * x2) * x3"</span><span class="p">,</span> <span class="s2">"(x1 * (x3 - x2)) + x0"</span><span class="p">,</span>
    <span class="s2">"((x3 + x2) - x0) + x1"</span><span class="p">,</span> <span class="s2">"(x0 * x1) * (x3 - x2)"</span><span class="p">,</span>
    <span class="s2">"(x1 * x0) - (x2 + x3)"</span><span class="p">,</span> <span class="s2">"(x3 / x1) * (x2 + x0)"</span><span class="p">,</span>
    <span class="s2">"((x2 + x1) + x3) * x0"</span><span class="p">,</span> <span class="s2">"(x3 - x0) / (x1 / x2)"</span><span class="p">,</span>
    <span class="s2">"(x3 + x1) * (x2 / x0)"</span><span class="p">,</span> <span class="s2">"(x1 * x3) + (x0 * x2)"</span><span class="p">,</span>
    <span class="s2">"((x3 * x1) + x2) + x0"</span><span class="p">,</span> <span class="s2">"((x0 - x2) + x1) * x3"</span><span class="p">,</span>
    <span class="s2">"((x3 / x0) + x2) * x1"</span><span class="p">,</span> <span class="s2">"(x3 + (x2 * x1)) - x0"</span><span class="p">,</span>
    <span class="s2">"(x1 * x3) - (x2 - x0)"</span><span class="p">,</span> <span class="s2">"(x1 * (x3 - x0)) - x2"</span><span class="p">,</span>
    <span class="s2">"((x2 + x1) * x3) / x0"</span><span class="p">,</span> <span class="s2">"(x0 * x3) - (x1 + x2)"</span><span class="p">,</span>
    <span class="s2">"(x1 + (x3 * x0)) * x2"</span><span class="p">,</span> <span class="s2">"(x0 * (x2 + x3)) - x1"</span><span class="p">,</span>
    <span class="s2">"(x1 * x3) - (x0 + x2)"</span><span class="p">,</span> <span class="s2">"(x3 - (x2 / x1)) * x0"</span><span class="p">,</span>
    <span class="s2">"(x0 - (x1 / x2)) * x3"</span><span class="p">,</span> <span class="s2">"(x3 * x0) + (x2 - x1)"</span><span class="p">,</span>
    <span class="s2">"((x3 / x0) + x1) + x2"</span><span class="p">,</span> <span class="s2">"(x3 + (x1 * x2)) + x0"</span><span class="p">,</span>
    <span class="s2">"(x0 + x2) * (x1 + x3)"</span><span class="p">,</span> <span class="s2">"(x0 * (x3 - x1)) + x2"</span><span class="p">,</span>
    <span class="s2">"((x0 + x3) * x1) * x2"</span><span class="p">,</span> <span class="s2">"(x2 * (x0 + x3)) / x1"</span><span class="p">,</span>
    <span class="s2">"(x2 - (x1 + x0)) * x3"</span><span class="p">,</span> <span class="s2">"(x3 * x2) - (x0 / x1)"</span><span class="p">,</span>
    <span class="s2">"((x0 + x3) * x1) + x2"</span><span class="p">,</span> <span class="s2">"((x0 * x3) + x1) - x2"</span><span class="p">,</span>
    <span class="s2">"(x2 + (x3 - x1)) * x0"</span><span class="p">,</span> <span class="s2">"(x2 * (x0 + x1)) + x3"</span><span class="p">,</span>
    <span class="s2">"((x2 + x3) * x0) + x1"</span><span class="p">,</span> <span class="s2">"(x0 - (x3 / x2)) * x1"</span><span class="p">,</span>
    <span class="s2">"((x0 + x2) - x3) * x1"</span><span class="p">,</span> <span class="s2">"((x3 / x2) + x0) * x1"</span><span class="p">,</span>
    <span class="s2">"(x1 / x0) + (x2 + x3)"</span><span class="p">,</span> <span class="s2">"((x1 * x0) - x2) * x3"</span><span class="p">,</span>
    <span class="s2">"((x0 + x1) + x2) * x3"</span><span class="p">,</span> <span class="s2">"(x2 * (x3 - x1)) - x0"</span><span class="p">,</span>
    <span class="s2">"((x2 * x1) - x0) * x3"</span><span class="p">,</span> <span class="s2">"((x3 - x1) * x2) + x0"</span><span class="p">,</span>
    <span class="s2">"(x3 / (x0 + x1)) * x2"</span><span class="p">,</span> <span class="s2">"((x1 * x0) + x3) + x2"</span><span class="p">,</span>
    <span class="s2">"(x3 + x0) * (x2 - x1)"</span><span class="p">,</span> <span class="s2">"(x2 - x0) * (x3 - x1)"</span><span class="p">,</span>
    <span class="s2">"((x3 / x0) * x2) + x1"</span><span class="p">,</span> <span class="s2">"((x2 * x1) - x0) - x3"</span><span class="p">,</span>
    <span class="s2">"(x0 + (x3 - x1)) * x2"</span><span class="p">,</span> <span class="s2">"(x0 * x2) / (x3 - x1)"</span><span class="p">,</span>
    <span class="s2">"((x3 * x2) - x1) / x0"</span><span class="p">,</span> <span class="s2">"(x2 - (x0 / x3)) * x1"</span><span class="p">,</span>
    <span class="s2">"(x3 - x2) * (x0 + x1)"</span><span class="p">,</span> <span class="s2">"(x0 * x2) - (x3 + x1)"</span><span class="p">,</span>
    <span class="s2">"((x2 - x0) * x3) + x1"</span><span class="p">,</span> <span class="s2">"(x1 * (x3 - x0)) + x2"</span><span class="p">,</span>
    <span class="s2">"(x1 * (x0 + x3)) - x2"</span><span class="p">,</span> <span class="s2">"((x0 + x1) * x3) + x2"</span><span class="p">,</span>
    <span class="s2">"((x1 - x2) + x3) * x0"</span><span class="p">,</span> <span class="s2">"((x3 - x1) * x2) * x0"</span><span class="p">,</span>
    <span class="s2">"((x2 + x1) - x3) * x0"</span><span class="p">,</span> <span class="s2">"(x1 + (x3 / x2)) * x0"</span><span class="p">,</span>
    <span class="s2">"(x2 / (x0 / x1)) + x3"</span><span class="p">,</span> <span class="s2">"(x2 / (x3 - x0)) * x1"</span><span class="p">,</span>
    <span class="s2">"(x3 * x1) - (x0 * x2)"</span><span class="p">,</span> <span class="s2">"((x1 + x0) * x2) * x3"</span><span class="p">,</span>
    <span class="s2">"(x1 - (x2 / x3)) * x0"</span><span class="p">,</span> <span class="s2">"(x2 + (x3 * x0)) + x1"</span><span class="p">,</span>
    <span class="s2">"((x2 * x3) + x1) / x0"</span><span class="p">,</span> <span class="s2">"(x3 - x0) * (x2 + x1)"</span><span class="p">,</span>
    <span class="s2">"(x1 * x3) + (x2 - x0)"</span><span class="p">,</span> <span class="s2">"(x3 * (x2 - x0)) - x1"</span><span class="p">,</span>
    <span class="s2">"(x0 + (x1 - x3)) * x2"</span><span class="p">,</span> <span class="s2">"(x1 * (x3 - x2)) - x0"</span><span class="p">,</span>
    <span class="s2">"(x0 + (x2 * x3)) - x1"</span><span class="p">,</span> <span class="s2">"(x2 + x3) / (x0 / x1)"</span><span class="p">,</span>
    <span class="s2">"(x0 * x3) / (x2 - x1)"</span><span class="p">,</span> <span class="s2">"(x2 - (x3 / x0)) * x1"</span><span class="p">,</span>
    <span class="s2">"(x0 - (x1 - x2)) * x3"</span><span class="p">,</span> <span class="s2">"(x3 + x1) + (x2 * x0)"</span><span class="p">,</span>
    <span class="s2">"((x3 - x1) - x0) * x2"</span><span class="p">,</span> <span class="s2">"(x1 * (x2 - x0)) - x3"</span><span class="p">,</span>
    <span class="s2">"(x2 + x0) * (x3 - x1)"</span><span class="p">,</span> <span class="s2">"((x3 - x1) * x2) / x0"</span><span class="p">,</span>
    <span class="s2">"((x1 * x3) - x2) * x0"</span><span class="p">,</span> <span class="s2">"((x1 + x3) * x0) - x2"</span><span class="p">,</span>
    <span class="s2">"((x3 - x2) + x0) * x1"</span><span class="p">,</span> <span class="s2">"((x2 * x0) - x3) * x1"</span><span class="p">,</span>
    <span class="s2">"(x2 * (x1 + x0)) - x3"</span><span class="p">,</span> <span class="s2">"(x0 + (x1 / x2)) * x3"</span><span class="p">,</span>
    <span class="s2">"((x2 - x1) * x3) + x0"</span><span class="p">,</span> <span class="s2">"((x2 / x1) + x3) * x0"</span><span class="p">,</span>
    <span class="s2">"(x1 * x0) - (x2 / x3)"</span><span class="p">,</span> <span class="s2">"((x3 * x0) - x1) * x2"</span><span class="p">,</span>
    <span class="s2">"((x2 - x0) * x1) + x3"</span><span class="p">,</span> <span class="s2">"((x1 + x0) * x3) - x2"</span><span class="p">,</span>
    <span class="s2">"(x1 * x0) / (x3 - x2)"</span><span class="p">,</span> <span class="s2">"(x3 * (x1 - x0)) - x2"</span>
<span class="p">]</span>

<span class="c1"># Since we no longer try all permutations of cards, we</span>
<span class="c1"># need to split inputs containing aces by replacing aces</span>
<span class="c1"># with both 1 and 11</span>
<span class="k">def</span> <span class="nf">get_input</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">'A'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">]</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">'A'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">get_input</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">get_input</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">'11'</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

<span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">get_input</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]):</span>
    <span class="c1"># We also expect inputs to be in sorted order now</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="c1"># Replace x0 ... x3 with args[0] ... args[3]</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'x'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">pass</span>

<span class="k">print</span><span class="p">(</span><span class="s1">'No solution'</span><span class="p">)</span>
</pre></div>
</div>
<p>We can test this by ensuring that we still see 117 games without solution when
we try to solve all 715 games, which is indeed the case. We reduced the number
of tests we perform on a game from 4608 to 110.</p>
</div>
<div class="section" id="unique-expressions">
<h2>Unique Expressions</h2>
<p>There are a couple of other interesting facts we can determine from the set of
all solutions for all games: the set of unique expressions and out of them, the
subset of expressions which are absolutely required in order to solve all
possible games.</p>
<p>By <em>unique expression</em> I mean picking an expression and eliminating all other
equivalent expressions from the set (for example keeping only
<span class="math notranslate">\(((x_0 + x_1) + x_2) + x_3\)</span> while dropping all other permutations and
groupings of addition). We can easily do this by defining equivalent expressions
as expressions which solve the exact same games. So if <span class="math notranslate">\(E_1\)</span> solves some
subset <span class="math notranslate">\(R_{E_1}\)</span> of <span class="math notranslate">\(R\)</span>, an expression <span class="math notranslate">\(E_2\)</span> is equivalent to
it if the set <span class="math notranslate">\(R_{E_2}\)</span> of games it solves is equal to <span class="math notranslate">\(R_{E_1}\)</span>. We
can define equivalence as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">equivalent</span><span class="p">(</span><span class="n">exp1</span><span class="p">,</span> <span class="n">exp2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exp1</span> <span class="ow">in</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">exp2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">exp1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">exp2</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<p>With this function, we can go over our univese <span class="math notranslate">\(\mathcal{U}\)</span> of
expressions and eliminate all expressions which are the equivalent of another
expression:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">expressions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
<span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">):</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">equivalent</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="n">i2</span><span class="p">]):</span>
            <span class="n">expressions</span> <span class="o">=</span> <span class="n">expressions</span><span class="p">[:</span><span class="n">i2</span><span class="p">]</span> <span class="o">+</span> <span class="n">expressions</span><span class="p">[</span><span class="n">i2</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">expressions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting set of unique expressions has 273 elements. This means these 273
expressions are enough to solve all possible games and, more so, adding any
other expression to this set would be redundant. This is a lower bound than our
original 1809 expressions which solve games, but higher than our previously
found bound of 110 expressions. Note that this data point is not useful in the
greedy algorithm shown in the previous section, since once that algorithm picks
an expression, it would automatically discard all other equivalent expressions,
since it eliminates all games which are solved by the picked expression from the
search space. This should put the problem in combinatorial perspective though,
as we need to select from 273 candidates to find the smallest hitting set.</p>
<p>Once we have eliminated equivalent expressions, we can update the set of game
results accordingly, by intersecting each <span class="math notranslate">\(R_i\)</span> with our new
<span class="math notranslate">\(\mathcal{U}\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
</pre></div>
</div>
<p>Now we can search <span class="math notranslate">\(R\)</span> for sets with a single element. This will give us
expressions which must be part of our solution, otherwise eliminating them would
cause a solvable game to appear as unsolvable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">min_expressions</span><span class="p">,</span> <span class="n">games_with_unique_result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">min_expressions</span> <span class="o">=</span> <span class="n">min_expressions</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">games_with_unique_result</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Turns out there are 62 expressions which (ignoring equivalences) provide unique
solutions to games. They are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>{'(x1 + x2) - (x0 - x3)', '(x1 + x0) * (x2 * x3)',
 '((x1 + x0) - x2) * x3', '((x3 + x2) * x0) + x1',
 '(x0 + x3) * (x2 - x1)', '((x2 * x1) / x0) + x3',
 '((x3 - x1) * x2) - x0', '(x1 - (x3 / x2)) * x0',
 '((x1 * x0) - x2) - x3', '((x2 - x1) - x0) * x3',
 '((x1 * x0) - x3) + x2', '(x2 + (x1 / x0)) + x3',
 '((x1 + x3) - x2) * x0', '(x2 - (x3 - x0)) * x1',
 '(x2 + (x1 + x3)) + x0', '(x1 * x0) - (x2 / x3)',
 '(x3 + (x2 * x1)) - x0', '((x0 * x1) + x3) + x2',
 '(x2 + (x1 - x3)) * x0', '((x0 * x1) - x2) * x3',
 '(x2 * x0) + (x1 + x3)', '(x2 + (x3 * x0)) + x1',
 '((x0 * x3) - x1) + x2', '(x0 + (x2 - x1)) * x3',
 '((x3 * x1) - x2) - x0', '(x1 - x2) * (x0 - x3)',
 '((x3 - x0) - x1) * x2', '(x1 * (x2 - x0)) - x3',
 '(x0 / (x3 - x2)) * x1', '((x0 + x1) - x3) * x2',
 '((x3 - x1) + x0) * x2', '((x1 + x0) * x3) + x2',
 '((x1 + x0) * x3) - x2', '(x3 / x1) * (x2 + x0)',
 '((x3 - x1) * x0) + x2', '(x3 * (x2 - x0)) + x1',
 '((x0 + x2) + x1) * x3', '(x2 * (x0 + x1)) - x3',
 '(x2 * x1) / (x3 - x0)', '(x3 + x0) + (x1 * x2)',
 '(x0 + (x3 * x2)) - x1', '(x0 - x2) * (x1 - x3)',
 '((x2 + x3) * x1) / x0', '(x2 / x0) * (x3 + x1)',
 '(x3 * (x1 - x0)) - x2', '((x3 + x1) * x0) - x2',
 '((x0 + x3) * x1) - x2', '((x3 + x2) * x0) - x1',
 '(x3 + x0) / (x1 / x2)', '(x0 + x2) * (x3 - x1)',
 '(x2 * (x3 - x1)) + x0', '((x0 * x3) - x2) - x1',
 '((x1 * x2) - x3) - x0', '(x3 - (x1 - x2)) * x0',
 '(x2 * x3) / (x1 + x0)', '(x3 - x2) * (x0 + x1)',
 '(x0 / (x3 - x1)) * x2', '((x2 * x3) - x0) / x1',
 '(x2 * (x3 - x0)) / x1', '((x1 + x0) * x2) + x3',
 '(x1 * (x2 - x0)) + x3', '(x3 * (x2 - x1)) + x0'}
</pre></div>
</div>
<p>This is a lower bound for our problem, since at the very least we need these
expressions in order to correcly solve all possible games. We also computed the
number of games with a unique solution, which is 122. The remaining games are
either unsolvable or admit multiple solutions. Note we considered aces as 1s and
aces as 11s as distinct games in the above analysis. We could search for
equivalent games (number of 1s and 11s is the same) and see if we can eliminate
some expressions from the list above. This is left as an exercise to the reader.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>There are 715 distinct games in 24, with 117 of them unsolvable and the
remaining 598 having at least one solution.</li>
<li>A brute-force solution checks 4608 expressions (double for each ace) to
determine that a game is unsolvable.</li>
<li>Only 1809 expressions (out of the 4608) solve at least one game.</li>
<li>Finding the minimum number of expressions we need to check in order to find
whether a game has a solution is equivalent to the hitting set problem which
is NP-hard.</li>
<li>A greedy algorithm finds a set of 110 expressions which is enough to find a
solution for any solvable game.</li>
<li>Removing equivalent expressions, we are left with 273 expressions which all
solve at least one different game than any other. Out of these, 62 expressions
are unique solutions to 122 games, so they must necessarily be checked in
order to find solutions for all possible games.</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Wikipedia explains the <a class="reference external" href="https://en.wikipedia.org/wiki/Set_cover_problem">set cover problem</a>
which is equivalent to the hitting set problem (one can be converted to
the other).</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sun, 13 Aug 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/07/20/idris-totality-dependent-types-proofs.html</link>
            <guid>http://vladris.com/blog/2017/07/20/idris-totality-dependent-types-proofs.html</guid>
            <title><![CDATA[Idris: Totality, Dependent Types, Proofs]]></title>
            <description><![CDATA[<h1>Idris: Totality, Dependent Types, Proofs</h1>
<p>Idris is a programming language inspired by Haskell, with a set of innovative
features to facilitate type safety and program correctness.
<a class="reference external" href="https://www.manning.com/books/type-driven-development-with-idris">Type Driven Development with Idris</a>
is a great introductory book which I highly recommend. In this post, I will try
to cover the features I was most impressed with, providing some simple code
samples. I will not cover syntax since most should be familiar from Haskell. If
you are not familiar with Haskell syntax, here is a nice <a class="reference external" href="https://matela.com.br/pub/cheat-sheets/haskell-ucs-0.4.pdf">syntax cheat sheet</a>.
If you are not interested in either Haskell or Idris syntax, start with the last
section of this post, <a class="reference internal" href="http://vladris.com/blog/2017/07/20/idris-totality-dependent-types-proofs.html#thoughts-about-the-future">Thoughts about the Future</a>.</p>
<div class="section" id="totality-checking">
<h2>Totality Checking</h2>
<p>A total function in Idris is a function which is defined for all possible inputs
and is guaranteed to produce a result in a finite amount of time <a class="footnote-reference" href="#id3" id="id1">[1]</a>. The
compiler obviously employs a heuristic, since the halting problem is
undecidable, but is usually close enough to the truth to guarantee correctness
from this point of view. It achieves this not by evaluating the function, but by
ensuring that every recursive branch converges to a halting branch.</p>
<p>Natural numbers are defined in Idris using Peano axioms, so it is easy to prove
things about them. Here is a minimal definition of natural numbers <a class="footnote-reference" href="#id4" id="id2">[2]</a>:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Nat'</span> <span class="ow">=</span> <span class="kt">Z</span> <span class="ow">|</span> <span class="kt">S</span> <span class="kt">Nat'</span>
</pre></div>
</div>
<p>This defines <span class="docutils literal"><span class="pre">Nat'</span></span> as a data type which can be constructed either as <span class="docutils literal"><span class="pre">Z</span></span>
(zero) or <span class="docutils literal"><span class="pre">S</span> <span class="pre">Nat'</span></span> (successor of another natural number). With this
definition, the compiler can easily determine the following function is total:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">f</span> <span class="ow">:</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="ow">()</span>
f <span class="kt">Z</span> <span class="ow">=</span> <span class="ow">()</span>
f <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> <span class="ow">=</span> f k
</pre></div>
</div>
<p>This function return a unit given <span class="docutils literal"><span class="pre">Z</span></span>, otherwise it recursively takes the
predecessor of the argument. This converges to the <span class="docutils literal"><span class="pre">Z</span></span> case. The following
function, on the other hand, is correctly identified as potentially
non-terminating:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">g</span> <span class="ow">:</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="ow">()</span>
g n <span class="ow">=</span> g <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span>
</pre></div>
</div>
<p>These are trivial examples, but in general, having a compile-time check for
termination is a very powerful tool.</p>
</div>
<div class="section" id="dependent-types">
<h2>Dependent Types</h2>
<p>Dependent types are types computed from other types. To put it another way,
Idris has first-order types, meaning functions can take types as arguments and
return types as their output. Functions that compute types are evaluated at
compile time. This is similar to C++ metaprogramming, but without employing a
different syntax.</p>
<p>Before an example, we first need to define addition on naturals as follows:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="ow">(+)</span> <span class="ow">:</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="kt">Nat'</span>
<span class="ow">(+)</span> <span class="kt">Z</span> r <span class="ow">=</span> r
<span class="ow">(+)</span> <span class="ow">(</span><span class="kt">S</span> l<span class="ow">)</span> r <span class="ow">=</span> <span class="kt">S</span> <span class="ow">(</span>l <span class="ow">+</span> r<span class="ow">)</span>
</pre></div>
</div>
<p>Now we can declare a vector type consisting of a size (<span class="docutils literal"><span class="pre">Nat'</span></span>) and a type
argument:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Vect'</span> <span class="ow">:</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
     <span class="nf">Nil</span> <span class="ow">:</span> <span class="kt">Vect'</span> <span class="kt">Z</span> a
     <span class="ow">(::)</span> <span class="ow">:</span> <span class="ow">(</span>x <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>xs <span class="ow">:</span> <span class="kt">Vect'</span> k a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Vect'</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> a
</pre></div>
</div>
<p>Here <span class="docutils literal"><span class="pre">a</span></span> is a type argument. <span class="docutils literal"><span class="pre">Vect'</span></span> has two constructors: <span class="docutils literal"><span class="pre">Nil</span></span>,
creating a <span class="docutils literal"><span class="pre">Vect'</span></span> of size <span class="docutils literal"><span class="pre">Z</span></span> containing elements of type <span class="docutils literal"><span class="pre">a</span></span> (0
elements) and <span class="docutils literal"><span class="pre">(::)</span></span>, which concatenates an object of type <span class="docutils literal"><span class="pre">a</span></span> with a vector
of size <span class="docutils literal"><span class="pre">k</span></span> of <span class="docutils literal"><span class="pre">a</span></span> and produces a vector of size <span class="docutils literal"><span class="pre">S</span> <span class="pre">k</span></span> containing <span class="docutils literal"><span class="pre">a</span></span>.</p>
<p>Now to see dependent types in action, we can define <span class="docutils literal"><span class="pre">append'</span></span>, a function that
appends a vector to another vector:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">append'</span> <span class="ow">:</span> <span class="kt">Vect'</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> m a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> <span class="ow">(</span>n <span class="ow">+</span> m<span class="ow">)</span> a
append' <span class="kt">Nil</span> ys <span class="ow">=</span> ys
append' <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> ys <span class="ow">=</span> x <span class="ow">::</span> append' xs ys
</pre></div>
</div>
<p>The interesting part is the function signature - given a vector of size <span class="docutils literal"><span class="pre">n</span></span>
and a vector of size <span class="docutils literal"><span class="pre">m</span></span>, the resulting vector will have size <span class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">m</span></span>. This
information is captured in the declaration and the compiler knows to apply the
<span class="docutils literal"><span class="pre">(+)</span></span> defined above and type-check that this is indeed true for a given pair
of arguments.</p>
</div>
<div class="section" id="proofs">
<h2>Proofs</h2>
<p>We can also attempt to define a <span class="docutils literal"><span class="pre">reverse'</span></span> function, which recursively appends
the head of the vector to the reversed tail:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">reverse'</span> <span class="ow">:</span> <span class="kt">Vect'</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> n a
reverse' <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">Nil</span>
reverse' <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> <span class="ow">=</span> append' <span class="ow">(</span>reverse' xs<span class="ow">)</span> <span class="ow">[</span>x<span class="ow">]</span>
</pre></div>
</div>
<p>This doesn’t compile though. We get the following error message:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>When checking right hand side of reverse' with expected type
        Vect' (S k) a

Type mismatch between
        Vect' (k + S Z) a (Type of append' (reverse' xs) [x])
and
        Vect' (S k) a (Expected type)

Specifically:
        Type mismatch between
                k + S Z
        and
                S k
</pre></div>
</div>
<p>We are claiming the function returns a vector of the same length as the input
vector, but we haven’t proven enough theorems about our definition of natural
numbers to convince the type checker. In this particular case, the problem is
that the compiler expects an <span class="docutils literal"><span class="pre">S</span> <span class="pre">k</span></span> but finds an <span class="docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span>. We need to prove
that these are indeed equal (<span class="docutils literal"><span class="pre">successor</span> <span class="pre">of</span> <span class="pre">k</span></span> is the same as
<span class="docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">successor</span> <span class="pre">of</span> <span class="pre">Z</span></span>). Here is the proof:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">addOneProof</span> <span class="ow">:</span> <span class="ow">(</span>n <span class="ow">:</span> <span class="kt">Nat'</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">S</span> n <span class="ow">=</span> n <span class="ow">+</span> <span class="kt">S</span> <span class="kt">Z</span>
addOneProof <span class="kt">Z</span> <span class="ow">=</span> <span class="kt">Refl</span>
addOneProof <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> <span class="ow">=</span> cong <span class="ow">(</span>addOneProof k<span class="ow">)</span>
</pre></div>
</div>
<p>Proofs are functions. There are a few things worth noting here: first, the
return type of this function is an equality (our theorem). Given a natural
<span class="docutils literal"><span class="pre">n</span></span>, the function proves that the equality holds. <span class="docutils literal"><span class="pre">Refl</span></span> is the built-in
reflexivity constructor, which constructs <span class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></span>. For the <span class="docutils literal"><span class="pre">Z</span></span> case, we can
use <span class="docutils literal"><span class="pre">Refl</span></span> to say that <span class="docutils literal"><span class="pre">S</span> <span class="pre">Z</span> <span class="pre">=</span> <span class="pre">Z</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span> which is true by the definition of
<span class="docutils literal"><span class="pre">(+)</span></span>. For the <span class="docutils literal"><span class="pre">(S</span> <span class="pre">k)</span></span> case, we use <span class="docutils literal"><span class="pre">cong</span></span>. <span class="docutils literal"><span class="pre">cong</span></span> is a built in
function that states that equality holds after function application. It’s
signature is <span class="docutils literal"><span class="pre">cong</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">=</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">b</span></span>, which basically means if <span class="docutils literal"><span class="pre">a</span></span> is
equal to <span class="docutils literal"><span class="pre">b</span></span>, then <span class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></span> is equal to <span class="docutils literal"><span class="pre">f</span> <span class="pre">b</span></span>. In our case, we are saying
that if <span class="docutils literal"><span class="pre">addOneProof</span> <span class="pre">k</span></span> holds, then so does <span class="docutils literal"><span class="pre">addOneProof</span> <span class="pre">(S</span> <span class="pre">k)</span></span>, which
allows us to converge on the <span class="docutils literal"><span class="pre">Z</span></span> case.</p>
<p>We now have a proof that <span class="docutils literal"><span class="pre">S</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span>. With this, we can prove that the
type <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(k</span> <span class="pre">+</span> <span class="pre">(S</span> <span class="pre">Z))</span> <span class="pre">a</span></span> can be rewritten as <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(S</span> <span class="pre">k)</span> <span class="pre">a</span></span>:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">reverseProof</span> <span class="ow">:</span> <span class="kt">Vect'</span> <span class="ow">(</span>k <span class="ow">+</span> <span class="ow">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="ow">))</span> a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> a
reverseProof <span class="ow">{</span>k<span class="ow">}</span> result <span class="ow">=</span> <span class="kr">rewrite</span> addOneProof k <span class="kr">in</span> result
</pre></div>
</div>
<p>There is some Idris-specific syntax here: <span class="docutils literal"><span class="pre">{k}</span></span> brings <span class="docutils literal"><span class="pre">k</span></span> from the function
declaration in scope, so we can refer to it in the function body even if it is
not passed in as an argument. The <span class="docutils literal"><span class="pre">rewrite</span> <span class="pre">...</span> <span class="pre">in</span></span> expression applies the
equality in the proof above to the input, in this case effectively rewriting
<span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(k</span> <span class="pre">+</span> <span class="pre">(S</span> <span class="pre">Z))</span> <span class="pre">a</span></span> to <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(S</span> <span class="pre">k)</span> <span class="pre">a</span></span>. Note these proofs are evaluated at
compile time and simply provide information to the type checker. With this
proof, we can implement reverse like this:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">reverse'</span> <span class="ow">:</span> <span class="kt">Vect'</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> n a
reverse' <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">Nil</span>
reverse' <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> <span class="ow">=</span> reverseProof <span class="ow">(</span>append' <span class="ow">(</span>reverse' xs<span class="ow">)</span> <span class="ow">[</span>x<span class="ow">])</span>
</pre></div>
</div>
<p>This is similar to the previous implementation, we just apply <span class="docutils literal"><span class="pre">reverseProof</span></span>
to the result of <span class="docutils literal"><span class="pre">append'</span></span>. This definition compiles.</p>
</div>
<div class="section" id="thoughts-about-the-future">
<h2>Thoughts About the Future</h2>
<p>Software development is generally driven by economics, where we more often than
not trade correctness for speed to market. But once the software is up and
running, correctness becomes an issue. As code increases in complexity, the
number of issues tends to increase, and the velocity with which changes can be
made without introducing regression drops dramatically. We have various
techniques that aim to maintain stability, like automated testing, but these are
not perfect: a test can prove that for a given input we get an expected output,
but cannot prove that for <em>any</em> input we would get the expected output.</p>
<p>On the other hand, we have solutions that do eliminate entire classes of issues.
An example is typing. Python, Ruby, and JavaScript, all dynamically typed, are
extremely expressive and make it very easy to whip up a proof of concept. But
there is an entire class of type errors which now turns into runtime issues. We
are notoriously bad at predicting what our code does, so the more help we get
from machines to ensure correctness, the better. In a strongly typed language,
even though it takes longer to convince the compiler that the code is type-safe,
this whole class of errors is eliminated. Language evolution over the years
tends to converge towards stronger typing: dynamic languages are augmented with
type checkers (Python has type hints, JavaScript has TypeScript etc.) and
statically typed languages are becoming less verbose as type inference evolves.
There will always be a need for a quick prototype, but code we want to deem
<em>reliable</em> should be typed. This includes a wide range of business-critical
applications where errors are very costly.</p>
<p>I see Idris as the next step beyond this. Totality checking allows the compiler
to guarantee termination, eliminating hangs from the code. First-order types
allows us to push more information to the type-checker, allowing for stricter
type-checking. Proofs, expressed as functions with regular syntax, allow the
compiler to provide formal verification of programs - here, as opposed to unit
tests, we are actually proving that we get the expected output for <em>any</em> input.
These are all tools for writing better, more correct code. As other functional
concepts got adopted over the years into more mainstream languages (for example
first-order functions, anonymous functions, algebraic types etc.), I expect (and
hope) these features to eventually be adopted too.</p>
<p>There is still a lot of room for improvement: writing proofs is tedious,
compiler errors are not always very clear, and, coming back to the speed to
market tradeoff, I doubt we will ever get to entire large applications formally
proven correct (barring some form of proof inference to speed things up by a
couple of orders of magnitude). That being said, I would love to have these
facilities as optional features in other languages and at least have the ability
to prove that the core functionality of a component does what it is supposed to
do, and get a compile break whenever a regression is introduced.</p>
<p>Programming languages are continuously evolving and the future looks exciting!</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Idris also supports functions that produce an infinite stream of values
which can be used with lazy evaluation. The full definition of totality
includes functions which don’t terminate but produce <span class="docutils literal"><span class="pre">Inf</span></span>. This
allows for non-terminating functions, but ensures non-termination is
intentional.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>I am using <span class="docutils literal"><span class="pre">'</span></span> to avoid naming conflicts with the built-in types and
functions. Idris already provides <span class="docutils literal"><span class="pre">Nat</span></span>, <span class="docutils literal"><span class="pre">Vect</span></span>, <span class="docutils literal"><span class="pre">append</span></span> and
<span class="docutils literal"><span class="pre">reverse</span></span>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Thu, 20 Jul 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/07/10/singletons.html</link>
            <guid>http://vladris.com/blog/2017/07/10/singletons.html</guid>
            <title><![CDATA[Singletons]]></title>
            <description><![CDATA[<h1>Singletons</h1>
<div class="section" id="singletons-are-evil">
<h2>Singletons are evil</h2>
<p>I will start off with a word of caution that singletons should be avoided.
Singleton is the object-oriented equivalent of a global variable – a piece of
state which anyone can grab and modify, which makes it hard to reason locally
about code and generates ugly dependency graphs. That being said, in a large
system there are situations where there is a legitimate need for global state or
some component that exposes a service to other components.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<p><a class="reference external" href="https://www.youtube.com/watch?v=23xDn3ReH7E">This CppCon lightning talk</a>
by Arno Lepisk covers some implementation alternatives, suggesting that in most
cases using a namespace and flat functions is the simplest and best way to
implement a singleton:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">namespace</span> <span class="n">Foo</span> <span class="p">{</span>

<span class="kt">void</span> <span class="n">DoFoo</span><span class="p">();</span>

<span class="p">}</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">DoFoo</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">Foo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>I completely agree with this, with the caveat that sometimes we do want to
inject dependencies and work against an interface instead of the actual
implementation, in which case the above approach might be insufficient. Note
that unless dependency injection is needed, the default should be a namespace
and flat functions.</p>
</div>
<div class="section" id="dependency-injection">
<h2>Dependency Injection</h2>
<p>Given an interface, an implementation, and a function to retrieve the singleton
like the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">DoFoo</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">IFoo</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Foo</span> <span class="p">:</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">DoFoo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="p">};</span>

<span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>a common mistake I see is components directly calling the function like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Component</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">UseFoo</span><span class="p">().</span><span class="n">DoFoo</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If the goal is to inject the dependency, for example have tests run against
<span class="docutils literal"><span class="pre">MockFoo</span></span>, this approach is not ideal. Code explicitly calls <span class="docutils literal"><span class="pre">UseFoo</span></span> so the
only way to switch implementation is to modify <span class="docutils literal"><span class="pre">UseFoo</span></span> and provide some
internal mechanism to change its return value. A better approach is to have the
client simply require an interface and provide that at construction time:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Component</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Component</span><span class="p">(</span><span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">UseFoo</span><span class="p">())</span>
        <span class="o">:</span> <span class="n">m_foo</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_foo</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">m_foo</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that in the above example we can create <span class="docutils literal"><span class="pre">Component</span></span> with a <span class="docutils literal"><span class="pre">MockFoo</span></span>
implementation of <span class="docutils literal"><span class="pre">IFoo</span></span> or some other implementation, which is a better
decoupling than directly calling <span class="docutils literal"><span class="pre">UseFoo</span></span> inside the member functions of
<span class="docutils literal"><span class="pre">Component</span></span>.</p>
</div>
<div class="section" id="magic-statics">
<h2>Magic Statics</h2>
<p>By definition, a singleton should represent a unique object, so our <span class="docutils literal"><span class="pre">UseFoo</span></span>
needs to return the same reference on each call. Ensuring that concurrent calls
from multiple threads don’t cause problems was non-trivial until C++11, which
introduced “magic statics”. Quote from the C++ standard section 6.7:</p>
<blockquote>
<div>… such a variable [with static storage] is initialized the first time
control passes through its declaration; such a variable is considered
initialized upon the completion of its initialization. If the initialization
exits by throwing an exception, the initialization is not complete, so it
will be tried again the next time control enters the declaration. If control
enters the declaration concurrently while the variable is being initialized,
the concurrent execution shall wait for completion of the initialization.</div></blockquote>
<p>The standard now guarantees that a static would only ever be created once, and
the simple way to implement a singleton (for example according to Scott Meyer’s
<a class="reference external" href="https://www.goodreads.com/book/show/22800553-effective-modern-c">Effective Modern C++</a>)
is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Foo</span> <span class="n">instance</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Or the heap-allocated version:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="deterministic-shutdown">
<h2>Deterministic shutdown</h2>
<p>A more interesting problem which the above implementation doesn’t cover is
deterministic shutdown. A local static, once created, will be live for the
duration of the program, which might not always be desirable. Building on the
previous implementation, here is a singleton which we can also shutdown on
demand:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">Use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">instance</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_instance</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">m_instance</span><span class="p">;</span>
        <span class="p">}();</span>

        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">Free</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="n">m_instance</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_instance</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_instance</span><span class="p">;</span>

<span class="cm">/* ... */</span>

<span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;::</span><span class="n">Use</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FreeFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;::</span><span class="n">Free</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using this implementation, we can deterministically free the singleton on demand
via the <span class="docutils literal"><span class="pre">Free</span></span> function as opposed to having to wait for the program to get
unloaded, which can be useful in certain cases.</p>
</div>
<div class="section" id="atomics">
<h2>Atomics</h2>
<p>Magic statics provide an easy way to guarantee we end up with a single object,
but the code generated to support this is non-trivial. Disassembly of the
<span class="docutils literal"><span class="pre">UseFoo</span></span> above as compiled by Clang 4.0.0 with <span class="docutils literal"><span class="pre">-O3</span></span> flag:</p>
<div class="highlight-objdump notranslate"><div class="highlight"><pre><span/><span class="x">UseFoo():                             # @UseFoo()</span>
<span class="x">        push    rbx</span>
<span class="x">        mov     al, byte ptr [rip + guard variable for Singleton&lt;Foo&gt;::Use()::instance]</span>
<span class="x">        test    al, al</span>
<span class="x">        jne     .LBB0_6</span>
<span class="x">        mov     edi, guard variable for Singleton&lt;Foo&gt;::Use()::instance</span>
<span class="x">        call    __cxa_guard_acquire</span>
<span class="x">        test    eax, eax</span>
<span class="x">        je      .LBB0_6</span>
<span class="x">        mov     edi, 8</span>
<span class="x">        call    operator new(unsigned long)</span>
<span class="x">        mov     qword ptr [rax], vtable for Foo+16</span>
<span class="x">        mov     rdi, qword ptr [rip + Singleton&lt;Foo&gt;::m_instance]</span>
<span class="x">        mov     qword ptr [rip + Singleton&lt;Foo&gt;::m_instance], rax</span>
<span class="x">        test    rdi, rdi</span>
<span class="x">        je      .LBB0_5</span>
<span class="x">        mov     rax, qword ptr [rdi]</span>
<span class="x">        call    qword ptr [rax + 8]</span>
<span class="x">        mov     rax, qword ptr [rip + Singleton&lt;Foo&gt;::m_instance]</span>
<span class="x">.LBB0_5:</span>
<span class="x">        mov     qword ptr [rip + Singleton&lt;Foo&gt;::Use()::instance], rax</span>
<span class="x">        mov     edi, guard variable for Singleton&lt;Foo&gt;::Use()::instance</span>
<span class="x">        call    __cxa_guard_release</span>
<span class="x">.LBB0_6:</span>
<span class="x">        mov     rax, qword ptr [rip + Singleton&lt;Foo&gt;::Use()::instance]</span>
<span class="x">        pop     rbx</span>
<span class="x">        ret</span>
<span class="x">        mov     rbx, rax</span>
<span class="x">        mov     edi, guard variable for Singleton&lt;Foo&gt;::Use()::instance</span>
<span class="x">        call    __cxa_guard_abort</span>
<span class="x">        mov     rdi, rbx</span>
<span class="x">        call    _Unwind_Resume</span>
</pre></div>
</div>
<p>A lot of the generated code is the compiler implementing the guarantee that on
concurrent calls, a single intialization is performed. The <span class="docutils literal"><span class="pre">Singleton</span></span>
functions are inlined here since we are compiling with <span class="docutils literal"><span class="pre">-O3</span></span>. We can provide a
much more efficient implementation using an atomic pointer on architectures
where atomics are lock-free and we are not worried about redundantly calling the
constructor in the rare cases of concurrent access that requires
initialization:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">Use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_instance</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">instance</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>

        <span class="k">delete</span> <span class="n">instance</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_instance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">Free</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">m_instance</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_instance</span><span class="p">;</span>

<span class="cm">/* ... */</span>

<span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;::</span><span class="n">Use</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FreeFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;::</span><span class="n">Free</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The disassembly of the above <span class="docutils literal"><span class="pre">UseFoo</span></span> (built with the same compiler and
<span class="docutils literal"><span class="pre">-O3</span></span> flag) is:</p>
<div class="highlight-objdump notranslate"><div class="highlight"><pre><span/><span class="x">UseFoo():                             # @UseFoo()</span>
<span class="x">        push    rax</span>
<span class="x">        mov     rcx, qword ptr [rip + Singleton&lt;Foo&gt;::m_instance]</span>
<span class="x">        test    rcx, rcx</span>
<span class="x">        jne     .LBB0_3</span>
<span class="x">        mov     edi, 8</span>
<span class="x">        call    operator new(unsigned long)</span>
<span class="x">        mov     rcx, rax</span>
<span class="x">        mov     qword ptr [rcx], vtable for Foo+16</span>
<span class="x">        xor     eax, eax</span>
<span class="x">        lock</span>
<span class="x">        cmpxchg qword ptr [rip + Singleton&lt;Foo&gt;::m_instance], rcx</span>
<span class="x">        je      .LBB0_3</span>
<span class="x">        mov     rax, qword ptr [rcx]</span>
<span class="x">        mov     rdi, rcx</span>
<span class="x">        call    qword ptr [rax + 8]</span>
<span class="x">        mov     rcx, qword ptr [rip + Singleton&lt;Foo&gt;::m_instance]</span>
<span class="x">.LBB0_3:</span>
<span class="x">        mov     rax, rcx</span>
<span class="x">        pop     rcx</span>
<span class="x">        ret</span>
</pre></div>
</div>
<p>This code might new the object multiple times, but is guaranteed to always
return the same instance and retrieving it is more efficient than relying on
statics, since it uses a compare-exchange to guarantee uniqueness. Many thanks
to my colleague Vladimir Morozov who suggested this approach.</p>
</div>
<div class="section" id="tri-state">
<h2>Tri-state</h2>
<p>We now have an efficient way to create and shutdown a singleton. If shutdown, a
subsequent call to <span class="docutils literal"><span class="pre">Use</span></span> would re-create the object. One optional feature we
can add is to enforce that once shutdown, a singleton should never be accessed
again. So instead of the two-state <em>not initialized</em> and <em>live</em>, we can use
three states: <em>not initialized</em>, <em>live</em>, <em>freed</em> and terminate if an access
is attempted in the <em>freed</em> state:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">uintptr_t</span> <span class="n">FreedSingleton</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">Use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">Get</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">FreedSingleton</span><span class="p">))</span>
            <span class="n">terminate</span><span class="p">();</span>

        <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">Free</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">FreedSingleton</span><span class="p">));</span>
        <span class="k">delete</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">T</span><span class="o">*</span> <span class="n">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_instance</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">instance</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>

        <span class="k">delete</span> <span class="n">instance</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">m_instance</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_instance</span><span class="p">;</span>
</pre></div>
</div>
<p>We now have an efficient generic singleton which we can shutdown on-demand and
ensure clients never call after shutdown.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Try not to use singletons, singletons are evil</li>
<li>In most cases, a namespace and flat functions are enough, no need to
over-complicate things</li>
<li>If dependency injection is required, make sure dependency is properly injected
during construction as opposed to member functions directly calling the
singleton-retrieving function</li>
<li>Magic statics provide an easy way to implement singletons</li>
<li>Atomics are more efficient than magic statics when they are lock-free and we
aren’t worried about potentially having multiple constructor calls in race
cases</li>
<li>If needed, singletons can be extended with a shutdown mechanism</li>
<li>Three-state singletons can terminate on use-after-shutdown</li>
</ul>
</div>
]]></description>
             <pubDate>Mon, 10 Jul 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/04/07/data-structures-and-algorithms.html</link>
            <guid>http://vladris.com/blog/2017/04/07/data-structures-and-algorithms.html</guid>
            <title><![CDATA[Data Structures and Algorithms]]></title>
            <description><![CDATA[<h1>Data Structures and Algorithms</h1>
<p>“Data Structures and Algorithms” is one of the basic CS courses. Data structures
and algorithms are also the building blocks of software. In this post I will
give a quick overview of data structures, algorithms, and cover <em>iterators</em>,
which bridge the two together.</p>
<div class="section" id="data-structures">
<h2>Data Structures</h2>
<p>As the name implies, data structures provide a way of structuring data, in other
words, they maintain some set of relationships between the contained elements.
Data structures are built around expected access/update patterns and encapsulate
the inherent tradeoffs. For example, a queue models FIFO access (so accessing
the last inserted element requires dequeuing all elements which is <span class="docutils literal"><span class="pre">O(n)</span></span> for
<span class="docutils literal"><span class="pre">n</span></span> elements) while a stack models the opposite LIFO access (which can access
the last inserted element in <span class="docutils literal"><span class="pre">O(1)</span></span> but conversely makes accessing the first
element <span class="docutils literal"><span class="pre">O(n)</span></span> for <span class="docutils literal"><span class="pre">n</span></span> elements). A deque allows elements to be inserted and
removed from both front and back, but not from the middle. On the other hand,
inserting an element in a forward list (where each node starting form head has a
pointer to its successor) can be done anywhere, but requires a traversal of the
data structure up to the insertion point (<span class="docutils literal"><span class="pre">O(n)</span></span>).</p>
<p>More complex data structures exist which model more complex relationships
between elements, for example graphs and trees.</p>
<p>In practice, while there are always complex situations which require the use or
development of exotic data structure, I consider those to be exceptions - a few
basic data structures are enough to solve most problems. In fact, in most cases,
simple linear data structures like lists are sufficient.</p>
<p>It’s worth noting that the relationships and access patterns modeled by a data
structure do not have anything to do with the type of the contained data. A
queue of integers or a queue of strings work in exactly the same way. Generics
provide a great mechanism to separate the organizing structure from the data
itself. Thus the C++ <span class="docutils literal"><span class="pre">std::vector&lt;T&gt;</span></span> can provide a generic implementation of
a heap array for any type <span class="docutils literal"><span class="pre">T</span></span>, the same way a C# <span class="docutils literal"><span class="pre">List&lt;T&gt;</span></span> does. These
generic data structure model how the contained elements are laid out, but work
with any provided type.</p>
</div>
<div class="section" id="algorithms">
<h2>Algorithms</h2>
<p>The dictionary definition of an algorithm is:</p>
<blockquote>
<div>noun: a process or set of rules to be followed in calculations or other
problem-solving operations, especially by a computer.</div></blockquote>
<p>There is a set of basic functions we can put our data through: search,
partition, rotate, sort, map, reduce, filter and so on. These functions can be
implemented in several ways, depending on the characteristics of the input. For
example, we can search for an element in <span class="docutils literal"><span class="pre">O(log</span> <span class="pre">n)</span></span> time if our input is
sorted and we can access it from the “middle” at no extra cost. On the other
hand, given unsorted data or a data structure like a forward list which we can
only access through its head, search becomes an <span class="docutils literal"><span class="pre">O(n)</span></span> operation. The
implementations of these functions are what we call algorithms. In the examples
above the algorithms are <em>binary search</em> and <em>linear search</em>.</p>
<p>The same observation as with data structures applies: while there are complex
problems which require the development of brand new algorithms, in practice,
the vast majority of processing that we want to perform on our data can be
expressed either as a simple algorithm or a composition of simple algorithms.</p>
<p>It is also interesting to note that the algorithms themselves are not tied to a
particular data type either, rather they only require certain characteristics of
their input. So we can perform a search as long as there is some equivalence
relation defined for the input data. Similarly, we can perform a sort as long as
there is a total order relation defined on the input type. It doesn’t really
matter whether we search for numbers or strings, the steps we take are the same.</p>
<p>Generics help here too, since they allow us to conceptually separate the
implementation of the algorithm (the steps) from the data we are operating on.
So the C++ <span class="docutils literal"><span class="pre">std::partition</span></span> algorithm can partition any input – given by a
pair of forward iterators using any given predicate. Similarly, the C# LINQ
<span class="docutils literal"><span class="pre">Select</span></span> (known in most other languages as a <span class="docutils literal"><span class="pre">map</span></span> operation), transforms
all input values into output values given a mapping function from the input type
to the output type. We don’t need to implement a partition for ints, one for
strings, and one for dates, we need a generic partition which implements the
steps of the algorithm and works with any given data type.</p>
</div>
<div class="section" id="iterators-and-ranges">
<h2>Iterators and Ranges</h2>
<p>Iterators act as the bridge between data structures and algorithms. Iterators
traverse a given data structure in a linear fashion, such that an algorithm can
process the input in a consistent manner, regardless of the actual layout of the
data. Note the data structure itself does not need to be a linear one: a binary
tree can be traversed with a preorder iterator, or an inorder iterator, or a
postorder iterator.</p>
<p>Algorithms work on ranges of data, which can be defined as a pair of iterators
(beginning and end) or an iterator and the number of available elements
(beginning and length). I will cover some of the C++ iterator concepts since
they are the most fleshed out. Other languages usually rely on a subset of
these.</p>
<p><strong>Input iterators</strong> can only be advanced and are one-pass only. These map to
input streams, for example unbuffered keyboard input where data can be read
once, but a subsequent read would yield different data.</p>
<p><strong>Forward iterators</strong> extend input iterators to multiple passes. For example, a
forward iterator models traversal of a forward list. We can always re-start
traversal from any saved position, but we cannot move back (since nodes only
have links to successors, not predecessors).</p>
<p><strong>Bidirectional iterators</strong> extend forward iterators to bidirectional access.
For example, a bidirectional iterator models traversal of a doubly linked list.
Here, we can move from one node in either direction – to its predecessor or to
its successor.</p>
<p><strong>Random access iterators</strong> extend bidirectional iterators to random access,
meaning any element can be accessed in constant time. For example, a random
access iterator models traversal of an array. Here, we can access any element at
the same cost, since we don’t need to perform any traversal, simply index into
the array.</p>
<p>Depending on the implementation of a given algorithm, different iterator types
might be required. The same function can sometimes be implemented with several
algorithms, having a more efficient version work with more capable iterators and
an alternative algorithm for less capable iterators. For example we can
implement an <span class="docutils literal"><span class="pre">O(n</span> <span class="pre">log</span> <span class="pre">n)</span></span> quicksort with a random access iterator but we can
also implement an <span class="docutils literal"><span class="pre">O(n^2)</span></span> bubblesort that works with forward iterators.</p>
<p><span class="docutils literal"><span class="pre">IEnumerator&lt;T&gt;</span></span> in C# models a forward iterator. The (simplified) interface
is:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">Current</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">Reset</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This allows us to advance the iterator and to reset it to the initial position
and re-start traversal, which is exactly what a forward iterator does.</p>
<p>Lazy evaluation in some functional languages and generators (functions that
yield results) model input iterators which can be advanced in a single pass.</p>
<p>While most relevant operations can be implemented with input iterators, the
resulting algorithms are not very efficient. For example, with a bidirectional
iterator, <span class="docutils literal"><span class="pre">reverse</span></span> can be implemented in <span class="docutils literal"><span class="pre">O(1)</span></span> space by starting from both
ends and swapping elements. On the other hand, given an input iterator,
<span class="docutils literal"><span class="pre">reverse</span></span> requires <span class="docutils literal"><span class="pre">O(n)</span></span> space as elements need to be pushed onto a stack
and popped in reverse order.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Data structures model the relationship between elements and encapsulate access
patterns. Generic data structures provide a good abstraction decoupling the
structure of the data from the actual contianed data.</li>
<li>Algorithms implement operations over data. Algorithms are grouped together
based on the function or transformation they implement. Generic algorithms
abstract the operational steps from the input the algorithms operate on.</li>
<li>Iterators provide a bridge between data structures and algorithms. The more
capabilities an iterator has (ie. the more restrictions we impose on the
input), the more efficient the algorithm can be. Similarly, most operations
can be implemented in less efficent manners (time and space-wise) on iterators
with fewer capabilities (ie. fewer restrictions imposed on the input).</li>
</ul>
<p>Recommended reading:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.goodreads.com/book/show/23498372-from-mathematics-to-generic-programming">From Mathematics to Generic Programming</a>
by Alexander A. Stepanov and Daniel E. Rose</li>
<li><a class="reference external" href="https://www.goodreads.com/book/show/6142482-elements-of-programming">Elements of Programming</a>
by Alexander A. Stepanov and Paul McJones</li>
</ul>
</div>
]]></description>
             <pubDate>Fri, 07 Apr 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/02/25/a-heterogeneous-event-store.html</link>
            <guid>http://vladris.com/blog/2017/02/25/a-heterogeneous-event-store.html</guid>
            <title><![CDATA[A Heterogeneous Event Store]]></title>
            <description><![CDATA[<h1>A Heterogeneous Event Store</h1>
<p>I recently stumbled upon a heterogeneous event collection which turned out to
pose an interesting design problem. We are using library code (we can’t change)
that provides a templated <span class="docutils literal"><span class="pre">Event</span></span> to which we can register callbacks and
which we can raise later to invoke the callbacks. The interface looks like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cm">/* Library code */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">Event</span>
<span class="p">{</span>
    <span class="c1">// T is a callable object, like std::function</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Register a callback */</span> <span class="p">}</span>

    <span class="c1">// Raises the event and forwards the arguments to the callbacks</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Invoke all registered callbacks */</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A stub implementation that validates client code is typed properly would be:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">Event</span>
<span class="p">{</span>
    <span class="c1">// T is a callable object, like std::function</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Register a callback */</span>
        <span class="n">_callback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Raises the event and forwards the arguments to the callbacks</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Invoke all registered callbacks */</span>
        <span class="n">_callback</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">_callback</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that unlike the real implementation, this only stores the last registered
event, but that is irrelevant for the purpose of this post. I’m providing the
code just to have something to compile against (otherwise <span class="docutils literal"><span class="pre">Raise</span></span> would
happily swallow any combination of arguments passed to it). In reality, a more
complex implementation would maintain a list of callbacks, but this is
sufficient for framing the design problem.</p>
<p>The event collection which was wrapping a set of library events looked like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">using</span> <span class="n">LaunchCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">SaveCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ExitCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">OnLaunch</span><span class="p">(</span><span class="n">LaunchCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_launchEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">OnSave</span><span class="p">(</span><span class="n">SaveCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_saveEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">OnExit</span><span class="p">(</span><span class="n">ExitCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_exitEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseLaunch</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_launchEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseSave</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fileName</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_saveEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseExit</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_exitEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span> <span class="n">m_launchEvent</span><span class="p">;</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span> <span class="n">m_saveEvent</span><span class="p">;</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;</span> <span class="n">m_exitEvent</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sample usage of the <span class="docutils literal"><span class="pre">EventStore</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">OnLaunch</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">OnSave</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">RaiseSave</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>Looking at <span class="docutils literal"><span class="pre">EventStore</span></span>, it’s obvious that there is a lot of repetition
involved: hooking up a new event involves aliasing a new callback, adding a new
member to the class, and adding the corresponding registration and <span class="docutils literal"><span class="pre">Raise</span></span>
member functions which end up being copy/pastes of the other ones. There must
be a better way!</p>
<p>An initial idea would be to use some sort of associative container (hopefully
something <a class="reference external" href="http://vladris.com/blog/2016/04/24/abusing-maps.html">better than an unordered_map</a>),
but there is an interesting complication due to the fact that some of the
various events are actually of different types. <span class="docutils literal"><span class="pre">Event&lt;std::function&lt;void()&gt;&gt;</span></span>
has a different type than <span class="docutils literal"><span class="pre">Event&lt;std::function&lt;void(const</span> <span class="pre">string&amp;)&gt;&gt;</span></span>. There
are potential workarounds to explore, like standardizing on a single type and
requiring clients to, for example, only use callbacks that do not take any
arguments. Another option would be to pass in some base object to each event
and let each callback re-interpret it. This takes us down the wrong path though.
We don’t need to do any runtime lookup - the initial code doesn’t.</p>
<p>From the repetition in <span class="docutils literal"><span class="pre">EventStore</span></span>, it should become apparent that we need
some form of templated <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> that would work for each type
of event we care about. A quick sketch of our function signatures should look
something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="cm">/* ??? */</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="cm">/* ??? */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Register callback to the appropriate event</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="cm">/* ??? */</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Raise the appropriate event, forwarding args to it</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is also clear that we need a way to store all of the events we need in our
class. Since they are of heterogeneous types, we can’t store them in a map or
equivalent, but we don’t need to. <span class="docutils literal"><span class="pre">std::tuple</span></span> was build exactly for this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>Now the only remaining question is how to templatize our two member functions to
enable a lookup in the tuple. One approach would be to use an enum:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">EventType</span> <span class="o">:</span> <span class="kt">size_t</span>
<span class="p">{</span>
    <span class="n">LaunchEvent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">SaveEvent</span><span class="p">,</span>
    <span class="n">ExitEvent</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Given this enum, we can templatize on its values:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">EventType</span> <span class="n">eventType</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">eventType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">EventType</span> <span class="n">eventType</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">eventType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Callers can use this new implementation like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">LaunchEvent</span><span class="o">&gt;</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">Raise</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>With this implementation, we preserve the ability to have polymorphic events but
only need to implement the <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> functions. Adding a new
event type now only requires aliasing the callback, adding an enum member, and
extending our member tuple by adding the new <span class="docutils literal"><span class="pre">Event</span></span> to it.</p>
<p>The only drawback of this approach is the fact that we need to manually keep the
enum and the tuple in sync. This is not too bad, because if we try to call
<span class="docutils literal"><span class="pre">std::get</span></span> with a number higher than the size of the tuple, we get a compile
time error. If we accidentally swap two events, if they are of incompatible
types (for example <span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span> and <span class="docutils literal"><span class="pre">Event&lt;SaveCallback&gt;</span></span>, as one
expects callbacks of type <span class="docutils literal"><span class="pre">std::function&lt;void()&gt;</span></span> and the other expects
<span class="docutils literal"><span class="pre">std::function&lt;void(const</span> <span class="pre">std::string&amp;)&gt;</span></span>), we get a compile-time error
because <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> calls would fail to compile (attempting to
pass in callback/arguments of incompatible types). If we accidentally swap two
events of the same type, (<span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span> and <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span>,
since both <span class="docutils literal"><span class="pre">LaunchCallback</span></span> and <span class="docutils literal"><span class="pre">ExitCallback</span></span> are aliased to the same
<span class="docutils literal"><span class="pre">std::function&lt;void()&gt;</span></span>), runtime behavior is equivalent, it just makes
reading the code confusing. Now we end up storing launch callbacks inside what
we called <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span> and vice-versa. Runtime is not affected, as we
would also raise <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span> by calling
<span class="docutils literal"><span class="pre">Raise&lt;EventType::LaunchEvent&gt;</span></span>, but it’s not ideal. We could drop the aliases
altogether and simply have:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>This solves the above issues but is not very readable. There are other options,
like picking different names for the aliases - instead of naming the event, have
them name the type of callback. Either way, effectively what we are doing is a
mapping from an enum into a set of <span class="docutils literal"><span class="pre">Event</span></span> types. We can actually push more
information to the type system and get rid of the need to do this mapping. We do
that by making sure our events are always of different types, even if the
callback signatures are the same. One way of achieving this is wrapping
<span class="docutils literal"><span class="pre">Event</span></span> and defining different types for each of our events:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">EventWrapper</span>
<span class="p">{</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">m_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">LaunchEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nl">SaveEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nl">ExitEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
</pre></div>
</div>
<p>Note this is type information used only by the compiler and doesn’t bring any
runtime overhead to our code. Inheritance is used here just so we don’t have to
repeat declaring <span class="docutils literal"><span class="pre">m_event</span></span>, we could have just as well declared each struct
independently. Now we can update the member tuple to store an event of each of
these types:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="p">,</span> <span class="n">SaveEvent</span><span class="p">,</span> <span class="n">ExitEvent</span><span class="o">&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>Since they are of different types, we no longer need an enum to index into the
tuple, we can do it by type (note <span class="docutils literal"><span class="pre">std::get</span></span> indexed by type requires that the
tuple contains distinct types, which is not the case for <span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span>
and <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span>, but it is for <span class="docutils literal"><span class="pre">LaunchEvent</span></span> and <span class="docutils literal"><span class="pre">ExitEvent</span></span>):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Callback</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">Callback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">Callback</span></span> template argument in <span class="docutils literal"><span class="pre">Register</span></span> can be deduced once <span class="docutils literal"><span class="pre">T</span></span> is
specified. The full implementation is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">EventWrapper</span>
<span class="p">{</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">m_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">LaunchEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nl">SaveEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nl">ExitEvent</span> <span class="p">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Callback</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">Callback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="p">,</span> <span class="n">SaveEvent</span><span class="p">,</span> <span class="n">ExitEvent</span><span class="o">&gt;</span> <span class="n">m_events</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Callers can use it like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="o">&gt;</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">Raise</span><span class="o">&lt;</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, adding a new event requires declaring a new struct and adding it
to the tuple. Since we are retrieving the event by its type, no mapping is
involved.</p>
]]></description>
             <pubDate>Sat, 25 Feb 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/02/20/memory-management.html</link>
            <guid>http://vladris.com/blog/2017/02/20/memory-management.html</guid>
            <title><![CDATA[Memory Management]]></title>
            <description><![CDATA[<div class="section" id="memory-management">
<h1>Memory Management</h1>
<p>Memory management involves handling memory resources allocated for a certain
task, ensuring that the memory is freed once it is no longer needed so it can
be reused for some other task. If the memory is not freed in a timely manner,
the system might run out of resources or incur degraded performance. A memory
resource that is never freed once no longer needed is called a leak - the
resource becomes unusable, usually for the duration of the process. Another
issue is <em>use after free</em>, in which a memory resource that was already freed
is used as if it wasn’t. This usually causes unexpected behavior as the code
is trying to read, modify or wrongly interpret data at a memory location.
Memory management can be <em>manual</em> - with code explicitly handling
deallocation, or <em>automatic</em>, in which memory gets freed once no longer needed
by an automated process.</p>
<div class="section" id="manual-memory-management">
<h2>Manual Memory Management</h2>
<p>Manual memory management is efficient, since allocations and deallocations
don’t incur any overhead. In C:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_Foo</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span>

<span class="p">...</span>

<span class="n">free</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>The disadvantage of this approach, and the main reason automatic memory
management models were invented, is that this puts the developer in charge of
making sure memory doesn’t leak and that it is not used after it is freed. As
the complexity of the code increases, this becomes increasingly difficult. As
pointers are passed around the system and get stored in various data structures,
it becomes difficult to know given some pointer that is no longer needed
whether: a) this was the very last piece of code that actually needed to access
the location pointed to by this pointer, in which case the memory should be
freed, and b) whether the memory this pointer is pointing to is still valid and
hasn’t been freed previously.</p>
</div>
<div class="section" id="automatic-memory-management">
<h2>Automatic Memory Management</h2>
<p>Automatic memory management attempts to move the responsibility of tracking
when a memory resource is no longer needed (and handling its deallocation) from
the developer to the system. Such a system is called <em>garbage collected</em>, as
memory that is no longer needed (“garbage”) is reclaimed by the system
automatically. The two most popular methods used to automatically free memory
are <em>tracing garbage collectors</em> and <em>reference counting</em>.</p>
<div class="section" id="tracing-garbage-collector">
<h3>Tracing Garbage Collector</h3>
<p>Tracing garbage collectors work by tracing references to objects on the heap
and checking whether a given resource allocated on the heap has at least one
reference path to it from the stack. If such a path exists, it means that from
the stack (an argument to a function, a local variable), there is a way to
perform a set of dereference and access the memory resource. If such a path
doesn’t exist, it means the memory is unreachable, so regardless of how
executing code accesses other objects on the heap, there is no way to access
this resource - which means the memory can be safely deallocated.</p>
<p>For example, a naïve tracing garbage collection algorithm, <em>mark-and-sweep</em>,
involves adding an “in-use” bit to each memory resource allocated then, during
collection, following all references starting from the stack and marking each as
“in-use”. Once all used resources are marked, the sweep stage involves walking
the whole heap and for each memory resource, if not marked as “in-use”, freeing
it.</p>
<p>Tracing garbage collectors are used by many popular runtimes, like JVM and .NET.
In C#:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Bar</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">struct</span> <span class="nc">Foo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">bar</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>

    <span class="c1">// there is no stack variable pointing to the Bar object, but it can</span>
    <span class="c1">// still be reached through foo (foo.bar), so there exists a path from</span>
    <span class="c1">// the stack to it, meaning code can still access it.</span>
<span class="p">}</span>

<span class="c1">// foo goes out of scope which means neither foo nor its member Bar can be</span>
<span class="c1">// accessed any longer, so they can be safely collected</span>
</pre></div>
</div>
<p>There are a couple of disadvantages with the tracing GC approach: first, the
system needs to ensure memory resources are not being allocated while a garbage
collection is taking place. This means code execution is paused during
collection, which obviously impacts performance. The second disadvantage of
this approach is that the system is not as lean as other memory management
models: memory resources are kept allocated longer than really needed, for the
time interval between the last reference to them goes out of scope until the
actual collection is performed.</p>
</div>
<div class="section" id="reference-counting">
<h3>Reference Counting</h3>
<p>An alternative to tracing garbage collectors is reference counting. As the name
implies, a memory resource in such a system has an associated reference count -
the number of references to it. As soon as the last reference goes out of scope,
when the reference count reaches zero, the memory can be safely deallocated.
Unlike tracing, reference counting is performed as code executes: the count of a
given memory resource is automatically increased with each assignment where the
resource is on the right-hand-side, and is automatically decreased whenever a
reference goes out of scope.</p>
<p>Python manages memory using reference counting:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>

<span class="c1"># allocate Foo, its reference count is 1</span>
<span class="n">foo1</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="c1"># reference count is 2 after assignment</span>
<span class="n">foo2</span> <span class="o">=</span> <span class="n">foo1</span>

<span class="o">...</span>
<span class="c1"># once foo1 and foo2 go out of scope, reference count becomes 0 and memory</span>
<span class="c1"># is automatically freed</span>
</pre></div>
</div>
<p>C++ smart pointers work in a similar manner:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="p">...</span>

<span class="c1">// foo1 is a shared_ptr pointing to a Foo stored on the heap. Reference</span>
<span class="c1">// count for the Foo object is 1</span>
<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// reference count becomes 2 after assignment</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>

<span class="p">...</span>
<span class="c1">// Once foo1 and foo2 go out of scope, reference count becomes 0 and memory</span>
<span class="c1">// is automatically freed</span>
</pre></div>
</div>
<p>The main advantages over tracing garbage collection are the fact that execution
doesn’t need to be paused in order to reclaim memory and that resources are
deallocated as soon as they are no longer used (once reference count becomes 0).
There are also several disadvantages with this approach: first, each memory
resource needs to store an additional reference count and updating the reference
count in a multi-threaded environment needs to be performed atomically. Second,
and most important, this memory management model does not handle <em>reference
cycles</em>.</p>
<p>Reference cycles occur when two heap objects hold references to each other even
after no longer being reachable from the stack. In this case, a tracing garbage
collector would mark the objects as being unreachable and deallocate them, but
simple reference counting would not be able to identify this - from that point
of view, each object is being referred to by another object thus it should not
be collected. Example of reference cycle in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(),</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">other</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
<span class="c1"># a.other holds a reference to b, b.other holds a reference to a</span>
<span class="c1"># even when a and b go out of scope, the "other" attributes still hold references</span>
<span class="c1"># to the objects so their reference count would not drop to 0</span>
</pre></div>
</div>
<p>A similar example in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">foo1</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo2</span><span class="p">;</span>
<span class="n">foo2</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>
<span class="c1">// there are two references to each Foo object: foo1 and foo2-&gt;other for the first</span>
<span class="c1">// object, foo2 and foo1-&gt;other for the second object. Even if the foo1 and foo2</span>
<span class="c1">// variables go out of scope, neither of the objects would be collected due to the</span>
<span class="c1">// extra reference</span>
</pre></div>
</div>
<p>Python and C++ solve this problem in different ways: Python supplements reference
counting with a tracing garbage collector. So while most of the memory
management is done via reference counting, a tracing garbage collector is still
employed to clean up cycles like in the above example. This hybrid approach has
he pros and cons of both of the mechanisms discussed above. C++ avoids the
execution pauses a tracing garbage collectors would create by, instead,
leveraging <em>weak references</em>. Weak or non-owning references point to an object
but do not prevent it from being collected when all <em>strong</em> references go away.
There are several ways to express a non-owning reference, with different
advantages and drawbacks:</p>
<ul class="simple">
<li>A <span class="docutils literal"><span class="pre">&amp;</span></span> reference has to be assigned on construction and cannot be re-assigned
after being bound to an object. If used after the underlying object was
destroyed, it causes undefined behavior.</li>
<li>A <span class="docutils literal"><span class="pre">*</span></span> pointer can be <span class="docutils literal"><span class="pre">nullptr</span></span>-initialized and assigned later or
re-assigned. Similarly, if used after the pointed-to object was destroyed,
causes undefined behavior.</li>
<li>A <span class="docutils literal"><span class="pre">weak_ptr&lt;T&gt;</span></span> is a standard library type implementing a non-owning
reference. A <span class="docutils literal"><span class="pre">weak_ptr</span></span> can be converted to a <span class="docutils literal"><span class="pre">shared_ptr</span></span> (using  its
<span class="docutils literal"><span class="pre">lock()</span></span> method). If there is no strong (<span class="docutils literal"><span class="pre">shared_ptr</span></span>) reference to an
object it gets destroyed, regardless of how many <span class="docutils literal"><span class="pre">weak_ptr</span></span> instances point
to it. But once a <span class="docutils literal"><span class="pre">weak_ptr</span></span> successfully locks an object, it creates a
strong reference which ensures the object is kept alive. The drawback of
using <span class="docutils literal"><span class="pre">weak_ptr</span></span> is additional overhead: the control block of a smart
pointer needs to store both strong and weak reference count (with similar
atomic reference counting), and, even if an object gets destroyed because all
strong references went out of scope, the control block stays alive until all
weak references go away too.</li>
</ul>
<p>Updating the <span class="docutils literal"><span class="pre">Foo</span></span> struct in the example above to use a <span class="docutils literal"><span class="pre">weak_ptr</span></span> instead,
the reference cycle is avoided:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">foo1</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo2</span><span class="p">;</span>
<span class="n">foo2</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>
<span class="c1">// now the two Foo objects have only one strong reference to them through</span>
<span class="c1">// the foo1 and foo2 variables The other pointers are weak references which</span>
<span class="c1">// won't prevent the objects from being destroyed when foo1 and foo2 go out</span>
<span class="c1">// of scope</span>
</pre></div>
</div>
</div>
<div class="section" id="ownership-and-lifetimes">
<h3>Ownership and Lifetimes</h3>
<p>An alternative way to think about heap objects is in terms of <em>ownership</em> and
<em>lifetime</em>. In this model, a heap object is uniquely owned by some other object
and gets freed automatically when the owner is destructed. In C++, this is
achieved through <span class="docutils literal"><span class="pre">unique_ptr</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">Bar</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// this creates a Foo object on the heap, owned by bar</span>
<span class="p">}</span>
<span class="c1">// the heap object gets freed once bar gets freed</span>
</pre></div>
</div>
<p>Ownership of the object can be transferred by moving the <span class="docutils literal"><span class="pre">unique_ptr</span></span>. The
main advantage of this model is that it has no overhead - unlike tracing memory
which involves pausing execution or reference counting which involves atomic
count of references, a <span class="docutils literal"><span class="pre">unique_ptr</span></span> is just a wrapper over a pointer.</p>
<p>Unique pointers cannot be copied though (by definition, otherwise there would
no longer denote unique ownership), so when other code needs to access the heap
object, it would need to get a reference from the owning object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">UseFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>

<span class="n">UseFoo</span><span class="p">(</span><span class="o">*</span><span class="n">bar</span><span class="p">.</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>The problem with this approach is that if another object ends up holding on to a
reference which outlives the owning object, the reference becomes dangling and
refers to an object which was already freed. This becomes the equivalent of a
<em>use after free</em>, so here is where the concept of <em>lifetime</em> becomes important:
none of the non-owning references of a uniquely owned heap object should outlive
the object.</p>
<p>Unfortunately in C++ this has to be handled through sensical design and is
mostly left up to the developer. Rust on the other hand provides strong static
analysis and lifetime annotations to ensure such issues do not occur. In fact,
the default in Rust is to have uniquely owned objects which can be “borrowed”
when needed and static analysis ensures no dangling references appear. In C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">Bar</span><span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">bar</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="o">*</span><span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// bar.foo is now a dangling pointer since Foo was freed</span>
</pre></div>
</div>
<p>The above example used a pointer for simplicity, since a <span class="docutils literal"><span class="pre">&amp;</span></span> reference
(<span class="docutils literal"><span class="pre">Foo&amp;</span></span>) needs to be bound at construction time, but same applies for
that type of reference: once an object gets freed, &amp; references and
non-owning pointers to it are left dangling. On the other hand, this does
not compile in Rust:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="k">struct</span> <span class="nc">Bar</span><span class="o">&lt;</span><span class="na">'a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="na">'a</span><span class="w"> </span><span class="n">Foo</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="p">...</span><span class="w"/>

<span class="kd">let</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"/>
<span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{};</span><span class="w"/>
<span class="w">    </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="nc">foo</span><span class="w"> </span><span class="p">};</span><span class="w"/>
<span class="p">}</span><span class="w"/>
<span class="c1">// compiler correctly shows `foo` dropped here while still borrowed</span>
</pre></div>
</div>
<p>In Rust, the compiler ensures dangling references (“borrowed” objects) do not
exist once owning object goes out of scope.</p>
<p>It seems that in most cases, the best approach to memory management is to use
the latter model of ownership and lifetimes which comes with no runtime
overhead and handle the dangling reference problem through static analysis.
The advantages of this approach extend beyond the runtime cost of other
automatic memory management techniques to a model which also works well in a
multi-threaded environment, eg. if we only allow the owner of an object to
modify it, we can eliminate certain data races. From a systems design
perspective it is also an advantage to have a clear understanding of ownership
throughout the system.</p>
</div>
</div>
</div>
<div class="section" id="summary">
<h1>Summary</h1>
<p>This post covered several memory management techniques, outlining their pros
and cons:</p>
<ul class="simple">
<li>Manual - human error prone</li>
<li>Automatic using a tracing garbage collector - safe but comes with runtime
overhead</li>
<li>Automatic using reference counting - smaller runtime cost than a tracing
garbage collector but needs additional mechanisms to deal with reference
cycles</li>
<li>Concepts of ownership and lifetime - no runtime overhead, but should be
supplemented by static analysis to avoid dangling references</li>
</ul>
</div>
]]></description>
             <pubDate>Mon, 20 Feb 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/12/03/notes-on-error-handling.html</link>
            <guid>http://vladris.com/blog/2016/12/03/notes-on-error-handling.html</guid>
            <title><![CDATA[Notes on Error Handling]]></title>
            <description><![CDATA[<h1>Notes on Error Handling</h1>
<p>I recently read Joe Duffy’s excellent blog post
<a class="reference external" href="http://joeduffyblog.com/2016/02/07/the-error-model/">The Error Model</a>. Joe
worked on Midori and has some great insights on error model design. I wanted to
write down a couple of personal notes on error handling.</p>
<div class="section" id="using-the-type-system">
<h2>Using the Type System</h2>
<p>Before even talking about error scenarios, it’s worth pointing out that there
are categories of errors where the type system helps if not to eliminate them,
at least to scope them and prevent them from propagating unchecked throughout
the system.</p>
<div class="section" id="arguments">
<h3>Arguments</h3>
<p>In many cases, an error means the value of some variable has an invalid value.
If this invalid value is passed down to called functions, it can manifests
itself deep in the stack when it could’ve been caught earlier. A simple example
would be move directions for a game - let’s say the player can move <span class="docutils literal"><span class="pre">Up</span></span>,
<span class="docutils literal"><span class="pre">Down</span></span>, <span class="docutils literal"><span class="pre">Left</span></span>, or <span class="docutils literal"><span class="pre">Right</span></span>. This can be encoded as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">int</span> <span class="n">UP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">LEFT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">DOWN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">RIGHT</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="p">...</span>

<span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="n">player</span> <span class="n">player</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">UP</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_up</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">LEFT</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_left</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">DOWN</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_down</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">RIGHT</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_right</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="c1">// direction should only be 0, 1, 2, 3</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but ultimately a caller can still pass any int value to this function which
would end up in the default branch as a direction the code doesn’t know how to
handle. The alternative is, of course:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">direction</span>
<span class="p">{</span>
    <span class="n">up</span><span class="p">,</span>
    <span class="n">left</span><span class="p">,</span>
    <span class="n">down</span><span class="p">,</span>
    <span class="n">right</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="n">direction</span> <span class="n">direction</span><span class="p">,</span> <span class="n">player</span> <span class="n">player</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, the type system ensures direction can only possibly hold one of
the allowed values. This is a trivial example but there are many more
interesting ones. Take for example some connection which, if opened, can receive
data and close and, if not opened, can be opened. This can be modelled like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">open</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection already opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="nf">close</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection not opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">receive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection not opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">is_opened</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we have to handle various cases where we try to perform an open-connection
operation on a connection that hasn’t been opened yet, and vice-versa. Another
way to model this (as of C++17) is using a variant and separate types for open
and closed connections:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">opened_connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">close</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="k">auto</span> <span class="n">receive</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">closed_connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">open</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">closed_connection</span><span class="p">,</span> <span class="n">opened_connection</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, as long as we have a <span class="docutils literal"><span class="pre">closed_connection</span></span> instance, we can only perform
closed-connection operations and as long as we have an <span class="docutils literal"><span class="pre">open_connection</span></span>
instance, we can only perform opened-connection operations. The error states we
had to handle above go away as the type system ensures we can never call
<span class="docutils literal"><span class="pre">receive</span></span> on a closed connection etc.</p>
</div>
<div class="section" id="return-values">
<h3>Return Values</h3>
<p>The type system can also be leveraged to embellish return types as an
alternative to using return codes. For example, assume we have a function which
parses a phone number provided by the user into some <span class="docutils literal"><span class="pre">phone_number_t</span></span> used
internally. There are a few ways to implement this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">phone_number_t</span> <span class="nf">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span> <span class="c1">// assume we can construct a phone_number_t from a valid string</span>
    <span class="k">else</span>
        <span class="k">throw</span> <span class="n">invalid_phone_number</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not ideal though, since exception should really be exceptional (more on
this below), and user providing invalid input should be a completely valid
scenario. The alternative would be to use a return code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">bool</span> <span class="nf">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">phone_number_t</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, but calling code is uglier:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">phone_number</span> <span class="o">=</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
</pre></div>
</div>
<p>now becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">phone_number_t</span> <span class="n">phone_number</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">phone_number</span><span class="p">);</span>
</pre></div>
</div>
<p>We can also end up in a bad state if we forget to check the return value. The
alternative is to encode the information that we either have a
<span class="docutils literal"><span class="pre">phone_number_t</span></span> or an invalid number in a type. In C++ we have (as of C++17)
<span class="docutils literal"><span class="pre">optional&lt;T&gt;</span></span> for this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">optional</span><span class="o">&lt;</span><span class="n">phone_number_t</span><span class="o">&gt;</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nullopt</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not quite a return error code and cannot really be ignored - there is no
implicit case from <span class="docutils literal"><span class="pre">optional&lt;T&gt;</span></span> to <span class="docutils literal"><span class="pre">T</span></span>, so callers need to explicitly
handle the case when the operation failed. Calling this is as natural as the
throwing version, but does not rely on exceptions <a class="footnote-reference" href="#id3" id="id1">[1]</a>. This is also called
<em>monadic error handling</em> and is widely employed by functional languages. I find
this a good alternative to throwing exceptions as long as it is well scoped and
error checks don’t have to pollute too many functions in the call stack.</p>
</div>
</div>
<div class="section" id="preconditions">
<h2>Preconditions</h2>
<p>Preconditions are conditions that should be satisfied upon entering a function
to ensure the function works as expected. When a function is called but the
preconditions are not met, it is not an error, it is a developer bug. The
recommended way of handling such a situation is, if possible, to crash
immediately. The reason for crashing is that calling a function with
preconditions not being met means the system is an invalid state and attempting
recovery is usually not worth it. Crashing on the other hand would provide
developers with dumps to help understand how the system got into this state and
fix the underlying bug.</p>
<p>The alternative to this is undefined behavior - calling a function without
meeting the preconditions cannot guarantee anything about the execution of the
function. Undefined behavior is used extensively throughout the C++ standard
<a class="footnote-reference" href="#id4" id="id2">[2]</a>. While failing fast is the preferred approach, sometimes it is unfeasible
to check preconditions at runtime: for example a precondition of binary search
is that it searches over an ordered range. Performing a binary search takes
logarithmic time but validating that a range is ordered takes linear time, so
adding this check would negatively impact the run time of the algorithm. In this
case, it is OK to say that we cannot provide any guarantees on what the function
will do. Debug-time asserts are a middle ground solution, since we can afford to
perform more expensive checks in debug builds to deterministically fail when
preconditions are not met. That being said, if the check is not prohibitively
expensive, it should be performed on all build flavors and immediately fail (via
<span class="docutils literal"><span class="pre">std::terminate</span></span> or equivalent).</p>
<p>What should not be done is treating such a state as an error - this is a bug in
the code and throwing an exception or returning some error result would just
leak the bug and make it impact more of the system. There really isn’t anything
useful to do with such an error - it only tells us that there is an issue in the
code and we are now in a state we should never be in. At this point we don’t
know which component originated the error and we cannot deterministically
recover - we might abort the current operation but there is no guarantee that
this would bring us back to a valid state. We are in undefined behavior land,
where crashing is the best option.</p>
</div>
<div class="section" id="recoverable-errors">
<h2>Recoverable Errors</h2>
<p>We covered several ways to handle errors by either eliminating invalid states at
compile-time or by failing fast when in an invalid state. There are, on the
other hand, classes of errors from which we can legitimately recover, which
brings us to exception and error codes.</p>
<div class="section" id="exceptions">
<h3>Exceptions</h3>
<p>I am a big fan of handling exceptional states using exceptions over returning
error codes. For one, the code is more readable: instead of reserving the return
type of a function to signal success or failure and resort to out parameters,
functions can be declared in a natural way. We also end up with less code
overall as instead of having to check error codes inside all functions in the
call stack in order to propagate back an error, we simply throw it from the top
of the stack and catch it where we can deal with it. This approach also composes
better - take, for example, a generic algorithm that takes some throwing
function. Since we supply the predicate, we know what exception it can throw and
we can catch it in the code that invokes the generic algorithm, keeping this
invisible to the algorithm:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryFunction</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryFunction</span> <span class="n">f</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">UnaryFunction</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
        <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If our predicate returns an error code instead, the generic algorithm must be
aware of this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UnaryFunction</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryFunction</span> <span class="n">f</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that here we are also making an assumption that 0 means success, which is
an arbitrary decision for a plug-in function.</p>
<p>That being said, I want to reiterate that exceptions should only be used for
exceptional cases. The readability advantage gained with exceptions is lost if
they are abused. It’s great if the callee throws one or two exception types
which the caller catches and handles. On the other hand, if we have to resort to
catch-all <span class="docutils literal"><span class="pre">catch</span> <span class="pre">(...)</span></span> and we have so many possible exception types coming
out of a function that we can’t keep track of them, the code actually becomes
harder to reason about.</p>
<p>An example and a counter-example: when reading a file with a set schema
generated by our application, we expect it to be in a valid format. If it isn’t,
it means some data corruption occurred but this should really be an exceptional
case. If we encounter such data corruption, we can throw an exception and let
the caller handle the fact that we cannot interpret this file. On the other
hand, when reading user input, we should never throw an exception if input is
not conforming - this should be a much more common scenario of user error.</p>
</div>
<div class="section" id="return-codes">
<h3>Return Codes</h3>
<p>There are cases which are not exceptional enough to warrant an exception but
where some error information needs to be propagated through the call stack.
Take, for example, a compiler which encounters an invalid token while parsing a
file. Since this is user input, it should not be treated as an exception. On the
other hand, simply using an optional and failing to parse without providing
additional information is also not ideal. In this case we probably want to
return additional information around the encountered error.</p>
<p>In this case we would return the error rather than throw it, but I would still
prefer an embellished type like Rust’s <span class="docutils literal"><span class="pre">Result</span></span> and return an
<span class="docutils literal"><span class="pre">std::variant&lt;T,</span> <span class="pre">Error&gt;</span></span> (as of C++17). In general I consider bad practice
returning an <span class="docutils literal"><span class="pre">int</span></span> or an <span class="docutils literal"><span class="pre">HRESULT</span></span> which would afterwards have to be decoded
to understand the actual error. For simple cases, if no other information
besides success/failure has to be returned, a <span class="docutils literal"><span class="pre">bool</span></span> would suffice, or an
<span class="docutils literal"><span class="pre">enum</span></span> or <span class="docutils literal"><span class="pre">struct</span></span> which contains the expected error information. Such an
error type can be composed with a valid return type using a variant which brings
us back to monadic error-handling.</p>
<p>My general rule of thumb is to use exceptions for really exceptional situations,
which keeps the code cleaner as long as the number of exception types is
managable, and use monadic error handling when errors are expected, as long as
these can be scoped to a limited number of functions (repeated error checking
all over the place is messy, error-prone, and makes code hard to read).</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We went over various ways of handling errors:</p>
<ul class="simple">
<li>Declaring types that restrict the range of values a variable can take to
eliminate invalid states at compile-time</li>
<li>Monadic error handling using embelished return types</li>
<li>Failing fast when preconditions of a function are not met</li>
<li>Throwing exceptions in exceptional cases</li>
<li>Returning strongly typed errors when errors are not exceptional</li>
</ul>
<p>There is still a fair amount of controversy around what is <em>the right way</em> of
handling errors. My personal take on this is that there are tradeoffs that come
with each approach and rather than saying “always use exceptions” or “never use
exceptions”, it’s more a matter of choosing <em>the right tool for the job</em>. I
tried to list some of the possible approaches with their pros and cons, and how
I employ them. Your mileage may vary depending on your specific language,
runtime, problem domain, application type etc.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This is the recommended way of <a class="reference external" href="https://doc.rust-lang.org/book/error-handling.html">handling errors in Rust</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>See Chandler Carruth’s CppCon talk <a class="reference external" href="https://www.youtube.com/watch?v=yG1OZ69H_-o">Garbage In, Garbage Out</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sat, 03 Dec 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/10/16/notes-on-types.html</link>
            <guid>http://vladris.com/blog/2016/10/16/notes-on-types.html</guid>
            <title><![CDATA[Notes on Types]]></title>
            <description><![CDATA[<h1>Notes on Types</h1>
<div class="section" id="type-systems">
<h2>Type Systems</h2>
<p>A good type system can eliminate entire categories of errors in a program and
simply make invalid code not compile. Before digging into types, below are a few
common distinctions between the type systems of various programming languages:</p>
<div class="section" id="dynamic-typing-vs-static-typing">
<h3>Dynamic Typing vs Static Typing</h3>
<p>In a statically typed language, the types are determined at compile time so if a
function was declared as only accepting a certain type <span class="docutils literal"><span class="pre">T</span></span> but we attempt to
pass it an unrelated type <span class="docutils literal"><span class="pre">U</span></span>, the program is considered invalid. This is
invalid C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">sqr</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">sqr</span><span class="p">(</span><span class="s">"not an int"</span><span class="p">);</span> <span class="c1">// does not compile</span>
</pre></div>
</div>
<p>On the other hand, in a dynamically typed language, we do not perform any
compile time checks and, if the data we get is of an unexpected type, we treat
it as a runtime error. Below is a Python function that squares a number:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">sqr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
<span class="o">...</span>
<span class="n">sqr</span><span class="p">(</span><span class="s2">"not an int"</span><span class="p">)</span>
<span class="c1"># runs but fails with TypeError: unsupported operand type(s)</span>
<span class="c1"># for ** or pow(): 'str' and 'int'</span>
</pre></div>
</div>
<p>Some of the interesting features of dynamic languages are <em>duck typing</em> (“if it
walks like a duck, and it quacks like a duck…”) and <em>monkey patching</em>. Duck
typing means that accessing a member of an object works as long as that object
has such a member, regardless of the type of the object. In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"bar"</span><span class="p">)</span>

<span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Foo</span><span class="p">(),</span> <span class="n">Bar</span><span class="p">()]]</span> <span class="c1"># prints "foo" and "bar"</span>
</pre></div>
</div>
<p>This can’t work in a statically typed language where, at the bare minimum, we
would have to add some form of constraint for the types in the list to ensure
they contain a <span class="docutils literal"><span class="pre">func()</span></span> method we can call.</p>
<p>Monkey patching refers to the ability to change the structure of an object at
runtime. For example we can swap the <span class="docutils literal"><span class="pre">func</span></span> method from an instance of <span class="docutils literal"><span class="pre">foo</span></span>
with another function like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func_bar</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"bar"</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="c1"># prints "foo"</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func_bar</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="c1"># prints "bar"</span>
</pre></div>
</div>
<p>These are useful capabilities, but the tradeoff is a whole class of type errors
which a statically typed language would’ve caught.</p>
<p>As a side note, the fact that dynamic languages don’t need to specify types
makes them more terse. That being said, the
<a class="reference external" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner algorithm W</a>
can infer the types of a program in linear time with respect to the source size.
So while Python is starting to support type annotations for better static
analysis and TypeScript provides a way for writing type-safe JavaScript, C++ has
better and better type inference, while in Haskell (which has one of the
strongest static type systems) type annotations are mostly optional.</p>
</div>
<div class="section" id="strong-typing-vs-weak-typing">
<h3>Strong Typing vs Weak Typing</h3>
<p>At a high level, a strongly typed language does not implicitly convert between
unrelated types. This is good in most situations as implicit conversions are
often meaningless or have surprising effects - for example, adding a number to
a list of characters. This can either result in runtime errors or garbage data.
In contrast, a strongly typed language will not accept code that attempts to do
this.</p>
<p>In Python, which is strongly typed, this doesn’t work:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">foo</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="c1"># foo is "foo"</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="s2">" bar"</span> <span class="c1"># foo is "foo bar"</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1"># TypeError: Can't convert 'int' object to str implicitly</span>
</pre></div>
</div>
<p>It works just fine in JavaScript though:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span/><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s2">"foo"</span><span class="p">;</span> <span class="c1">// foo is "foo"</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">+</span> <span class="s2">" bar"</span><span class="p">;</span> <span class="c1">// foo is "foo bar"</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// foo is "foo bar5"</span>
</pre></div>
</div>
<p>Note type strength is not an either/or - C++, while considered strongly typed,
still allows several implicit casts between types (eg. pointer to bool). Some
languages are more strict about converting between types implicitly, others less
so.</p>
</div>
<div class="section" id="dynamic-polymorphism-vs-static-polymorphism">
<h3>Dynamic Polymorphism vs Static Polymorphism</h3>
<p>Another difference to note is between static and dynamic polymorphism. Dynamic
polymorphism happens at runtime, when calling a function on a base type gets
resolved to the actual function of the deriving type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">foo</span> <span class="p">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">bar</span> <span class="p">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">call_func</span><span class="p">(</span><span class="n">base</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">foo</span><span class="p">{});</span> <span class="c1">// prints "foo"</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">bar</span><span class="p">{});</span> <span class="c1">// prints "bar"</span>
</pre></div>
</div>
<p>In the above case, we effectively have a single function <span class="docutils literal"><span class="pre">call_func</span></span> which
takes a reference to a <span class="docutils literal"><span class="pre">base</span></span> struct. The compiler generates a v-table for
<span class="docutils literal"><span class="pre">struct</span> <span class="pre">base</span></span> and a call to <span class="docutils literal"><span class="pre">func()</span></span> on <span class="docutils literal"><span class="pre">base</span></span> involves a v-table jump to
the actual implementation of the function, which is different between the
inheriting types <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span>.</p>
<p>Contrast this with the static alternative:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">foo</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bar</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">call_func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">foo</span><span class="p">{});</span> <span class="c1">// prints "foo"</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">bar</span><span class="p">{});</span> <span class="c1">// prints "bar"</span>
</pre></div>
</div>
<p>In this case there is no relationship between <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span> and no v-table
is needed. On the other hand, we no longer have a single <span class="docutils literal"><span class="pre">call_func</span></span>, we have
a templated function which is instantiated for both <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span> types.
This is all done at compile-time, the advantage being faster code, the drawback
being compiler needs to be aware of all the types involved - we can no longer
“inject” types implementing an interface at runtime. When calling <span class="docutils literal"><span class="pre">call_func</span></span>,
we need to have both the definition of the function and the declaration of the
type we’re passing in visible.</p>
</div>
</div>
<div class="section" id="types">
<h2>Types</h2>
<p>During the rest of this post, I will talk about types in the context of a
statically and strongly typed language, with a focus on static polymorphism.
This pushes as much as possible of the type checking to the compilation stage,
so many of the runtime issues of less strict languages become invalid syntax.</p>
<p>I will focus on C++ and cover some of the new C++17 feature which enable or make
some of these concepts easier to work with. That being said, since this post
focuses on types, I will also provide examples in Haskell, as Haskell can
express these concepts much more succinctly.</p>
<div class="section" id="type-basics">
<h3>Type Basics</h3>
<p>Let’s start with the definition of a type: <em>a type represents the set of
possible values</em>. For example, the C++ type <span class="docutils literal"><span class="pre">uint8_t</span></span> represents the set of
integers from 0 to 255. Effectively this means that a variable of a given type
can only have values from within that set.</p>
</div>
<div class="section" id="interesting-types">
<h3>Interesting Types</h3>
<p>Since we defined a type as a set of possible values, we can talk about the
cardinality of a type, in other words the number of values in the set. Based on
cardinality, there are a few interesting classes of types to talk about:</p>
</div>
<div class="section" id="empty-type">
<h3>Empty Type</h3>
<p>The first interesting type to talk about is the type that represents the empty
set, with <span class="docutils literal"><span class="pre">|T|</span> <span class="pre">=</span> <span class="pre">0</span></span>.</p>
<p>In Haskell, this type is named <span class="docutils literal"><span class="pre">Void</span></span>. Since Haskell is a functional language,
all functions must return a value, so it does not make sense to have a function
that returns <span class="docutils literal"><span class="pre">Void</span></span> - the same way it doesn’t make sense to define a
mathematical function with the empty set as its codomain. We do have an
<span class="docutils literal"><span class="pre">absurd</span></span> function though, which maps the empty set to any value:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="nf">absurd</span> <span class="ow">::</span> <span class="kt">Void</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>This function cannot be called though.</p>
<p>In C++, the absence of a value is represented as the <span class="docutils literal"><span class="pre">void</span></span> type. Since C++ is
not purely functional, we can define functions that don’t return anything. We
can even say that a function does not take any arguments by putting a <span class="docutils literal"><span class="pre">void</span></span>
between the parenthesis:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the equivalent of:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span>
</pre></div>
</div>
<p>Note though that we cannot have a <em>real</em> argument of type <span class="docutils literal"><span class="pre">void</span></span>, that is a
compile error as it doesn’t make any sense - we would be mandating the function
takes a value from the empty set. So we can say <span class="docutils literal"><span class="pre">foo(void)</span></span> but not
<span class="docutils literal"><span class="pre">foo(void</span> <span class="pre">arg)</span></span>, or even <span class="docutils literal"><span class="pre">foo(int</span> <span class="pre">arg,</span> <span class="pre">void)</span></span>.</p>
</div>
<div class="section" id="unit-type">
<h3>Unit Type</h3>
<p>The next interesting class consists of types with cardinality 1. A type <span class="docutils literal"><span class="pre">T</span></span>
with <span class="docutils literal"><span class="pre">|T|</span> <span class="pre">=</span> <span class="pre">1</span></span> is called a <em>unit</em> or <em>singleton type</em>. A variable of such a
type can only ever have a single possible value. In Haskell, the anonymous
representation is the empty tuple <span class="docutils literal"><span class="pre">()</span></span>. Here is an example of a function that
maps anything to this type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="nf">unit</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">unit</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Of course, we can declare our own singleton types. Below is a custom
<span class="docutils literal"><span class="pre">Singleton</span></span> type and an equivalent unit function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Singleton</span> <span class="ow">=</span> <span class="kt">Singleton</span>
<span class="nf">unit</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Singleton</span>
<span class="nf">unit</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Singleton</span>
</pre></div>
</div>
<p>In C++, the anonymous representation of a singleton is an empty <span class="docutils literal"><span class="pre">std::tuple</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As can be seen from the above, Haskell makes it easier to define a function that
takes an argument of any type, as it provides syntactic sugar for type
parameters (<span class="docutils literal"><span class="pre">a</span></span> in our example). In C++, the equivalent declaration involves a
template, but they boil down to the same thing. The non-anonymous C++
representation is a struct which doesn’t contain anything. All instances of such
a struct are equivalent:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">singleton</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">singleton</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sum-types">
<h3>Sum Types</h3>
<p>Here, things get a bit more interesting: a <span class="docutils literal"><span class="pre">sum</span> <span class="pre">type</span></span> is a type which can
represent a value from any of the types it sums. So given type <span class="docutils literal"><span class="pre">A</span></span> and type
<span class="docutils literal"><span class="pre">B</span></span>, the type <span class="docutils literal"><span class="pre">S</span></span> summing up <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> is <span class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:</span> <span class="pre">i</span> <span class="pre">∈</span> <span class="pre">A</span> <span class="pre">U</span> <span class="pre">B</span> <span class="pre">}</span></span>.
So a variable of type <span class="docutils literal"><span class="pre">S</span></span> could have any value in <span class="docutils literal"><span class="pre">A</span></span> or any value in <span class="docutils literal"><span class="pre">B</span></span>.
<span class="docutils literal"><span class="pre">S</span></span> is called a sum type because its cardinality is the sum of the
cardinalities of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span>, <span class="docutils literal"><span class="pre">|S|</span> <span class="pre">=</span> <span class="pre">|A|</span> <span class="pre">+</span> <span class="pre">|B|</span></span>.</p>
<p>Sum types are great, because they allow us to build up more complex types from
simpler ones. Once we have unit types, we can build up more complex types out
of them by summing them. For example, a boolean type which can be either
<span class="docutils literal"><span class="pre">true</span></span> or <span class="docutils literal"><span class="pre">false</span></span> can be thought of as the sum of the singleton <span class="docutils literal"><span class="pre">true</span></span>
type and the singleton <span class="docutils literal"><span class="pre">false</span></span> type. In Haskell, a boolean is defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">True</span> <span class="o">|</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Similarly, a <span class="docutils literal"><span class="pre">Weekday</span></span> type can be defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Weekday</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
</pre></div>
</div>
<p>Theoretically, numerical types could also be defined as huge sum types of every
possible value they can represent. Of course, this is impractical, but we can
reason about them the same way we reason about other sum types, we don’t have to
treat them as a special case.</p>
<p>In C++, an equivalent of the above is an <span class="docutils literal"><span class="pre">enum</span> <span class="pre">class</span></span>. <span class="docutils literal"><span class="pre">bool</span></span> is a built-in
type with special syntax, but we could define an equivalent as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">Boolean</span>
<span class="p">{</span>
    <span class="n">True</span><span class="p">,</span>
    <span class="n">False</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It’s easy to see how a <span class="docutils literal"><span class="pre">Weekday</span></span> definition would look like. Things get more
interesting when we throw type parameters into the mix. In Haskell, we have the
<span class="docutils literal"><span class="pre">Either</span></span> type, which is declared as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</pre></div>
</div>
<p>An instance of this could be either a <span class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></span>, where <span class="docutils literal"><span class="pre">a</span></span> is a type itself,
which means it can be any of the values of <span class="docutils literal"><span class="pre">a</span></span>, or it can be <span class="docutils literal"><span class="pre">Right</span> <span class="pre">b</span></span>, with
any of the values of <span class="docutils literal"><span class="pre">b</span></span>. In Haskell we use pattern-matching to operate on
such a type, so we can declare a simple function that tells us whether we were
given a <span class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></span> like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="nf">isLeft</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isLeft</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isLeft</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>This might not look like much, but of course we can compose more complex
functions. For example, say we have a function <span class="docutils literal"><span class="pre">foo</span></span> that takes an <span class="docutils literal"><span class="pre">a</span></span> and
returns an <span class="docutils literal"><span class="pre">a</span></span>, a function <span class="docutils literal"><span class="pre">bar</span></span> that takes a <span class="docutils literal"><span class="pre">b</span></span> and returns a <span class="docutils literal"><span class="pre">b</span></span>. We
can then write a <span class="docutils literal"><span class="pre">transform</span></span> function which takes an <span class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></span> and,
depending on the contained type, it applies the appropriate function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="c1">-- Implementation of foo and bar not provided in this example</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">bar</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">bar</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>This is way beyond the capabilities of a C++ <span class="docutils literal"><span class="pre">enum</span> <span class="pre">class</span></span>. The old way of
implementing something like this in C++ was using a union and a tag enum to keep
track of which is the actual type we’re working with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Declaration of A and B not provided in this example</span>
<span class="k">struct</span> <span class="n">A</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Either</span>
<span class="p">{</span>
    <span class="n">Either</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ab</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">::</span><span class="n">isA</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Either</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ab</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">::</span><span class="n">isB</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">A</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">B</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">ab</span><span class="p">;</span>

    <span class="k">enum</span> <span class="k">class</span> <span class="nc">tag</span>
    <span class="p">{</span>
        <span class="n">isA</span><span class="p">,</span>
        <span class="n">isB</span>
    <span class="p">}</span> <span class="n">tag</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Our implementation of transform would look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Implementation of A and B not provided in this example</span>
<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">B</span> <span class="nf">bar</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>

<span class="n">Either</span> <span class="nf">transform</span><span class="p">(</span><span class="n">Either</span> <span class="n">either</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">Either</span><span class="o">::</span><span class="n">tag</span><span class="o">::</span><span class="nl">isA</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">ab</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">Either</span><span class="o">::</span><span class="n">tag</span><span class="o">::</span><span class="nl">isB</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bar</span><span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">ab</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our <span class="docutils literal"><span class="pre">Either</span></span> type definition is obviously much more verbose than what we had
in Haskell, and it doesn’t even support type parameters - at this point it only
works with <span class="docutils literal"><span class="pre">struct</span> <span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">struct</span> <span class="pre">B</span></span>, while the Haskell version works for
any <span class="docutils literal"><span class="pre">a</span></span> and <span class="docutils literal"><span class="pre">b</span></span> types. The other major problem is that, while unions provide
efficient storage for different types (the size of the union is the size of the
maximum contained type), it is up to the implementer to make sure we don’t try
to read an <span class="docutils literal"><span class="pre">A</span></span> as a <span class="docutils literal"><span class="pre">B</span></span> or vice-versa. That means we need to keep our tag in
sync with what we put in the type and respect it when accessing the value of the
union.</p>
<p>C++17 introduces a better, safer, parameterized type for this: <span class="docutils literal"><span class="pre">std::variant</span></span>.
Variant takes any number of types as template arguments and stores an instance
of any one of those types. Using variant, we can re-write the above as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">either</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">([](</span><span class="k">auto</span> <span class="n">e</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nf">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
    <span class="p">},</span> <span class="n">either</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a lot of new syntax, so let’s break it down: <span class="docutils literal"><span class="pre">std::variant&lt;A,</span> <span class="pre">B&gt;</span></span> is
the new C++17 sum type. In this case, we specify it holds either <span class="docutils literal"><span class="pre">A</span></span> or <span class="docutils literal"><span class="pre">B</span></span>
(but it can hold an arbitrary number of types).</p>
<p><span class="docutils literal"><span class="pre">std::visit</span></span> is a function that applies the visitor function given as its
first argument to the variants given as its subsequent arguments. In our
example, this effectively expands to applying the lambda to
<span class="docutils literal"><span class="pre">std::get&lt;0&gt;(either)</span></span> and <span class="docutils literal"><span class="pre">std::get&lt;1&gt;(either)</span></span>.</p>
<p><span class="docutils literal"><span class="pre">if</span> <span class="pre">constexpr</span></span> is also a new C++17 construct which evaluates the if expression
at compile time and discards the else branch from the final object code. So in
this example, we determine at compile time whether the type we are being called
with is <span class="docutils literal"><span class="pre">A</span></span> or <span class="docutils literal"><span class="pre">B</span></span> and apply the correct function based on that. Something
very similar can be achieved with templates and <span class="docutils literal"><span class="pre">enable_if</span></span>, but this syntax
makes for more readable code.</p>
<p>Note that with this version we can simply prepend a <span class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;typename</span> <span class="pre">A,</span>
<span class="pre">typename</span> <span class="pre">B&gt;</span></span> and make the whole function generic, as in the Haskell example. It
doesn’t read as pretty (because we don’t have good pattern matching syntax in
the language), but this is the new, type safe way of implementing and working
with sum types, which is a major improvement.</p>
</div>
<div class="section" id="product-types">
<h3>Product Types</h3>
<p>With sum types out of the way, the remaining interesting category is that of
<em>product types</em>. Product types combine the values of several other types into
one. For types <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span>, we have <span class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">(a,</span> <span class="pre">b)</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">∈</span> <span class="pre">A,</span> <span class="pre">b</span> <span class="pre">∈</span> <span class="pre">B</span> <span class="pre">}</span></span>, so
<span class="docutils literal"><span class="pre">|P|</span> <span class="pre">=</span> <span class="pre">|A|</span> <span class="pre">x</span> <span class="pre">|B|</span></span>.</p>
<p>In Haskell, the anonymous version of product types is represented by tuples,
while the named version is represented by records. An example of a <span class="docutils literal"><span class="pre">perimeter</span></span>
function which computes the perimeter of a rectangle defined by two points,
where each point is a tuple of numbers:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="nf">perimeter</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">n</span>
<span class="nf">perimeter</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span>
</pre></div>
</div>
<p>The named version would declare a <span class="docutils literal"><span class="pre">Point</span></span> type with <span class="docutils literal"><span class="pre">Int</span></span> coordinates and
use that instead:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="nf">perimeter</span> <span class="ow">::</span> <span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">perimeter</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span>
</pre></div>
</div>
<p>The C++ equivalents are <span class="docutils literal"><span class="pre">std::tuple</span></span> for anonymous product types and
<span class="docutils literal"><span class="pre">struct</span></span> for named types:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Anonymous</span>
<span class="kt">int</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span>
        <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// Named</span>
<span class="k">struct</span> <span class="n">point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">point</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While sum types allow us to express values from multiple types into one, product
types allow us to express values from several types together. Empty, unit, sum,
and product types are the building blocks of a type system.</p>
</div>
<div class="section" id="bonus-optional-types">
<h3>Bonus: Optional Types</h3>
<p>An optional type is a type that can hold any of the values of another type, or
not hold any value, which is usually represented as a singleton. So an optional
is effectively a sum type between a given type and a singleton representing
“doesn’t hold a value”. In other words, the cardinality of an optional for a
type <span class="docutils literal"><span class="pre">T</span></span> is <span class="docutils literal"><span class="pre">|O|</span> <span class="pre">=</span> <span class="pre">|T|</span> <span class="pre">+</span> <span class="pre">1</span></span>.</p>
<p>In Haskell, an optional is the famous <span class="docutils literal"><span class="pre">Maybe</span></span> type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>A function that operates on <span class="docutils literal"><span class="pre">Maybe</span></span> could say “only apply <span class="docutils literal"><span class="pre">foo</span></span> if the
optional contains an <span class="docutils literal"><span class="pre">a</span></span>”:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="c1">-- Implementation of foo not provided in this example</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">transform</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>The new C++17 equivalent is the <span class="docutils literal"><span class="pre">optional</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Implementation of foo not provided in this example</span>
<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">nullopt</span> <span class="o">?</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">nullopt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This might read a bit like the pointer implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">A</span><span class="o">*</span> <span class="nf">transform</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">?</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a key difference though: the type contained in the optional is part of
the object, so it is not allocated dynamically the way we would allocate a
pointer. <span class="docutils literal"><span class="pre">nullopt</span></span> is a helper object of the singleton type <span class="docutils literal"><span class="pre">nullopt_t</span></span>.</p>
<p>Types are important because a big part of programming effectively consits of
designing and composing types. Having a good understanding of the fundamentals
leads to better, safer, and saner code.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We started by outlining some of the basic principles of type systems:</p>
<ul class="simple">
<li>Static and dynamic typing</li>
<li>Weak and strong typing</li>
<li>Static and dynamic polymorphism</li>
</ul>
<p>Then we went over the building block types of a type system, with Haskell and
C++ examples:</p>
<ul class="simple">
<li>Empty types (cardinality 0)</li>
<li>Unit types (cardinality 1)</li>
<li>Sum types (<span class="docutils literal"><span class="pre">S</span></span> of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></span>)</li>
<li>Product types (<span class="docutils literal"><span class="pre">P</span></span> of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">B</span></span>)</li>
<li>Optional types (<span class="docutils literal"><span class="pre">O</span></span> of <span class="docutils literal"><span class="pre">A</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">1</span></span>)</li>
</ul>
</div>
<div class="section" id="further-reading">
<h2>Further Reading</h2>
<p>Ben Dean had an excellent talk at CppCon this year, <a class="reference external" href="https://www.youtube.com/watch?v=ojZbFIQSdl8">Using Types Effectively</a>. Another great talk about type
design from CppCon is <a class="reference external" href="https://www.youtube.com/watch?v=632a-DMM5J0">C++, Abstract Algebra and Practical Applications</a> by Robert Ramey. And then there
is Bartosz Milewski <a class="reference external" href="https://bartoszmilewski.com/">blog</a> about Haskell,
C++, and category theory.</p>
</div>
]]></description>
             <pubDate>Sun, 16 Oct 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/10/09/composable-generators.html</link>
            <guid>http://vladris.com/blog/2016/10/09/composable-generators.html</guid>
            <title><![CDATA[Composable Generators]]></title>
            <description><![CDATA[<h1>Composable Generators</h1>
<p>One of the most exciting features coming to C++ are coroutines. In this post,
I will give a quick overview of how they are used today in C# to support
generators and go over a few possible ways to bring the composability of Linq to
the C++ world.</p>
<div class="section" id="generators-in-c">
<h2>Generators in C#</h2>
<p>I will not go into the nitty-gritty details of coroutines, but in short, they
are resumable functions – functions that can be suspended/resumed. Coroutines
enable lazy evaluation, with two major applications: easy to read
multi-threading (with async/await syntax in C#) and generators (with yield
return syntax in C#). In this post, I will focus on generators and how they
compose.</p>
<p>I will start with a C# example since Linq is, in my opinion, the golden
standard for creating a processing pipeline, at least for non-functional
languages. Linq is implemented as a set of extension methods for
<span class="docutils literal"><span class="pre">IEnumerable</span></span>, and enables some very readable chaining of operations. For
example, let’s get the first 100 natural numbers, filter out the odds, then
square the remaining list.</p>
<p>The wrong way of doing this would be something like:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetNumbers</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">GetNumbers</span><span class="p">();</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main problem with the above is that all the logic is inlined into
<span class="docutils literal"><span class="pre">GetNumbers</span></span>, so things don’t decompose very well – for example what if we
also want a function that squares the odd numbers? We would either duplicate the
looping and squaring logic, or make the predicate we use to filter out things an
input to the function. Same goes for the iterating logic and for the squaring.
Luckily, we have Linq, which does just that:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span>
        <span class="n">Enumerable</span><span class="p">.</span><span class="n">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">).</span>
        <span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">).</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To illustrate the magic of generators, instead of relying on
<span class="docutils literal"><span class="pre">Enumerable.Range</span></span>, let’s introduce a function that generates numbers
forever:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">Count</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our code would then become:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span>
        <span class="n">Count</span><span class="p">().</span>
        <span class="n">Take</span><span class="p">(</span><span class="m">100</span><span class="p">).</span>
        <span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">).</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While not strictly necessary in this particular case, infinite generators cannot
exist without lazy evaluation, a feature of many functional languages. Lazy
evaluation has some very practical applications as it allows processing of data
as it becomes available, instead of waiting for everything to be ready before
moving on to the next step. While the 100 natural numbers example might not
sound so useful, imagine rendering frames in a streaming video as they arrive
over the network. Linq is great because it provides a clean separation between
the generic algorithms (<span class="docutils literal"><span class="pre">Where</span></span>, <span class="docutils literal"><span class="pre">Select</span></span> etc.) and the problem-specific
operations which are passed in as arguments. Linq operations also compose well,
so they can be chained together to form pipelines.</p>
</div>
<div class="section" id="id1">
<h2>Generators in C++</h2>
<p>While coroutines haven’t made it into the C++17 standard itself, they are coming
as a technical specification, with MSVC already supporting them (code samples
below compile with VS 2015 Update 3). The main syntax additions are the new
<span class="docutils literal"><span class="pre">co_await</span></span>, <span class="docutils literal"><span class="pre">co_return</span></span>, and <span class="docutils literal"><span class="pre">co_yield</span></span> keywords. The first two are used
for creating and awaiting tasks (which I won’t cover in this post), while
<span class="docutils literal"><span class="pre">co_yield</span></span> is used in generators.</p>
<p>Here is a lazy counter in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="nf">count_to</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">count_to</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the return type of <span class="docutils literal"><span class="pre">count_to</span></span> is a <span class="docutils literal"><span class="pre">generator&lt;int&gt;</span></span> (currently in the
experimental namespace). <span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span> is the type implicitly created by the
compiler when encountering a <span class="docutils literal"><span class="pre">co_yield</span></span>. Also worth noting that range-based
for loops work over generators, as they expose <span class="docutils literal"><span class="pre">begin()</span></span> and <span class="docutils literal"><span class="pre">end()</span></span>
methods. The type annotation for the <span class="docutils literal"><span class="pre">count_to</span></span> return type above is not
really needed, I added it just to clarify what the complier will generate in
this case.</p>
<p><span class="docutils literal"><span class="pre">generator</span></span> itself is pretty bare-boned, it doesn’t provide all the algorithms
that Linq adds to <span class="docutils literal"><span class="pre">IEnumerable</span></span>. So if we wanted to do something like the
above pipeline, we would need some algorithms. Here’s one way of implementing
some of them:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="nf">count</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here I switched from Linq’s <span class="docutils literal"><span class="pre">Select</span></span> and <span class="docutils literal"><span class="pre">Where</span></span> to the more commonly used
<span class="docutils literal"><span class="pre">map</span></span> and <span class="docutils literal"><span class="pre">filter</span></span>, but they effectively implement the same thing. While
this implementation is pretty-straight forward, it doesn’t compose well at all:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">map</span><span class="p">(</span>
            <span class="n">filter</span><span class="p">(</span>
                <span class="n">take_n</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="mi">100</span><span class="p">),</span>
                <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}),</span>
            <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Definitely not like the nice chaining of Linq. So what gives? Why doesn’t
generator come out-of-the-box with <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">map</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> and all the
other useful algorithms? Well, according to the
<a class="reference external" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>,
these algorithms don’t belong in <span class="docutils literal"><span class="pre">generator</span></span> – <span class="docutils literal"><span class="pre">generator</span></span> encapsulates the
lazy evaluation of the coroutine, it wouldn’t be the right place for algorithms.
It’s also worth noting that Linq methods are not part of <span class="docutils literal"><span class="pre">IEnumerable</span></span>, they
are <a class="reference external" href="https://msdn.microsoft.com/en-us/library/bb383977.aspx">extension methods</a>.
C++ doesn’t support extension methods, so we would need a slightly different
design to achieve better chaining.</p>
</div>
<div class="section" id="decorator">
<h2>Decorator</h2>
<p>The next idea comes from pure OOP - let’s create a decorator over <span class="docutils literal"><span class="pre">generator</span></span>
that exposes these algorithms. First, let’s declare our decorator as
<span class="docutils literal"><span class="pre">enumerable&lt;T&gt;</span></span> and change our algorithms to work with the new type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enumerable</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation looks pretty much like before, except that now we are getting
and returning <span class="docutils literal"><span class="pre">enumerable&lt;T&gt;</span></span> instead of <span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span>. In this case the
type annotation is mandatory, as by default the complier would create a
<span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span>.</p>
<p>We can then implement our enumerable to wrap a generator and expose member
functions which forward to the above algorithms:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enumerable</span>
<span class="p">{</span>
    <span class="c1">// Needed by compiler to create enumerable from co_yield</span>
    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>

    <span class="n">enumerable</span><span class="p">(</span><span class="n">promise_type</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">)</span> <span class="o">:</span> <span class="n">_gen</span><span class="p">(</span><span class="n">promise</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">enumerable</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_gen</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>

    <span class="n">enumerable</span><span class="p">(</span><span class="k">const</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_gen</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">auto</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_gen</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">take_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">pred</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_gen</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A few things to note: we declare a <span class="docutils literal"><span class="pre">promise_type</span></span> and have a constructor which
takes a promise as an argument. This is required by the compiler when creating
the object on <span class="docutils literal"><span class="pre">co_yield</span></span>. We follow the same semantics as generator, since
that is what we are wrapping – support only move-constructor, no
copy-constructor. All the member algorithms do a destructive move on <span class="docutils literal"><span class="pre">*this</span></span>.
This is intentional, as once we iterate over the encapsulated generator, it is
no longer valid. Since we don’t expose a copy-constructor, we move out of
<span class="docutils literal"><span class="pre">*this</span></span> when passing the generator to an algorithm. For completeness, we can
also provide a function which converts from a generator to an enumerable:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">to_enumerable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, and we can now compose algorithms by chaining the calls:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">to_enumerable</span><span class="p">(</span><span class="n">count</span><span class="p">()).</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}).</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Still, it is not ideal – first, we need to explicitly tell the compiler
everywhere to return our type with <span class="docutils literal"><span class="pre">co_yield</span></span> instead of the default
generator, and we need to handle conversions to and from the standard library
generator. The enumerable algorithms compose well, but we’ll have trouble
composing with functions that work with generators. Also, having a huge class
consisting solely of algorithms is not the best design, especially in a language
where free functions are first class citizens.</p>
</div>
<div class="section" id="pipe-operator">
<h2>Pipe Operator</h2>
<p>An alternative approach, which the
<a class="reference external" href="http://www.boost.org/doc/libs/1_62_0/libs/range/doc/html/index.html">Boost Ranges library</a>
takes, is to overload <span class="docutils literal"><span class="pre">|</span></span>, the “pipe” operator, so we can compose our calls
like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">count</span><span class="p">()</span> <span class="o">|</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">|</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span> <span class="o">|</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One way we can get this working is to first create a type that wraps an
algorithm and an <span class="docutils literal"><span class="pre">operator|</span></span> implementation between a lhs <span class="docutils literal"><span class="pre">generator</span></span> and a
rhs of our type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">filter_t</span>
<span class="p">{</span>
    <span class="n">filter_t</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Predicate</span> <span class="n">_pred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <span class="docutils literal"><span class="pre">filter_t</span></span> holds the <span class="docutils literal"><span class="pre">Predicate</span></span> we want to use, and <span class="docutils literal"><span class="pre">operator|</span></span>
applies it on the given <span class="docutils literal"><span class="pre">generator</span></span>. This works, but we wouldn’t be able to
instantiate <span class="docutils literal"><span class="pre">filter_t</span></span> with a lambda like in the above chaining example
without specifying the Predicate type in the call. If we want to leverage type
deduction, we can create a simple helper function that creates a <span class="docutils literal"><span class="pre">filter_t</span></span>
from a given argument:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this we can call <span class="docutils literal"><span class="pre">|</span> <span class="pre">filter(/*</span> <span class="pre">predicate</span> <span class="pre">*/)</span></span> on a generator and get back
a filtered generator. Full implementation for <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> and <span class="docutils literal"><span class="pre">map</span></span>
would be:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">take_n_t</span>
<span class="p">{</span>
    <span class="n">take_n_t</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">_n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">_n</span><span class="p">)</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">_n</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">take_n_t</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">take_n_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">filter_t</span>
<span class="p">{</span>
    <span class="n">filter_t</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Predicate</span> <span class="n">_pred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">map_t</span>
<span class="p">{</span>
    <span class="n">map_t</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="o">:</span> <span class="n">_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">_op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">BinaryOperation</span> <span class="n">_op</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">map_t</span><span class="o">&lt;</span><span class="n">BinaryOperation</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">map_t</span><span class="o">&lt;</span><span class="n">BinaryOperation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach, we can apply our algorithms over a generator without having
to introduce a different type. They also compose very nicely, the only slightly
odd thing being using the <span class="docutils literal"><span class="pre">|</span></span> operator (though as I mentioned, there is a
precedent for this in Boost and chances are it might show up in other places in
the future).</p>
</div>
<div class="section" id="unified-call-syntax">
<h2>Unified Call Syntax</h2>
<p>One thing that would’ve made things even easier but unfortunately was not
approved for C++17 is <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4165.pdf">unified call syntax</a>.
At a high level, unified call syntax would make the compiler try to resolve
<span class="docutils literal"><span class="pre">x.f()</span></span> to <span class="docutils literal"><span class="pre">f(x)</span></span> if <span class="docutils literal"><span class="pre">decltype(x)</span></span> doesn’t have an <span class="docutils literal"><span class="pre">f()</span></span> member function
but there is a free function <span class="docutils literal"><span class="pre">f(decltype(x))</span></span>. Similarly, if no
<span class="docutils literal"><span class="pre">f(decltype(x))</span></span> exists but <span class="docutils literal"><span class="pre">decltype(x)</span></span> has a member function <span class="docutils literal"><span class="pre">f()</span></span>,
<span class="docutils literal"><span class="pre">f(x)</span></span> would resolve to the member function call <span class="docutils literal"><span class="pre">x.f()</span></span>.</p>
<p>If it’s not obvious, unified call syntax would allow us to easily create
extension methods. We would be able to revert our algorithm code to the first
version:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="n">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="n">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But now this becomes very composable as calling <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> or
<span class="docutils literal"><span class="pre">map</span></span> on a generator would resolve to the free functions if the <span class="docutils literal"><span class="pre">generator</span></span>
itself does not have them as members:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">count</span><span class="p">().</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}).</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above currently does not compile but it should (disclaimer: slight tweaks
might be required) if unified call syntax becomes part of the standard.</p>
</div>
<div class="section" id="in-summary">
<h2>In Summary</h2>
<p>We went over a couple of alternatives to implement some common algorithms over
C++ generators with a focus on composability:</p>
<ul class="simple">
<li>Stand-alone functions are simple but don’t compose very well</li>
<li>Using a decorator works, but is not ideal from a design point of view and not
very idiomatic</li>
<li>Using the pipe operator for chaining and helper types for the algorithms is
the best approach today</li>
<li>Unified call syntax would simplify things a lot, enabling a mechanism to
implement these algorithms as extension methods</li>
</ul>
</div>
]]></description>
             <pubDate>Sun, 09 Oct 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/08/17/concepts-and-modules.html</link>
            <guid>http://vladris.com/blog/2016/08/17/concepts-and-modules.html</guid>
            <title><![CDATA[Concepts and Modules]]></title>
            <description><![CDATA[<h1>Concepts and Modules</h1>
<p>As a follow up to my previous post, I want to talk about two major new C++
features that keep not making it into the standard, namely <em>Concepts</em> and
<em>Modules</em>. These would have a significant impact on the code examples I
provided while discussing dependency injectiojn, so here’s a quick peek into the
future:</p>
<div class="section" id="concepts">
<h2>Concepts</h2>
<p>One way to think about concepts is that concepts are to templates what
interfaces are to classes. Similarly to how interfaces specify a contract which
implementing types must satisfy, concepts specify a contract which template
argument types must satisfy. The main difference is that interfaces/classes
enable runtime polymorphism while concepts/templates enable polymorphism at
compile-time.</p>
<p>Runtime polymorphism:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Our interface</span>
<span class="k">struct</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// One implementation</span>
<span class="k">class</span> <span class="nc">V6Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Another implementation</span>
<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A function that works against the interface</span>
<span class="kt">void</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StartEngines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">V6Engine</span> <span class="n">v6engine</span><span class="p">;</span>
    <span class="n">V8Engine</span> <span class="n">v8engine</span><span class="p">;</span>

    <span class="c1">// calls Start() on V6Engine instance passed as IEngine</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v6engine</span><span class="p">);</span>
    <span class="c1">// calls Start() on V8Engine instance passed as IEngine</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v8engine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we have a single <span class="docutils literal"><span class="pre">StartEngine</span></span> function which works against an
interface. Calling <span class="docutils literal"><span class="pre">Start()</span></span> for that interface involves a virtual function
call, which means that at runtime, given an object of a type implementing
<span class="docutils literal"><span class="pre">IEngine</span></span>, the code needs to figure out which function of the implementing
type to call. For <span class="docutils literal"><span class="pre">V6Engine</span></span>, <span class="docutils literal"><span class="pre">IEngine::Start()</span></span> is <span class="docutils literal"><span class="pre">V6Engine::Start();</span></span>
for <span class="docutils literal"><span class="pre">V8Engine</span></span>, <span class="docutils literal"><span class="pre">IEngine::Start()</span></span> is <span class="docutils literal"><span class="pre">V8Engine::Start()</span></span>. Our classes
have a vtable - a table containing this mapping, so a virtual call looks up the
actual function to call in the vtable.</p>
<p>This is the “classical” object-oriented way of dispatching calls. The advantage
of this approach is that it works across binaries <a class="footnote-reference" href="#id3" id="id1">[1]</a> (we can export
<span class="docutils literal"><span class="pre">StartEngine</span></span> from a shared library and pass in an external <span class="docutils literal"><span class="pre">IEngine</span></span>
implementation to it), the disadvantage is the extra redirection - implementing
classes must have a vtable and call resolution involves jumping through it.</p>
<p>Compile-time polymorphism:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// One implementation</span>
<span class="k">class</span> <span class="nc">V6Engine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Another implementation</span>
<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A generic function</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">TEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StartEngines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">V6Engine</span> <span class="n">v6engine</span><span class="p">;</span>
    <span class="n">V8Engine</span> <span class="n">v8engine</span><span class="p">;</span>

    <span class="c1">// calls Start() on V6Engine, this instantiates</span>
    <span class="c1">// StartEngine&lt;V6Engine&gt;(V6Engine&amp; engine)</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v6engine</span><span class="p">);</span>
    <span class="c1">// calls Start() on V8Engine, this instantiates</span>
    <span class="c1">// StartEngine&lt;V8Engine&gt;(V8Engine&amp; engine)</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v8engine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A few differences to note here: we don’t have an <span class="docutils literal"><span class="pre">IEngine</span></span> interface anymore
and the two types we use, <span class="docutils literal"><span class="pre">V6Engine</span></span> and <span class="docutils literal"><span class="pre">V8Engine</span></span>, no longer have virtual
functions. Calling <span class="docutils literal"><span class="pre">V6Engine::Start()</span></span> or <span class="docutils literal"><span class="pre">V8Engine::Start()</span></span> now no longer
involves a virtual call. The two <span class="docutils literal"><span class="pre">StartEngine</span></span> calls are actually made to
different functions now - at compile time, whenever the compiler encounters a
call to <span class="docutils literal"><span class="pre">StartEngine</span></span> with a new type, it instantiates the template, meaning
it creates a new function based on that template with the template type as the
provided type. We actually end up with one function that can start a
<span class="docutils literal"><span class="pre">V6Engine</span></span> and one that can start <span class="docutils literal"><span class="pre">V8Engine</span></span>, both produced from the same
template.</p>
<p>This is compile-time polymorphism, the advantage being that everything is
determined during build - no virtual calls etc., the disadvantage being that
the compiler needs to have a definition of the template available whenever it
needs to create a new instance <a class="footnote-reference" href="#id4" id="id2">[2]</a>. In this case we can’t encapsulate what
happens inside <span class="docutils literal"><span class="pre">StartEngine</span></span> if we want others to be able to call the
function.</p>
<div class="section" id="with-concepts">
<h3>With Concepts</h3>
<p>The above works just fine, the problem being that, in general, if you have
a templated function, it’s not obvious what contracts do the types it expects
need to satisfy. For example, our <span class="docutils literal"><span class="pre">StartEngine</span></span> expects that the given type
has a <span class="docutils literal"><span class="pre">Start()</span></span> function it can call. This isn’t obvious from the function
declaration though. Also, compiler errors when templates cannot be instantiated
are notoriously hard to decipher. The proposed solution to both of the above
are concepts. Here is how an engine concept would look like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="kt">bool</span> <span class="n">Engine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">requires</span><span class="p">(</span><span class="n">TEngine</span> <span class="n">engine</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">()</span> <span class="p">};</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This defines the <span class="docutils literal"><span class="pre">Engine</span></span> concept to require any type satisfying it to have a
<span class="docutils literal"><span class="pre">Start()</span></span> function and a <span class="docutils literal"><span class="pre">Stop()</span></span> function. <span class="docutils literal"><span class="pre">StartEngine</span></span> would then be
able to explicitly say what kind of types it expects:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="n">Engine</span> <span class="n">TEngine</span><span class="o">&gt;</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">TEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is now clear from the function declaration that <span class="docutils literal"><span class="pre">StartEngine</span></span> expects a
type satisfying the <span class="docutils literal"><span class="pre">Engine</span></span> concept. We can look at the concept definition to
see what we need to implement on our type. The compiler would also be able to
issue much clearer errors when the type we pass in is missing one of the concept
requirements.</p>
<p>Unfortunately, while several proposals for concepts have been put forward in the
past years, they weren’t approved to be part of the C++17 standard. That being
said, it’s fairly certain that they will eventually make it into the standard.</p>
</div>
</div>
<div class="section" id="modules">
<h2>Modules</h2>
<p>Another noteworthy feature are modules: currently, the <span class="docutils literal"><span class="pre">#include</span></span> directive
textually includes the given file into the source file being compiled. This has
a lot of build-time overhead (same header files get compiled over and over as
they are included in various source files) and forces us to be extra-careful in
how we scope things: what goes in a header file vs. what goes in a source file
etc.</p>
<p>Modules aim to replace the header/source file split and provide a better way to
group components and expose functionality. For example, here is a header/source
file pair from my previous post:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// ICar.h</span>
<span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
<span class="n">Car</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span>

<span class="c1">// Car.cpp</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using modules, we would have:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">module</span> <span class="n">Car</span><span class="p">;</span>

<span class="n">import</span> <span class="n">Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is now a single file where we import the <span class="docutils literal"><span class="pre">Engine</span></span> module (instead of
<span class="docutils literal"><span class="pre">#include</span></span>), we provide the interface and concrete implementation, the factory
function, and we mark publicly-visible declarations with the <span class="docutils literal"><span class="pre">export</span></span> keyword.</p>
<p>Like Concepts, Modules haven’t made it into the C++17 standard, but MSVC has a
working implementation as of VS2015 Update 1.</p>
</div>
<div class="section" id="dependency-injection-in-the-future">
<h2>Dependency Injection in the Future</h2>
<p>So putting the above together, here is how dependency injection in C++ might
look like in the not too far future:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Engine.m</span>
<span class="n">module</span> <span class="n">Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">concept</span> <span class="kt">bool</span> <span class="n">Engine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">requires</span><span class="p">(</span><span class="n">TEngine</span> <span class="n">engine</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">()</span> <span class="p">};</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// V8Engine.m</span>
<span class="n">module</span> <span class="n">V8Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// start the engine }</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// stop the engine }</span>
<span class="p">};</span>

<span class="c1">// Car.m</span>
<span class="n">module</span> <span class="n">Car</span><span class="p">;</span>

<span class="n">import</span> <span class="n">Engine</span><span class="p">;</span>
<span class="n">import</span> <span class="n">V8Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="n">Engine</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="n">requires</span> <span class="n">DefaultConstructible</span><span class="o">&lt;</span><span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Explicit instantiation exported from this module so clients</span>
<span class="c1">// won't have to re-instantiate the template for V8Engine type</span>
<span class="k">export</span> <span class="k">class</span> <span class="nc">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>This can be used as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">import</span> <span class="n">Car</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
<span class="n">car</span><span class="p">.</span><span class="n">Drive</span><span class="p">();</span>
</pre></div>
</div>
<p>This would be the equivalent of Dependency Injection with Templates I mentioned
in the previous post.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>As long as binaries are compiled with the same compiler. Otherwise the
code produced by different compilers might have different vtable layouts
and different name mangling.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Other disadvantages are slower compile times and potential code bloat,
as each template instantiation gets translated into a new function.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Wed, 17 Aug 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/07/06/dependency-injection-in-c.html</link>
            <guid>http://vladris.com/blog/2016/07/06/dependency-injection-in-c.html</guid>
            <title><![CDATA[Dependency Injection in C++]]></title>
            <description><![CDATA[<h1>Dependency Injection in C++</h1>
<p>In this post, I will switch gears from functional C++ to object oriented C++ and
talk about dependency injection.</p>
<p>Let’s start with a simple example: take a <span class="docutils literal"><span class="pre">Car</span></span> class with a <span class="docutils literal"><span class="pre">Drive()</span></span>
method. Let’s say this class contains a <span class="docutils literal"><span class="pre">V8Engine</span></span> attribute with <span class="docutils literal"><span class="pre">Start()</span></span>
and <span class="docutils literal"><span class="pre">Stop()</span></span> methods. An initial implementation might look like this:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">V8Engine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="dependency-injection-with-interfaces">
<h2>Dependency Injection with Interfaces</h2>
<p>In the above example, <span class="docutils literal"><span class="pre">Car</span></span> is tightly coupled to <span class="docutils literal"><span class="pre">V8Engine</span></span>, meaning we
can’t create a car without a concrete engine implementation. If we want the
ability to swap various engines or use a mock engine during testing, we could
reverse the dependency by creating an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and decoupling
<span class="docutils literal"><span class="pre">Car</span></span> from the concrete <span class="docutils literal"><span class="pre">V8Engine</span></span> implementation. This way, we only expose
an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and a factory function. <span class="docutils literal"><span class="pre">Car</span></span> can work against that:</p>
<p><em>IEngine.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">();</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* start the engine */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* stop the engine */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="notes">
<h2>Notes</h2>
<div class="section" id="a-note-on-headers">
<h3>A note on headers</h3>
<p>Headers simply get textually included in each compilation unit by the
<span class="docutils literal"><span class="pre">#include</span></span> directive. It is not mandatory to provide a header file for each
class declaration. If a class can be scoped to a single source file, then it
doesn’t need a header declaration (for example the <span class="docutils literal"><span class="pre">V8Engine</span></span> class above
does not need a V8Engine.h header corresponding to the V8Engine.cpp). It is also
a good idea to have public headers and internal headers: public headers contain
the public API surface and can be included by other parts of the system, while
internal headers are only used within the component and should not be included
by external code.</p>
<p>Default should be the least visible: try to keep everything inside the cpp file
(like V8Engine.cpp). If that is not enough, an internal header might do. A
declartion should be pulled into a public header only when external components
need to reference it.</p>
</div>
<div class="section" id="a-note-on-interfaces">
<h3>A note on interfaces</h3>
<p>It’s a good idea to declare a default virtual destructor: if a deriving type has
a destructor, it won’t get called if we store an upcast pointer to the interface
unless the interface declares a virtual destructor. Note a destructor does not
to be expicitly defined - compiler might generate a default one.</p>
<p>MSVC compiler provides a <span class="docutils literal"><span class="pre">__declspec(novtable)</span></span> <a class="footnote-reference" href="#id2" id="id1">[1]</a> custom attribute which
tells the compiler not to generate a vtable for pure abstract classes. This
reduces code size. Below is the <span class="docutils literal"><span class="pre">IEngine</span></span> declaration with this attribute:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">novtable</span><span class="p">)</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>I won’t include it in the code samples in this post, but it’s worth keeping in
mind when working with MSVC.</p>
</div>
<div class="section" id="a-note-on-factory-functions">
<h3>A note on factory functions</h3>
<p>When working with interfaces as opposed to concrete types, we use factory
functions to get object instances. Below is a possible naming convention, taking
object ownership into account:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">MakeFoo</span><span class="p">();</span>
<span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">UseFoo</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">GetFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>The first function, <span class="docutils literal"><span class="pre">MakeFoo</span></span>, returns a unique pointer, passing ownership to
the caller. Like in the example above, the <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> can be moved into the
object, which ends up owning it. Use a Make when each call creates a new
instance.</p>
<p>The second function implies there already exists an <span class="docutils literal"><span class="pre">IFoo</span></span> object which is
owned by someone else, with the guarantee that it will outlive the caller. In
that case, there is no need for pointers and we can simply return a reference to
the object. This can be used, for example, for singletons. Below is an example
of a singleton <span class="docutils literal"><span class="pre">Engine</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">UseEngine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The third function, <span class="docutils literal"><span class="pre">GetFoo</span></span>, implies shared ownership - we get an object that
other objects might hold a reference to, but we don’t have the lifetime
guarantee a singleton would give us, so we need to use a shared pointer to make
sure the object is kept alive long enough.</p>
</div>
</div>
<div class="section" id="mocking">
<h2>Mocking</h2>
<p>Since <span class="docutils literal"><span class="pre">Car</span></span> now works with an <span class="docutils literal"><span class="pre">IEngine</span></span> interface, in test code we can mock
the engine:</p>
<p><em>Test.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span> <span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also expose <span class="docutils literal"><span class="pre">Car</span></span> as a simple interface, hiding its implementation
details, in which case we would end up with the following:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would become:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">car</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test ICar without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note this allows the caller to pass in any <span class="docutils literal"><span class="pre">IEngine</span></span>. We provide an
out-of-the-box <span class="docutils literal"><span class="pre">V8Engine</span></span> but other engines can be injected when <span class="docutils literal"><span class="pre">Car</span></span> gets
constructed. The headers IEngine.h and ICar.h are public per our above
defintion.</p>
<p>In general, it’s great if we can get the rest of the component code and unit
tests to work against the interface. Sometimes though we might need to know more
about the actual implementation inside our component, even if externally we only
expose an interface. In that case, we can add an internal Car.h header:</p>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em> becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can include the internal header, and, while not necessarily recommended,
we can cast <span class="docutils literal"><span class="pre">ICar</span></span> to <span class="docutils literal"><span class="pre">Car</span></span> inside the component:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">icar</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">MakeV8Engine</span><span class="p">());</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">car</span><span class="p">);</span>
</pre></div>
</div>
<p>Another trick if needing access to internals (again, not something necessarily
recommended), is to make the unit test class testing <span class="docutils literal"><span class="pre">Car</span></span> a friend of the
<span class="docutils literal"><span class="pre">Car</span></span> class, in which case it can access its private members.</p>
<p>In summary, with this approach we are able to:</p>
<ul class="simple">
<li>Hide implementation details in the .cpp files</li>
<li>Work against abstract interfaces</li>
<li>Inject dependencies during object construction</li>
</ul>
</div>
<div class="section" id="dependecy-injection-with-templates">
<h2>Dependecy Injection with Templates</h2>
<p>An alternative to the above is to use templates. In this case, we would have to
provide the implementation inside the header file, as code needs to be available
when templates get instantiated:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note <span class="docutils literal"><span class="pre">Car</span></span> is implemented in the header and <span class="docutils literal"><span class="pre">V8Engine</span></span> is also a publicly
visible header. Now we can create an instance of <span class="docutils literal"><span class="pre">Car</span></span> like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="p">...</span>

<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
</pre></div>
</div>
<p>Mocking the engine in test code would look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach we are able to:</p>
<ul class="simple">
<li>Inject dependencies during template instantiation</li>
<li>No need for virtual calls (note <span class="docutils literal"><span class="pre">TEngine</span></span> is not an interface, so calls can
be resolved at compile-time)</li>
<li><span class="docutils literal"><span class="pre">Car&lt;T&gt;</span></span> can be default-constructed</li>
</ul>
<p>A drawback here is we expose the implementation details of <span class="docutils literal"><span class="pre">Car</span></span> inside the
header file and we have to make this publicly visible.</p>
</div>
<div class="section" id="hybrid-approach">
<h2>Hybrid Approach</h2>
<p>We can use a hybrid approach if we don’t need an externally injected <span class="docutils literal"><span class="pre">Engine</span></span>.
Say our component provides a <span class="docutils literal"><span class="pre">V8Engine</span></span>, a <span class="docutils literal"><span class="pre">V6Engine</span></span>, and we have a
<span class="docutils literal"><span class="pre">MockEngine</span></span> used during testing. We have the same componentization
requirements but don’t need to expose all the details to consumers. In that case
we could have something like this:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="n">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
</pre></div>
</div>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"V6Engine.h"</span><span class="cp"/>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V6Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would remain the same as in the example above, where we worked against a
<span class="docutils literal"><span class="pre">Car</span></span> type (not an <span class="docutils literal"><span class="pre">ICar</span></span>) which we instantiate with a <span class="docutils literal"><span class="pre">MockEngine</span></span>.</p>
<p>With this approach:</p>
<ul class="simple">
<li>Our external API is an interface</li>
<li>Internally we still inject the dependency using a template</li>
</ul>
<p>With this approach, we do have an interface and virtual calls for <span class="docutils literal"><span class="pre">Car</span></span> but
not for <span class="docutils literal"><span class="pre">TEngine</span></span> types. One drawback with this approach is that consumers
cannot inject their own Engine type: we can only create cars with engines that
are known within our component.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We decoupled <span class="docutils literal"><span class="pre">Car</span></span> from <span class="docutils literal"><span class="pre">V8Engine</span></span> and looked at three ways of injecting
the dependency:</p>
<ul class="simple">
<li>Using interfaces, where dependency is injected at runtime during object
creation</li>
<li>Using templates, where dependency is injected at compile-time during template
instantiation</li>
<li>A hybrid approach which uses templates internally but exposes only interfaces
publicly</li>
</ul>
<p>Each of these approaches has pros and cons, the tradeoffs mostly being around
encapsulation (how much of the component code we expose publicly), runtime
(templates are instantiated at compile-time so no virtual calls etc.), type
constraints (with templates we don’t require engines to implement a particular
<span class="docutils literal"><span class="pre">IEngine</span></span> interface), and flexibility (with the hybrid approach we can’t
inject an external engine, we can only use what the component has available
internally).</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For more details on <span class="docutils literal"><span class="pre">novtable</span></span>, see <a class="reference external" href="https://msdn.microsoft.com/en-us/library/k13k85ky.aspx">MSDN</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Wed, 06 Jul 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/04/24/abusing-maps.html</link>
            <guid>http://vladris.com/blog/2016/04/24/abusing-maps.html</guid>
            <title><![CDATA[(Ab)using Maps]]></title>
            <description><![CDATA[<h1>(Ab)using Maps</h1>
<div class="section" id="mapping-pattern">
<h2>Mapping pattern</h2>
<p>Using hash maps (or dictionaries, or lookups) is a very natural way of coding in
some languages, especially dynamic languages, where usually an object can be
treated as a map itself, to which attributes and methods can be added or removed
at runtime.</p>
<p>In practice though, maps are often used to convert a value of one type into a
value of a different type. It is not uncommon to have very small maps like</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>Here it is useful to make a distinction between the pattern and the data
structure. The coding pattern itself is great - mapping a value from a type to
a value of another type should definitely be declarative. Below is a
counterexample of non-declarative mapping:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">Bar</span> <span class="nf">barFromFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar3</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is really ugly. As I mentioned in <a class="reference internal" href="http://vladris.com/blog/2016/01/04/clean-code-part-1.html#clean-code-1"><span class="std std-ref">Clean Code - Part 1</span></a>, branching should be
avoided whenever possible, and this is a good opportunity to use a declarative
approach as opposed to a bunch of branching logic. That being said, while the
mapping pattern is great, in C++ the data structure most developers default to
is not the optimal one for this.</p>
</div>
<div class="section" id="the-problem-with-unordered-map">
<h2>The problem with unordered_map</h2>
<p>If you are coding in C++, odds are you care a little bit about the runtime
footprint of your code. In that case, you might be surprised to learn that,
while an <span class="docutils literal"><span class="pre">unordered_map</span></span> in C++ (or a lookup or hash map or dictionary in any
other language) has an average lookup cost of <span class="docutils literal"><span class="pre">O(1)</span></span>, there are better ways to
implement the above pattern.</p>
<p>A map in C++ is implemented as a red-black tree containing buckets of hashed
values. Calling <span class="docutils literal"><span class="pre">at()</span></span> on a map implies the given key has to be hashed and
the tree traversed to find the value. Calling <span class="docutils literal"><span class="pre">[]</span></span> on an inexistent key will
add it to the data structure, which might trigger a rebalancing of the tree.
There is a lot of work happening under the hood, and while this makes sense for
an <span class="docutils literal"><span class="pre">unordered_map</span></span> of arbitrarily large size, for small lookups it is a lot
of overhead.</p>
</div>
<div class="section" id="alternatives">
<h2>Alternatives</h2>
<p>An alternative to <span class="docutils literal"><span class="pre">unordered_map</span></span> provided by the boost library is
<span class="docutils literal"><span class="pre">flat_map</span></span> <a class="footnote-reference" href="#id3" id="id1">[1]</a>. This has similar semantics to an <span class="docutils literal"><span class="pre">unordered_map</span></span>, but the
key-values are stored in a contiguous data structure so traversing it is more
efficient than walking a tree.</p>
<p>In general, there are a couple of approaches for keeping a hash map in a linear
data structure:</p>
<ul class="simple">
<li>The keys can be kept sorted, which has <span class="docutils literal"><span class="pre">O(N)</span></span> worst case insertion since it
might require all elements to be moved to fit a new one and <span class="docutils literal"><span class="pre">O(logN)</span></span> lookup
(binary search)</li>
<li>The keys can be kept unsorted, which has <span class="docutils literal"><span class="pre">O(1)</span></span> insertion (simple append) but
<span class="docutils literal"><span class="pre">O(N)</span></span> lookup (linear search)</li>
</ul>
<p>For very small-sized lookups, the cost of hashing itself might out-weight a
linear traversal, so for a small N</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>performs worse than</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
    <span class="n">fooBarMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span>
    <span class="n">fooBarMap</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
    <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">foo</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
<p>On my machine (using MSVC 2015 STL implementation), for an N of 5, <span class="docutils literal"><span class="pre">find_if</span></span>
on a vector is about twice as fast as the equivalent <span class="docutils literal"><span class="pre">unordered_map</span></span> lookup.</p>
</div>
<div class="section" id="initialization-cost">
<h2>Initialization cost</h2>
<p>There’s event more hidden cost: <span class="docutils literal"><span class="pre">std::vector</span></span> manages a dynamic array which is
allocated on the heap. Having an <span class="docutils literal"><span class="pre">std::vector</span></span> initialized with key-values as
described above, even if more efficent than an <span class="docutils literal"><span class="pre">unordered_map</span></span>, still has
some associated cost in terms of heap allocations (albeit smaller than
<span class="docutils literal"><span class="pre">unordered_map</span></span>). <span class="docutils literal"><span class="pre">std::array</span></span> is a much better suited container for cases
when the key-values are known at compile time, as <span class="docutils literal"><span class="pre">std::array</span></span> simply wraps a
regular array which is not allocated on the heap. So a more efficient (in terms
of initialization cost) way of declaring such a look up is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">arrray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>We can still apply the <span class="docutils literal"><span class="pre">std::find_if</span></span> algorithm on this array, but we skip a
heap allocation. Depending on the template types used, we might be able to skip
any allocations whatsoever (if both types are trivial <a class="footnote-reference" href="#id4" id="id2">[2]</a>). For example, note
that <span class="docutils literal"><span class="pre">std::string</span></span>, similarly to a vector, wraps a heap-allocated <span class="docutils literal"><span class="pre">char*</span></span>
and constructing it requires heap allocations. <span class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></span> to a string
literal on the other hand is just a pointer to the <span class="docutils literal"><span class="pre">.rodata</span></span> segment. So this</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="s">"foo1"</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo2"</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo3"</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>performs three heap allocations (for <span class="docutils literal"><span class="pre">"foo1"</span></span>, <span class="docutils literal"><span class="pre">"foo2"</span></span>, and <span class="docutils literal"><span class="pre">"foo3"</span></span>),
while the (mostly) equivalent</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="s">"foo1"</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo2"</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo3"</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>shouldn’t perform any allocations.</p>
</div>
<div class="section" id="associative-array">
<h2>associative_array</h2>
<p>Since in practice maps are often used to implement the above described pattern
of mapping a value from one type to a value of a different type for a small
set of known values, it would be great to combine the efficiency of an array
with the nice lookup semantics of an <span class="docutils literal"><span class="pre">unordered_map</span></span> conatiner.</p>
<p>I propose a generic container of the following shape:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">TKey</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">KeyEqual</span> <span class="o">=</span> <span class="n">key_equal</span><span class="o">&lt;</span><span class="n">TKey</span><span class="o">&gt;&gt;</span>
<span class="k">struct</span> <span class="n">associative_array</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">m_array</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">keq_equal</span></span> should simply resolve to <span class="docutils literal"><span class="pre">==</span></span> for most types, but be
specialized for strings types (to use <span class="docutils literal"><span class="pre">strcmp</span></span>, <span class="docutils literal"><span class="pre">wcscmp</span></span> etc.) and allow
clients to specialize their own <span class="docutils literal"><span class="pre">key_equal</span></span> when needed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">key_equal</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">key_equal</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="c1">// specializations for wchar_t and const variations of the above</span>
</pre></div>
</div>
<p>Satisfying the container concept is fairly easy (eg. <span class="docutils literal"><span class="pre">size()</span></span> would return
<span class="docutils literal"><span class="pre">N</span></span>, iterators over the member array are trivial to implement etc.), the only
interesting methods are <span class="docutils literal"><span class="pre">find()</span></span>, <span class="docutils literal"><span class="pre">at()</span></span>, and <span class="docutils literal"><span class="pre">operator[]</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="p">...</span>
<span class="k">struct</span> <span class="n">associative_array</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
            <span class="n">begin</span><span class="p">(),</span>
            <span class="n">end</span><span class="p">(),</span>
            <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">KeyEqual</span><span class="p">{}(</span><span class="n">key</span><span class="p">,</span> <span class="n">elem</span><span class="p">.</span><span class="n">first</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">end</span><span class="p">())</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"..."</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">find()</span></span> wraps <span class="docutils literal"><span class="pre">std::find_if</span></span> leveraging <span class="docutils literal"><span class="pre">KeyEqual</span></span> (with default
implementation as <span class="docutils literal"><span class="pre">key_equal</span></span>), <span class="docutils literal"><span class="pre">at()</span></span> wraps a bounds-checked <span class="docutils literal"><span class="pre">find</span></span>,
while <span class="docutils literal"><span class="pre">operator[]</span></span> does not check bounds. <span class="docutils literal"><span class="pre">const</span></span> implementations of the
above are also needed (identical except returning <span class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></span>).</p>
<p>Such a container would have similar semantics to <span class="docutils literal"><span class="pre">std::unordered_map</span></span> (minus
the ability to add elements given a key not already present in the container)
and the same performance profile of <span class="docutils literal"><span class="pre">std::array</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">associative_array</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>Note the only syntax difference between above and <span class="docutils literal"><span class="pre">unordered_map</span></span> is the
container type, the extra size <span class="docutils literal"><span class="pre">N</span></span> which needs to be specified at
declaration time, and an extra pair of curly braces. In practice, this should
have a significantly better lookup time than an unordered_map for a small N
(linear time, but since N is small and no hashing or heap traversal occurs,
should clock better than a map lookup) and virtually zero initialization time
- depending on the <span class="docutils literal"><span class="pre">TKey</span></span> and <span class="docutils literal"><span class="pre">T</span></span> types used, it is possible to declare
an <span class="docutils literal"><span class="pre">associative_array</span></span> as a <span class="docutils literal"><span class="pre">constexpr</span></span> fully evaluated at compile-time.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Boost <span class="docutils literal"><span class="pre">flat_map</span></span> documentation is <a class="reference external" href="http://www.boost.org/doc/libs/1_56_0/doc/html/boost/container/flat_map.html">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>For more details on trivial types, see the <a class="reference external" href="http://www.cplusplus.com/reference/type_traits/is_trivial/">is_trivial type trait</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sun, 24 Apr 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/03/11/arguments-and-smart-pointers.html</link>
            <guid>http://vladris.com/blog/2016/03/11/arguments-and-smart-pointers.html</guid>
            <title><![CDATA[Arguments and Smart Pointers]]></title>
            <description><![CDATA[<h1>Arguments and Smart Pointers</h1>
<p>For efficiency reasons, C++ had a myriad of ways to pass data around. A
function can take arguments in several forms:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>
</div>
<p>No to mention adding <span class="docutils literal"><span class="pre">const</span></span> and smart pointers into the mix.</p>
<p>And speaking of pointers, we have raw pointers, <span class="docutils literal"><span class="pre">unique_ptr</span></span>, <span class="docutils literal"><span class="pre">shared_ptr,</span></span>
<span class="docutils literal"><span class="pre">CComPtr</span></span>/<span class="docutils literal"><span class="pre">ComPtr</span></span> (for Windows COM objects), and, if you are working in
older codebases, <span class="docutils literal"><span class="pre">auto_ptr</span></span>, and maybe even some homebrewed refcounted
pointers.</p>
<p>All of this might seem a bit daunting and make C++ seem more complicated than
it really is. One way to think about it is from the ownership perspective:
objects are resources and the key question is “who owns this resource?”. This
should dictate both how a particular resource is allocated (and released) and
the shape function arguments should take. Lifetime is also an important
consideration - a resource shouldn’t be released while other components expect
it to be available, but it should be released as soon as it is no longer
needed.</p>
<p>In this post I will try to cover the various ways in which resources can be
allocated, owned, and passed around.</p>
<div class="section" id="stack-objects-and-passing-arguments">
<h2>Stack Objects and Passing Arguments</h2>
<p>The simplest, clearest thing to do is allocate objects on the stack. A stack
object doesn’t involve any pointers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The variable <span class="docutils literal"><span class="pre">bar</span></span> of type <span class="docutils literal"><span class="pre">Bar</span></span> is created on the stack. Once the stack
frame is popped (once the function is done executing, either through a normal
return or due to an exception) the object goes away. This is the easiest, safest
thing to do. The only reasons we wouldn’t always do this are time and space
requirements: lifetime-wise, we might want to somehow use <span class="docutils literal"><span class="pre">bar</span></span> after
<span class="docutils literal"><span class="pre">foo()</span></span> returns - for example we might want to pass it around to some other
object that wants to use at a later time; in terms of space, stack memory is
more limited than the heap, so large objects are better kept on the heap to
avoid overflow.</p>
<div class="section" id="pass-by-value">
<h3>Pass by value</h3>
<p>One way to get around the lifetime requirement is to pass the object by value:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="n">Bar</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// hands bar off to some other object</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s assume for this example that <span class="docutils literal"><span class="pre">do_suff</span></span> takes the argument and sticks it
into some global object which will use it as some future time.</p>
<p>The above code will simply create a copy of the object, so whatever <span class="docutils literal"><span class="pre">do_suff</span></span>
gets won’t be the original resource which gets freed once the function returns,
rather a copy of it. Copying an object costs both run time and space, but if
neither are a big concern, this is a great, safe way of ensuring resources don’t
get released before we’re done with them.</p>
</div>
<div class="section" id="move">
<h3>Move</h3>
<p>C++11 introduces a cheaper way of achieving this, through move semantics:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;&amp;</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// hands bar off to some other object</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With move semantics, the resource is actually <em>moved</em> into the <span class="docutils literal"><span class="pre">do_suff</span></span>
function. Once this happens, the original object is left in an undefined state
and shouldn’t be used anymore. This approach is usually employed when we have a
sink argument - we <em>sink</em> <span class="docutils literal"><span class="pre">bar</span></span> to its final resting place somewhere and
<span class="docutils literal"><span class="pre">foo()</span></span> no longer cares about it after passing it down to <span class="docutils literal"><span class="pre">do_stuff</span></span>.</p>
<p>One thing to keep in mind is that <span class="docutils literal"><span class="pre">move</span></span> is not magic, so <span class="docutils literal"><span class="pre">Bar</span></span> needs to
declare a <a class="reference external" href="http://en.cppreference.com/w/cpp/language/move_constructor">move constructor</a>
in order for this to do what we expect it to do. If Bar doesn’t declare a move
constructor, the above becomes a simple copy <a class="footnote-reference" href="#id4" id="id1">[1]</a>.</p>
</div>
<div class="section" id="pass-by-reference">
<h3>Pass by reference</h3>
<p>On the flipside, when we care about the size, so that we don’t want to create a
copy of the object, but we aren’t worried about the lifetime - meaning the
object we pass to <span class="docutils literal"><span class="pre">do_stuff</span></span> won’t have to outlive the function call, we can
pass by reference:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// bar is only used within do_suff</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the <span class="docutils literal"><span class="pre">const</span></span> above - this means <span class="docutils literal"><span class="pre">do_suff</span></span> will use <span class="docutils literal"><span class="pre">bar</span></span> but won’t
modify it. By default, arguments should be marked as <span class="docutils literal"><span class="pre">const</span></span> unless the
function does indeed need to alter the object. Regardless of constness, in this
case we pass a reference to <span class="docutils literal"><span class="pre">bar</span></span> as an argument, which is very cheap (a
reference has the same size as a pointer). The only caveat is that <span class="docutils literal"><span class="pre">do_stuff</span></span>
should not pass this to some other object that outlives the function call (eg. a
global object which tries to use it later), because as soon as <span class="docutils literal"><span class="pre">foo</span></span> returns,
the reference becomes invalid.</p>
</div>
<div class="section" id="pass-by-pointer">
<h3>Pass by pointer</h3>
<p>A pointer argument would look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">*</span> <span class="n">bar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A good rule of thumb is to not do this. The difference between passing by
reference and by pointer in this case is that a pointer can be null, while a
reference can’t. So passing by pointer here automatically brings the need to
perform null checks to ensure bad things don’t happen. You would need to make a
very good argument to convince me during code review that using a pointer
instead of a reference is appropriate. Unless working against a legacy API which
can’t be changed, I highly discourage use of raw pointers.</p>
</div>
<div class="section" id="summary">
<h3>Summary</h3>
<p>In summary, when designing an API:</p>
<ol class="arabic simple">
<li>Take argument by value if copying it is not a concern</li>
<li>Take argument by <span class="docutils literal"><span class="pre">const&amp;</span></span> if it’s not a sink argument, meaning we don’t
need to refer to it passed the function call</li>
<li>Take argument by reference (<span class="docutils literal"><span class="pre">&amp;</span></span>) if 2) but the API needs to modify it</li>
<li>Take argument by <span class="docutils literal"><span class="pre">&amp;&amp;</span></span> if it’s a sink argument, the type has a move
constructor, and copying it is expensive</li>
<li>Don’t pass raw pointers around</li>
</ol>
</div>
</div>
<div class="section" id="heap-objects-and-smart-pointers">
<h2>Heap Objects and Smart Pointers</h2>
<p>In all of the examples above, <span class="docutils literal"><span class="pre">bar</span></span> was an object created on the stack. This
works great in some cases, but some objects are simply too big to fit on the
stack, or it doesn’t make sense for them to do so (if, for example, we want to
vary their size at runtime). In this case, we allocate the object on the heap
and keep a pointer to it.</p>
<p>Once we start working with heap objects, ownership becomes even more important:
unlike stack objects, which get automatically destroyed when their stack frame
gets popped, heap objects need to be explicitly deleted. This responsibility
should be with the <em>owner</em> of the object.</p>
<div class="section" id="unique-pointer">
<h3>Unique pointer</h3>
<p>A unique pointer (<span class="docutils literal"><span class="pre">std::unique_ptr</span></span>) is a wrapper around a raw pointer which
will automatically delete the heap object when it goes out of scope itself:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// ptrBar goes out of scope =&gt; heap object gets deleted</span>
</pre></div>
</div>
<p>The above call to <span class="docutils literal"><span class="pre">make_unique</span></span> allocates an instance of Bar on the heap and
wraps the pointer to it into the unique pointer <span class="docutils literal"><span class="pre">ptrBar</span></span>. Now <span class="docutils literal"><span class="pre">ptrBar</span></span>
<em>owns</em> the object and as soon as ptrBar goes out of scope, the heap object is
also deleted.</p>
<p>Unique pointers cannot be copied, so we can never accidentally have more than
one single <span class="docutils literal"><span class="pre">unique_ptr</span></span> pointing to the same heap object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar2</span> <span class="o">=</span> <span class="n">ptrBar</span><span class="p">;</span> <span class="c1">// Won't compile</span>
</pre></div>
</div>
<p>Of course, if we <em>really</em> want to, we can get the raw pointer out of <span class="docutils literal"><span class="pre">ptrBar</span></span>
using <span class="docutils literal"><span class="pre">get()</span></span> and we can initialize a <span class="docutils literal"><span class="pre">unique_ptr</span></span> from a raw pointer -</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Please don't do this</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar2</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
</div>
<p>but this is very bad - now both pointers think they have sole ownership of the
resource, and as soon as one goes out of scope, using the other one leads to
undefined behavior. In general, the same way there are very few good reasons to
use raw pointers, there are very few good reasons to call <span class="docutils literal"><span class="pre">get()</span></span> on a smart
pointer.</p>
</div>
<div class="section" id="shared-pointer">
<h3>Shared pointer</h3>
<p>Sometimes, we do need to have several pointers pointing to the same heap object.
In this case, we can use shared pointers. Shared pointers pointing to the same
heap object keep a common reference count. Whenever a new shared pointer is
created for that particular heap object, the reference count is incremented.
Whenever a shared pointer for that heap object goes out of scope, the reference
count is decremented. Once the last shared pointer goes out of scope, the heap
object is deleted.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="c1">// one pointer to a Bar object on the heap (ref count = 1)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptrBar2</span><span class="p">(</span><span class="n">ptrBar1</span><span class="p">);</span>
        <span class="c1">// second shared pointer (ref count = 2)</span>
    <span class="p">}</span>
    <span class="c1">// ptrBar2 goes out of scope (ref count = 1)</span>
<span class="p">}</span>
<span class="c1">// ptrBar1 goes out of scope (ref count = 0) =&gt; heap object is deleted</span>
</pre></div>
</div>
<p>Shared pointers incur a bit more overhead than unique pointers - reference
counting needs to be atomic to account for multi-threaded environments, which
comes with a runtime cost. The reference count itself also needs to be stored
somewhere, which is a small space cost. Unique pointers don’t have these time
and space costs since they don’t need to count references - there is always only
one pointer to the object.</p>
<p>Costs aside, shared pointers also don’t make the ownership clear - there are
several instances “owning” the heap resource at the same time, which can
potentially alter it and step on each other’s toes. In general, prefer unique
pointers to shared pointers whenever possible.</p>
</div>
<div class="section" id="raw-pointer">
<h3>Raw pointer</h3>
<p>Avoid using raw pointers. Raw pointers don’t express ownership, so they don’t
offer the same guarantees that a) the resource pointed to gets properly cleaned
up and b) the resource pointed to is still valid at a given time. This leads to
dereferencing invalid memory and double-deletes (trying to free the same heap
object multiple times), which means undefined behavior. Also, don’t mix smart
and raw pointers - the smart pointers will keep doing their job happily, with
the potential of making the raw pointers invalid.</p>
</div>
<div class="section" id="com-pointers">
<h3>COM pointers</h3>
<p>On Windows, COM uses a different reference counting mechanism: the base
<span class="docutils literal"><span class="pre">IUnknown</span></span> interface declares <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> methods, which
implementations are expected to use to keep track of the reference count.
<span class="docutils literal"><span class="pre">CComPtr</span></span> (in ATL) and <span class="docutils literal"><span class="pre">ComPtr</span></span> (in WRL) are the COM smart pointers. They
call <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> on the owned object, and the owned object is
supposed to delete itself once its reference count drops to 0. Note that COM
uses a slightly different mechanism than the standard library shared pointers -
instead of the smart pointer keeping track of the reference count in the control
block and deleting the object once the last reference goes away, COM objects are
expected to keep track of their reference count themselves through the
<span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> methods and self-delete when the last reference goes
away (through <span class="docutils literal"><span class="pre">Release</span></span> call). The COM smart pointers only need to call
<span class="docutils literal"><span class="pre">Release</span></span> when they go out of scope.</p>
<p>It’s not a good idea to have both standard library and COM pointers point to the
same object, as each might decide to delete the object at different times -
<span class="docutils literal"><span class="pre">shared_ptr</span></span> looks at the <span class="docutils literal"><span class="pre">shared_ptr</span></span> refcount while COM objects look at
their internal reference count. So a <span class="docutils literal"><span class="pre">shared_ptr</span></span> might decide to delete an
object while a <span class="docutils literal"><span class="pre">ComPtr</span></span> still expects it to be valid or vice-versa. In
general, when working with COM objects, use COM smart pointers.</p>
</div>
<div class="section" id="auto-ptr">
<h3>auto_ptr</h3>
<p><span class="docutils literal"><span class="pre">auto_ptr</span></span> is a deprecated smart pointer. Unless working with an old compiler
and standard library, use <span class="docutils literal"><span class="pre">unique_ptr</span></span> or <span class="docutils literal"><span class="pre">shared_ptr</span></span> instead.</p>
</div>
<div class="section" id="other-smart-pointers">
<h3>Other smart pointers</h3>
<p>Old code bases might have custom smart pointer implementations, for the simple
fact that automatic memory management is always a good idea, and there is C++
code that predates the introduction of smart pointers into the standard library.
When interoperating with legacy code, use whatever works, but when writing new
code, do prefer standard library smart pointers to homebrewed ones.</p>
</div>
<div class="section" id="id2">
<h3>Summary</h3>
<p>In summary, when creating objects:</p>
<ol class="arabic simple">
<li>Create them on the stack if feasible (note that standard library types
like <span class="docutils literal"><span class="pre">std::vector</span></span> and <span class="docutils literal"><span class="pre">std::string</span></span> internally keep their data on
the heap, but they fit perfectly well on the stack, so you don’t need to
create an <span class="docutils literal"><span class="pre">std::vector</span></span> on the heap just because you are planning to
store a lot of elements in it - the vector manages a heap array
internally already).</li>
<li>Use a <span class="docutils literal"><span class="pre">unique_ptr</span></span> when creating them on the heap, to make ownership
obvious.</li>
<li>Use a <span class="docutils literal"><span class="pre">shared_ptr</span></span> only when <span class="docutils literal"><span class="pre">unique_ptr</span></span> isn’t sufficient (review
your design first, might be a design issue).</li>
<li>Use COM smart pointers like <span class="docutils literal"><span class="pre">CComPtr</span></span> when dealing with COM.</li>
<li>Don’t use <span class="docutils literal"><span class="pre">auto_ptr</span></span> or other old constructs unless working with legacy
code/compiler.</li>
<li>Don’t use raw pointers.</li>
</ol>
</div>
</div>
<div class="section" id="passing-smart-pointers-as-arguments">
<h2>Passing Smart Pointers as Arguments</h2>
<p>We covered passing arguments and smart pointers. Now combining the two, how do
we pass heap objects as arguments? Turns out Herb Sutter has
<a class="reference external" href="http://bit.ly/227Na5c">a great post</a> on this exact topic on his blog. I can’t
hope to explain better than him, so go read his post. I will try to summarize:</p>
<div class="section" id="pass-by-reference-the-pointed-to-type">
<h3>Pass by reference the pointed-to type</h3>
<p>Rather than forcing callers to use <span class="docutils literal"><span class="pre">unique_ptr</span></span> or <span class="docutils literal"><span class="pre">shared_ptr</span></span> by
specifying the smart pointer type (which makes assumptions about ownership),
just ask for a reference to the pointed-to-type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">*</span><span class="n">ptrBar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Herb also mentions raw pointer to the underlying type if the argument can be
null, but as I mentioned above, I’d rather stick to references and discourage
use of raw pointers as a general rule of thumb.</p>
</div>
<div class="section" id="pass-smart-pointer-by-value">
<h3>Pass smart pointer by value</h3>
<p>Passing a <span class="docutils literal"><span class="pre">unique_ptr</span></span> by value implies a sink argument - since a
<span class="docutils literal"><span class="pre">unique_ptr</span></span> cannot be copied, it has to be <span class="docutils literal"><span class="pre">std::move</span></span>’d in. Interestingly,
Scott Meyers has <a class="reference external" href="http://bit.ly/1WgkvEh">a post</a> on his blog where he
disagrees with this and argues that arguments of move-only types should be
specified as <span class="docutils literal"><span class="pre">&amp;&amp;</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span> <span class="c1">// sink</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Passing a <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value implies the function wants to partake in the
ownership - in other words, will keep somewhere a reference to the object after
the function returns, but unlike the above <span class="docutils literal"><span class="pre">unique_ptr</span></span> example, it won’t have
exclusive ownership of the resource:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">);</span> <span class="c1">// copy-constructs another shared_ptr which shares ownership of the heap object</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pass-smart-pointer-by-reference">
<h3>Pass smart pointer by reference</h3>
<p>Only expect a smart pointer by non-const reference if the function is going to
modify the smart pointer itself (eg. by making it point to a different object).
In my experience, this is a rare occurrence.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Implies this function modifies the pointer itself.</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span>
</pre></div>
</div>
<p>There is no good reason to expect a <span class="docutils literal"><span class="pre">const&amp;</span></span> to a <span class="docutils literal"><span class="pre">unique_ptr</span></span>, just reference
the underlying type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// void do_stuff(const unique_ptr&lt;Bar&gt;&amp; ptrBar);</span>
<span class="c1">// No reason to use the above as opposed to</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>
</pre></div>
</div>
<p>Expect <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">shared_ptr</span></span> only if the function <em>might</em> create a copy
of the smart pointer. If the function would never create a copy of the pointer,
simply use <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type. If the function would always copy the
pointer, expect <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Might or might not share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span>

<span class="c1">// Will never share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>

<span class="c1">// Will always share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>Summary</h3>
<p>A summary of the summary:</p>
<ol class="arabic simple">
<li>Take argument by <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type if you only care about the heap
object, not about the pointer.</li>
<li>Take <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> by <span class="docutils literal"><span class="pre">&amp;&amp;</span></span> to transfer ownership.</li>
<li>Take <span class="docutils literal"><span class="pre">shared_ptr</span></span> argument by value to partake in ownership.</li>
<li>Take smart pointer by (non-const) reference only if you are going to
modify the smart pointer itself.</li>
<li>No need for <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">unique_ptr</span></span> (just take <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type)</li>
<li>Take <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">shared_ptr</span></span> only if unknown whether function wants
ownership (take by <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type if function never wants
ownership, <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value if function always wants ownership).</li>
</ol>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Move constructors can be implicitly declared by the compiler if certain
conditions are met, see <a class="reference external" href="http://en.cppreference.com/w/cpp/language/move_constructor#Implicitly-declared_move_constructor">here</a>
for details.</td></tr>
</tbody>
</table>
</div>
</div>
]]></description>
             <pubDate>Fri, 11 Mar 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/01/07/clean-code-part-2.html</link>
            <guid>http://vladris.com/blog/2016/01/07/clean-code-part-2.html</guid>
            <title><![CDATA[Clean Code - Part 2]]></title>
            <description><![CDATA[<h1>Clean Code - Part 2</h1>
<p>In <a class="reference external" href="http://vladris.com/blog/2016/01/04/clean-code-part-1">Part 1</a> I talked about writing less code and
writing simple code. In this post I will cover writing stateless code and
writing readable code.</p>
<div class="section" id="write-stateless-code">
<h2>Write Stateless Code</h2>
<blockquote>
<div><p>A <strong>pure function</strong> is a <strong>function</strong> where the return value is only
determined by its input values, without observable side effects. This is
how <strong>functions</strong> in math work: <span class="docutils literal"><span class="pre">Math.cos(x)</span></span> will, for the same value
of <span class="docutils literal"><span class="pre">x</span></span>, always return the same result.</p>
<p><em>Source:</em> <a class="reference external" href="http://www.sitepoint.com/functional-programming-pure-functions/">SitePoint</a></p>
</div></blockquote>
<p>Things break when a program gets into a “bad state”. There are a couple of ways
to make this less likely to happen: making data immutable and writing functions
that don’t have side-effects (<em>pure</em> functions).</p>
<div class="section" id="immutable-data">
<h3>Immutable data</h3>
<p>If something shouldn’t change, mark it as immutable and let the compiler enforce
that. A good rule of thumb is to mark things as <span class="docutils literal"><span class="pre">const</span></span> (<span class="docutils literal"><span class="pre">const&amp;</span></span>,
<span class="docutils literal"><span class="pre">const*</span></span> etc.) and/or <span class="docutils literal"><span class="pre">readonly</span></span> by default, and make them mutable only when
truly needed <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>A simple example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">StringUtil</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Both <span class="docutils literal"><span class="pre">StringUtil::Concat1</span></span> and <span class="docutils literal"><span class="pre">StringUtil::Concat2</span></span> return the same thing
for the same input, the difference being that <span class="docutils literal"><span class="pre">Concat2</span></span>, as opposed to
<span class="docutils literal"><span class="pre">Concat1</span></span>, modifies its first argument. In a bigger function, such a change
might be introduced accidentally and have unexpected consequences down the line.</p>
<p>A simple way to address this is by explicitly marking the arguments as
<span class="docutils literal"><span class="pre">const</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="n">StringUtil</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat1</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat2</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span> <span class="c1">// Won't compile - can't call append on str1</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this case, <span class="docutils literal"><span class="pre">Concat2</span></span> won’t compile, so we can rely on the compiler to
eliminate this type of unintended behavior.</p>
<p>Another example: a simple <span class="docutils literal"><span class="pre">UpCase</span></span> function which calls <span class="docutils literal"><span class="pre">toupper</span></span> on each
character of the given string, upcasing it in place:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">UpCase</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">);</span>
        <span class="n">string</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Calling it with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">char</span><span class="o">*</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">UpCase</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>
</pre></div>
</div>
<p>will lead to a crash at runtime - the function will try to call <span class="docutils literal"><span class="pre">toupper</span></span> on
the characters of <span class="docutils literal"><span class="pre">myString</span></span>. The problem is that <span class="docutils literal"><span class="pre">myString</span></span> is a <span class="docutils literal"><span class="pre">char*</span></span>
to a string literal which gets compiled into the read-only data segment of the
binary. This cannot be modified.</p>
<p>To catch this type of errors at compile-time, we again only need to mark the
immutable data as such:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">UpCase</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span> <span class="c1">// Won't compile - can't call UpCase on myString</span>
</pre></div>
</div>
<p>In contrast with the previous example, the argument to <span class="docutils literal"><span class="pre">UpCase</span></span> is mutable by
design (the API is modifying the string in-place), but marking <span class="docutils literal"><span class="pre">myString</span></span> as
<span class="docutils literal"><span class="pre">const</span></span> tells the complier this is non-mutable data, so it can’t be used with
this API.</p>
</div>
<div class="section" id="pure-functions">
<h3>Pure functions</h3>
<p>Another way to reduce states is to use pure functions. Unfortunately there isn’t
a lot of syntax-level support for this in C++ and C# (C++ supports <span class="docutils literal"><span class="pre">const</span></span>
member functions, which guarantee at compile time that calling the member
function on an instance of the type won’t change the attributes of that
instance) <a class="footnote-reference" href="#id6" id="id2">[2]</a></p>
<p>This goes back to the recommendation from Part 1 of using generic algorithms and
predicates rather than implementing raw loops. In many cases, traversal state is
encapsulated in the library algorithm or in an iterator, and predicates ideally
don’t have side-effects.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span>
                <span class="n">Where</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">).</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>Above code (also from Part 1) doesn’t hold any state: traversal is handled by
the Linq methods, the predicates are pure.</p>
<p>In general, try to encapsulate state in parts of the code built to manage state,
and keep the rest stateless. Note that immutable data and pure functions are
also an advantage in concurrent applications, since they can’t generate race
conditions.</p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Prefer pure functions to stateful functions and, if state is needed, keep it
contained</li>
<li>By default mark everything as <span class="docutils literal"><span class="pre">const</span></span> (or <span class="docutils literal"><span class="pre">readonly</span></span>), and only remove
the constraint when mutability is explicitly needed</li>
</ul>
</div>
</div>
<div class="section" id="write-readable-code">
<h2>Write Readable Code</h2>
<blockquote>
<div><p>In computer science, the <strong>expressive power</strong> (also called
<strong>expressiveness</strong> or expressivity) of a language is the breadth of ideas
that can be represented and communicated in that language […]</p>
<ul class="simple">
<li>regardless of ease (theoretical expressivity)</li>
<li><strong>concisely and readily</strong> (practical expressivity)</li>
</ul>
<p><em>Source:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Expressive_power_(computer_science)">Wikipedia</a></p>
</div></blockquote>
<p>Code is read many more times than it is written/modified, so it should be
optimized for readability. What I mean by this is making the intent of the code
clear at a glance - this includes giving good descriptive names to variables,
functions, and types, adding useful comments where appropriate (a comment should
describe what the code does if it is non-obvious; a comment like <span class="docutils literal"><span class="pre">foo();</span> <span class="pre">//</span> <span class="pre">calls</span> <span class="pre">foo()</span></span>
is not a useful comment), and in general structure the code for easy reading.</p>
<p>For a counterexample, think back on a piece of code you read that elicited a
WTF. That’s the kind of code you don’t want to write.</p>
<p>I won’t insist much here, since there are countless books and industry best
practices for improving code readability.</p>
<p>Another way to make the code more readable is to have a good knowledge of the
language you are using. The strength of a language lies in its particularities,
so use them whenever appropriate. This means writing <a class="reference external" href="http://stackoverflow.com/questions/84102/what-is-idiomatic-code">idiomatic code</a>,
which implies knowledge of the language idioms. Don’t write C++ code like C
code, write it like C++ code. Don’t write C# code as C++, write it as C# etc.</p>
<p>Also, keep up to date on the language. Language syntax evolves to address needs,
so in general modern syntax introduces simpler, better ways to implement things
than old syntax. Take object allocation and initialization in C++ as an example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span>
<span class="n">init</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">deinit</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the C way of allocating and initializing a structure on the heap, then
deinitializing and freeing it. Allocation and initialization are separate steps,
with opportunity to leak both memory (by omitting the <span class="docutils literal"><span class="pre">free</span></span> call) and
managed resources (by omitting the <span class="docutils literal"><span class="pre">deinit</span></span> call). Not to mention opportunity
to end up with an initialized struct (by omitting the <span class="docutils literal"><span class="pre">init</span></span> call), or
accidental double-initialization, double-deinitialization, double-free etc.</p>
<p>C++ introduced classes, and the following syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">...</span>
<span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">new</span></span> both allocates memory and calls the constructor, while <span class="docutils literal"><span class="pre">delete</span></span> calls
the destructor then releases the memory. Many of the problems in the C example
go away, but there is still the problem of leaking the resource by omitting the
<span class="docutils literal"><span class="pre">delete</span></span> call, and the issue of calling <span class="docutils literal"><span class="pre">delete</span></span> twice on the same memory
address.</p>
<p>To address these issues, smart pointers were introduced in the language:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">());</span>
</pre></div>
</div>
<p>Smart pointers encapsulate reference counting (how many <span class="docutils literal"><span class="pre">shared_ptr</span></span> objects
point to the same memory address), and automatically release the resource when
the last reference goes away. This gets rid of most problems, but there is an
even better way of allocating heap objects:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">make_shared</span></span> has the advantage of improved performance, by allocating memory
in a single operation for both the object and the shared pointer’s own control
block <a class="footnote-reference" href="#id7" id="id3">[3]</a>. It also prevents leaks due to interleaving <a class="footnote-reference" href="#id8" id="id4">[4]</a>. So as the C++
language evolved, new constructs appeared to address potential problems. Keeping
up to date with these updates, and incorporating them into your code will reduce
the opportunity for bugs, make the code more concise, and thus more readable.</p>
<div class="section" id="beautiful-code">
<h3>Beautiful Code</h3>
<p>I encourage you to not stop at writing <em>working</em> code, rather strive to write
<em>beautiful</em> code. I have the following quote from <a class="reference external" href="http://www.goodreads.com/book/show/5608045-apprenticeship-patterns">Apprenticeship Patterns</a>
on the wall behind my monitors, so I can see it while I work:</p>
<blockquote>
<div>There’s always a better/faster/smarter way to do what you’re currently doing</div></blockquote>
<p>So don’t stop as soon as something works, ask yourself <em>is this the best way to
implement this?</em></p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Come up with good names</li>
<li>Write meaningful comments</li>
<li>Keep up to date with your language</li>
<li>Don’t just write working code, write beautiful code.</li>
</ul>
</div>
</div>
<div class="section" id="epilogue">
<h2>Epilogue</h2>
<p>As I was working on putting together the talk that inspired this post, I
realized there are a few more rules of thumb which I could cover. The current
working draft is:</p>
<ul class="simple">
<li>Write safe code</li>
<li>Write leakproof code</li>
<li>Write responsive code</li>
<li>Write testable code</li>
</ul>
<p>Sometime in the future I hope to continue the series with the above, in the
meantime, I’ll leave you with this one sentence summary:</p>
<blockquote>
<div><p>Always code as if the person who ends up maintaining your code is a violent psychopath who
knows where you live</p>
<p><em>Source:</em> <a class="reference external" href="http://blog.codinghorror.com/coding-for-violent-psychopaths/">Coding Horror</a></p>
</div></blockquote>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>At the time of this writing, there is an <a class="reference external" href="https://github.com/dotnet/roslyn/issues/7626">active proposals</a>
to extend the C# language with an <span class="docutils literal"><span class="pre">immutable</span></span> keyword.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>C# has a <span class="docutils literal"><span class="pre">PureAttribue</span></span> in the <span class="docutils literal"><span class="pre">System.Diagnostics.Contracts</span></span>
namespace (purity not compiler-enforced) and there is an <a class="reference external" href="https://github.com/dotnet/roslyn/issues/7561">active proposal</a>
to add a keyword for it too.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>This is a non-binding requirement in the standard, meaning a standard
library implementation doesn’t <em>have to</em> do this, but most implementations
will. You can read more about it <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Interleaving occurs since call order is not guaranteed. For example, in
<span class="docutils literal"><span class="pre">bar(std::share_ptr&lt;Foo&gt;(new</span> <span class="pre">foo()),</span> <span class="pre">baz())</span></span>, there is no guarantee that
call order will be <span class="docutils literal"><span class="pre">new</span> <span class="pre">foo()</span></span>, then the shared pointer’s constructor, then
<span class="docutils literal"><span class="pre">baz()</span></span>. Calls might get interleaved and executed as <span class="docutils literal"><span class="pre">new</span> <span class="pre">foo()</span></span>, then
<span class="docutils literal"><span class="pre">baz()</span></span>, then the shared pointer constructor, in which case an exception
thrown by <span class="docutils literal"><span class="pre">baz()</span></span> would leak the newly allocated <span class="docutils literal"><span class="pre">Foo</span></span> object, since the
shared pointer didn’t get ownership of it yet.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Thu, 07 Jan 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/01/04/clean-code-part-1.html</link>
            <guid>http://vladris.com/blog/2016/01/04/clean-code-part-1.html</guid>
            <title><![CDATA[Clean Code - Part 1]]></title>
            <description><![CDATA[<span id="clean-code-1"/><h1>Clean Code - Part 1</h1>
<p>These posts are based on a Clean Code talk I did for my team a few months ago,
which, in turn, was inspired by the advice I gave to some of our summer
interns as four rules of thumb for writing cleaner code:</p>
<ul class="simple">
<li>Write less code</li>
<li>Write simple code</li>
<li>Write stateless code</li>
<li>Write readable code</li>
</ul>
<p>I will cover the first two points in this post and the remaining two in Part 2.
I’m talking about C++ and C# throughout, but most of this should be applicable
to any object-oriented or multi-paradigm language.</p>
<div class="section" id="write-less-code">
<h2>Write Less Code</h2>
<blockquote>
<div><p>The number of defects found in open source projects was 0.45 defects/1,000
lines of code, while the industry’s average is around 1 defect per 1,000
lines of code for companies not using automated testing such as static
analysis.</p>
<p><em>Source:</em> <a class="reference external" href="http://www.infoq.com/news/2012/03/Defects-Open-Source-Commercial">InfoQ</a></p>
</div></blockquote>
<p>A great way to have fewer bugs is to have fewer lines of code! What I mean by
this is that churning out many lines of code is by no means a measure of
productivity yet, unfortunately, most developers still feel great when, at the
end of the day, we wrote <em>insert high number</em> LoC.</p>
<div class="section" id="how-to-write-less-code">
<h3>How to write less code?</h3>
<p>Two points to keep in mind: first, don’t reinvent the wheel - don’t write code
if there is an existing library, internal to your company or open-source, that
already does what needs to be done. Case in point, we refactored some code for
a project (C#), extracted some interfaces, componentized things, and wrote a
bunch of unit tests. All of this was great, except we ended up with a bunch of
handcrafted stub classes: for</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IMyComponent</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Foo</span><span class="p">();</span>
    <span class="kt">int</span> <span class="nf">Bar</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">Baz</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>we had</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">MyComponentStub</span> <span class="p">:</span> <span class="n">IMyComponent</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Baz</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">myComponentStub</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyComponentStub</span><span class="p">();</span>
</pre></div>
</div>
<p>and so on. Implementing these stubs was tedious, needless work - we integrated
<a class="reference external" href="https://github.com/Moq/moq4">Moq</a> , a mocking library, and the above code
turned into:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">using</span> <span class="nn">Moq</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">myComponentStub</span> <span class="p">=</span> <span class="n">Mock</span><span class="p">.</span><span class="n">Of</span><span class="p">&lt;</span><span class="n">IMyComponent</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Moq uses reflection to stub out interfaces at run-time, so simply adopting the
library helped us get rid of a lot of code.</p>
<p>The second way to write less code is to know the standard library of your
language of choice. Many times, a block of code can be replaced with a simple
library call. For C++, pay particular attention to the STL <span class="docutils literal"><span class="pre">&lt;algorithm&gt;</span></span> header
and for C#, <span class="docutils literal"><span class="pre">System.Linq</span></span>. Both contain many of useful algorithms which can
replace a lot of code.</p>
<p>I also recommend watching Sean Parent’s <a class="reference external" href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">C++ Seasoning</a>
talk, one of the best tech talks I’ve seen. The example he gives in the talk
(from the Chrome codebase) shows how a couple of lines of STL code can be used
instead of a whole convoluted function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="n">PanelBar</span><span class="o">::</span><span class="n">RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span>

  <span class="c1">// First, find the index of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span> <span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Next, check if the panel has moved to the other side of another panel.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">center_x</span> <span class="o">=</span> <span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">center_x</span> <span class="o">&lt;=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span> <span class="o">||</span>
        <span class="n">i</span> <span class="o">==</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">panel</span> <span class="o">!=</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If it has, then we reorder the panels.</span>
        <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">];</span>
        <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Find the total width of the panels to the left of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">total_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fixed_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span> <span class="o">==</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">total_width</span> <span class="o">+=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">new_fixed_index</span> <span class="o">=</span> <span class="n">fixed_index</span><span class="p">;</span>

  <span class="c1">// Move panels over to the right of the fixed panel until all of the ones</span>
  <span class="c1">// on the left will fit.</span>
  <span class="kt">int</span> <span class="n">avail_width</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">&gt;</span> <span class="n">avail_width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_fixed_index</span><span class="o">--</span><span class="p">;</span>
    <span class="n">CHECK_GE</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">total_width</span> <span class="o">-=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Reorder the fixed panel if its index changed.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_fixed_index</span> <span class="o">!=</span> <span class="n">fixed_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
    <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
    <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">new_fixed_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Now find the width of the panels to the right, and move them to the</span>
  <span class="c1">// left as needed.</span>
  <span class="n">total_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">total_width</span> <span class="o">+=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">avail_width</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">&gt;</span> <span class="n">avail_width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_fixed_index</span><span class="o">++</span><span class="p">;</span>
    <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">total_width</span> <span class="o">-=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Do the reordering again.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_fixed_index</span> <span class="o">!=</span> <span class="n">fixed_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
    <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
    <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">new_fixed_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Finally, push panels to the left and the right so they don't overlap.</span>
  <span class="kt">int</span> <span class="n">boundary</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">reverse_iterator</span> <span class="n">it</span> <span class="o">=</span>
       <span class="c1">// Start at the panel to the left of 'new_fixed_index'.</span>
       <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">new_fixed_index</span><span class="p">);</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">),</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">boundary</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span>
                  <span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">),</span>
                  <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="n">PanelBar</span><span class="o">::</span><span class="n">RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span>

  <span class="c1">// First, find the index of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span> <span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Next, check if the panel has moved to the left side of another panel.</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">)</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">),</span> <span class="n">f</span><span class="p">,</span> <span class="n">center_x</span><span class="p">,</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

  <span class="c1">// If it has, then we reorder the panels.</span>
  <span class="n">rotate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Code snippets borrowed from Sean Parent’s slides, I highly recommend watching the
whole talk.</p>
<p>The key takeaway here is that there could be a standard library implementation or
an external module that can greatly simplify your work and it’s a good practice
to always ask yourself <em>“do I really need to write this?”</em></p>
</div>
</div>
<div class="section" id="write-simple-code">
<h2>Write Simple Code</h2>
<p>First, a few notes on cyclomatic complexity from Wikipedia:</p>
<blockquote>
<div><p>Cyclomatic complexity is a software metric (measurement), used to indicate
the complexity of a program. It is a quantitative measure of the number of
linearly independent paths through a program’s source code.</p>
<dl class="docutils">
<dt>The complexity M is then defined as</dt>
<dd><em>M = E − N + 2P</em></dd>
<dt>where</dt>
<dd><em>E = the number of edges of the graph, N = the number of nodes of the
graph, P = the number of connected components.</em></dd>
</dl>
<div align="center" class="align-center"><img alt="../../../_images/cyclomatic_complexity.svg" src="http://vladris.com/blog/_images/cyclomatic_complexity.svg"/></div>
<p>A control flow graph of a simple program. The program begins executing at
the red node, then enters a loop (group of three nodes immediately below
the red node). On exiting the loop, there is a conditional statement (group
below the loop), and finally the program exits at the blue node. This graph
has 9 edges, 8 nodes, and 1 connected component, so the cyclomatic
complexity of the program is 9 - 8 + 2 * 1 = 3.</p>
<p><em>Source:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Wikipedia</a></p>
</div></blockquote>
<p>The cyclomatic complexity of any piece of code should be minimized. This can be
achieved by avoiding branching, namely, whenever possible, avoiding conditional
statements and loops. Linear code is easier to read and maintain, and provides
less opportunities for bugs.</p>
<div class="section" id="avoiding-conditional-statements">
<h3>Avoiding conditional statements</h3>
<p>One way to avoid conditional statements is to, whenever feasible, throw
exceptions instead of propagating errors through return values.</p>
<p>Here is an example of error code propagation through return values using the
Windows API’s <span class="docutils literal"><span class="pre">HRESULT</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">HRESULT</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">// Does some work and returns an HRESULT</span>
<span class="n">HRESULT</span> <span class="nf">bar</span><span class="p">();</span> <span class="c1">// Does some work and returns an HRESULT</span>

<span class="n">HRESULT</span> <span class="nf">baz</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">S_OK</span><span class="p">;</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="n">baz</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>

    <span class="p">...</span> <span class="c1">// Some more work here which might fail</span>

    <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">baz</span><span class="p">()))</span>
<span class="p">{</span>
    <span class="c1">// :)</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// :(</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This can be replaced with the more concise and much easier to read:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">// Does some work, might throw</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">();</span> <span class="c1">// Does some work, might throw</span>

<span class="kt">void</span> <span class="nf">baz</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
    <span class="n">baz</span><span class="p">();</span>

    <span class="p">...</span> <span class="c1">// Some more work here which might fail (and throw)</span>
<span class="p">}</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">baz</span><span class="p">();</span>
    <span class="c1">// :)</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span>
    <span class="c1">// :(</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Error code return values come from the old days when exceptions didn’t exist
and make code harder to read. That being said, for C++ specifically, you
should be careful about throwing exceptions across DLL boundaries. In practice
though, a lot of code in the shape of the above example appears within the
same executable for no good reason. If cross-DLL boundary is a problem, I would
actually recommend using exceptions internally and switching to return codes at
the public API boundary.</p>
<p>Another way to avoid conditional statements is to use the <a class="reference external" href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null Object pattern</a>
instead of checking for null. For example, take an <span class="docutils literal"><span class="pre">IActivity</span></span> interface on
which we can log success or failure, and an <span class="docutils literal"><span class="pre">ActivityScope</span></span> which can retrieve
the current activity from a context:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IActivity</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">LogSuccess</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">LogFailure</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActivityScope</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IActivity</span> <span class="nf">GetCurrentActivity</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this implementation, all clients of the API have to make sure <span class="docutils literal"><span class="pre">GetCurrentActivity()</span></span>
returns an object as opposed to null. All callers look like this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">ActivityScope</span> <span class="n">activityScope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ActivityScope</span><span class="p">();</span>
<span class="n">activityScope</span><span class="p">.</span><span class="n">CreateActivity</span><span class="p">();</span>

<span class="p">...</span> <span class="c1">// Do a bunch of stuff</span>

<span class="kt">var</span> <span class="n">activity</span> <span class="p">=</span> <span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">activity</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">activity</span><span class="p">.</span><span class="n">LogSuccess</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While there is a single <span class="docutils literal"><span class="pre">ActivityScope</span></span> implementation, there are hundreds of
calls to <span class="docutils literal"><span class="pre">GetCurrentActivity</span></span>, all coming with a boilerplate null check. The
Null Object alternative for this is to provide a <span class="docutils literal"><span class="pre">NullActivity</span></span>, for which
<span class="docutils literal"><span class="pre">LogSuccess</span></span> and <span class="docutils literal"><span class="pre">LogFailure</span></span> don’t do anything. <span class="docutils literal"><span class="pre">ActivityScope</span></span> can return
<span class="docutils literal"><span class="pre">NullActivity</span></span> instead of null if there is no <span class="docutils literal"><span class="pre">Activity</span></span> in the context:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">NullActivity</span> <span class="p">:</span> <span class="n">IActivity</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LogSuccess</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LogFailure</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActivityScope</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">NullActivity</span> <span class="n">_nullActivity</span> <span class="p">=</span> <span class="k">new</span> <span class="n">NullActivity</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">IActivity</span> <span class="nf">GetCurrentActivity</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_nullActivity</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now callers don’t need to worry about getting back a null, and can use the API
like this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">().</span><span class="n">LogSuccess</span><span class="p">();</span>
</pre></div>
</div>
<p>Yet another way to reduce branching is when it used for mapping between two types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="p">=</span> <span class="s">"Foo string"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="p">=</span> <span class="s">"Bar string"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">...</span>
</pre></div>
</div>
<p>A pattern like this (which can also take the form of a big switch/case statement)
can usually be replaced with indexing into an array or looking up the
corresponding value in a hash map:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">IdTypeToStringMap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">,</span> <span class="s">"Foo"</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">,</span> <span class="s">"Bar"</span> <span class="p">},</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="n">b</span> <span class="p">=</span> <span class="n">IdTypeToStringMap</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
</pre></div>
</div>
<p>This is, again, easier to maintain, since it is declarative - the mapping is given as
data (<span class="docutils literal"><span class="pre">IdTypeToStringMap</span></span>), not as code (long series of if/else).</p>
</div>
<div class="section" id="avoid-loops">
<h3>Avoid loops</h3>
<p>This goes back to the C++ Seasoning talk, namely the <em>No Raw Loops</em> guideline. Here’s
a C# example: given a list of numbers, we want to get the square of all the odd
numbers in the list.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="m">6</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">8</span> <span class="p">};</span>

<span class="c1">// Get the squares of all odd numbers</span>
</pre></div>
</div>
<p>One way to do this is to maintain a list of numbers, iterate over the list, check
if numbers are odd, and if so, square them and add them to the list:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">squares</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">squares</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
</pre></div>
</div>
<p>A neater way to do this is to use a generator instead of manually maintaining
the list of squares:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
</pre></div>
</div>
<p>That being said, what I would actually recommend is using Linq:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span>
                <span class="n">Where</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">).</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>Fewer lines of code and no branching whatsoever <a class="footnote-reference" href="#id2" id="id1">[*]</a>. <span class="docutils literal"><span class="pre">Where</span></span> and <span class="docutils literal"><span class="pre">Select</span></span>
are generic algorithms, and their arguments are the predicates we use. This makes
the intent of the code clear at a glance - we are filtering the collection with
a predicate (<span class="docutils literal"><span class="pre">number</span> <span class="pre">=&gt;</span> <span class="pre">number</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">!=</span> <span class="pre">0</span></span>) and applying a transformation to it
with another predicate (<span class="docutils literal"><span class="pre">number</span> <span class="pre">=&gt;</span> <span class="pre">number</span> <span class="pre">*</span> <span class="pre">number</span></span>). Also, the filtering and
transformation are library functions, so we can be fairly certain they work
well, and only need to worry about maintaining our predicates.</p>
<p>It might not look like a big deal in this simple made-up example, but as code
evolves, it becomes harder and harder to follow the iteration logic, as the
code gets littered with <span class="docutils literal"><span class="pre">break</span></span>, <span class="docutils literal"><span class="pre">continue</span></span>, and <span class="docutils literal"><span class="pre">return</span></span> statements (see
the Chrome example quoted in the Write Less Code section).</p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Try to keep functions linear (or as linear as possible)</li>
<li>Default to throwing instead of propagating errors up the call stack</li>
<li>Consider creating a null object when code is littered with null checks</li>
<li>Separate algorithm logic from predicates to make the intent of the code clear (in other words, no raw loops).</li>
</ul>
</div>
</div>
<div class="section" id="notes-on-performance">
<h2>Notes on performance</h2>
<p>The most interesting question I was asked is what are the performance
implications of using an STL algorithm or Linq.</p>
<p>The default answer is, of course, you have to measure for your particular case!
Blanket statements cannot be made about performance, as there are many factors
involved: compiler, runtime, standard library, OS, architecture, whether code is
on a hot path or not, and so on and so forth.</p>
<p>Still, my recommendation is to use the library algorithms and, only if they
become the bottleneck (which in most cases shouldn’t happen), look into replacing
them with handcrafted code. Another thing to keep in mind is that standard
library authors know what they’re doing, so it’s very likely that library code is
already pretty well optimized. I ran a simple wall clock benchmark for 1M
iterations for some of the examples I used throughout the presentation (both the
handcrafted and the library versions), and in all cases the code leveraging
library functions ran slightly faster.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[*]</a></td><td>Cyclomatic complexity of this is actually higher when computed by looking
at basic blocks (eg. from Visual Studio’s <span class="docutils literal"><span class="pre">Analyze</span></span> menu), since the compiler
will automatically add a finally block to dispose of the Linq-returned
IEnumerables in case of exception. That being said, I prefer
compiler-generated complexity to developer-generated complexity.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Mon, 04 Jan 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2015/12/28/hello-world.html</link>
            <guid>http://vladris.com/blog/2015/12/28/hello-world.html</guid>
            <title><![CDATA[Hello World]]></title>
            <description><![CDATA[<h1>Hello World</h1>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="s2">"Hello World!"</span><span class="p">)</span>
</pre></div>
</div>
]]></description>
             <pubDate>Mon, 28 Dec 2015 00:00:00 -0800</pubDate>
        </item>
    
    </channel>
</rss>
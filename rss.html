<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Blog</title>
        <link>http://vladris.com/blog/</link>
        <description></description>
        <language>en-us</language>
        <pubDate>Mon, 21 Jun 2021 00:00:00 -0700</pubDate>
        
        <item>
            <link>http://vladris.com/blog/2021/06/21/data-engineering-on-azure-rtm.html</link>
            <guid>http://vladris.com/blog/2021/06/21/data-engineering-on-azure-rtm.html</guid>
            <title><![CDATA[Data Engineering on Azure RTM]]></title>
            <description><![CDATA[<h1>Data Engineering on Azure RTM</h1>
<p>My book, <a class="reference external" href="https://www.manning.com/books/data-engineering-on-azure">Data Engineering on Azure</a>,
which I announced in <a class="reference external" href="https://vladris.com/blog/2020/10/08/azure-data-engineering.html">this blog post</a>,
is going to print soon. As I did with my previous book, <a class="reference external" href="https://vladris.com/blog/2019/10/16/programming-with-types-rtm.html">Programming with Types</a>,
I’m writing another “RTM” post to talk about a few aspects of the process.</p>
<div class="section" id="title-evolution">
<h2>Title evolution</h2>
<p>When I pitched the book to Manning, I used the title <em>Production Data Engineering
with Azure</em>. The title was supposed to capture that this is a book about the
practical aspects of data engineering, with examples on the Azure platform. In
fact, here is how I described the book’s topic in the proposal:</p>
<blockquote>
<div><p>The same way Software Engineering brings engineering rigor to software
development, Data Engineering aims to bring rigor to working with data in a
reliable way.</p>
<p>This book is about implementing the various aspects of a big data platform –
data ingestion, running analytics and ML, distributing data – in a real-world
production system. The focus is on operational aspects like DevOps, monitoring,
scale, and compliance. Examples will be provided using Azure services.</p>
<p>There is a big gap between what it takes, for example, to implement an ML model
in Python and what it takes to run in a production environment, on a regular
basis, with robust guardrails in place. The book focuses on the latter, which
makes it different than other data platform books.</p>
</div></blockquote>
<p>The Manning team has a lot of experience putting together books (and selling
them). We iterated on the title quite a few times, trying to best capture the
essence of the book. Once we started the project, we changed the name from
<em>Production Data Engineering with Azure</em> to <em>Practical Data Engineering on Azure</em>.</p>
<p>Before launching the book as a Manning Early Access Preview (MEAP), we changed
the name again, this time to <em>Azure Data Engineering</em>: the “Practical” part of the
title made it a bit too long and not very clear.</p>
<p>As the manuscript was wrapping up, we took another look at the title: <em>Azure Data
Engineering</em> implies the book is Azure-specific. While all the examples provided
are built in the Azure cloud, my hope is the patterns and ideas discussed apply
to any big data platform, in any cloud. We iterated on the title again, to
emphasize the “data engineering” part, and ended up with <em>Data Engineering on
Azure</em>. This is the final title of the book.</p>
</div>
<div class="section" id="articles-and-excerpts">
<h2>Articles and excerpts</h2>
<p>Before starting the project, I wrote a few articles on the topic. The first
one was <a class="reference external" href="https://vladris.com/blog/2019/12/08/notes-on-data-engineering.html">Notes on Data Engineering</a>.
Soon after, my team launched the <a class="reference external" href="https://medium.com/data-science-at-microsoft">Data Science @ Microsoft</a>
Medium publication, where I contributed several articles:</p>
<ul class="simple">
<li><a class="reference external" href="https://medium.com/data-science-at-microsoft/how-we-built-self-serve-data-environment-tools-with-azure-3951a698fc9d">How we built self-serve data environment tools with Azure</a>.</li>
<li><a class="reference external" href="https://medium.com/data-science-at-microsoft/azure-data-explorer-at-the-azure-business-scale-89262ef8c1fd">Azure Data Explorer at the Azure business scale</a>.</li>
<li><a class="reference external" href="https://medium.com/data-science-at-microsoft/running-machine-learning-at-scale-808b90f0ec75">Running machine learning at scale</a>.</li>
<li><a class="reference external" href="https://medium.com/data-science-at-microsoft/common-data-engineering-challenges-and-their-solution-dd51872812ac">Common data engineering challenges and their solution</a> - which is a retake on that first article (Notes on Data Engineering).</li>
<li><a class="reference external" href="https://medium.com/data-science-at-microsoft/partnering-for-data-quality-dc9123557f8b">Partnering for data quality</a>.</li>
<li><a class="reference external" href="https://medium.com/data-science-at-microsoft/partnering-for-metadata-management-277733911d03">Partnering for metadata management</a>.</li>
<li><a class="reference external" href="https://medium.com/data-science-at-microsoft/data-distribution-9085b4316591">Data distribution</a>.</li>
</ul>
<p>Most of the ideas from these articles show up in the book. While the articles
talk about the specific challenges my team encountered and the solutions we came
up with to solve them, the book covers patterns - the general types of problems
you would encounter while building a big data platform, and solutions you could
apply. The articles helped me to clarify (for myself) the topics I wanted to
cover in the book, and refine the proposed solutions.</p>
<p>Once the manuscript was well underway, I wrote a blog post on <a class="reference external" href="https://vladris.com/blog/2020/11/13/data-quality-testing-patterns.html">Data Quality Testing Patterns</a>
to clarify my thoughts as I was working on chapter 9 (Data quality), but
otherwise switched my focus from articles to getting the book done. At this
point, I started publishing excerpts from the book. So far I wrote about
<a class="reference external" href="https://vladris.com/blog/2020/11/27/changing-data-classification-through-processing.html">Changing data classification through processing</a>
and <a class="reference external" href="https://vladris.com/blog/2021/03/12/ingesting-data.html">Ingesting data</a>,
with more to come.</p>
</div>
<div class="section" id="the-speed-of-the-cloud">
<h2>The speed of the cloud</h2>
<p>Innovation in cloud computing moves at a break-neck speed. The technology
changes so fast, it is hard to pin things down in written form. For setting up
various Azure services, I wanted to rely on command line scripts instead of the
Azure Portal UI - walking readers through series of screenshots is tedious, and
UI changes all the time. I used <a class="reference external" href="https://docs.microsoft.com/en-us/cli/azure/">Azure CLI</a>
instead. That said, many of the extensions I used throughout the book are
currently “experimental”, which means they might change at a future time. I
also found a couple of bugs I reported to the teams maintaining the Azure CLI
extensions.</p>
<p>Another example of the speed of innovation is <a class="reference external" href="https://azure.microsoft.com/en-us/services/purview/">Azure Purview</a>.
When I started working on our data platform, there was no Azure Purview and my
team had to develop a home-grown solution to address our data inventory needs.
We then got to use a preview, in-development version of Azure Purview before it
was publicly announced (one of the perks of working at Microsoft). Chapter 8 of
my book covers metadata management, with the reference implementation on Azure
Purview. That meant I wasn’t able to start on this chapter until Azure Purview
was officially announced, even though I knew what I wanted to write about.
Things lined up pretty well, I finished chapter 7 and had to skip to chapter 9,
but as I was working on that, Azure Purview went into public preview.</p>
<p>This was a very interesting experience, very different than my previous book.
Writing my first book, I didn’t feel like there were so many moving parts to
get a handle on and the speed with which things changed wasn’t overwhelming.
Even so, I’m confident the patterns I cover in the book will remain the same
for quite some time, regardless of the technologies used to implement them. So
even as new services launch and the ways we interact with the cloud evolve,
the key takeaways should stay relevant.</p>
<p>Check out my book here: <a class="reference external" href="https://www.manning.com/books/data-engineering-on-azure">Data Engineering on Azure</a>.</p>
</div>
]]></description>
             <pubDate>Mon, 21 Jun 2021 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2021/03/12/ingesting-data.html</link>
            <guid>http://vladris.com/blog/2021/03/12/ingesting-data.html</guid>
            <title><![CDATA[Ingesting Data]]></title>
            <description><![CDATA[<h1>Ingesting Data</h1>
<p>This is an excerpt from chapter 2 of my book, <a class="reference external" href="https://www.manning.com/books/azure-data-engineering">Data Engineering on Azure</a>,
which deals with storage. In this article we’ll look at a few aspects of data
ingestion: frequency and load type, and how we can handle corrupted data.
We’ll use Azure Data Explorer as the storage solution, but keep in mind that
the same concepts apply regardless of the data fabric used. Code samples are
omitted from this article, though available in the book. Let’s start by
looking at the frequency with which we ingest data.</p>
<div class="section" id="ingestion-frequency">
<h2>Ingestion frequency</h2>
<p>Frequency defines how often we ingest a given dataset. This can range from
continuous ingestion, for streaming data, to yearly ingestion – a dataset
which we only need to ingest once a year. For example, our website team
produces web telemetry which we can, if we want to, ingest in real time. If
our analytics scenarios include some real time or near real time processing,
we can bring the data into our data platform as it is being generated.</p>
<p>The following figure shows this streaming ingestion setup.</p>
<img alt="../../../_images/fig11.png" class="align-center" src="http://vladris.com/blog/_images/fig11.png"/>
<p><em>As users visit website pages, each visit is sent as an event to an Azure
Event Hub. Azure Data Explorer ingests data into the PageViews table in real
time.</em></p>
<p>Azure Event Hub is a service that can receive and process millions of events
per second. An event contains some data payload sent by the client to the
Event Hub. A high-traffic website could treat each page view as an event and
pass the user ID, URL, and timestamp to an Even Hub. From there, data can be
routed to various other services. In our case, it can be ingested in Azure
Data Explorer in real time.</p>
<p>Another option, if we don’t have any real time requirements, is to ingest the
data on some regular cadence, for example every midnight we load the logs for
the day.</p>
<p>The following figure shows this alternative setup.</p>
<img alt="../../../_images/fig21.png" class="align-center" src="http://vladris.com/blog/_images/fig21.png"/>
<p><em>Logs get copied from the website Azure Data Explorer cluster to our Azure
Data Explorer cluster using an Azure Data Factory. Copy happens on a daily
basis.</em></p>
<p>In this case, the website team stores its logs into a dedicated Azure Data
Explorer cluster. Their cluster only stores data for the past 30 days since
it is used just to measure the website performance and debug issues. Since we
want to keep data for longer for analytics, we want to copy it to our cluster
and preserve it there.</p>
<p>Azure Data Factory is the Azure ETL service, which enables serverless data
integration and transformation. We can use a Data Factory to coordinate when
and where data gets moved. In our case, we copy the logs of the previous day
every night and append them to our <span class="docutils literal"><span class="pre">PageViews</span></span> table.</p>
<p>Let’s take another example: the sales data from our Payments team. We use
this data to measure revenue and other business metrics. Since not all
transactions are settled, it doesn’t make sense to ingest this data daily.
Our Payments team curates this data and officially publishes the financials
for the previous month on the first day of each month. This is an example of
a monthly dataset, one we would ingest once it becomes available, on the 1st
of each month.</p>
<p>The following figure shows this ingestion.</p>
<img alt="../../../_images/fig31.png" class="align-center" src="http://vladris.com/blog/_images/fig31.png"/>
<p><em>Sales data gets copied from the Payments team’s Azure SQL to our Azure Data
Explorer cluster on a monthly cadence.</em></p>
<p>This is very similar to our previous Azure Data Factory ingestion of page
view logs, the difference being the data source – in this case we ingest data
from Azure SQL, and the ingestion cadence – monthly instead of daily.</p>
<p>Let’s define the cadence of when a dataset is ready for ingestion as its
<em>grain</em>.</p>
<blockquote>
<div>The <strong>grain</strong> of a dataset specifies the frequency at which new data is
ready for consumption. This can be continuous for streaming data, hourly,
daily, weekly, and so on.</div></blockquote>
<p>We would ingest a dataset with a weekly grain on a weekly cadence. The grain
is usually defined by the upstream team producing the dataset. Partial data
might be available earlier, but the upstream team can usually tell us when
the dataset is complete and ready to be ingested.</p>
<p>While some data, like the logs in our example, can be ready in real time or
at a daily grain, there are datasets who get updated once a year. For
example, businesses use fiscal years for financial reporting, budgeting and
so on. These datasets only change year over year.</p>
<p>Another ingestion parameter is the type of data load.</p>
</div>
<div class="section" id="load-type">
<h2>Load type</h2>
<p>Outside of streaming data, where data gets ingested as it is produced, we
have two options for updating a dataset in our system. We can perform a full
load or an incremental load.</p>
<blockquote>
<div>A <strong>full load</strong> means we fully refresh the dataset, discarding our
current version and replacing it with a new version of the data.</div></blockquote>
<p>For example, our Customer Success team has the list of active customer
issues. As these issues get resolved and new issues appear, we perform a full
load whenever we ingest the active issues into our system.</p>
<p>The usual pattern is to ingest the updated data into a staging table, then
swap it with the destination table, as show in the following figure.</p>
<img alt="../../../_images/fig41.png" class="align-center" src="http://vladris.com/blog/_images/fig41.png"/>
<p><em>Queries are running against the ActiveIssues table. We ingest the data into
the ActiveIssuesStaging table. Queries are still running against the old
ActiveIssues table. We swap the two tables. Queries already started before
the swap will run against the old tables, queries started after the swap will
run against the new table. Finally, we can drop the old table.</em></p>
<p>Most storage solutions offer some transactional guarantees on renames to
support scenarios like this. This means if someone is running a query against
the <span class="docutils literal"><span class="pre">ActiveIssues</span></span> table, there is no chance of the query failing due to the
table not being found or of the query getting rows from both the old and the
new table. Queries running in parallel with a rename are guaranteed to either
hit the old or the new table.</p>
<p>The other type of data load is incremental.</p>
<blockquote>
<div>An <strong>incremental load</strong> means we append data to the dataset. We start
with the current version and enhance it with additional data.</div></blockquote>
<p>Let’s take as an example a <span class="docutils literal"><span class="pre">PageViews</span></span> table. Since the Website team only
keeps logs around for 30 days and we want to maintain a longer record when we
ingest the data into our system, we can’t fully refresh the <span class="docutils literal"><span class="pre">PageViews</span></span> table.
Instead, every night we take the page view logs of the previous day and we
<em>append</em> them to the table.</p>
<p>One challenge of incremental loads is to figure out exactly what data is
missing (that we need to append), and what data we already have. We don’t
want to append again data we already have, as it would create duplicates.</p>
<p>There are a couple of ways we can go about determining the delta between
upstream and our storage. The simplest one is contractual: the upstream team
guarantees that data will be “ready” at a certain time or date. For example,
the Payments team promises that the sales data for the previous month will be
ready on the 1st, by noon. In that case, on July 1st we will load all sales
data with a timestamp within June and append it to the existing sales data we
have in our system. In this case, the delta is June sales.</p>
<p>Another way to determine the delta is to keep track on our side of what is
the last row we ingested and only ingest from upstream data after this row.
This is also known as a <em>watermark</em>. Whatever is “under the watermark” is data
we already have in our system. Upstream can have data “above the watermark”,
which we need to ingest.</p>
<p>Depending on the dataset, keeping track of the watermark can be very simple
or very complex. In the simplest case, if the data has a column where values
always increase, we can simply see what the latest value is in our dataset
and ask upstream for data with values greater than our latest.</p>
<p>We can then ask for page views with a timestamp greater than the watermark
when we append data in our system.</p>
<p>Other examples of ever-increasing values are auto-incrementing columns, like
the ones we can define in SQL.</p>
<p>Things get more complicated if there is no easy ordering of the data from
which we can determine our watermark. In that case, the upstream system needs
to keep track of what data it already gave us, and hand us a watermark
object. When we hand back the object, upstream can determine what is the
delta we need. Fortunately, this scenario is less common in the big data
world. We usually have simpler ways to determine delta, like timestamps and
auto-incrementing IDs.</p>
<p>What happens though when a data issue makes its way into the system? We got
the sales data from our Payments team on July 1st, but the next day we get
notified that there was an issue: somehow a batch of transactions was
missing. They fixed the dataset upstream, but we already loaded the erroneous
data into our platform. Let’s talk about restatements and reloads.</p>
</div>
<div class="section" id="restatements-and-reloads">
<h2>Restatements and reloads</h2>
<p>In a big data system, it is inevitable that at some point, some data gets
corrupted, or is incomplete. The owners of the data fix the problem, then
issue a <em>restatement</em>.</p>
<blockquote>
<div>A <strong>restatement</strong> of a dataset is a revision and re-release of a dataset
after one or more issues were identified and fixed.</div></blockquote>
<p>Once data is restated, we need to reload it into our data platform. This is
obviously much simpler if we perform a full load for the dataset. In that
case, we simply discard the corrupted data we previously loaded and replace
it with the restated data.</p>
<p>Things get more complicated if we load this dataset incrementally. In that
case, we need to drop only the corrupted slice of the data and reload that
from upstream. Let’s see how we can do this in Azure Data Explorer .</p>
<p>Azure Data Explorer stores data in <em>extents</em>. An extent is a shard of the data,
a piece of a table which contains some of its rows. Extents are immutable –
once written, they are never modified. Whenever we ingest data, one or more
extents are created. Periodically, Azure Data Explorer merges extents to
improve query performance. This is handled by the engine in the background.</p>
<p>The following figure shows how extents are created during ingestion, then
merged by Azure Data Explorer.</p>
<img alt="../../../_images/fig51.png" class="align-center" src="http://vladris.com/blog/_images/fig51.png"/>
<p><em>Extents are created during ingestion, then merged by Azure Data Explorer to
improve query performance</em></p>
<p>While we can’t modify an extent, we can drop it. Dropping an extent removes
all data stored within. Extents support tagging, which enable us to attach
metadata to them. A best practice is to add the <span class="docutils literal"><span class="pre">drop-by</span></span> tag to extents on
creation. This tag has special meaning for Azure Data Explorer: it will only
merge extents with the same <span class="docutils literal"><span class="pre">drop-by</span></span> tag. This will ensure that all data
ingested into an extent with a <span class="docutils literal"><span class="pre">drop-by</span></span> tag is never grouped with data
ingested with another <span class="docutils literal"><span class="pre">drop-by</span></span> tag.</p>
<p>The following figure shows how we can use this tag to ensure data doesn’t get
mixed, then we can drop extents with that tag to remove corrupted data.</p>
<img alt="../../../_images/fig61.png" class="align-center" src="http://vladris.com/blog/_images/fig61.png"/>
<p><em>We ingested 2 extents with drop-by tag 2020-06-29 and 2 extents with drop-by
tag 2020-06-30. They get merged into 1 extent with drop-by tag 2020-06-29 and
1 extent with drop-by tag 2020-06-30. We can ask Azure Data Explorer to drop
all extents tagged with 2020-06-29 to remove a part of the data.</em></p>
<p>The <span class="docutils literal"><span class="pre">drop-by</span></span> tag ensures that extents with different values for the tag never
get merged together, so we don’t risk dropping more data than what we want
dropped. The value of the tag is arbitrary, we can use anything, but a good
practice is to use an ingestion timestamp. So for example when we load data
on 2020-06-29, we use the <span class="docutils literal"><span class="pre">drop-by:2020-06-29</span></span> tag.</p>
<p>If we later learn that the data we loaded was corrupted and upstream restates
the data, we can drop the extents containing corrupted data and re-ingest
from upstream to repair our dataset.</p>
<p>Obviously, this process is more complicated than if we were doing a full load
of the data every time. In general, if we can afford a full load, we should
use that. Maintenance-wise, it is a much simpler approach. Sometimes though,
this is impossible – for example if we want to maintain page view logs beyond
the 30-day retention period upstream has, we can’t keep reloading the data.
Other times, full load is just too expensive: we end up moving the same
gigabytes of data again and again, with minor differences. For these
situations, we have to look at an incremental load and manage the additional
complexity.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>We can ingest data continuously (streaming), or at a certain regular cadence
like daily, weekly, monthly, or yearly.</li>
<li>When we ingest data, we can perform either a full load, or we can perform an
incremental load.</li>
<li>A full load means we fully refresh the dataset, discarding our current
version and replacing it with a new version of the data.</li>
<li>An incremental load means we append data to the dataset. We start with the
current version and enhance it with additional data.</li>
<li>It is inevitable for some data to get corrupted. Once repaired upstream, we
need a way to discard the corrupted data from our system and reload the
updated data.</li>
</ul>
</div>
]]></description>
             <pubDate>Fri, 12 Mar 2021 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/12/29/recommendations.html</link>
            <guid>http://vladris.com/blog/2020/12/29/recommendations.html</guid>
            <title><![CDATA[Recommendations]]></title>
            <description><![CDATA[<h1>Recommendations</h1>
<p>I sometimes get asked for learning resources and areas aspiring software
engineers should focus on. This post will cover some of my recommendations.
This is purely for software development, design, and engineering. I will
share a complementary list of resources on soft skills, systems, leadership,
and working within organizations in a future post.</p>
<div class="section" id="fundamentals">
<h2>Fundamentals</h2>
<p><strong>Data structures and algorithms</strong> – This is CS 101. Understand lists, stacks,
queues, heaps, trees, graphs, and algorithms to sort, select, traverse etc.
Understand big-O notation and complexity – this is important in practice, when
implementing solutions that deal with real-world data. This is foundational to
the field of computer science, so unless you are working on some cutting-edge
stuff, there’s probably a well-known solution to your problem. You don’t need
to know all implementations by heart but know what applies and where to look
it up when needed, be it an A* search or B-tree.</p>
<p><strong>Understand your compute target</strong> – this can be a physical machine, an
operating system, a virtual machine like the JVM or .NET CLR, the browser, or
the cloud. Either way you need to know what resources are available, how they
are allocated, what are the performance characteristics and so on. Without
understanding your compute target you won’t be able to leverage it to its
full capabilities and run the risk of misusing it.</p>
<p><strong>Concurrent programming</strong> – today, I believe this is unescapable. Concurrency
is everywhere, regardless of whether you are building services that talk to
each other, a multi-threaded native application, or a Node.JS, event
loop-based application. Having a good mental model of how concurrency works,
understanding deadlocks, livelocks, synchronization mechanisms, and
consistency models is foundational.</p>
</div>
<div class="section" id="programming-languages">
<h2>Programming languages</h2>
<p>Programming languages are not just how we talk to computers, they are tools
for thought. They enable us to express solutions to problems. We model our
solutions using the languages, and different languages are best suited to
different problems. I’m a firm believer in multi-paradigm and using the best
tool for a job. Saying that <em>everything is an object</em>, or <em>everything is a
function</em> is an oversimplification. Many modern programming languages support
multiple paradigms, so we can write object-oriented code when appropriate,
and functional code when appropriate. With that said, I suggest learning:</p>
<p><strong>A system programming language</strong> like C++, Rust or Swift if you need to write
native, performant code. These languages are close to the machine and will
help you understand OS resource management, how code gets executed, and what
impacts performance.</p>
<p><strong>A “higher-level” language</strong> for writing tools and services. Something like C#,
Java or Go. These are all garbage collected and trade off some performance
for productivity.</p>
<p><strong>A dynamic language</strong> for quick prototyping and experimentation. Python and
Ruby come to mind. While static typing is much safer for production code, I
do love <em>thinking</em> in Python.</p>
<p><strong>A purely functional language</strong> like Haskell or Idris. This is again to
understand different ways of thinking about problems. Even if you don’t get
to write production code in a purely functional language, you will learn
alternative approaches to designing your code which you will be able to
apply even when using other languages.</p>
<p><strong>A language with strong support for generics</strong>, like C++, Rust, or TypeScript.
Generics are a powerful way to reuse and combine code and understanding them
will make you a better programmer.</p>
<p>From my personal experience, within the same paradigm, languages are more
similar than different. In other words, once you know two, it is
significantly easier to understand the third. There is value in learning new
programming languages to see how they differ from existing ones and what they
bring to the table.</p>
</div>
<div class="section" id="practice">
<h2>Practice</h2>
<p>Write code. Learning needs to be a mix of theory and practice. Here are some
practice ideas:</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Kata_(programming)">Code katas</a> – These
could be some good first projects when picking up a new language. For example:
<a class="reference external" href="http://codekata.com/">http://codekata.com/</a>, <a class="reference external" href="https://github.com/gamontal/awesome-katas">https://github.com/gamontal/awesome-katas</a>.</p>
<p><strong>Programming puzzles</strong> – These are good ways to practice problem solving,
data structures, and algorithms. I really enjoy <a class="reference external" href="https://adventofcode.com/">Advent of Code</a>,
which has been running every December since 2015. <a class="reference external" href="https://www.facebook.com/codingcompetitions/hacker-cup/">Facebook Hacker Cup</a>
also has some great puzzles.</p>
<p><strong>Contribute to an open-source project</strong>, many have supportive communities and
paths to get you started.</p>
<p><strong>Work on your own project</strong>, be it a website or a game or something else you
are passionate about. Scope it to fit the amount of time you must dedicate
and use the technologies you want to learn.</p>
<p>Of course, you will do most of the <strong>learning on the job</strong>. Work on projects
that interest you, projects you can learn from, and projects where you can
apply what you learned.</p>
</div>
<div class="section" id="books">
<h2>Books</h2>
<p>This is a list of books on software design and craftsmanship that I highly
recommend:</p>
<p><a class="reference external" href="https://www.goodreads.com/book/show/4845.Code_Complete">Code Complete</a> -
I love this one. This is The Big Book of Software Engineering, and it covers
the fundamentals, like writing proper functions, using good naming in the
code, testing, debugging etc.</p>
<p><a class="reference external" href="https://www.goodreads.com/book/show/4099.The_Pragmatic_Programmer">The Pragmatic Programmer</a>
- Great book which gives general advice on what it takes to become a good
programmer. From basic tips like know thy text editor and use source control
to implementation and design advice.</p>
<p><a class="reference external" href="https://www.goodreads.com/book/show/84983.Agile_Principles_Patterns_and_Practices_in_C_">Agile Principles, Patterns and Practices in C#</a>
- On writing software in an agile world. Principles to keep in mind (like the
Open/Close Principle, the Single Responsibility Principle etc.), patterns to
enable them, and agile practices. Also covers TDD, extreme programming, and
all the other agile methodologies.</p>
<p><a class="reference external" href="https://www.goodreads.com/book/show/85009.Design_Patterns">Design Patterns</a>
- The classic book on design patterns. It is a bit cumbersome but definitely
worth reading. Patterns are basically well-known solutions to recurring
design problems. Do read <a class="reference external" href="https://vladris.com/blog/2020/12/10/notes-on-design-patterns.html">my previous post</a>
and don’t over-index on patterns.</p>
<p><a class="reference external" href="https://www.goodreads.com/book/show/44936.Refactoring">Refactoring</a> - The
classical book on refactoring code - re-structuring implementation without
changing functionality. Talks about code smells (pieces of code that feel
wrong) and how to rearchitect such code to make it right.</p>
<p><a class="reference external" href="https://www.goodreads.com/book/show/3139913-emergent-design">Emergent Design</a>
- This book talks about how design emerges as code evolves. By respecting a
few principles and knowing about design patterns, you don’t have to
over-design and future-proof, rather keep refactoring and extending as new
requirements come in.</p>
<p>There are a few other books which I really enjoyed, though they are a bit
different than the above. I recommend these more for the aesthetics and
insights (more on that below): <a class="reference external" href="https://www.goodreads.com/book/show/52084.Programming_Pearls">Programming Pearls</a>,
<a class="reference external" href="https://www.goodreads.com/book/show/23498372-from-mathematics-to-generic-programming">From Mathematics to Generic Programming</a>,
<a class="reference external" href="https://www.goodreads.com/book/show/405790.Beautiful_Code">Beautiful Code</a>.</p>
</div>
<div class="section" id="other-considerations">
<h2>Other considerations</h2>
<p><strong>Develop a sense of aesthetics</strong> - This comes with practice. Know what good
code looks like, what makes it beautiful. Don’t just get code working, try to
make it beautiful.</p>
<p><strong>Understand your problem space</strong> – Whatever you are working on, knowing the
business domain will help inform your software design. Understand why you are
doing what you are doing. Is there a better way to solve the same business
problem? Do you know what will likely come up in 6 months from now or a year?</p>
<p><strong>Security</strong> – Software security is critical in today’s connected world. You
should understand security best practices, which hashing algorithms to use,
how to properly store secrets and passwords, how trust gets established,
attack vectors, how to create a <a class="reference external" href="https://en.wikipedia.org/wiki/Threat_model">threat model</a>
and so on.</p>
<p><strong>AI</strong> - AI is permeating more areas of software. It is also being
commoditized through libraries like scikit-learn and services like Azure
Cognitive Services. While I won’t quite yet put it under <em>fundamentals</em>, I
believe using AI will soon be a must-know, much like concurrent programming.
Having a good understanding of the types of problems AI can help with, when
and how to apply it is very valuable.</p>
<p><strong>Keep learning</strong> – The way we build software keeps evolving. Try to keep up to
date with recent developments and trends. This is one of the reasons software
engineering is such an exciting field: there’s always something new, there’s
always more to learn.</p>
</div>
]]></description>
             <pubDate>Tue, 29 Dec 2020 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/12/10/notes-on-design-patterns.html</link>
            <guid>http://vladris.com/blog/2020/12/10/notes-on-design-patterns.html</guid>
            <title><![CDATA[Notes on Design Patterns]]></title>
            <description><![CDATA[<h1>Notes on Design Patterns</h1>
<blockquote>
<div><em>Patterns mean “I have run out of language.”</em> — Rich Hickey.</div></blockquote>
<p>Many junior developers want to improve their software design skills by
studying design patterns. I was there too, of course. I believe there is a
big misconception of what design patterns <em>are</em>, and I believe we are,
indeed, over-indexing on them when we are thinking of software design.</p>
<p>It is very easy to over-design things, and if blindly apply design patterns,
we end up with code like the <a class="reference external" href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">FizzBuzz Enterprise Edition</a>,
which in real life translate into incomprehensible software that burns
hundreds of developer-hours for even tiny changes.</p>
<div class="section" id="a-good-design-by-any-other-name">
<h2>A good design by any other name…</h2>
<p>So what are design patterns? A common definition is:</p>
<blockquote>
<div>A software design pattern is a general, reusable solution to a commonly
occurring problem within a given context in software design.</div></blockquote>
<p>A lot of design patterns criticism centers around how, using some non-object
oriented language, you can express design patterns from the Gang of Four
succinctly within the language syntax, without having to code extra
scaffolding. This is why I believe there is a misconception around what
design patterns really are. My take on design patterns is that they provide
good solutions to software design problems, for dimensions like
encapsulation, decoupling etc. These patterns are <strong>not</strong> their representation
in any particular language.</p>
<p>In some instances, a language can express the same idea more succinctly. That
doesn’t mean the pattern is useless. We are still modeling complex domains
with code, and we still need to account for all aspects of good design so we
don’t end up with a jumbled mess. In other words, you can write bad code in
any programming language.</p>
<p>This is a recurring topic in my book <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>,
where I show alternative implementations to the strategy pattern, the
decorator pattern, and the visitor pattern. The first two have more succinct
functional implementations, while the last one can be better encapsulated
using a discriminated union type. Regardless of how we express the design, we
are still solving the same problem. Which is why I believe over-indexing on
learning design patterns as code recipes is a mistake.</p>
</div>
<div class="section" id="smelling-software-rot">
<h2>Smelling software rot</h2>
<p>As a young developer wanting to learn design patterns, I stumbled upon the
<a class="reference external" href="https://www.goodreads.com/book/show/84983.Agile_Principles_Patterns_and_Practices_in_C_">Agile Principles, Patterns, and Practices in C#</a>
book, probably because it contained “patterns” in the title. But this book is
a real gem on good design, and I highly recommend it.</p>
<p>Chapter 7 talks about design smells. Design smells are a sign that the
software is rotting and might need refactoring. Here are a few examples
from the book:</p>
<ul class="simple">
<li><strong>Rigidity</strong> - because of poorly-structured dependencies, a small change in
one part of the code causes a cascade of subsequent changes in other parts of
the code.</li>
<li><strong>Viscosity</strong> - when modifying the code, it is easier to add a hack rather
than to implement a desing-preserving change. In other words, it is easier to
do the wrong thing than it is to do the right thing.</li>
<li><strong>Needles Repetition</strong> - copy/pasted code, often with minor modifications,
which makes minor updates very difficult to apply across the code base.</li>
</ul>
<p>There are a bunch more in the book and plenty more documented online.</p>
<p>Developing a nose for design is, in my opinion, a lot more important than
<em>knowing</em> patterns. And while you can read about common smells, nothing beats
experience (much like reading descriptions of actual smells vs. using your
nose).</p>
<p>When I write code, sketching out a solution to some problem, I refactor it
several times before I submit a pull request. It is an iterative process - I
try something out, notice something off with the design, refactor to improve
and simplify.</p>
<p>Instead of bringing a set of prefabricated solutions and checking to see
which one fits the problem best, we can focus on refactoring smells away.
This avoids the FizzBuzz Enterprise Edition problem. The Enterprise Edition
of FizzBuzz is full of patterns! But it is needlessly complex. Accidental
complexity is one of the worst smells. I mentioned accidental complexity in the
<a class="reference external" href="https://vladris.com/blog/2020/01/19/time-and-complexity.html">Time and Complexity</a>
post and I will probably write more about it since I find this a fascinating
topic.</p>
<p>Smells tell us how a design is bad, but what makes a good design?</p>
</div>
<div class="section" id="solid-principles-and-beyond">
<h2>SOLID principles and beyond</h2>
<p>There is a small set of design principles, known as the SOLID design
principles which make for good code:</p>
<ul class="simple">
<li><strong>The single-responsibility principle</strong> - a class (or program unit) should be
responsible for one thing, and have to change only when the requirements of
that thing change.</li>
<li><strong>The open/closed principle</strong> - code should be open for extension, closed for
modification.</li>
<li><strong>The Liskov substitution principle</strong> - replacing an instance of some type
with an instance of a subtype should maintain program correctness.</li>
<li><strong>The interface segregation principle</strong> - single-responsibility principle
applied to interfaces.</li>
<li><strong>The dependency-inversion principle</strong> - code should depend on abstractions,
not concrete implementations.</li>
</ul>
<p>While a lot of the literature is centered around object-oriented programming,
these principles transcend OOP. For example, an interface can be an
<span class="docutils literal"><span class="pre">interface</span></span> definition, a function signature, a set of APIs exposed by a
module etc. Similarly, subtyping does not imply inheritance - check out my
<a class="reference external" href="https://vladris.com/blog/2019/12/27/variance.html">Variance</a> post which
covers this in more depth.</p>
<p>These SOLID principles are the subject of chapter 8 through 12 of the <em>Agile
Principles, Patterns, and Practices in C# book</em>.</p>
<p>Knowing these principles and having a nose for design smells, you can derive
any design pattern from first principles. In some cases it’s easier if you
are aware of the pattern - you don’t have to spend time solving an
already-solved problem. But it doesn’t work the other way around: You can’t
start with a set of patterns without understanding the underlying principles
and without being able to tell when a design smells.</p>
<p>Beyond these principles, exploring well-crafted software helps us develop a
sense of good design. In the real-world, most codebases have good and bad
parts. I won’t go into the details of why in this article, but keep this in
mind when working on your project. Which parts are designed well? Why? Which
parts could benefit from a refactoring? Why?</p>
<p>Learning design patterns is secondary to understanding good and bad design.</p>
</div>
]]></description>
             <pubDate>Thu, 10 Dec 2020 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/11/27/changing-data-classification-through-processing.html</link>
            <guid>http://vladris.com/blog/2020/11/27/changing-data-classification-through-processing.html</guid>
            <title><![CDATA[Changing Data Classification Through Processing]]></title>
            <description><![CDATA[<h1>Changing Data Classification Through Processing</h1>
<p>This is an excerpt from a draft of chapter 10 of my book, <a class="reference external" href="https://www.manning.com/books/azure-data-engineering">Azure Data Engineering</a>,
which deals with compliance. In this article we’ll look at a few techniques
to transform sensitive user data into less sensitive data. In the book, this
includes code samples for implementation on Azure Data Explorer, which are
omitted from this article. Let’s start with a couple of definitions.</p>
<div class="section" id="user-data">
<h2>User Data</h2>
<p>User data is data that can be directly tied to the user. This class of data
is important since this is what GDPR covers. User data also comes in a couple
of subcategories. One of them is <em>End User Identifiable Information</em> or <em>EUII</em>.</p>
<blockquote>
<div><strong>End user identifiable information</strong> is information that can directly
identify the user. Examples of EUII are name, email address, IP address, or
location information.</div></blockquote>
<p>As data moves through our systems, we generate various IDs. Any data that we
have tied to such an ID, for example order history for account ID, is called
<em>End User Pseudonymous Information</em> or <em>EUPI</em>.</p>
<blockquote>
<div><strong>End user pseudonymous information</strong> are IDs used by our systems which, in
conjunction with additional information (for example a mapping table) can
be used to identify the user.</div></blockquote>
<p>Note the important distinction: When we look at EUII, for example name and
address, we can immediately identify the user. When we look at EUPI, for
example account ID, we need an additional mapping to tell us which user the
account ID belongs to.</p>
<p>In general, we have one primary ID (or several) which directly identifies the
user, which we consider EUII, and multiple other IDs which indirectly
identify the user through their connection to the primary ID. These other IDs
are EUPI.</p>
</div>
<div class="section" id="changing-classification-through-processing">
<h2>Changing Classification Through Processing</h2>
<p>In general, we restrict the number of people who can access sensitive data.
In most cases, access is <em>on a need-to-know basis</em>, where data scientists and
engineers allowed to process this data have done some compliance training and
understand the risks and liabilities.</p>
<p>In some scenarios we want to process data so that it becomes less sensitive.
A good example is we want to open it up for more data scientists to look at.
In this article we will look at a few techniques for achieving this.</p>
<p>Let’s start by defining two datasets, as shown in the following figure:</p>
<img alt="../../../_images/fig1.png" class="align-center" src="http://vladris.com/blog/_images/fig1.png"/>
<p>The first dataset, <em>User profiles</em>, contains user accounts, including names,
credit cards, and billing addresses. We omitted actual billing addresses to
keep things short. This dataset also contains a <em>User ID</em> column which
associates an identification number with each user. This is the primary ID in
our system, since we can use it to link back to a user’s profile information.</p>
<p>The second dataset, <em>User telemetry</em>, contains telemetry data we collect from
our users. It contains the user ID, timestamp and product feature the user
engaged with.</p>
<p>Let’s see some techniques we can use on the <em>User telemetry</em> table to change
its classification to something less sensitive.</p>
<div class="section" id="aggregation">
<h3>Aggregation</h3>
<p>The first technique is aggregation: we can take user identifiable information
from multiple users, aggregate it, and get rid of the end user identifiable
part. For example, if we collect telemetry from our users that captures which
features of our product they are using, we can aggregate it, so we know how
much each feature is being used, but not who used what.</p>
<p>The following figure shows how aggregation transform user identifiable
information into data that can’t be tied back to individual users.</p>
<img alt="../../../_images/fig2.png" class="align-center" src="http://vladris.com/blog/_images/fig2.png"/>
<p>Before processing, we could see exactly what set of features an individual
user was using, which has privacy implications. After aggregation, we can no
longer tell that. We still have valuable data – we know which features of our
product are the most used, which ones are not that important to our customers
etc. We can store this data for analytics and ML purposes without having to
worry about end user privacy.</p>
<blockquote>
<div>Data <strong>aggregation</strong> is the processing of data into a summarized format.
This can be used to transform the data so it can no longer be tied to
individual users.</div></blockquote>
<p>But maybe we want to know more: we want to see when each feature is used or
how our customers use different features in conjunction. Now simply counting
feature usage is not enough. We can use a different technique for that:
anonymization.</p>
</div>
<div class="section" id="anonymization">
<h3>Anonymization</h3>
<p>We can use anonymization to unlink the data from the end user. Once the data
is no longer connected to a user identifier, we can’t tell which user it came
from. Going back to our telemetry example, if we want to know when features
are used, but don’t care who uses them, we can get rid of the user
identifier. The following figure shows how we can anonymize data by dropping
the user identifiers.</p>
<img alt="../../../_images/fig3.png" class="align-center" src="http://vladris.com/blog/_images/fig3.png"/>
<p>Maybe this is not enough either. What if we still need to see which features
are used together by a user, but we don’t really care who the user is? We can
still anonymize by replacing user identifiers (which can be tracked back to
the user) with randomly generated IDs. The following figure shows how we can
anonymize the data by replacing each user ID with a randomly generated GUID.</p>
<img alt="../../../_images/fig4.png" class="align-center" src="http://vladris.com/blog/_images/fig4.png"/>
<p>Note that we are intentionally not persisting a mapping between user IDs and
corresponding random IDs. We generate the random IDs once and intentionally
“forget” the association.</p>
<p>Once this happens, we can no longer tie the data back to the user, so it is
no longer user identifiable. We can still tie together datasets by the random
ID, but there is no way to associate the random ID with a user.</p>
<blockquote>
<div><strong>Anonymization</strong> is the process of removing user identifiable information
from the data or replacing it with data that cannot be linked back to a
user.</div></blockquote>
<p>If we get new telemetry from our users, we won’t be able to generate the same
GUID when anonymizing. Each time we run the query we will get different
random IDs corresponding to our users. In some cases, this might not be
enough. Or we might need to maintain that ability to link back to our
original user IDs but restrict who can make that association. For these
cases, we can use pseudonymization.</p>
</div>
<div class="section" id="pseudonymization">
<h3>Pseudonymization</h3>
<p>In this case, we have scenarios for which we still need to know who the data
belongs to, but this is not needed for all scenarios. For example, we might
want to keep track of which user used which features so we can notify them of
updates to that feature. But for other analytics, it is irrelevant who the
user is. For the first case, we have a small set of people who can view this
association. For analytics, we have a large team of people looking at the
data, but from their perspective, it is anonymous.</p>
<p>We can achieve this by pseudonymizing the data. The difference between
pseudonymization and anonymization is that pseudonymization gives us a way to
reconstruct the relationship.</p>
<p>When we looked at anonymizing data, we swapped out the user ID with a
randomly generated ID. Unless we explicitly stored which user ID got assigned
which random ID, we can no longer recover the link.</p>
<p>For pseudonymization, we replace random IDs with something more
deterministic. This can be either a hash of the user ID, or an encryption of
the user ID.</p>
<p>As a reminder, hashing is a one-way function. Give the result of a hash, you
cannot “un-hash” it to get the original value. Encryption is different – an
encrypted value can be decrypted if we know the encryption key.</p>
<blockquote>
<div><strong>Pseudonymization</strong> is the process of replacing user identifiable
information with a pseudonym. The data can be linked back to a user given
some additional information.</div></blockquote>
<p>Let’s look at both approaches.</p>
<div class="section" id="pseudonymizing-by-hashing">
<h4>Pseudonymizing by hashing</h4>
<p>If we hash the user IDs and provide a dataset with just hashes, the only way
to tie this pseudonymous data back to actual users would be to take all the
user IDs in our system and hash them to see where we find a match.</p>
<p>If we restrict the access to the user IDs, then someone who can only query
the pseudonymized table can still see all the connections within the dataset
(which features are used by which user), but instead of seeing a user ID,
they see a pseudonymous identifier. The following figure shows the
transformation.</p>
<img alt="../../../_images/fig5.png" class="align-center" src="http://vladris.com/blog/_images/fig5.png"/>
<p>Note that if we only have this dataset consisting of <em>Pseudonymous ID</em>,
<em>Timestamp</em>, and <em>Feature</em>, we can’t produce a user ID. On the other hand, if
we have a user ID, we can always hash it and link it to the pseudonymized
data.</p>
<p>We can use this technique in cases when the data scientists processing the
pseudonymized data don’t have access to the unprocessed, end user
identifiable data. This way, they get a dataset that is, for all intents and
purposes, just like the original, except there is no mention of user IDs.</p>
<p>This doesn’t work if the user IDs are also visible since it is easy to hash
them again and produced the pseudonymous IDs. One option is to keep the
hashing algorithm secret and add a salt. In cryptography, a salt is some
additional secret data mixed-in, to make it harder to recreate the
connection. For example we can XOR the user ID with some number (our salt).</p>
<p>Now, as long as the salt is kept secret, someone can’t get from user ID to
the pseudonymous ID even if they know which hashing algorithm is used for
pseudonymization.</p>
<p>Let’s now look at the alternative to hashing: encryption.</p>
</div>
<div class="section" id="pseudonymizing-by-encrypting">
<h4>Pseudonymizing by encrypting</h4>
<p>If we encrypt the user IDs and provide a dataset with encrypted values, the
only way to tie this back to actual users would be to decrypt. As long as the
encryption key is secure and only available on a need-to-know basis, people
that don’t need to know can’t recover the association.</p>
<p>This is similar to the hashing technique we just saw, except it is a two-way
transformation. Even without having access to a user ID to hash, we can
produce a user ID by decrypting an encrypted pseudonymized ID. Figure 6 shows
how this would look like.</p>
<img alt="../../../_images/fig6.png" class="align-center" src="http://vladris.com/blog/_images/fig6.png"/>
<p>We will use encryption instead of hashing if we have a scenario in which we
don’t have the original dataset available, but we need a way to recover it.
In this case, we can rely on the two-way transformation provided by
encryption and restore the original dataset by decrypting the pseudonymized
dataset.</p>
<p>An alternative to transforming data is masking.</p>
</div>
</div>
<div class="section" id="masking">
<h3>Masking</h3>
<p>Masking means hiding parts of the data from whoever access it, even if the
data is fully available in our system. Think of how social security numbers
are reduced to the last 4 digits: <span class="docutils literal"><span class="pre">***-**-1234</span></span>.</p>
<p>Masking sensitive data makes it less sensitive – obviously, even with bad
intent, someone can’t do much with just the last 4 digits of a social
security number, with just the city and state of a home address, or with the
first few digits of a phone number.</p>
<p>Masking the data does require an additional layer in between the raw storage
and people querying the data, which determines who gets to see the unmasked,
full dataset, and who is restricted to a more limited view of the data.
The following figure shows how masking looks like for our <em>User profile</em> table.</p>
<img alt="../../../_images/fig7.png" class="align-center" src="http://vladris.com/blog/_images/fig7.png"/>
<p>Unlike our previous techniques, which transformed the data, this happens
in-place. We still have the full credit card number stored, but not everyone
querying the table will be able to see it.</p>
<blockquote>
<div><strong>Masking</strong> leverages an additional layer between the raw data and query
issuers to hide sensitive information from non-privileged access.</div></blockquote>
<p>The good news is many storage solutions and database engines offer such a
layer out-of-the-box (see Azure Data Explorer’s <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-explorer/kusto/management/rowlevelsecuritypolicy">row level security</a>
for example).</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this article we looked at a few ways in which we can take sensitive data
and make it less sensitive:</p>
<ul class="simple">
<li>Aggregating data makes it impossible to connect it back to individual users.</li>
<li>Anonymizing data, while a bit more involved than aggregating, preserves the
granularity of user-level data, while removing the identifiable parts.</li>
<li>In some cases, we do have legitimate scenarios in which we want to trace back
the data to actual users. In this case, we can use pseudonymization to make
the data partially anonymous and only restore the link with the real user ID
on a need-to-know basis.</li>
<li>Hashing is a one-way transformation of the data. Given a pseudonymized ID, we
can’t recover a user ID. We can restore the association by hashing user ID
again and joining on the pseudonymized ID. Adding secret salt to a hash makes
it harder to restore the association (one would need to also know the salt
value).</li>
<li>Encryption is a two-way transformation, which requires an additional piece of
information: a key. Given a pseudonymized ID, we can recover the user ID if
we have the key by decrypting the data.</li>
<li>Masking is another technique for hiding sensitive information. In this case,
the data is not transformed, rather an in-between layer can hide sensitive
information and only make it available when appropriate.</li>
</ul>
<p>This are important techniques to know when dealing with sensitive data, since
they all allow us to make more data available to more analytical scenarios
without compromising on user privacy.</p>
</div>
]]></description>
             <pubDate>Fri, 27 Nov 2020 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/11/13/data-quality-testing-patterns.html</link>
            <guid>http://vladris.com/blog/2020/11/13/data-quality-testing-patterns.html</guid>
            <title><![CDATA[Data Quality Testing Patterns]]></title>
            <description><![CDATA[<h1>Data Quality Testing Patterns</h1>
<p>The insights generated by a data platform are only as good as the quality of
the underlying data. I briefly mentioned data quality in my <a class="reference external" href="https://vladris.com/blog/2019/12/08/notes-on-data-engineering.html">Notes on Data
Engineering</a>
blog post and elaborated on the DataCop solution in the
<a class="reference external" href="https://medium.com/data-science-at-microsoft/partnering-for-data-quality-dc9123557f8b">Partnering for data quality</a>
Medium article I co-authored with my colleagues.</p>
<p>In this post I want to talk about some of the requirements and common
patterns of data quality test solutions. I maintain that in the future data
quality testing will be commoditized and offered “as a service” by cloud
providers. As of today, it is still something we have to stitch together or
onboard a 3rd party solution. Below is a blueprint for such solutions.</p>
<div class="section" id="data-fabrics">
<h2>Data Fabrics</h2>
<p>Any data quality test run is eventually translated into a query executing on
the underlying data fabric. In Azure, this can be, for example, Azure SQL,
Azure Data Explorer, Data Lake Storage etc. Data quality frameworks need to
support multiple data fabrics for several reasons. First, in a big enough
enterprise, data will live in multiple systems. Second, different data
fabrics are optimized for different workloads, so even if we are very strict
about the number of technology choices, sometimes it simply makes sense to
leverage different data fabrics for different workloads.</p>
<p>We probably don’t want to manage multiple data quality solutions specializing
in different data fabrics, since data quality solutions become part of our
infrastructure. Regardless of target data fabrics, any data quality solution
needs to implement some form of test scheduling, alerting etc.</p>
<p>The best pattern is to support multiple data fabrics through a plug-in model,
so support for additional data fabrics can be easily added by implementing a
new plug-in, while the core of the system is shared for all data fabrics
plugged into the system.</p>
</div>
<div class="section" id="types-of-tests">
<h2>Types of Tests</h2>
<p>The <a class="reference external" href="https://smartbridge.com/data-done-right-6-dimensions-of-data-quality/">6 Dimensions of Data Quality</a>
article talks about <em>completeness</em>, <em>consistency</em>, <em>conformity</em>, <em>accuracy</em>,
<em>integrity</em>, and <em>timeliness</em>. I think of data quality testing like unit
testing for code, so I will present a slightly different take on this. Some
of the dimensions are harder to test for than others, for example checking
consistency across multiple data systems is non-trivial (more equivalent to
an integration test). Some of the dimensions have nuances – for example
detecting anomalies in day over day data volume change to identify potential
issues vs. just looking at a point in time.</p>
<div class="section" id="availability">
<h3>Availability</h3>
<p>The simplest type of data test is availability, meaning <em>is data available for
a certain date</em>. If, for example, we ingest yesterday’s telemetry data every
night, we expect to have yesterday’s telemetry data available in our system
tomorrow.</p>
<p>This type of test can be implemented as a query against the underlying data
fabric that ensures some data is there. That can mean a query that returns at
least one row passes the test. This can be an early smoke test we can run
before performing more involved testing.</p>
</div>
<div class="section" id="correctness">
<h3>Correctness</h3>
<p>This type of test ensures data is <em>correct</em>, based on some criteria. For
example, ensuring columns that shouldn’t be empty are not empty, values are
within expected ranges, and so on.</p>
<p>This type of test can be implemented as a query against the underlying data
fabric that ensures no out-of-bounds values are returned. Going back to the
unit test equivalency, we likely want multiple correctness tests per dataset,
one or more per column we want to test.</p>
</div>
<div class="section" id="completeness">
<h3>Completeness</h3>
<p>Completeness tests expand on availability tests and validate not only that
some data is available, but that <em>all</em> the data is available.</p>
<p>In some cases, this can be an exact query: for example, if we are expecting
some data for all 50 states of US, we can check that the count of distinct
states is 50.</p>
<p>More advanced checks look at historical data and ensure the volume of the
data we are checking is within a certain threshold – for example, our
telemetry data volume should be within +/-5% of the data volume we observed
yesterday.</p>
</div>
<div class="section" id="anomaly-detection">
<h3>Anomaly detection</h3>
<p>We won’t go to deep into this, but there are some complexities associated
with the previous type of historical data checks. For example, website
traffic volume, depending on the website, might be very different day over
day between weekends and workdays, or during holidays etc.</p>
<p>For these situations we can use more complex AI-based anomaly detection to
track volume over time until the system can identify anomalous data.</p>
</div>
</div>
<div class="section" id="queries-code-or-configuration">
<h2>Queries, Code or Configuration</h2>
<p>The implementation of tests can be done as queries, code, configuration, or a mix.</p>
<p>Implementing all tests as queries means writing each test as a stored
procedure (or equivalent), so it is fully implemented on the data fabric it
executes against. The test framework just invokes the test and reads the
result. The main challenge with this is that there is not a lot of reuse.
Since the framework ends up just calling a stored procedure, it is up to the
test author to write the test, which is ultimately an arbitrary query.</p>
<p>Implementing all tests as code means wrapping each data quality test into a
test method in some programming language. The main advantage of this is we
can use an off-the-shelf test framework with all its benefits. Unlike data
quality testing, the field of software testing is mature. On the other hand,
the main drawback is that authoring tests as code really raises a barrier to
entry, making it harder for non-engineers to create tests.</p>
<p>Tests as configuration means defining tests using text configuration files in
a format like JSON, YAML, or XML. The framework interprets these and
translates them into the final queries to execute against the data fabric.
The main advantage of this approach is a fairly data fabric-independent way
to specify tests, around which we can build schema validation etc. The
disadvantage is increased complexity in the framework, as it must translate
configuration to queries.</p>
<p>What works best, from my experience, is a mix of queries and configuration:
give enough flexibility in the config schema to author custom queries and
let the framework handle some of the common concerns like scheduling.</p>
</div>
<div class="section" id="test-execution">
<h2>Test Execution</h2>
<p>Another important concern is when we want to run a given data quality test.</p>
<p>In some scenarios we want to run tests as part of a data movement workflow.
We want to either check that the data is in good shape at the source, before
we copy it, or check that the data is in good shape after it got copied to
the destination. Let’s call this type of <em>execution on demand</em>. This type of
test execution is integrated in the ETL pipeline.</p>
<p>In other scenarios we want to run the tests on a schedule, as we expect the
data to be available. For example, if data should have arrived in our SQL
database by 7 AM every morning, we want to run our data quality tests at 7 AM
to make sure everything is in good shape. In this case, we don’t really care
how the data gets here, so we are running independent of the ETL pipeline
that brings the data in. Let’s call this <em>scheduled execution</em>.</p>
<p>A good data quality test framework should support both on demand and
scheduled test execution, as there is room (and need) for both types of tests.</p>
</div>
<div class="section" id="monitoring-and-alerting">
<h2>Monitoring and Alerting</h2>
<p>A data quality framework must be integrated with an alerting system such that
whenever a data quality test fails, data engineers are proactively alerted so
they can start investigating/mitigating the data issue.</p>
<p>A dashboard showing the overall health of the data platform is another
important component. This should include data quality for all datasets under
test, so stakeholders suspecting a data issue can quickly check to see when
did the latest tests run for a given dataset and what were the results.</p>
<p>A slightly more advanced capability is lineage tracking – if we identify an
issue with a dataset, do we know what is the impact? What analytics or
machine learning models or downstream processing is impacted? Tracking
metadata like lineage is a deep topic itself but integrating this with a data
quality framework enables very powerful observability.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post we covered some patterns for data quality testing:</p>
<ul class="simple">
<li>Supporting multiple data fabrics via a plug-in model.</li>
<li>Types of tests, from simple availability to anomaly detection.</li>
<li>How to best specify tests as a mix of queries and configuration.</li>
<li>Test execution, both on a schedule and on-demand.</li>
<li>Monitoring and alerting to bubble up data quality issues.</li>
</ul>
<p>A data quality test framework is a critical part of a data platform, giving
confidence in the results produced by all workloads running on the platform.</p>
</div>
]]></description>
             <pubDate>Fri, 13 Nov 2020 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/10/08/azure-data-engineering.html</link>
            <guid>http://vladris.com/blog/2020/10/08/azure-data-engineering.html</guid>
            <title><![CDATA[Azure Data Engineering]]></title>
            <description><![CDATA[<h1>Azure Data Engineering</h1>
<p>I am happy to announce that my new book, <a class="reference external" href="https://www.manning.com/books/azure-data-engineering">Azure Data Engineering</a>,
launched in Manning Early Access Preview (MEAP). While still a work in progress,
the first chapters are available online. As I keep working on the book and
polishing the draft, more chapters will be added, and existing chapters will be
updated. That being said, the preview is now live.</p>
<img alt="../../../_images/book.png" class="align-center" src="http://vladris.com/blog/_images/book.png"/>
<p>For the past few years, I had the opportunity to work as the architect for
Azure’s growth team. Ron Sielinski, our director of data science, describes how
our team uses Azure to understand Azure in <a class="reference external" href="https://medium.com/data-science-at-microsoft/using-azure-to-understand-azure-1c8f5dc60a0a">this great article</a>
on our <a class="reference external" href="https://medium.com/data-science-at-microsoft">Data Science @ Microsoft</a>
Medium publication.</p>
<p>Our engineering team maintains a big data platform, built fully on Azure, which
supports all our team’s workloads. After we launched our Medium publication, I
contributed a bunch of articles describing some of our infrastructure,
challenges, and solutions. I talked about how we use <a class="reference external" href="https://medium.com/data-science-at-microsoft/azure-data-explorer-at-the-azure-business-scale-89262ef8c1fd">Azure Data Explorer</a>,
how we enabled <a class="reference external" href="https://medium.com/data-science-at-microsoft/how-we-built-self-serve-data-environment-tools-with-azure-3951a698fc9d">self-serve analytics</a>,
how we scaled out our <a class="reference external" href="https://medium.com/data-science-at-microsoft/running-machine-learning-at-scale-808b90f0ec75?source=friends_link&amp;sk=f89feb151de7645a75fad0b84911c9a6">ML platform</a>,
<a class="reference external" href="https://medium.com/data-science-at-microsoft/common-data-engineering-challenges-and-their-solution-dd51872812ac">common challenges</a>
I noticed across the industry, and <a class="reference external" href="https://medium.com/data-science-at-microsoft/partnering-for-data-quality-dc9123557f8b">data quality</a>.</p>
<p>There are plenty of resources out there covering statistics, data science, and
machine learning, but comparatively little covering the engineering aspects of
working with big data. This book is what I wish I had available to read when
joining the team, to help navigate this complex space and lessons I had to
learn the hard way.</p>
<div class="section" id="the-engineering-in-data-engineering">
<h2>The “engineering” in data engineering</h2>
<p>While many data science projects start as exploratory, once they show real
value, they need to be supported in an ongoing, reliable fashion. In the
software engineering world, this is the equivalent of taking a research,
proof of concept, or hackathon project and graduating it into a fully
production-ready solution. While a hack or a prototype can cut many shortcuts
and focus on “the meat of the problem” it addresses, a production-ready
system does not cut any corners. This is where the engineering part of
software engineering comes into play: the engineering rigor to build and run
a reliable system. This includes a plethora of concerns like architecture and
design, performance, security, accessibility, telemetry, debuggability,
extensibility and so on.</p>
<blockquote>
<div><strong>Data engineering</strong> is the part of data science dealing with the practical
applications of collecting and analyzing data. It aims to bring engineering
rigor to the process of building and supporting reliable data systems.</div></blockquote>
<p>Data engineering is surprisingly similar to software engineering and
frustratingly different. While we can leverage a lot of the learnings from
the software engineering world, as we will see in this book, there is a
unique set of challenges we will have to address. Some of the common themes
are making sure everything is tracked in source control, automatic
deployments, monitoring and alerting. A key difference between data and code
is that code is static: once the bugs are worked out, a piece of code is
expected to consistently work reliably. On the other hand, data moves
continuously into and out of a data platform and it is very likely for
failures to occur due to various external reasons. Governance is another
major topic which is specific to data: access control, cataloguing, privacy,
and regulatory concerns are a big part of a data platform.</p>
<p>The main theme of the book is bringing some of the lessons learned from data
engineering over the past few decades to the data space, so you can build a
data platform exhibiting the properties of a solid software solution: scale,
reliability, security, and so on.</p>
</div>
<div class="section" id="anatomy-of-a-big-data-platform">
<h2>Anatomy of a big data platform</h2>
<p>A big data platform ingests data from multiple sources into a storage layer.
Data is consumed from the storage layer to enable various workloads (data
modeling, analytics, machine learning). Data is then distributed downstream
to consumers. All the activity in a data platform needs to be orchestrated by
an orchestration layer. Governance is extremely important. And, of course,
DevOps is the key: deploying everything from source control.</p>
<img alt="../../../_images/platform.png" class="align-center" src="http://vladris.com/blog/_images/platform.png"/>
<p>The book is divided in 3 parts, each part looking at a big data platform through
a different lens:</p>
<ul class="simple">
<li>Part 1 of the book will focus on <strong>infrastructure</strong>, the core services of a
data platform.<ul>
<li>We will start with <strong>storage</strong>, the backbone of any data platform. Chapter 2
will cover the requirements and common patterns for storing data in a data
platform.</li>
<li>Since our focus is on production systems, in chapter 3 we’ll discuss
<strong>DevOps</strong> and what DevOps means for data.</li>
<li>Data is ingested into the system from multiple sources. Data flows into and
out of the platform and various workflows are executed. All of this needs an
orchestration layer to keep things running. We will talk about
<strong>orchestration</strong> in chapter 4.</li>
</ul>
</li>
<li>Part 2 will focus on the 3 main <strong>workloads</strong> that a data platform must
support:<ul>
<li><strong>Modeling</strong>: this includes aggregating and reshaping the data,
standardizing schema, and any other processing of the raw input data. This
makes the data easier to consume by the other two main processes: analytics
and machine learning. We will talk about data modeling in chapter 5.</li>
<li><strong>Analytics</strong>: this covers all analysis and reporting on the data, deriving
knowledge and insights. We will look at ways to support this in production
in chapter 6.</li>
<li><strong>Machine learning</strong>: these are all machine learning models training on the
data. We cover running ML at scale in chapter 7.</li>
</ul>
</li>
<li>Part 3, <strong>governance</strong>, is a major topic with many aspects. We will cover
governance in chapters 8, 9, and 10, touching on the key topics:<ul>
<li><strong>Metadata</strong>: cataloguing and inventorying the data, tracking lineage,
definitions and documentation is the subject of chapter 8.</li>
<li><strong>Data quality</strong>: how to test data and asses its quality is the topic of
chapter 9.</li>
<li><strong>Compliance</strong>: honoring complying requirements like the General Data
Protection Regulation (GDPR), handling sensitive data, and controlling
access is covered in chapter 10.</li>
<li>After all the processing steps, data eventually leaves the platform to be
consumed by other systems. We will cover the various patterns for
<strong>distributing data</strong> in chapter 11.</li>
</ul>
</li>
</ul>
<p>The examples in the book are built on Azure, using a specific set of
technologies, but the patterns should apply regardless of specific tech choices
or even cloud providers. Check out the book <a class="reference external" href="https://www.manning.com/books/azure-data-engineering">here</a>
and follow me on <a class="reference external" href="linkedin.com/in/vladris/">LinkedIn</a> or <a class="reference external" href="https://twitter.com/vladris">Twitter</a>
for updates.</p>
<p>Also posted on <a class="reference external" href="https://medium.com/@vladris/azure-data-engineering-8b5280a12048">Medium</a>.</p>
</div>
]]></description>
             <pubDate>Thu, 08 Oct 2020 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/04/27/machine-learning-at-scale.html</link>
            <guid>http://vladris.com/blog/2020/04/27/machine-learning-at-scale.html</guid>
            <title><![CDATA[Machine Learning at Scale]]></title>
            <description><![CDATA[<h1>Machine Learning at Scale</h1>
<p>This is a cross-post of the article I wrote for Data Science @ Microsoft,
<a class="reference external" href="https://medium.com/data-science-at-microsoft/running-machine-learning-at-scale-808b90f0ec75">Running machine learning at scale</a>.</p>
<p>Our team runs dozens of production machine learning models on a daily,
weekly, and monthly basis. We recently went through a redesign of our ML
infrastructure to increase its abilities to enable self-serve, scale to match
computing needs, reduce impacts among models running on the same VM, and
remove differences between dev and production environments. In this post, I
will describe the challenges we faced with the previous infrastructure and
how we addressed them with our Version 2 architecture.</p>
<div class="section" id="version-1">
<h2>Version 1</h2>
<p>Our machine learning engineers use Python and R to implement models. Our
Version 1 infrastructure used a custom XML format from which we generated
Azure Data Factory (ADF) v1 pipelines to copy the model input data to blob
storage. Then the models ran on a set of VMs our team maintained. The models
read their input from and wrote their output back to blob storage. The ADF
pipelines then copied the outputs to <a class="reference external" href="https://vladris.com/blog/2020/03/01/azure-data-explorer.html">Azure Data Explorer</a>
and to our data distribution Data Lake.</p>
<img alt="../../../_images/v1.png" class="align-center" src="http://vladris.com/blog/_images/v1.png"/>
<p><em>The Control VM consumes XML from Git and generates ADF pipelines to
orchestrate data movement and run ML code on a set of VMs.</em></p>
<p>The V1 infrastructure had several challenges we set out to overcome:</p>
<ul class="simple">
<li><strong>No self-serve</strong>: Much like how we <a class="reference external" href="https://vladris.com/blog/2020/02/01/self-serve-analytics.html">implemented a self-serve environment
for analytics</a>,
we wanted to do something similar for machine learning, so our ML engineers
can create and deploy models without needing help from the data engineering
team.</li>
<li><strong>Auto-scaling</strong>: We have some compute-intensive models that run on a certain
day of the month when upstream datasets become available. For a few days, we
need large compute. Then, until the next month, our compute needs decrease
significantly. The V1 infrastructure didn’t account for this and we had a
constant number of VMs running at all times.</li>
<li><strong>Isolation</strong>: We used to pack multiple models on the same VM, so if one of
them consumed, for example, too much RAM, it would impact all the other
models running on the same VM. We needed better isolation.</li>
<li><strong>Differences between dev and prod environments</strong>: One issue we kept hitting
involved models that ran fine on the ML engineer’s VM but failed when
moving to production because of environment differences such as missing
packages.</li>
</ul>
<p>The combination of these issues created significant operational costs for the
data engineering team: VM management, scaling issues, and having to re-run
models that failed because of either resource constraints or bugs caused by
missing packages in the production environment. As our machine learning
engineers develop more and more models, we decided to invest in making our
infrastructure more robust, scalable, and self-serve.</p>
</div>
<div class="section" id="version-2">
<h2>Version 2</h2>
<p>Our Version 2 infrastructure aims to address all these issues and provide a
scalable, self-serve platform for machine learning. Built fully on Azure, it
is made up of the following components, which we’ll discuss in turn:</p>
<ul class="simple">
<li>Orchestration</li>
<li>Storage and distribution</li>
<li>Compute</li>
<li>DevOps</li>
<li>Monitoring and alerting</li>
</ul>
<img alt="../../../_images/v2.png" class="align-center" src="http://vladris.com/blog/_images/v2.png"/>
<p><em>ADF pipelines deployed from Git orchestrate data movement and running ML
code, also deployed from Git, on Azure Machine Learning. Data is distributed
through ADLS. The system is monitored using Azure Monitor.</em></p>
<div class="section" id="orchestration">
<h3>Orchestration</h3>
<p>For orchestration, we use Azure Data Factory V2. In contrast to our V1
infrastructure, we don’t use XML to generate pipelines, rather we provide a
set of <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-factory/solution-templates-introduction">templates</a>
that ML engineers can use to author the pipelines themselves. We have a dev
ADF and a production one.</p>
<p>In general, an end-to-end machine learning pipeline has three steps: Move
inputs, kick off compute, and move outputs. Templates make it easy to create
and configure a pipeline.</p>
<p>We use <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-factory/continuous-integration-deployment">CI/CD for ADF</a>:
The dev ADF instance is synced with Git, and so an ML engineer can submit a
pull request for review. Once approved and merged to master, ADF generates
the ARM template we use to deploy the production ADF instance.</p>
<p>The two data factories are similar, except that they are connecting to
different environments: Dev to the development storage and compute, and
production to the production storage and compute, which is locked down. This
addresses one of the limitations of our V1, as we now have similar dev and
production environments and so graduating a model from dev to production is
much more seamless.</p>
</div>
<div class="section" id="storage-and-distribution">
<h3>Storage and distribution</h3>
<p>For storage, we switched from blob to Azure Data Lake Storage (ADLS) gen2.
ADLS gen2 is backed by blob storage, with a couple of important additional
features: A hierarchical file system and granular access control. Both are
key to our infrastructure.</p>
<p>The hierarchical file system allows us to create a common folder structure
for our models, with separate folders for inputs and outputs for each run.
The granular access control allows us to enforce who gets to see what data.
This is an important aspect of our platform, since some models are trained on
sensitive information such as Microsoft revenue that not everyone can view.</p>
<p>Because we are already distributing data through ADLS, we can skip a copy
step: Instead of moving the model output to our data distribution Data Lake,
we can share it in place, applying proper access control. The less data moves
around, the less opportunity for issues in our system and the less network
bandwidth our platform needs to use.</p>
</div>
<div class="section" id="compute">
<h3>Compute</h3>
<p>Compute is our biggest upgrade from V1: Instead of maintaining VMs, we
switched to using <a class="reference external" href="https://azure.microsoft.com/en-us/services/machine-learning/">Azure Machine Learning</a> (AML). This
is an important switch from IaaS to PaaS, where a lot of the infrastructure
we spent time maintaining is now provisioned and handled by AML.</p>
<p>AML addresses two of the main problems we set out to solve: Auto-scaling and
isolation for our models. We can run each model on dedicated compute and then
AML <a class="reference external" href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-set-up-training-targets#run-based-creation">takes care of spinning up the resources required for a run</a>,
winding them down once the run is over.</p>
<p>Because the configuration for compute is done via code, the dev and
production environments are identical, meaning we don’t run into any issues
when graduating a model to production. We can also select the size of compute
we want via this configuration, and so a model that is more resource
intensive can be configured to run with more RAM and/or more CPU power. AML
also gives us statistics on CPU and memory usage, which helps us right-size
compute for each model.</p>
</div>
<div class="section" id="devops">
<h3>DevOps</h3>
<p>Both ADF and AML are synced with Git and deployed via two Azure DevOps
<a class="reference external" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/release/?view=azure-devops">release pipelines</a>.
One of them updates the production ADF instance, the other updates the AML
production instance. We split the two because updating model code doesn’t
require any updates to the orchestration. This means, for example, that for a
model bug fix it is enough to deploy to AML without touching the Data
Factory.</p>
<img alt="../../../_images/devops1.png" class="align-center" src="http://vladris.com/blog/_images/devops1.png"/>
<p>Having everything in Git enables self-serve, and brings in the required
engineering rigor: Changes are done through pull requests, we have a code
review process, we don’t make manual changes in the production environment,
we have a history of all the changes, and we can rebuild an environment from
scratch if needed.</p>
</div>
<div class="section" id="monitoring-and-alerting">
<h3>Monitoring and alerting</h3>
<p>We are running a production system, and so monitoring and alerting are key
components. For monitoring, we use Azure Monitor/Log Analytics. ADF
orchestrates all our model runs and it <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-factory/monitor-using-azure-monitor">integrates natively</a>
with Azure Monitor, where we can define alerts for pipeline failures.</p>
<p>For alerting, we use IcM, the Microsoft-wide incident tracking system.
Pipeline failures generate incident tickets, which alert engineering of live
site issues, like all Azure production services. We are also providing a
Power BI dashboard where stakeholders can see the status of all models.</p>
<p>Monitoring and alerting help us maintain our service-level agreements and
operational excellence.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this article we looked at our Version 2 machine learning infrastructure,
going over its key components:</p>
<ul class="simple">
<li>We use Azure Data Factory to orchestrate all data movement and model runs.</li>
<li>We use Azure Data Lake Storage to store both model inputs and outputs,
which allows us to implement granular access control and easily distribute
the data to teams downstream.</li>
<li>We use Azure Machine Learning for compute, which enables auto-scaling and
isolation for model runs.</li>
<li>We use Azure DevOps to deploy from Git, which enables self-serve and
reproducibility.</li>
<li>We use Azure Monitor for production environment monitoring and alerting.</li>
</ul>
<p>This cloud-native architecture allows us to reliably run ML at scale with a
self-serve environment for our machine learning team, increasing their
productivity while decreasing the resources we need to spend.</p>
</div>
]]></description>
             <pubDate>Mon, 27 Apr 2020 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/03/01/azure-data-explorer.html</link>
            <guid>http://vladris.com/blog/2020/03/01/azure-data-explorer.html</guid>
            <title><![CDATA[Azure Data Explorer]]></title>
            <description><![CDATA[<h1>Azure Data Explorer</h1>
<p>This is a cross-post of the article I wrote for Data Science @ Microsoft,
<a class="reference external" href="https://medium.com/data-science-at-microsoft/azure-data-explorer-at-the-azure-business-scale-89262ef8c1fd">Azure Data Explorer at the Azure business scale</a>.</p>
<p>As I mentioned in my previous post, <a class="reference external" href="https://vladris.com/blog/2020/02/01/self-serve-analytics.html">“Self-Serve Analytics”</a>,
our team uses Azure Data Explorer (ADX) as our main data store. In this post, I will delve deeply into how we use ADX.</p>
<div class="section" id="use-case">
<h2>Use Case</h2>
<p>The <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-explorer">ADX documentation</a>
describes it as “a fast, fully managed data analytics service for real-time
analysis on large volumes of data streaming from applications, websites, IoT
devices, and more.” ADX streams terabytes of data and enables real-time
analytics to be performed on it. In many cases, this ADX-enabled data is used
in the context of ingesting and analyzing telemetry from various services or
endpoints. Our use case for ADX is different: We use it as the main data store
for our big data platform.</p>
<p>We rely on the ingestion capabilities of ADX to pull in terabytes of data
pertaining to the Azure business from various sources. Our data science team
then leverages the fast query capabilities offered by ADX to explore the data
in real time and perform modeling work, which leads to a better understanding
of our customers.</p>
<p>Some of the data points our team uses are already stored in ADX when we
access them, in different clusters managed by other teams. We use the
<a class="reference external" href="https://docs.microsoft.com/en-us/azure/kusto/query/cross-cluster-or-database-queries?pivots=azuredataexplorer">cross-cluster query capabilities</a>
provided by ADX to join these external data sets with local data.</p>
<p>Our engineering team also relies on the same fast query capabilities of ADX
to power some of our web APIs.</p>
</div>
<div class="section" id="ingestion">
<h2>Ingestion</h2>
<p>We have a well-defined process to bring new data sets into our cluster.
First, we take a one-time snapshot of a potential data set and store it in a
separate cluster (our <em>acquisition</em> cluster), where access is even further
restricted to the small set of individuals tasked with exploring this new
data set. This initial exploration gives us a good sense of which parts of
the data are useful for ingesting on a regular cadence, and what our data
model should look like. We can then create a data contract with the upstream
team to define SLAs and start automating the data pull.</p>
<p>All data movement is set up in <a class="reference external" href="https://azure.microsoft.com/en-us/services/data-factory/">Azure Data Factory</a>
and actively monitored.</p>
</div>
<div class="section" id="devops-and-analytics">
<h2>DevOps and Analytics</h2>
<p>As I mentioned in my <a class="reference external" href="https://vladris.com/blog/2020/02/01/self-serve-analytics.html">previous post</a>
on our data environment, we use the <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-explorer/devops">Azure DevOps ADX Task</a>
to deploy objects from git. Tables are set up using a <span class="docutils literal"><span class="pre">.create-or-merge</span> <span class="pre">table</span></span>
script while functions are set up using a <span class="docutils literal"><span class="pre">.create-or-alter</span> <span class="pre">function</span></span> script.
Both commands are idempotent so we can replay them even if objects already
exist.</p>
<p>As a team, we’ve standardized on ADX functions for analytics, so all the
reports, KPIs, and metrics our team produces end up implemented as functions
stored in git and deployed using Azure DevOps. The ability to organize
objects in a folder structure helps us group them by focus area.</p>
</div>
<div class="section" id="customer-model">
<h2>Customer Model</h2>
<p>Not only do we ingest large amounts of data into our main ADX cluster, we are
also processing and enhancing it to build what we call the <em>customer model</em>.</p>
<p>The customer model consists of three components:</p>
<ul class="simple">
<li>A <em>keyring</em>, which helps us tie together various identifiers used across the
business, enabling us to understand, for example, which company a
subscription belongs to.</li>
<li>A set of <em>customer properties</em>, which you can think of as key-value pairs
attached to an identity in our system.</li>
<li>An <em>activity model</em>, which represents a timeline view of various relevant
events for an identity in our system. For example, for a subscription
identifier we have events such as “created” and “closed”.</li>
</ul>
<img alt="../../../_images/customer-model.png" class="align-center" src="http://vladris.com/blog/_images/customer-model.png"/>
<p><em>We use a set of Logic Apps and CosmosDB to process and enhance raw data into
our customer model, which consists of a keyring, customer properties, and an
activity model.</em></p>
<p>The customer model is continuously updated as we ingest new data points and
represents an enhanced view of the raw data. It is implemented as a small set
of (very large) tables and multiple functions to improve navigation. The
expressive ADX function syntax allows us to create functions that can be
combined to produce very complex queries of the data model.</p>
<p>The workflow of building the model is orchestrated by <a class="reference external" href="https://azure.microsoft.com/en-us/services/logic-apps/">Logic Apps</a>,
which run ADX functions to join and enhance the raw data. The keyring is an
exception: We build it using <a class="reference external" href="https://docs.microsoft.com/en-us/azure/cosmos-db/introduction">CosmosDB</a>,
namely the <a class="reference external" href="https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction">Gremlin API</a>,
which can perform graph traversal. We load all identifiers as vertices and
known connections as edges, and then we group each connected component of the
graph into a key group. This gives us the association across all identities
within our system. The output is written back to ADX.</p>
<p>We consume the customer model through ADX functions. As an example, the
<span class="docutils literal"><span class="pre">GetRelatedKeysByType()</span></span> function takes as arguments an identifier value and
an identifier type name and returns all identifiers related to it from the
keyring. We can pass the result of this call to the <span class="docutils literal"><span class="pre">GetActivities()</span></span>
function, which also takes as arguments a <span class="docutils literal"><span class="pre">startDate</span></span> datetime and an
<span class="docutils literal"><span class="pre">endDate</span></span> datetime, to get all activities for the given ID group within that
time range.</p>
<p>Different activities are described by different properties. For example, a
<em>subscription created</em> activity contains, among other things, an Offer ID, an
Offer Type, and a flag indicating whether the subscription was created as a
trial. As another example, a <em>daily usage</em> activity contains the name of the
sold service and consumption units. We use the ADX <a class="reference external" href="https://docs.microsoft.com/en-us/azure/kusto/query/packfunction">pack()</a>
function to store these properties as dynamic objects in the underlying data
model, allowing us to maintain a standard schema.</p>
</div>
<div class="section" id="compliance">
<h2>Compliance</h2>
<p>Because we store some high business impact data sets, such billing data for
Azure services, we must govern who can see different parts of the data. We
set role-base access control (RBAC) at the database level, so we can place
sensitive data sets in dedicated databases.</p>
<p>We can also mark tables as <em>restricted</em>, which limits users to those with the
<a class="reference external" href="https://docs.microsoft.com/en-us/azure/kusto/management/access-control/role-based-authorization">UnrestrictedViewer role</a>.
In ADX, a Viewer role can view any table in a database except those marked as
restricted. The UnrestrictedViewer role can view any table in a database
regardless of whether it is restricted or not. The ADX team is also working
on enabling table-level access control, which will allow even more granular
RBAC assignments.</p>
<p>We are also leveraging ADX retention policies to ensure data doesn’t stick
around forever. In some cases, this is a requirement of the Microsoft data
handling standards that are mandatory across the company. In other cases, we
ensure prototypes and proofs-of-concept are cleaned up so they don’t make
their way into our production boundary. I detailed this in my <a class="reference external" href="https://vladris.com/blog/2020/02/01/self-serve-analytics.html">previous post</a>,
where I discussed how we move analytics from the prototype Scratch database
(with its 30-day retention policy) to WorkArea and then to Production.</p>
</div>
<div class="section" id="scaling-out">
<h2>Scaling Out</h2>
<p>As more and more workloads are served by our main ADX cluster, we need to
start thinking about performance and scale. We are addressing this in two
main ways: With our approach to data distribution and by looking into follow
clusters.</p>
<img alt="../../../_images/scale-out.png" class="align-center" src="http://vladris.com/blog/_images/scale-out.png"/>
<p><em>Scaling out from a single ADX cluster serving all workloads to multiple
follow clusters supporting different workloads and ADLS for low frequency,
high volume data movement.</em></p>
<p>We used to simply grant access to our data in ADX to teams interested in
consuming it. The problem with this approach is that external teams might end
up running expensive queries against our cluster and disrupt other
operations. This happened frequently in the common scenario of bulk data
movement of the large data sets our team produces. Because of this, we are no
longer granting access to any service principles to ADX. We allow individuals
to come in and explore our data sets but when they want to start copying it
on a regular cadence, we use a different storage solution: <a class="reference external" href="https://azure.microsoft.com/en-us/services/storage/data-lake-storage/">Azure Data Lake
Storage</a>
(ADLS).</p>
<p>Because our data sets are updated on a daily, weekly, or monthly cadence, we
only need to copy them to ADLS once after an update, and then other teams can
pick them up from there without having an impact on the performance of our
ADX cluster. ADLS provides large scale storage at very low cost, so it is
ideal for this scenario.</p>
<p>The other scaling method we are considering is setting up <a class="reference external" href="https://docs.microsoft.com/en-us/azure/kusto/management/cluster-follower">follow clusters</a>.
A follower cluster can replicate data from the followed cluster, which would
enable us to offload some workloads to separate compute. By default,
everything is followed, which is redundant for the amount of data we have,
but a follower can be configured to mirror only a subset of the followed
data. We can do this by starting with a caching policy of 0 (which prevents
any data replication), and then selectively overwrite it for the databases
and tables we want to replicate.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post, I’ve discussed our team’s use of Azure Data Explorer:</p>
<ul class="simple">
<li>Many of our scenarios involve data exploration. That activity, combined with
the large data ingestion and cross-cluster capabilities of ADX, makes ADX a
great data store solution.</li>
<li>We bring data into our cluster via a clearly defined process so that data
loads can be consistently performed and monitored.</li>
<li>We use DevOps to deploy objects to production from git.</li>
<li>We enhance our raw data with a Customer Model, a curated data set consisting
of three major pieces: A keyring, a set of customer properties, and an
activity model. We use ADX functions as an interface to this data set.</li>
<li>For compliance, we place data in different databases depending on its
classification, and we have granular access control for each database.</li>
<li>Scaling out, we offload large copy jobs to Azure Data Lake Storage, and we
can create follow clusters to partition the compute load.</li>
</ul>
</div>
]]></description>
             <pubDate>Sun, 01 Mar 2020 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/02/01/self-serve-analytics.html</link>
            <guid>http://vladris.com/blog/2020/02/01/self-serve-analytics.html</guid>
            <title><![CDATA[Self-Serve Analytics]]></title>
            <description><![CDATA[<h1>Self-Serve Analytics</h1>
<p>This is a cross-post of the article I wrote for Data Science @ Microsoft,
<a class="reference external" href="https://medium.com/data-science-at-microsoft/how-we-built-self-serve-data-environment-tools-with-azure-3951a698fc9d">How we built self-serve data environment tools with Azure</a>.
Many thanks to my colleague Casey Doyle for editing this into good shape.</p>
<p>Our team not only helps the engineering org build Azure - we use it, too, in
our data science work. Our team consists of program managers, data
scientists, and data engineers. In this post I describe how our data
engineering team developed a scalable, self-serve analytics platform for our
data science organization.</p>
<p>We maintain a big data platform with all the required data points to view and
understand the Azure business. While we work with multiple data fabrics (such
as Azure SQL and Azure Data Lake Storage), our main storage solution is Azure
Data Explorer (ADX). We use ADX for several reasons, but two key ones involve
the scale of the data we are dealing with and the exploratory nature of the
work our data scientists are doing. ADX excels at quickly running queries
across huge volumes of data.</p>
<div class="section" id="reproducibility">
<h2>Reproducibility</h2>
<p>When we were a small team, data scientists produced ad hoc reports and
analyses, building queries and running them from their own machines. This
worked for a while, but soon we hit issues of reproducibility: If a set of
queries exists only on one person’s machine and that person goes on vacation,
nobody else on the team can reproduce their work.</p>
<p>Of course, this is a well known issue in the software engineering world, with
an industry-standard solution: Source control. As a first step, we asked
everyone on the team to use Git to store their ADX scripts. This not only
enabled capturing “canonical” queries in a public repository, it also allowed
us to adopt other good practices such as mandatory code reviews.</p>
<p>Bringing engineering best practices to analytics was the first step toward a
reliable analytics platform.</p>
</div>
<div class="section" id="environments">
<h2>Environments</h2>
<p>Another problem we ran into was around the interdependencies among various
data sets. Some reports or metrics took dependencies on the output of other
metrics. But consider a situation in which the dependent metric consists of
one-off exploratory output, while the other is a monthly report. Without a
systematic way of keeping track of what depends on what, things start to look
like Jenga - maybe a critical piece of an important artifact disappears
because the original author didn’t realize anyone cared about it.</p>
<p>To solve this problem, we split our ADX cluster into three different
environments: Scratch, Work Area, and Production.</p>
<img alt="../../../_images/areas.png" class="align-center" src="http://vladris.com/blog/_images/areas.png"/>
<p><em>Changes flow from Scratch to Work Area to Production. Production is read-only
for everyone except engineering.</em></p>
<p><em>Scratch</em> is an area open to everyone on the team to do anything they want,
with one important rule: No production dependencies are allowed. Scratch is
used for prototyping, proof-of-concepts, and other exploratory work. To
enforce this, we set a 30-day <a class="reference external" href="https://docs.microsoft.com/en-us/azure/kusto/management/retention-policy">retention policy</a>.
This ensures that nothing beyond prototypes exists there. Only our team has
access to this area.</p>
<p><em>Work Area</em> is the place data scientists use once they are done prototyping and
have a good idea of what they need to do next. They still have full access to
Work Area but unlike Scratch, data scientists can share work-in-progress with
external stakeholders for user acceptance testing. If the artifact is a
one-time analysis, it stops here. If it is recurring, for example a monthly
report, it graduates to Production.</p>
<p><em>Production</em> is a locked down environment and only a few data engineers have
Write access to it. This is the equivalent of a production services
environment, where access is restricted such that nobody can accidentally
cause an impact to a live application. In our case, nobody can accidentally
modify a recurring report or key metric others depend on.</p>
<p>Moving work from Scratch to Work Area to Production ensures dependencies can
only flow in one direction (Scratch can depend on something in Production,
but not vice versa). Quality gates like mandatory code reviews ensure that
whatever makes it to Production meets a high quality bar.</p>
<p>We also created explicit guidelines for what should go into Production:
Queries should be packaged into functions, tables and functions should be
created with <span class="docutils literal"><span class="pre">.create-or-alter</span></span>, and so on.</p>
</div>
<div class="section" id="self-serve">
<h2>Self-Serve</h2>
<p>Because the Production environment is restricted to data engineers,
graduating something to Production first involved a hand-off process: A data
scientist would have to ask the data engineering team to create or update an
entity in the Production environment. This usually meant creating a work item
that had to be prioritized against others.</p>
<p>Our data engineering team is much smaller than our data science organization
(we have about one engineer for every five data scientists), and so this
approach didn’t scale very well. To optimize this, we invested in enabling a
self-serve model.</p>
<p>We created an <a class="reference external" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/release/?view=azure-devops">Azure DevOps release pipeline</a>
that uses the <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-explorer/devops">ADX Task</a>
to execute ADX scripts in the git repo against the Production database. We
release from the master branch, but in order for a new script to make it to
master, it must be submitted as a pull request and code review signoff is
required from a member of the engineering team.</p>
<p>With this model, data scientists send a pull request and, once reviewed by a
maintainer of the Production environment, it is automatically merged and
deployed. In contrast to the original hand-off process (via work items),
engineering involvement can be as simple as approving a pull request. The
code review process still ensures that the engineers who operate the
Production environment have a say in what makes it into that environment and
can always request changes to scripts if they believe, for example, a query
can be further optimized.</p>
</div>
<div class="section" id="data-movement">
<h2>Data Movement</h2>
<p>Similar to the analytics needs described above, we needed to orchestrate data
movement. This includes copying data from external sources into our ADX
cluster and running functions on a schedule to produce reports.</p>
<p>Production data movement was originally operated by the engineering team, and
so requests again used to come in the form of work items to be prioritized
and scheduled. But because our data scientists are familiar with <a class="reference external" href="https://azure.microsoft.com/en-us/services/data-factory/">Azure Data
Factory</a> (ADF) and
use it for data movement in the Work Area environment, we realized we could
enable self-serve capabilities for data movement too, by leveraging the <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-factory/continuous-integration-deployment">ADF
continuous integration and delivery setup</a>.
This way, scientists can create ADF pipelines and submit pull requests that
engineers deploy to production.</p>
<p>We are using <a class="reference external" href="https://azure.microsoft.com/en-us/services/monitor/">Azure Monitor</a>
integrated with IcM, the company-wide incident management system, to monitor
the production pipelines. Azure Monitor <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-factory/monitor-using-azure-monitor">integrates natively with ADF</a>.
Our support model entails the engineering team looking at tickets generated by
pipeline failures, which are then restarted to recover from transient issues.
In case of persistent failures, we involve the original pipeline authors to
help debug. This way, the engineering team operates all Production data
movement without having full ownership of the pipelines.</p>
<img alt="../../../_images/devops.png" class="align-center" src="http://vladris.com/blog/_images/devops.png"/>
<p><em>We deploy both Kusto objects and Data Factory pipelines from ADO git using
ADO pipelines. The Production environment is operated by engineering.</em></p>
</div>
<div class="section" id="data-contracts">
<h2>Data Contracts</h2>
<p>But there is still more to it than just deploying and monitoring ADF
pipelines: Bringing external data into the production area of our cluster
means taking an upstream dependency on that data. There are several
properties to be defined for such a dependency, including things like the
service level agreement (SLA) with the upstream provider and the data
classification, which ensures our system stays compliant. The topic of
maintaining compliance in a big data platform deserves an article by itself,
so I won’t go into details in this one. The key point is that in this case,
self-serve is not enough - we also need data contracts.</p>
<p>A <em>data contract</em> specifies all the details of a dependency, whether upstream
or downstream of our platform. As part of the quality gates for pull
requests, we thoroughly review proposed pipelines and in general we don’t
allow new <a class="reference external" href="https://docs.microsoft.com/en-us/azure/data-factory/connector-overview">connectors</a>
to be added with this model. A new connector implies a new dependency, so
before deploying to production we need to ensure we have a contract in place
and that the connector uses the production service principles the engineering
team is maintaining.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this article we reviewed several of the infrastructure and processes built
by our data engineering team:</p>
<ul class="simple">
<li>We brought engineering rigor to our analytics through source control, code
reviews, and automated deployment.</li>
<li>We enabled self-serve by leveraging Azure
DevOps.</li>
<li>We similarly enabled self-serve for data movement using ADF CI/CD.</li>
<li>We have processes in place to ensure our data is compliant and that production
dependencies are properly documented.</li>
</ul>
<p>More importantly, we achieved all of the above without maintaining any custom
application code: Our entire solution is built on Azure PaaS services, which
frees up our engineering team to tackle other challenges, ones we will
discuss in future articles.</p>
</div>
]]></description>
             <pubDate>Sat, 01 Feb 2020 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2020/01/19/time-and-complexity.html</link>
            <guid>http://vladris.com/blog/2020/01/19/time-and-complexity.html</guid>
            <title><![CDATA[Time and Complexity]]></title>
            <description><![CDATA[<h1>Time and Complexity</h1>
<p>2020 being a leap year, it’s a good opportunity to talk about how we track
time. We’ll start with that, but this post is as a reflection on the inherent
complexity of the physical world and human societies.</p>
<p>There is a famous blog post, <a class="reference external" href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">Falsehoods programmers believe about time</a>,
which covers some well known pitfalls like <em>years have 365 days</em> or
<em>February is always 28 days long</em>. Unfortunately, a lot of software has such
assumptions hardcoded and things go awry.</p>
<p>But before talking about software, let’s step back and look at how we measure
time.</p>
<div class="section" id="atomic-clocks">
<h2>Atomic Clocks</h2>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Atomic_clock">Atomic clocks</a> provide an
extremely precise measure of the passage of time. These clock don’t gain or
lose a single second over hundreds of millions of years. These devices are
beautiful: they can provide a monotonic count of the passage of time with an
incredible precision.</p>
<p>In fact, we have the <a class="reference external" href="https://en.wikipedia.org/wiki/International_Atomic_Time">International Atomic Time</a> standard, or TAI,
which is defined, according to Wikipedia, by the weighted average of 400
atomic clocks from over 50 laboratories across the world. This is an
extremely precise measure of time passing on Earth.</p>
<p>It is also not practical enough to be used as the basis of our calendars.
Even with a very accurate, high-resolution, atomic clock, we still need to
account for the fact that the Earth orbits around the Sun (so we get
seasons), and spins around its axis (so we get day and night). Let’s see why
there isn’t a simple mathematical function from atomic clock tick to
year-month-day-hour-minute-second.</p>
</div>
<div class="section" id="leap-years">
<h2>Leap Years</h2>
<p>Leap years were introduced to account for the fact that Earth’s orbit around
the Sun is slightly longer than exactly 365 days. Without adjusting for this
fact, the seasons would gradually shift around the calendar. But a leap year
doesn’t necessarily occur every 4 years. Turns out Earth’s orbit is slightly
smaller than 365 days and 6 hours, so adding one day every 4 years would
cause seasons to drift the opposite direction. The leap year rule is actually</p>
<blockquote>
<div>A leap year is every year divisible by 4, except for years divisible by
100, unless they are also divisible by 400.</div></blockquote>
<p>So years like 2020, 2024, 2028 and so on are leap years. But years like 1700,
1800, 1900, are <em>not</em> leap years, because they are divisible by 100. Except
1600, and 2000, which are not only divisible by 100, but also by 400.</p>
<p>We started with a simple model of a precise, monotonic atomic clock measuring
ticks, but when get to user-friendly time, we end up with complex business
rules that aim to account for the physical world. But it gets more
complicated.</p>
</div>
<div class="section" id="leap-seconds-and-standards">
<h2>Leap Seconds and Standards</h2>
<p>If leap years were all there is to it, we could’ve easily mapped an atomic
clock tick to a precise date time value. But it gets more complicated. Turns
out Earth’s rotation is not constant - it is irregular, and trends towards
slow down. Major earthquakes can affect the momentum of the rotation. Tidal
interaction with the moon is also slowing down the speed of rotation over
millions of years.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Universal_Time">UT1</a>, the Universal Time
standard based on Earth’s rotation, is drifting from the <a class="reference external" href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a>, the Coordinated
Universal Time, which uses atomic clocks to measure time. Because of this,
UTC had to introduce leap seconds. A leap second aims to bring UTC time
(based on atomic clock measurements) back in sync with UT1 time (time as
observed astronomically), so they are not more than 1 second apart.</p>
<p>A leap second adds one second to a day, so we end up with a 61 seconds-long
minute. Leap seconds are usually added at the end of the month, UTC time. For
example, on June 30th 2015, the UTC time was, at some point, 23:59:60. This
effectively makes a day 1 second longer.</p>
<p>There is no formula for this: as we measure time both astronomically and
atomically, a standards body decides when a leap second is introduced and
notifies the world every 6 months. In fact, the standard UTC time we use is,
as of the time of this writing, 37 seconds behind the TAI.</p>
</div>
<div class="section" id="other-requirements">
<h2>Other Requirements</h2>
<p>Besides the physical realities of measuring time atomically and
astronomically, we have multiple other requirements.</p>
<p>We have daylight saving time, which moves the clocks forward 1 hour in spring
and 1 hour backward in the fall. This creates a 23 hour-long day in the
spring and a 25 hour-long day in the fall (falsehood programmers believe
about time: <em>all days have 24 hours</em>). This is also not standard across the
world: some countries observe daylight saving while others don’t.</p>
<p>We have time zones, which don’t neatly divide the earth in 24 equal-width
slices, rather are set at geopolitical boundaries. Time zones aren’t even
necessarily multiples of 1 hour: India is 5 hour and 30 minutes ahead of UTC.</p>
<p>Also note that daylight saving and time zones get updated: Russia recently
stopped observing daylight saving while China went from 5 different time
zones to a single one, even though its geography hasn’t changed.</p>
</div>
<div class="section" id="inherent-complexity">
<h2>Inherent Complexity</h2>
<p>Even with an exact atomic clock, when taking into account year length and day
and night cycles, we have to introduce additional rules to determine the date
and time, like leap years and daylight saving. Not only that, international
standards bodies determine when leap seconds occur, while countries are free
to decide which time zone or time zones they are using.</p>
<p>I believe this is typical of any non-trivial problem space we tackle with
software. When we try to model the physical world, things get messy. They get
messier with humans in the system: laws, standards, and expectations
introduce other arbitrary rules. Software needs to be complex to handle the
real world.</p>
</div>
<div class="section" id="accidental-complexity">
<h2>Accidental Complexity</h2>
<p>The above conclusion might seem to stand against pretty much everything I
wrote on this blog, where I try to argue for clean and simple code. Why
bother if any real world piece of software is destined to grow complex? The
reason is that there is enough complexity inherent in dealing with the real
world, without us having to introduce more. We don’t need to make things
worse than they are. To quote a couple of lines from <a class="reference external" href="https://www.python.org/dev/peps/pep-0020/">The Zen of Python</a>:</p>
<blockquote>
<div><p>Simple is better than complex.</p>
<p>Complex is better than complicated.</p>
</div></blockquote>
<p>We try to keep things simple. Sometime simple is not enough, we need complex
solutions to complex problems. But at least let’s not make them complicated.
A clean, well-crafted system, with rules properly encapsulated can still be
fairly easy to work with. If developers introduce additional complexity which
stems not from the problem domain but from coding practices, then the ability
to reason about and maintain the system drops precipitously. This is called
<em>accidental complexity</em>.</p>
<p>We should always ask ourselves whether the complexity we are dealing with is
inherent or accidental. The former is unavoidable, the latter should be
avoided at all cost.</p>
</div>
]]></description>
             <pubDate>Sun, 19 Jan 2020 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/12/27/variance.html</link>
            <guid>http://vladris.com/blog/2019/12/27/variance.html</guid>
            <title><![CDATA[Variance]]></title>
            <description><![CDATA[<h1>Variance</h1>
<p>This blog post is an excerpt from my book, <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>. The code samples
are in TypeScript. If you enjoy the article, you can use the discount code
<strong>vlri40</strong> for a 40% discount on the book.</p>
<div class="section" id="subtyping-relationships">
<h2>Subtyping Relationships</h2>
<p>We know that if <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">extends</span> <span class="pre">Shape</span></span>, then <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of
<span class="docutils literal"><span class="pre">Shape</span></span>. Let’s try to answer a few trickier questions:</p>
<ul class="simple">
<li>What is the subtyping relationship between the sum types <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span></span>
and <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span>?</li>
<li>What is the subtyping relationship between an array of triangles
(<span class="docutils literal"><span class="pre">Triangle[]</span></span>) and an array of shapes (<span class="docutils literal"><span class="pre">Shape[]</span></span>)?</li>
<li>What is the subtyping relationship between a generic data structure like
<span class="docutils literal"><span class="pre">List&lt;T&gt;</span></span>, for <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> and <span class="docutils literal"><span class="pre">List&lt;Shape&gt;</span></span>?</li>
<li>What about the function types <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Shape</span></span> and <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span>?</li>
<li>Conversely, what about the function type <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and
the function type <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span>?</li>
</ul>
<p>These are important questions, as they tell us which of these types can be
substituted for their subtypes. Whenever we see a function that expects an
argument of one of these types, we should understand whether we can provide a
subtype instead.</p>
<p>The challenge in the above examples is that things aren’t as straightforward
as <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">extends</span> <span class="pre">Shape</span></span>. We are looking at types which are defined <em>based</em>
on <span class="docutils literal"><span class="pre">Triangle</span></span> and <span class="docutils literal"><span class="pre">Shape</span></span>. <span class="docutils literal"><span class="pre">Triangle</span></span> and <span class="docutils literal"><span class="pre">Shape</span></span> are either part of
the sum types, or the types of elements of a collection, or a function’s
argument types or return types.</p>
</div>
<div class="section" id="subtyping-and-sum-types">
<h2>Subtyping and Sum Types</h2>
<p>Let’s take the simplest example first, the sum type. Let’s say we have a
<span class="docutils literal"><span class="pre">draw()</span></span> function which can draw a <span class="docutils literal"><span class="pre">Triangle</span></span>, a <span class="docutils literal"><span class="pre">Square</span></span>, or a
<span class="docutils literal"><span class="pre">Circle</span></span>. Can we pass a <span class="docutils literal"><span class="pre">Triangle</span></span> or <span class="docutils literal"><span class="pre">Square</span></span> to it? As you might have
guessed, the answer is “yes”. We can check that such code compiles:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">const</span> <span class="nx">TriangleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Triangle</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">TriangleType</span><span class="p">]</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
    <span class="cm">/* Triangle members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">SquareType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Square</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">SquareType</span><span class="p">]</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
    <span class="cm">/* Square members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">CircleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Circle</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">CircleType</span><span class="p">]</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
    <span class="cm">/* Circle members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeShape</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span> <span class="o">|</span> <span class="nx">Square</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">shape</span>: <span class="kt">Triangle</span> <span class="o">|</span> <span class="nx">Square</span> <span class="o">|</span> <span class="nx">Circle</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>

<span class="nx">draw</span><span class="p">(</span><span class="nx">makeShape</span><span class="p">());</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">makeShape()</span></span> returns a <span class="docutils literal"><span class="pre">Triangle</span></span> or a <span class="docutils literal"><span class="pre">Square</span></span> while <span class="docutils literal"><span class="pre">draw()</span></span>
accepts a <span class="docutils literal"><span class="pre">Triangle</span></span>, a <span class="docutils literal"><span class="pre">Square</span></span> or a <span class="docutils literal"><span class="pre">Circle</span></span> (implementations
omitted).</p>
<p>We enforce nominal subtyping throughout these examples since we’re not
providing full implementations for these types. In practice, they would have
various different properties and methods to distinguish them. We simulate that
with unique symbols for our examples, as leaving the classes empty would make
all of them equivalent due to TypeScript’s <a class="reference external" href="https://en.wikipedia.org/wiki/Structural_type_system">structural subtyping</a>.</p>
<p>As expected, this code compiles. The opposite doesn’t: if we can draw a
<span class="docutils literal"><span class="pre">Triangle</span></span> or a <span class="docutils literal"><span class="pre">Square</span></span> and we attempt to draw a <span class="docutils literal"><span class="pre">Triangle</span></span>, <span class="docutils literal"><span class="pre">Square</span></span>,
or <span class="docutils literal"><span class="pre">Circle</span></span>, the compiler will complain because we might end up passing a
<span class="docutils literal"><span class="pre">Circle</span></span> to the <span class="docutils literal"><span class="pre">draw()</span></span> function, which wouldn’t know what to do with it.
We can confirm that the below code doesn’t compile:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeShape</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span> <span class="o">|</span> <span class="nx">Square</span> <span class="o">|</span> <span class="nx">Circle</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">shape</span>: <span class="kt">Triangle</span> <span class="o">|</span> <span class="nx">Square</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>

<span class="nx">draw</span><span class="p">(</span><span class="nx">makeShape</span><span class="p">());</span>
</pre></div>
</div>
<p>We flipped the types so <span class="docutils literal"><span class="pre">makeShape()</span></span> could also return a <span class="docutils literal"><span class="pre">Circle</span></span>, while
<span class="docutils literal"><span class="pre">draw()</span></span> no longer accepts a <span class="docutils literal"><span class="pre">Circle</span></span>. This no longer compiles.</p>
<p>This means that <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span></span> is a subtype of
<span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span>: we can always substitute a <span class="docutils literal"><span class="pre">Triangle</span></span> or
<span class="docutils literal"><span class="pre">Square</span></span> for a <span class="docutils literal"><span class="pre">Triangle</span></span>, <span class="docutils literal"><span class="pre">Square</span></span>, or <span class="docutils literal"><span class="pre">Circle</span></span>, but not the other way
around. This might seem counterintuitive, since <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span></span> is “less”
than <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span>. Whenever we use inheritance, we end up
with a subtype that has more properties than its supertype. For sum types it
works the opposite way: the supertype has more types than the subtype.</p>
<img alt="../../../_images/sum-types.png" class="align-center" src="http://vladris.com/blog/_images/sum-types.png"/>
<p>Say we have an <span class="docutils literal"><span class="pre">EquilateralTriangle</span></span> which inherits from <span class="docutils literal"><span class="pre">Triangle</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">const</span> <span class="nx">EquilateralTriangleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">EquilateralTriangle</span> <span class="k">extends</span> <span class="nx">Triangle</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">EquilateralTriangleType</span><span class="p">]</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
    <span class="cm">/* EquilateralTriangle members */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As an exercise, check what happens when we mix sum types with inheritance.
Does <span class="docutils literal"><span class="pre">makeShape()</span></span> returning <span class="docutils literal"><span class="pre">EquilateralTriangle</span> <span class="pre">|</span> <span class="pre">Square</span></span> and <span class="docutils literal"><span class="pre">draw()</span></span>
accepting <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span> work? What about <span class="docutils literal"><span class="pre">makeShape()</span></span>
returning <span class="docutils literal"><span class="pre">Triangle</span> <span class="pre">|</span> <span class="pre">Square</span></span> and <span class="docutils literal"><span class="pre">draw()</span></span> accepting
<span class="docutils literal"><span class="pre">EquilateralTriangle</span> <span class="pre">|</span> <span class="pre">Square</span> <span class="pre">|</span> <span class="pre">Circle</span></span>?</p>
</div>
<div class="section" id="subtyping-and-collections">
<h2>Subtyping and Collections</h2>
<p>Now let’s look at types which contain a set of values of some other type. Let’s
start with arrays: can we pass an array of <span class="docutils literal"><span class="pre">Triangle</span></span> objects to a <span class="docutils literal"><span class="pre">draw()</span></span>
function which accepts an array of <span class="docutils literal"><span class="pre">Shape</span></span> objects, if <span class="docutils literal"><span class="pre">Triangle</span></span> is a
subtype of <span class="docutils literal"><span class="pre">Shape</span></span>?</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="cm">/* Shape members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">TriangleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Triangle</span> <span class="k">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">TriangleType</span><span class="p">]</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
    <span class="cm">/* Triangle members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeTriangles</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span><span class="p">[];</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">shapes</span>: <span class="kt">Shape</span><span class="p">[])</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>

<span class="nx">draw</span><span class="p">(</span><span class="nx">makeTriangles</span><span class="p">());</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>. <span class="docutils literal"><span class="pre">makeTriangles()</span></span> returns an array of
<span class="docutils literal"><span class="pre">Triangle</span></span> objects. <span class="docutils literal"><span class="pre">draw()</span></span> accepts an array of <span class="docutils literal"><span class="pre">Shape</span></span> objects. We can
use an array of <span class="docutils literal"><span class="pre">Triangle</span></span> objects as an array of <span class="docutils literal"><span class="pre">Shape</span></span> objects</p>
<p>This might not be surprising, but it is an important observation: <em>arrays
preserve the subtyping relationship of the underlying types they are storing</em>.
As expected, the opposite doesn’t work: if we try to pass an array of <span class="docutils literal"><span class="pre">Shape</span></span>
objects where an array of <span class="docutils literal"><span class="pre">Triangle</span></span> objects is expected, the code won’t
compile.</p>
<img alt="../../../_images/arrays.png" class="align-center" src="http://vladris.com/blog/_images/arrays.png"/>
<p>Arrays are basic types that come out-of-the-box in many programming languages.
What if we define a custom collection, say a <span class="docutils literal"><span class="pre">LinkedList&lt;T&gt;</span></span>?</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>
    <span class="nx">next</span>: <span class="kt">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">append</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LinkedList</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeTriangles</span><span class="p">()</span><span class="o">:</span> <span class="nx">LinkedList</span><span class="o">&lt;</span><span class="nx">Triangle</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">draw</span><span class="p">(</span><span class="nx">shapes</span>: <span class="kt">LinkedList</span><span class="o">&lt;</span><span class="nx">Shape</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>

<span class="nx">draw</span><span class="p">(</span><span class="nx">makeTriangles</span><span class="p">());</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">LinkedList&lt;T&gt;</span></span> is a generic linked list collection. <span class="docutils literal"><span class="pre">makeTriangle()</span></span> now
returns a linked list of traingles. <span class="docutils literal"><span class="pre">draw()</span></span> accepts a linked list of shapes.
This code compiles.</p>
<p>Even without an out-of-the-box type, TypeScript correctly establishes that
<span class="docutils literal"><span class="pre">LinkedList&lt;Triangle&gt;</span></span> is a subtype of <span class="docutils literal"><span class="pre">LinkedList&lt;Shape&gt;</span></span>. Like before,
the opposite doesn’t compile - we can’t pass a <span class="docutils literal"><span class="pre">LinkedList&lt;Shape&gt;</span></span> as a
<span class="docutils literal"><span class="pre">LinkedList&lt;Triangle&gt;</span></span>.</p>
<blockquote>
<div><p><strong>Covariance</strong></p>
<p>A type which preserves the subtyping relationship of its underlying type is
called <em>covariant</em>. An array is covariant, because it preserves the
subtyping relationship: <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, so
<span class="docutils literal"><span class="pre">Triangle[]</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape[]</span></span>.</p>
</div></blockquote>
<p>Various languages behave differently when dealing with arrays and collections
like <span class="docutils literal"><span class="pre">LinkedList&lt;T&gt;</span></span>. For example, in C# we would have to explicitly state
covariance for a type like <span class="docutils literal"><span class="pre">LinkedList&lt;T&gt;</span></span> by declaring an interface and
using the <span class="docutils literal"><span class="pre">out</span></span> keyword (<span class="docutils literal"><span class="pre">ILinkedList&lt;out</span> <span class="pre">T&gt;</span></span>), otherwise the compiler will
not deduce the subtyping relationship.</p>
<p>An alternative to covariance is to simply ignore the subtyping relationship
between two given types and consider a <span class="docutils literal"><span class="pre">LinkedList&lt;Shape&gt;</span></span> and
<span class="docutils literal"><span class="pre">LinkedList&lt;Triangle&gt;</span></span> as types with no subtyping relationship between them
(neither is a subtype of the other). This is not the case in TypeScript, but it
is in C#, where a <span class="docutils literal"><span class="pre">List&lt;Shape&gt;</span></span> and a <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> have no subtyping
relationship.</p>
<blockquote>
<div><p><strong>Invariance</strong></p>
<p>A type which ignores the subtyping relationship of its underlying type is
called invariant. A C# <span class="docutils literal"><span class="pre">List&lt;T&gt;</span></span> is invariant, because it ignores the
subtyping relationship “<span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>”, so
<span class="docutils literal"><span class="pre">List&lt;Shape&gt;</span></span> and <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> have no subtype-supertype
relationship.</p>
</div></blockquote>
<p>Now that we looked at how collections relate to each other in terms of
subtyping and saw two common types of variance, let’s see how function types
related to each other.</p>
</div>
<div class="section" id="subtyping-and-function-return-types">
<h2>Subtyping and Function Return Types</h2>
<p>We’ll start with the simpler case first: see what substitutions we can make
between a function that returns a <span class="docutils literal"><span class="pre">Triangle</span></span> and a function that returns a
<span class="docutils literal"><span class="pre">Shape</span></span>. We’ll declare two factory functions, a <span class="docutils literal"><span class="pre">makeShape()</span></span> which
returns a <span class="docutils literal"><span class="pre">Shape</span></span> and a <span class="docutils literal"><span class="pre">makeTriangle()</span></span> which returns a <span class="docutils literal"><span class="pre">Triangle</span></span>.</p>
<p>We’ll then implement a <span class="docutils literal"><span class="pre">useFactory()</span></span> function which takes a function of
type <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Shape</span></span> as argument and returns a <span class="docutils literal"><span class="pre">Shape</span></span>. We’ll try passing
<span class="docutils literal"><span class="pre">makeTriangle()</span></span> to it:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeTriangle</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeShape</span><span class="p">()</span><span class="o">:</span> <span class="nx">Shape</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">factory</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Shape</span><span class="p">)</span><span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">factory</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">shape1</span>: <span class="kt">Shape</span> <span class="o">=</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">makeShape</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">shape2</span>: <span class="kt">Shape</span> <span class="o">=</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">makeTriangle</span><span class="p">);</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">useFactory()</span></span> takes a function with no arguments which returns a <span class="docutils literal"><span class="pre">Shape</span></span>
and calls it. Both <span class="docutils literal"><span class="pre">makeTriangle()</span></span> and <span class="docutils literal"><span class="pre">makeShape()</span></span> can be used as
arguments to <span class="docutils literal"><span class="pre">useFactory()</span></span>.</p>
<p>Nothing out of the ordinary here: we can pass a function that returns a
<span class="docutils literal"><span class="pre">Triangle</span></span> as a function that returns a <span class="docutils literal"><span class="pre">Shape</span></span>, because the return value
(a <span class="docutils literal"><span class="pre">Triangle</span></span>) is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, so we can assign it to a <span class="docutils literal"><span class="pre">Shape</span></span>.</p>
<img alt="../../../_images/function-returns.png" class="align-center" src="http://vladris.com/blog/_images/function-returns.png"/>
<p>The opposite doesn’t work: if we change our <span class="docutils literal"><span class="pre">useFactory()</span></span> to expect a
<span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span> argument and try to pass it <span class="docutils literal"><span class="pre">makeShape()</span></span>, the code won’t
compile:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeTriangle</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">makeShape</span><span class="p">()</span><span class="o">:</span> <span class="nx">Shape</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">factory</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Triangle</span><span class="p">)</span><span class="o">:</span> <span class="nx">Triangle</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">factory</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">shape1</span>: <span class="kt">Shape</span> <span class="o">=</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">makeShape</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">shape2</span>: <span class="kt">Shape</span> <span class="o">=</span> <span class="nx">useFactory</span><span class="p">(</span><span class="nx">makeTriangle</span><span class="p">);</span>
</pre></div>
</div>
<p>We replaced <span class="docutils literal"><span class="pre">Shape</span></span> with <span class="docutils literal"><span class="pre">Triangle</span></span> in the <span class="docutils literal"><span class="pre">useFactory()</span></span> definition. The
code fails to compile: we can’t use <span class="docutils literal"><span class="pre">makeShape()</span></span> as a <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span>.</p>
<p>This is again pretty straightforward: we can’t use <span class="docutils literal"><span class="pre">makeShape()</span></span> as a function
of type <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span> because <span class="docutils literal"><span class="pre">makeShape()</span></span> returns a <span class="docutils literal"><span class="pre">Shape</span></span> object.
That object could be a <span class="docutils literal"><span class="pre">Triangle</span></span>, but it might be a <span class="docutils literal"><span class="pre">Square</span></span>.
<span class="docutils literal"><span class="pre">useFactory()</span></span> promises to return a <span class="docutils literal"><span class="pre">Triangle</span></span>, so it can’t return a
supertype of <span class="docutils literal"><span class="pre">Triangle</span></span>. It could, of course, return a subtype, like
<span class="docutils literal"><span class="pre">EquilateralTriangle</span></span>, given a <span class="docutils literal"><span class="pre">makeEquilateralTriangle()</span></span>.</p>
<p>Functions are covariant in their return types. In other words, if <span class="docutils literal"><span class="pre">Triangle</span></span>
is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, a function type like <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Triangle</span></span> is a subtype
of a function <span class="docutils literal"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">Shape</span></span>. Note that the function types don’t have to
describe functions that don’t take any arguments. If <span class="docutils literal"><span class="pre">makeTriangle()</span></span> and
<span class="docutils literal"><span class="pre">makeShape()</span></span> both took a couple of number arguments, they would still be
covariant as we just saw.</p>
<p>This is the behavior followed by most mainstream programming languages. The
same rules are followed for overriding methods in inherited types, changing
their return type. If we implement a <span class="docutils literal"><span class="pre">ShapeMaker</span></span> class which provides a
<span class="docutils literal"><span class="pre">make()</span></span> method that returns a <span class="docutils literal"><span class="pre">Shape</span></span>, we can override it in a derived
class <span class="docutils literal"><span class="pre">TriangleMaker</span></span> to return <span class="docutils literal"><span class="pre">Triangle</span></span> instead. The compiler will
allow this, as calling either of the <span class="docutils literal"><span class="pre">make()</span></span> methods will give us a
<span class="docutils literal"><span class="pre">Shape</span></span> object:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">ShapeMaker</span> <span class="p">{</span>
    <span class="nx">make</span><span class="p">()</span><span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Shape</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">TriangleMaker</span> <span class="k">extends</span> <span class="nx">ShapeMaker</span> <span class="p">{</span>
    <span class="nx">make</span><span class="p">()</span><span class="o">:</span> <span class="nx">Triangle</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Triangle</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is, again, allowed behavior in most mainstream programming languages, as
most consider functions covariant in their return type. Let’s now see what
happens to function types whose argument types are subtypes of each other.</p>
</div>
<div class="section" id="subtyping-and-function-argument-types">
<h2>Subtyping and Function Argument Types</h2>
<p>We’ll turn things inside out, so instead of a function that returns a <span class="docutils literal"><span class="pre">Shape</span></span>
and a function that returns a <span class="docutils literal"><span class="pre">Triangle</span></span>, we’ll take a function that takes a
<span class="docutils literal"><span class="pre">Shape</span></span> as argument and a function that takes a <span class="docutils literal"><span class="pre">Triangle</span></span> as argument.
We’ll call these <span class="docutils literal"><span class="pre">drawShape()</span></span> and <span class="docutils literal"><span class="pre">drawTriangle()</span></span>. How do
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> relate to one
another?</p>
<p>Let’s introduce another function, <span class="docutils literal"><span class="pre">render()</span></span>, which takes as arguments a
<span class="docutils literal"><span class="pre">Triangle</span></span> and an <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> function. It simply calls
the given function with the given <span class="docutils literal"><span class="pre">Triangle</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">drawShape</span><span class="p">(</span><span class="nx">shape</span>: <span class="kt">Shape</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">drawTriangle</span><span class="p">(</span><span class="nx">triangle</span>: <span class="kt">Triangle</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span>
    <span class="nx">triangle</span>: <span class="kt">Triangle</span><span class="p">,</span>
    <span class="nx">drawFunc</span><span class="o">:</span> <span class="p">(</span><span class="nx">argument</span>: <span class="kt">Triangle</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">drawFunc</span><span class="p">(</span><span class="nx">triangle</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">drawShape()</span></span> takes a <span class="docutils literal"><span class="pre">Shape</span></span> argument, <span class="docutils literal"><span class="pre">drawTriangle()</span></span> takes a
<span class="docutils literal"><span class="pre">Triangle</span></span> argument. <span class="docutils literal"><span class="pre">render()</span></span> expects a <span class="docutils literal"><span class="pre">Triangle</span></span> and a function that
takes a <span class="docutils literal"><span class="pre">Triangle</span></span> as argument. <span class="docutils literal"><span class="pre">render()</span></span> simply calls the provided
function passing it the triangle it received.</p>
<p>Here comes the interesting bit: in this case, we can safely pass
<span class="docutils literal"><span class="pre">drawShape()</span></span> to the <span class="docutils literal"><span class="pre">render()</span></span> function! That means we can use a
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> where an <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> is
expected.</p>
<p>Logically it makes sense: we have a <span class="docutils literal"><span class="pre">Triangle</span></span> and we pass it to a drawing
function which can use it as an argument. If the function itself expects a
<span class="docutils literal"><span class="pre">Triangle</span></span>, like our <span class="docutils literal"><span class="pre">drawTriangle()</span></span> function, then of course it works.
But it should also work for a function which expects a supertype of
<span class="docutils literal"><span class="pre">Triangle</span></span>: <span class="docutils literal"><span class="pre">drawShape()</span></span> wants a shape - any shape - to draw. Since it
doesn’t use anything that’s triangle-specific, it is more general than
<span class="docutils literal"><span class="pre">drawTriangle()</span></span>, it can accept any shape as argument, be it <span class="docutils literal"><span class="pre">Triangle</span></span> or
<span class="docutils literal"><span class="pre">Square</span></span>. So in this particular case, the subtyping relationship is reversed.</p>
<blockquote>
<div><p><strong>Contravariance</strong></p>
<p>A type which reverses the subtyping relationship of its underlying type is
called <em>contravariant</em>. In most programming languages, functions are
contravariant with regards to their arguments. A function which expects a
<span class="docutils literal"><span class="pre">Triangle</span></span> as argument can be substituted with a function which expects a
<span class="docutils literal"><span class="pre">Shape</span></span> as argument. The relationship of the functions is the reverse of
the relationship of the argument types: if <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype
<span class="docutils literal"><span class="pre">Shape</span></span>, the type of a function taking a <span class="docutils literal"><span class="pre">Triangle</span></span> as an argument is a
supertype of the type of a function taking a <span class="docutils literal"><span class="pre">Shape</span></span> as an argument.</p>
</div></blockquote>
<img alt="../../../_images/function-arguments.png" class="align-center" src="http://vladris.com/blog/_images/function-arguments.png"/>
<p>We said “most programming languages” in the definition above. A notable
exception is TypeScript. In TypeScript, we can also do the opposite: pass a
function which expects a subtype instead of a function which expects a
supertype. This was an explicit design choice, to facilitate common JavaScript
programming patterns. It can lead to runtime issues though. Let’s look at an
example. We’ll first define a method <span class="docutils literal"><span class="pre">isRightAngled()</span></span> on our <span class="docutils literal"><span class="pre">Triangle</span></span>
type, which would determine whether a given instance describes a right-angled
triangle. The implementation of the method is not important:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="cm">/* Shape members */</span>
<span class="p">}</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">TriangleType</span>: <span class="kt">unique</span> <span class="nx">symbol</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Triangle</span> <span class="k">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">TriangleType</span><span class="p">]</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>

    <span class="nx">isRightAngled</span><span class="p">()</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

        <span class="cm">/* Determine whether it is a right-angled triangle */</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* More Triangle members */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s reverse the drawing example and let’s say our <span class="docutils literal"><span class="pre">render()</span></span> function
expects a <span class="docutils literal"><span class="pre">Shape</span></span> instead of a <span class="docutils literal"><span class="pre">Triangle</span></span>, and a function which can draw
shapes <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> instead of a function which can only draw
triangles <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">drawShape</span><span class="p">(</span><span class="nx">shape</span>: <span class="kt">Shape</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">drawTriangle</span><span class="p">(</span><span class="nx">triangle</span>: <span class="kt">Triangle</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span>
    <span class="nx">shape</span>: <span class="kt">Shape</span><span class="p">,</span>
    <span class="nx">drawFunc</span><span class="o">:</span> <span class="p">(</span><span class="nx">argument</span>: <span class="kt">Shape</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">drawFunc</span><span class="p">(</span><span class="nx">shape</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">drawShape()</span></span> and <span class="docutils literal"><span class="pre">drawTriangle()</span></span> are just like before. <span class="docutils literal"><span class="pre">render()</span></span> now
expects a <span class="docutils literal"><span class="pre">Shape</span></span> and a function that takes a <span class="docutils literal"><span class="pre">Shape</span></span> as argument.</p>
<p>Here’s how we can cause a runtime error: we can define <span class="docutils literal"><span class="pre">drawTriangle()</span></span> to
actually use something that is triangle-specific, like the <span class="docutils literal"><span class="pre">isRightAngled()</span></span>
method we just added. We then call <span class="docutils literal"><span class="pre">render()</span></span> with a <span class="docutils literal"><span class="pre">Shape</span></span> object (not a
<span class="docutils literal"><span class="pre">Triangle</span></span>) and <span class="docutils literal"><span class="pre">drawTriangle()</span></span>.</p>
<p>Now <span class="docutils literal"><span class="pre">drawTriangle()</span></span> will receive a <span class="docutils literal"><span class="pre">Shape</span></span> object and attempt to call
<span class="docutils literal"><span class="pre">isRightAngled()</span></span> on it, but since the <span class="docutils literal"><span class="pre">Shape</span></span> is not a <span class="docutils literal"><span class="pre">Triangle</span></span>, this
will cause an error:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">drawTriangle</span><span class="p">(</span><span class="nx">triangle</span>: <span class="kt">Triangle</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">triangle</span><span class="p">.</span><span class="nx">isRightAngled</span><span class="p">());</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span>
    <span class="nx">shape</span>: <span class="kt">Shape</span><span class="p">,</span>
    <span class="nx">drawFunc</span><span class="o">:</span> <span class="p">(</span><span class="nx">argument</span>: <span class="kt">Shape</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">drawFunc</span><span class="p">(</span><span class="nx">shape</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">render</span><span class="p">(</span><span class="k">new</span> <span class="nx">Shape</span><span class="p">(),</span> <span class="nx">drawTriangle</span><span class="p">);</span>
</pre></div>
</div>
<p>We can pass a <span class="docutils literal"><span class="pre">Shape</span></span> and <span class="docutils literal"><span class="pre">drawTriangle()</span></span> to <span class="docutils literal"><span class="pre">render()</span></span>. This code will
compile but it will fail at runtime with a JavaScript error, since the runtime
won’t be able to find <span class="docutils literal"><span class="pre">isRightAngled()</span></span> on the <span class="docutils literal"><span class="pre">Shape</span></span> object we gave to
<span class="docutils literal"><span class="pre">drawTriangle()</span></span>. This is not ideal but, as mentioned before, it was a
conscious decision made during the implementation of TypeScript.</p>
<p>In TypeScript, if <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, a function of type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and a function of type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> can be substituted for each other. Effectively,
they are both subtypes of each other. This property is called <em>bivariance</em>.</p>
<blockquote>
<div><p><strong>Bivariance</strong></p>
<p>Types are <em>bivariant</em> if, from the subtyping relationship of their
underlying types, they become subtypes of each other. In TypeScript, if
<span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, the function types
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> are
subtypes of each other.</p>
</div></blockquote>
<img alt="../../../_images/bivariance.png" class="align-center" src="http://vladris.com/blog/_images/bivariance.png"/>
<p>Again, the bivariance of functions with respect to their arguments in TypeScript
allows incorrect code to compile. We rely on static type checking to eliminate
runtime errors at compile time. For TypeScript it was a deliberate design
decision to enable common JavaScript programming patterns.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We looked at what types can be substituted with what other types. While
subtyping is straight-forward when dealing with simple inheritance, things get
more complicated when we add types parameterized on other types. These could
be collections, function types, or other generic types. The way the subtyping
relationships of these parameterized types is removed, preserved, reversed, or
made two-way based on the relationship of their underlying types is called
<em>variance</em>.</p>
<ul class="simple">
<li><em>Invariant</em> types ignore the subtyping relationship of their underlying types.</li>
<li><em>Covariant</em> types preserve the subtyping relationship of their underlying
types. If <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, an array of type
<span class="docutils literal"><span class="pre">Triangle[]</span></span> is a subtype of an array of type <span class="docutils literal"><span class="pre">Shape[]</span></span>. In most
programming languages, function types are covariant in their return types.</li>
<li><em>Contravariant</em> types reverse the subtyping relationship of their underlying
types. If <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, the function type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> is a subtype of the function type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> in most languages. This is not true for
TypeScript, where function types are bivariant with regards to their argument
types.</li>
<li><em>Bivariant</em> types are subtypes of each other when their underlying types are
in a subtyping relationship. If <span class="docutils literal"><span class="pre">Triangle</span></span> is a subtype of <span class="docutils literal"><span class="pre">Shape</span></span>, the
function type <span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Shape)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and the function type
<span class="docutils literal"><span class="pre">(argument:</span> <span class="pre">Triangle)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> are subtypes of each other (functions of
both types can be substituted for one another).</li>
</ul>
<p>While some common rules exist across programming languages, there is no one way
to support variance. You should understand what the type system of
your programming language does and how it establishes subtyping relationships.
This is important to know, as these rules tell us what can be substituted for
what. Do you need to implement a function to transform a <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> into
a <span class="docutils literal"><span class="pre">List&lt;Shape&gt;</span></span>, or can you just use the <span class="docutils literal"><span class="pre">List&lt;Triangle&gt;</span></span> as-is? It all
depends on the variance of <span class="docutils literal"><span class="pre">List&lt;T&gt;</span></span> in your programming language of choice.</p>
</div>
]]></description>
             <pubDate>Fri, 27 Dec 2019 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/12/08/notes-on-data-engineering.html</link>
            <guid>http://vladris.com/blog/2019/12/08/notes-on-data-engineering.html</guid>
            <title><![CDATA[Notes on Data Engineering]]></title>
            <description><![CDATA[<h1>Notes on Data Engineering</h1>
<p>For over a year now I’ve been the architect for the Customer Growth and
Analytics team in Azure, scaling out our big data platform as our team grows
and matures. I’m going to share a few observations on some of the main
problems we’ve been solving, problems which I believe are fairly universal: I
attended the <a class="reference external" href="https://conferences.oreilly.com/strata-data-ai">Strata Data Conference</a>
this year and speakers from many other companies were talking about similar
problems and the solutions they were implementing.</p>
<p>Not too long ago, the major challanges were around storing and processing data
at scale. Since this has been more or less commoditized in the past few years,
especially with the emergence of cloud providers, it’s interesting to think
about how the big data landscape evolved and what are some of the present
challenges. I list some of them below.</p>
<div class="section" id="compliance">
<h2>Compliance</h2>
<p>Proper handling of data assets is a top priority for Microsoft and should be
for everyone. There are several aspects I consider to be part of compliance.</p>
<p>First, there are regulatory obligations, probably the best-known example
being GDPR. In order to be compliant with GDPR, a data platform needs to have
the ability to “forget” about a user if the user so desires. A data platform
needs to support all capabilities required by regulations of the countries it
gets its data from. There are many other regulations, and new ones can come
up at any time. Staying compliant is maybe the most important work for a data
platform.</p>
<p>Next, there is access control: who gets to see what data. There are various
types of data for which access should be restricted. Personally Identifiable
Information (PII) is data that can be used to identify a particular person,
like name or email address. High Business Impact (HBI) is data relevant to
the business, like revenue numbers, devices sold etc. Different companies use
different taxonomies to classifies their data assets, but regardless, in the
big data space, it is a non trivial problem to ensure that only people who
are allowed to access a certain data set are able to do so. If access to
sensitive data sets is under a need-to-know basis, and we create one security
group per dataset, just managing those security groups is hard in itself. On
top of that, people move and organizations change and that can impact who has
access to the data too.</p>
<p>I believe there is a lot of room to improve and innovate in this space. There
are many existing solutions to handle both regulatory and access control
requirements, but nothing that feels like <em>it just works</em>, and definitely
little in terms of industry standards.</p>
</div>
<div class="section" id="metadata">
<h2>Metadata</h2>
<p>As the data volume grows, organizing it becomes a big challenge. There is a
need for an additional layer of data about the data, or metadata. There are
several very important pieces of information which are not readily available
in the data itself that a big data platform must provide.</p>
<p>First, there is simply the descriptions of various datasets: what the various
columns are, how often is the data refreshed, how fresh the data is etc.
There also needs to be an ability to search this metadata in order to find
relevant data available in the system.</p>
<p>Next, there is data lineage. Where did the data come from and how was it
sourced? This has compliance implications: for example if end users agree to
share telemetry data for the purpose of improving the product, that data
should not be used for other purposes.</p>
<p>Also for compliance purposes, various datasets and columns have to be tagged
as containing PII or other sensitive information so the system can
automatically lock down or purge this type of sensitive data when needed.</p>
<p>Organizing data at scale also requires some amount of information
architecture. One aspect of this is controlled taxonomies: clear definitions
of what various business terms and data pieces mean, so everyone working in
the space shares the same understanding.</p>
<p><a class="reference external" href="https://azure.microsoft.com/en-us/services/data-catalog/">Azure Data Catalog</a>
is the Azure offering in this space.</p>
</div>
<div class="section" id="heterogeneity-by-design">
<h2>Heterogeneity by Design</h2>
<p>There is no one-size-fits-all data fabric. Each storage solution has some
workflows it was optimized for and some it’s not so great at. It’s next to
impossible to say that absolutely everything will be running on one single
solution, be that SQL, NoSQL, HDFS, or something else. Some workflows need
massive scale (processing terabytes of data), some workflows need fast reads
(serving a website). Teams upstream will expose data from different storage
solutions while teams downstream will expect it in different storage
solutions…</p>
<p>Standardizing on a unique storage solution is unfeasible, so the next best
thing to do is to standardize on the tooling to move the data around and
ensure that it is easy to operate: make it easy to create a new data movement
pipeline, provide monitoring, alerting etc. Since data movement is a
necessity, it must be as reliable as possible.</p>
<p>Our team uses <a class="reference external" href="https://azure.microsoft.com/en-us/services/data-factory/">Azure Data Factory</a>
for orchestrating data movement at scale.</p>
</div>
<div class="section" id="devops">
<h2>DevOps</h2>
<p>Another major bucket of work is bringing engineering rigor to workflows
supported by other disciplines like data science and machine learning
engineering. Again, with a small team, it is relatively easy to create ad-hoc
reports and run ad-hoc ML but this approach doesn’t scale. Once production
systems depend on the output.</p>
<p>This is a solved problem in the software engineering field: source control,
code reviews, continuous integration and so on. But non-engineering
disciplines are not accustomed to this type of workflow so there is
definitely a need to educate, support, and create similar devops workflows.
Analytics and ML ultimately reduce to code (SQL queries, Python, R etc.) and
should be handled just as production code.</p>
<p>Our team supports these types of workflows using <a class="reference external" href="https://azure.microsoft.com/en-us/services/devops/">Azure DevOps</a>
with pipelines that can deploy ML and analytics from git to our production
environment.</p>
</div>
<div class="section" id="data-quality">
<h2>Data Quality</h2>
<p>The last topic I will cover is data quality. The quality of all analytics and
machine learning outputs depends on the quality of the underlying data.</p>
<p>There are multiple aspects to data quality. One set of definitions is given
by the article <a class="reference external" href="https://smartbridge.com/data-done-right-6-dimensions-of-data-quality/">Data Done Right: 6 Dimensions of Data Quality</a>:</p>
<ul class="simple">
<li>Completeness - the dataset is not missing any required data</li>
<li>Consistency - the data is consistent across multiple datasets</li>
<li>Conformity - all data in the right format, within the right value ranges etc.</li>
<li>Accuracy - the data accurately represents the domain being modelled</li>
<li>Integrity - the data is valid across all relationships and datasets</li>
<li>Timeliness - the data available when expected and datasets are not delayed</li>
</ul>
<p>A reliable data platform can run various types of data quality tests on
the managed datasets, both at scheduled times and during ingress. Issues have
to be reported and the overall state of the data quality made visible through
a dashboard so stakeholders can easily see which datasets currently have
problems and what are the potential implications of that.</p>
<p>As of today, this seems to be a big gap in terms of industry-wide standard
solutions. Data engineering teams develop their bespoke data test runners for
their scenarios. There are many open source solutions, but we don’t have the
equivalent of JUnit yet, nor a common language for specifying tests and
assertions.</p>
</div>
<div class="section" id="conclusions">
<h2>Conclusions</h2>
<p>In the following years, I expect we will have both better tooling for some
of these problems and better defined industry-wide standards. As I mentioned
at the beginning of this post, not long ago, just storing and processing huge
amounts of data was a hard problem. Today, the main challanges are around
organizing and managing data. I fully expect that in the near future we will
have out-of-the-box solutions for all these problems and a new set of
challanges will emerge.</p>
</div>
]]></description>
             <pubDate>Sun, 08 Dec 2019 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/11/18/unit-testing-101.html</link>
            <guid>http://vladris.com/blog/2019/11/18/unit-testing-101.html</guid>
            <title><![CDATA[Unit Testing 101]]></title>
            <description><![CDATA[<h1>Unit Testing 101</h1>
<p>I wrote a while back about <a class="reference external" href="https://vladris.com/blog/2017/11/09/notes-on-unit-testing.html">unit testing</a>
from a philosophical perspective. This post is going to be more pragmatic. My
team is currently doing some MQ work which includes improving our unit test
story across the codebase. I put together a short unit tests 101 presentation
outlining some key principles:</p>
<ul class="simple">
<li>Run with each build</li>
<li>100% reliability</li>
<li>Test the public interface</li>
</ul>
<div class="section" id="run-with-each-build">
<h2>Run with Each Build</h2>
<p>Unit tests that don’t run aren’t very useful. I’ve seen projects before where
a unit test project does exist but the tests only run if manually executed.</p>
<p>The problem with this approach is that tests can stay not running for
days/weeks/months, and when they finally run, a bunch of them fail. Good luck
finding the change that introduced the regression. And wait, were we running
with that behavior all this time?</p>
<p>The biggest bang for the buck is making sure unit tests run as part of a
continuous integration build and pull requests get auto-rejected if a unit
test fails.</p>
</div>
<div class="section" id="reliability">
<h2>100% Reliability</h2>
<p>Once unit tests run with each build, the next most important thing to look
into is ensuring they pass consistently. Flaky unit tests are bad because
there’s no easy way to tell if a test run failed because of a regression or a
flaky test. Worst, if flaky tests are the standard, engineers start ignoring
the results. Hard to distill the signal from the noise in those situations.
Merge policies become more lax - after all, we can’t demand 100% green if
some unit tests randomly fail.</p>
<p>But stepping back, when are tests flaky? When they perform IO. Hitting the
network, connecting to a database, reading a file, these are all cases in
which a transient issue outside of our control can cause a test to fail.
That’s why unit tests shouldn’t perform IO, rather they should work against
mocks.</p>
<p>Let’s take, as an example, a method which performs a GET request and logs to
the console whether the request was successful:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span>
            <span class="s">"https://www.example.com"</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>

        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsSuccessStatusCode</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In its current form, the method isn’t really testable. Writing code without
thinking about testability yields such methods. We can refactor this to be
more testable. First, let’s put all IO behind interfaces:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IHttpClient</span>
<span class="p">{</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;</span> <span class="n">GetAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">interface</span> <span class="n">IOutput</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="kt">bool</span> <span class="k">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can update our <span class="docutils literal"><span class="pre">Example</span></span> to use these interfaces instead of directly
working with <span class="docutils literal"><span class="pre">HttpClient</span></span> and <span class="docutils literal"><span class="pre">Console</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">IHttpClient</span> <span class="n">client</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">IOutput</span> <span class="n">output</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Example</span><span class="p">(</span><span class="n">IHttpClient</span> <span class="n">client</span><span class="p">,</span> <span class="n">IOutput</span> <span class="n">output</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">client</span> <span class="p">=</span> <span class="n">client</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">output</span> <span class="p">=</span> <span class="n">output</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span>
            <span class="s">"https://www.example.com"</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>

        <span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsSuccessStatusCode</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We add adapters between the interfaces and the actual implementations:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">HttpClientWrapper</span> <span class="p">:</span> <span class="n">IHttpClient</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">HttpClient</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;</span> <span class="n">GetAsync</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ConsoleOutput</span> <span class="p">:</span> <span class="n">IOutput</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="kt">bool</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With these adapters, in our production code we can put together an instance
of <span class="docutils literal"><span class="pre">Example</span></span> that works just like the original, but which is componentized
enough that we can actually test it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">example</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Example</span><span class="p">(</span>
    <span class="k">new</span> <span class="nf">HttpClientWrapper</span><span class="p">(),</span>
    <span class="k">new</span> <span class="nf">ConsoleOutput</span><span class="p">());</span>
<span class="n">example</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>
</pre></div>
</div>
<p>In our test code, we can use a framework like Moq <a class="footnote-reference" href="#id2" id="id1">[1]</a> to set up mocks and
verify that the expected calls happen:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">mockClient</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Mock</span><span class="p">&lt;</span><span class="n">IHttpClient</span><span class="p">&gt;();</span>
<span class="n">mockClient</span><span class="p">.</span><span class="n">Setup</span><span class="p">(</span>
    <span class="n">client</span> <span class="p">=&gt;</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="s">"https://www.example.com"</span><span class="p">))</span>
    <span class="p">.</span><span class="n">Returns</span><span class="p">(</span><span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">HttpResponseMessage</span> <span class="p">{</span>
            <span class="n">StatusCode</span> <span class="p">=</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">OK</span>
        <span class="p">}));</span>

<span class="kt">var</span> <span class="n">mockOutput</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Mock</span><span class="p">&lt;</span><span class="n">IOutput</span><span class="p">&gt;();</span>
<span class="n">mockOutput</span><span class="p">.</span><span class="n">Setup</span><span class="p">(</span>
    <span class="n">output</span> <span class="p">=&gt;</span> <span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span>
        <span class="n">It</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;(</span><span class="k">value</span> <span class="p">=&gt;</span> <span class="k">value</span> <span class="p">==</span> <span class="k">true</span><span class="p">)));</span>

<span class="kt">var</span> <span class="n">example</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Example</span><span class="p">(</span>
    <span class="n">mockClient</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span>
    <span class="n">mockOutput</span><span class="p">.</span><span class="n">Object</span><span class="p">);</span>
<span class="n">example</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

<span class="n">mockOutput</span><span class="p">.</span><span class="n">VerifyAll</span><span class="p">();</span>
</pre></div>
</div>
<p>The above code sets up an <span class="docutils literal"><span class="pre">IHttpClient</span></span> mock implementation which so that
when <span class="docutils literal"><span class="pre">GetAsync()</span></span> is called with the argument <span class="docutils literal"><span class="pre">https://www.example.com</span></span>
it returns a <span class="docutils literal"><span class="pre">Task&lt;HttpResponseMessage&gt;</span></span> with a <span class="docutils literal"><span class="pre">StatusCode</span></span> of
<span class="docutils literal"><span class="pre">HttpStatusCode.OK</span></span>. The code also sets up an <span class="docutils literal"><span class="pre">IOutput</span></span> mock which
expects a <span class="docutils literal"><span class="pre">WriteLine()</span></span> call with a <span class="docutils literal"><span class="pre">true</span></span> argument.</p>
<p>We can initialize an instance of <span class="docutils literal"><span class="pre">Example</span></span> with these mocks, call
<span class="docutils literal"><span class="pre">Get()</span></span>, then verify <span class="docutils literal"><span class="pre">mockOutput</span></span> was used as expected.</p>
<div class="section" id="design-for-testability">
<h3>Design for Testability</h3>
<p>The general steps for making code testable:</p>
<ul class="simple">
<li>Extract interface (if one doesn’t exist already)</li>
<li>Create adapters if concrete implementation doesn’t implement an interface</li>
<li>Initialize class with real implementations in production</li>
<li>Initialize class with mocks in tests</li>
<li>Setup mocks to behave as required by each test</li>
<li>Verify mocks</li>
</ul>
<p>I will not talk about dependency injection in this post, but once all
components of the system expect several interfaces to run, it is worth
thinking about leveraging a DI framework to handle putting things together.</p>
<p>With this approach, we can make any component testable except the adapters.
By their nature, our adapters perform IO. We can’t reliably test
<span class="docutils literal"><span class="pre">HttpClientWrapper</span></span>. But such adapters shouldn’t contain any application
logic, they should be extremely thin, simply forwarding calls to the real
implementation. It’s perfectly fine to not test such trivial code.</p>
</div>
<div class="section" id="seams">
<h3>Seams</h3>
<p>Depending on the language, we can have several other ways to inject mocks. In
C++, for example, we can do it at compile-time, at link-time, or at run-time.</p>
<p>At compile-time, we can use a template parameter as the “interface”, have the
production version of the code instantiate it with one concrete
implementation and have the tests instantiate it with a mock:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TImpl</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">TImpl</span> <span class="n">impl</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">impl</span><span class="p">.</span><span class="n">Do</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteImpl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Concrete implementation</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MockImpl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Mock implementation</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ...</span>

<span class="n">Example</span><span class="o">&lt;</span><span class="n">ConcreteImpl</span><span class="o">&gt;</span> <span class="n">ex</span><span class="p">;</span>
</pre></div>
</div>
<p>At link-time, we can link against the concrete implementations in production
and against mock implementations in tests:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Example</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Impl</span> <span class="n">impl</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">impl</span><span class="p">.</span><span class="n">Do</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// In concrete implementation file:</span>
<span class="k">class</span> <span class="nc">Impl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Concrete implementation</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// In mock implementation file:</span>
<span class="k">class</span> <span class="nc">Impl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Do</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Mock implementation</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>At run-time, we can do something similar to our C# example above. There are
pros and cons with each approach. The run-time approach is what most
languages do, so easy to understand, though it adds more overhead. The
link-time approach is lean, but could end up being confusing: we have to
check makefiles to understand which code ends up in the binary and which code
doesn’t. The compile-time approach makes the code uglier, and requires making
implementation public.</p>
</div>
</div>
<div class="section" id="test-the-public-interface">
<h2>Test The Public Interface</h2>
<p>This one I did mention in my previous blog post to. The key point here is
that, while test frameworks usually provide various unnatural ways to access
an object’s internals, tests should focus on the public members.</p>
<p>The public members define the “contract” that a class provides. Tests should
ensure the contract is respected and not worry about the implementation. With
this approach, the implementation can easily be refactored and we know things
still work as expected as long as all tests pass. On the other hand, if we
have tests that cover various implementation details, they might break if we
move things around, even though the class still behaves correctly. In
general, having to update tests whenever we make tweaks to the implementation
is not ideal.</p>
<p>The other way to look at it is that if we have some code deep in the
implementation that can’t be reached through the public members, then it is
likely dead code.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Unit tests should run as part of continuous integration, otherwise they
aren’t really useful.</li>
<li>Unit tests have to be 100% reliable. We achieve this by isolating IO and
mocking it in tests.</li>
<li>Testability recipe:<ul>
<li>Code against interfaces, declare interfaces if none are available</li>
<li>Use thin adapters to make any concrete implementation compatible with any
interface</li>
<li>Use concrete implementations in production and mocks in tests</li>
</ul>
</li>
<li>In some languages there are multiple seams where we can inject mocks. In C++
we can do it at compile-time, at link-time, and at run-time. Each has its pros
and cons.</li>
<li>Test the public interface not the implementation.</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Moq is my favorite C# mocking library: <a class="reference external" href="https://github.com/moq/moq4">https://github.com/moq/moq4</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Mon, 18 Nov 2019 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/10/16/programming-with-types-rtm.html</link>
            <guid>http://vladris.com/blog/2019/10/16/programming-with-types-rtm.html</guid>
            <title><![CDATA[Programming with Types RTM]]></title>
            <description><![CDATA[<h1>Programming with Types RTM</h1>
<p><a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>
is going to the printer today and should be available as a print books in a
couple of weeks. I figured I’ll write a blog post about writing the book for
the occasion. I wrote in a <a class="reference external" href="https://vladris.com/blog/2019/04/28/programming-with-types.html">previous post</a>
how the book came to be, but didn’t really cover the implementation details.</p>
<div class="section" id="prototype">
<h2>Prototype</h2>
<p>I started writing the book before even thinking about publishing. The best
way I can put it is I felt I had a book in me. I learned a lot of material
during the past few years and I wanted to synthesize it in book form,
hopefully useful to others. I created a repository on GitHub, outlined the
topics I wanted to cover, and for a few weeks I spent a few minutes every
morning over coffee filling in some of the sections. As a fun fact, the
original title of the book was <em>Practical Types</em>. This was August 2018.</p>
</div>
<div class="section" id="pitch">
<h2>Pitch</h2>
<p>In September, when I realized I am indeed writing a book, I figured I should
pitch it to publishers. No harm in trying. I reached out to O’Reilly and
Manning. O’Reilly promptly dismissed my proposal. Manning put me in touch
with a publisher and we scheduled a couple of calls to discuss some of the
details.</p>
<p>I got some invaluable feedback even from those initial calls - suggestions on
how to improve the table of contents, how to make the book more accessible to
readers, how to split topics up into chapters based on the difficulty of the
topic and so on. After those initial calls, I was fortunate to get a
contract.</p>
</div>
<div class="section" id="contract">
<h2>Contract</h2>
<p>The most important part of the contract is the manuscript delivery. There are
3 key milestones, each 4 months apart. The milestones were:</p>
<ul class="simple">
<li>Deliver a third of the manuscript no later than February 2019</li>
<li>Deliver two thirds of the manuscript no later than June 2019</li>
<li>Deliver the complete draft of the manuscript no later than October 2019</li>
</ul>
<p>I got paid an advance delivered in two batches: the first half upon delivery
of the first third of the manuscript, the second half upon delivery of the
complete draft. I will also be getting a percentage of sales of the book. The
way advances work, the book needs to sell enough to cover the advance before
I will receive any more royalties. I will pause here to say that I don’t
expect to get rich off of this book. Another fun fact I learned is that most
books don’t even recover the advance, so if you ever want to write a book
simply for the money, you might want to reconsider.</p>
</div>
<div class="section" id="training">
<h2>Training</h2>
<p>After the paperwork was signed, I was assigned a developmental editor and the
first thing we did was a new author training where I was introduced to the
Manning method of writing books. Since Manning has been publishing high
quality technical books for many years, they have a set of best practices
authors are encouraged to follow. These include things like starting with a
concrete example then generalizing to the abstract, using figures to better
explain things, tracking the prerequisites of each chapter and making sure
there is a smooth progression and so on. These trainings were delivered by my
editor over a few Skype calls.</p>
</div>
<div class="section" id="feedback-loop">
<h2>Feedback Loop</h2>
<p>Throughout the writing stage, I worked closely with two editors. After
completing a draft of each chapter, I would upload it and get the initial
round of feedback from them. The developmental editor would make sure my
writing is up to par and the text makes sense; the technical developmental
editor would keep me honest for the technical aspects of the book, and make
sure I didn’t mess anything up there.</p>
<p>With each milestone (1/3, 2/3, 3/3 of the book), Manning also conducted an
external review with around 20 other volunteers who would go over the
manuscript and provide feedback. When the external feedback came in, we
analyzed it for trends to identify areas of improvement - for example, if
multiple people were saying a particular section is hard to grok, it was
clear it needed improvement.</p>
<p>As the book was nearing completion, I also got a reviewer for the code
samples. He made sure all the code makes sense, compiles, and the GitHub
version matches the book version.</p>
<p>Writing a book is definitely a team effort. Without all the great feedback I
received it would’ve been a pretty crappy book. Many thanks to Michael
Stephens, Elesha Hyde, Mike Shepard, German Gonzales, and all the other great
folks at Manning for all their help. I’m also grateful to all the external
reviewers for their time.</p>
<p>I learned that the first chapter is the one that usually requires the most
refactoring, which was definitely true in my case.</p>
</div>
<div class="section" id="writing">
<h2>Writing</h2>
<p>Because I started with a list of topics I wanted to cover and had a general
idea of what to write in each chapter, things went pretty smoothly. I was
able to write a chapter in a weekend so I was ahead of schedule most of the
time.</p>
<p>Turns out that writing a chapter is not the hard part, the grind comes when
you have to edit, re-edit, and incorporate all the rounds of feedback. The
editing part is much less creative than starting from a blank page, but is
equally if not more important.</p>
<p>I completed the draft mid-May and incorporated the last round of external
feedback by July. Beyond the chapters, there is also a Front Matter, inside
covers, and appendices, which I worked on in July/August.</p>
<p>All in all it took about a year from when I started outlining the book on
GitHub to having the final version ready to go to production.</p>
</div>
<div class="section" id="production">
<h2>Production</h2>
<p>From then on, the book goes to production and another set of people goes over
the spelling, layout, indexing and so on. At this stage, my responsibility
was mostly to review changes and suggest minor updates.</p>
<p>Last week I received the final PDF version of how the book will look like in
print, and today I was notified it is being sent to the printer.</p>
<p>Writing the book was a great experience and I got the chance to work with some
wonderful people. I hope the final product is a good book which leads to better
software.</p>
</div>
]]></description>
             <pubDate>Wed, 16 Oct 2019 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/09/07/higher-kinded-types-monads.html</link>
            <guid>http://vladris.com/blog/2019/09/07/higher-kinded-types-monads.html</guid>
            <title><![CDATA[Higher Kinded Types: Monads]]></title>
            <description><![CDATA[<h1>Higher Kinded Types: Monads</h1>
<p>This blog post is an excerpt from my book, <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>. The code samples
are in TypeScript. If you enjoy the article, you can use the discount code
<strong>vlri40</strong> for a 40% discount on the book.</p>
<p>Make sure to read the previous post first,
<a class="reference external" href="https://vladris.com/blog/2019/09/06/higher-kinded-types-functors.html">Higher Kinded Types: Functors</a>.</p>
<div class="section" id="monads">
<h2>Monads</h2>
<p>You have probably heard the term <em>monad</em>, as it’s been getting a lot of
attention lately. Monads are making their way into mainstream programming, so
you should know one when you see it. Building on the previous blog post, in this
post we will explain what a monad is and how it is useful. We’ll start
with a few examples and then look at the general definition.</p>
</div>
<div class="section" id="result-or-error">
<h2>Result or Error</h2>
<p>In the previous post, we had a <span class="docutils literal"><span class="pre">readNumber()</span></span> function that returned
<span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span>. We used functors to sequence processing with
<span class="docutils literal"><span class="pre">square()</span></span> and <span class="docutils literal"><span class="pre">stringify()</span></span>, so that if <span class="docutils literal"><span class="pre">readNumber()</span></span> returns
<span class="docutils literal"><span class="pre">undefined</span></span>, no processing happens, and the <span class="docutils literal"><span class="pre">undefined</span></span> is propagated
through the pipeline.</p>
<p>This type of sequencing works with functors as long as only the first
function - in this case, <span class="docutils literal"><span class="pre">readNumber()</span></span> - can return an error. But what
happens if any of the functions we want to chain can error out? Let’s say
that we want to open a file, read its content as a <span class="docutils literal"><span class="pre">string</span></span>, and  then
deserialize that string into a <span class="docutils literal"><span class="pre">Cat</span></span> object.</p>
<p>We have an <span class="docutils literal"><span class="pre">openFile()</span></span> function that returns an <span class="docutils literal"><span class="pre">Error</span></span> or a
<span class="docutils literal"><span class="pre">FileHandle</span></span>. Errors can occur if the file doesn’t exist, if it is locked by
another process, or if the user doesn’t have permission to open it. If the
operation succeeds, we get back a handle to the file.</p>
<p>We have a <span class="docutils literal"><span class="pre">readFile()</span></span> function that takes a <span class="docutils literal"><span class="pre">FileHandle</span></span> and returns ether
an <span class="docutils literal"><span class="pre">Error</span></span> or a <span class="docutils literal"><span class="pre">string</span></span>. Errors can occur if the file can’t be read,
perhaps due to being too large to fit in memory. If the file can be read, we get
back a <span class="docutils literal"><span class="pre">string</span></span>.</p>
<p>Finally, <span class="docutils literal"><span class="pre">deserializeCat()</span></span> function takes a <span class="docutils literal"><span class="pre">string</span></span> and returns an
<span class="docutils literal"><span class="pre">Error</span></span> or a <span class="docutils literal"><span class="pre">Cat</span></span> instance. Errors can occur if the string can’t be
deserialized into a <span class="docutils literal"><span class="pre">Cat</span></span> object, perhaps due to missing properties.</p>
<p>All these functions follow the “return result or error” pattern, which suggests
returning either a valid result or an error from a function, but not both. The
return type will be an <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">...&gt;</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">openFile</span><span class="p">(</span>
    <span class="nx">path</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">FileHandle</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">readFile</span><span class="p">(</span>
    <span class="nx">handle</span>: <span class="kt">FileHandle</span><span class="p">)</span><span class="o">:</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="kt">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">deserializeCat</span><span class="p">(</span>
    <span class="nx">serializedCat</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">Cat</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>We are omitting the implementations, as they are not important. Let’s also
quickly see the implementation of <span class="docutils literal"><span class="pre">Either</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">value</span>: <span class="kt">TLeft</span> <span class="o">|</span> <span class="nx">TRight</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="nx">left</span>: <span class="kt">boolean</span><span class="p">;</span>

    <span class="k">private</span> <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">TLeft</span> <span class="o">|</span> <span class="nx">TRight</span><span class="p">,</span> <span class="nx">left</span>: <span class="kt">boolean</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">isLeft</span><span class="p">()</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">getLeft</span><span class="p">()</span><span class="o">:</span> <span class="nx">TLeft</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">isLeft</span><span class="p">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">();</span>

        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">TLeft</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">isRight</span><span class="p">()</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">getRight</span><span class="p">()</span><span class="o">:</span> <span class="nx">TRight</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isRight</span><span class="p">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">();</span>

        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">TRight</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="nx">makeLeft</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">TLeft</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="nx">makeRight</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">TRight</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The type wraps a value of either <span class="docutils literal"><span class="pre">TLeft</span></span> or <span class="docutils literal"><span class="pre">TRight</span></span> and a flag to keep
track of that type is used. It has a private constructor, as we need to make
sure that the value and boolean flag are in sync. Attempting to get a <span class="docutils literal"><span class="pre">TLeft</span></span>
when we have a <span class="docutils literal"><span class="pre">TRight</span></span>, or vice versa, throws an error. The factory
functions call the constructor and ensure that the boolean flag is consistent
with the value.</p>
<p>Now let’s see how we could chain these functions together into a
<span class="docutils literal"><span class="pre">readCatFromFile()</span></span> function that takes a file path as an argument and returns
an <span class="docutils literal"><span class="pre">Error</span></span> if anything went wrong along the way, or a <span class="docutils literal"><span class="pre">Cat</span></span> instance:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">readCatFromFile</span><span class="p">(</span><span class="nx">path</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">Cat</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">handle</span>: <span class="kt">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">FileHandle</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">openFile</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">handle</span><span class="p">.</span><span class="nx">isLeft</span><span class="p">())</span> <span class="k">return</span> <span class="nx">Either</span><span class="p">.</span><span class="nx">makeLeft</span><span class="p">(</span><span class="nx">handle</span><span class="p">.</span><span class="nx">getLeft</span><span class="p">());</span>

    <span class="kd">let</span> <span class="nx">content</span>: <span class="kt">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="kt">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">readFile</span><span class="p">(</span><span class="nx">handle</span><span class="p">.</span><span class="nx">getRight</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">content</span><span class="p">.</span><span class="nx">isLeft</span><span class="p">())</span> <span class="k">return</span> <span class="nx">Either</span><span class="p">.</span><span class="nx">makeLeft</span><span class="p">(</span><span class="nx">content</span><span class="p">.</span><span class="nx">getLeft</span><span class="p">());</span>

    <span class="k">return</span> <span class="nx">deserializeCat</span><span class="p">(</span><span class="nx">content</span><span class="p">.</span><span class="nx">getRight</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function is very similar to the first implementation of <span class="docutils literal"><span class="pre">process()</span></span> in
the previous blog post. There, we provided an updated implementation that
removed all the branching and error checking from the function and delegated
those tasks to <span class="docutils literal"><span class="pre">map()</span></span>. Let’s see what a <span class="docutils literal"><span class="pre">map()</span></span> for
<span class="docutils literal"><span class="pre">Either&lt;TLeft,</span> <span class="pre">TRight&gt;</span></span> would look like. We will follow the convention
“Right is right; left is error”, which means that <span class="docutils literal"><span class="pre">TLeft</span></span> contains an error,
so <span class="docutils literal"><span class="pre">map()</span></span> will just propagate it. <span class="docutils literal"><span class="pre">map()</span></span> will apply a given function only
if the <span class="docutils literal"><span class="pre">Either</span></span> contains a <span class="docutils literal"><span class="pre">TRight</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">Either</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="p">,</span> <span class="nx">URight</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">value</span>: <span class="kt">Either</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">TRight</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">URight</span><span class="p">)</span><span class="o">:</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">URight</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">isLeft</span><span class="p">())</span> <span class="k">return</span> <span class="nx">Either</span><span class="p">.</span><span class="nx">makeLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">getLeft</span><span class="p">());</span>

        <span class="k">return</span> <span class="nx">Either</span><span class="p">.</span><span class="nx">makeRight</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">getRight</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a problem with using <span class="docutils literal"><span class="pre">map()</span></span>, though: the types of the functions it
expects as argument is incompatible with the functions we are using. With
<span class="docutils literal"><span class="pre">map()</span></span>, after we call <span class="docutils literal"><span class="pre">openFile()</span></span> and get back an
<span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">FileHandle&gt;</span></span>, we would need a function
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">FileHandle)</span> <span class="pre">=&gt;</span> <span class="pre">string</span></span> to read its content. That function can’t
itself return an <span class="docutils literal"><span class="pre">Error</span></span>, like <span class="docutils literal"><span class="pre">square()</span></span> or <span class="docutils literal"><span class="pre">stringify()</span></span>. But in our
case, <span class="docutils literal"><span class="pre">readFile()</span></span> itself can fail, so it doesn’t return <span class="docutils literal"><span class="pre">string</span></span>, it
returns <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">string&gt;</span></span>. If we attempt to use it in our
<span class="docutils literal"><span class="pre">readCatFromFile()</span></span>, we get a compilation error:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">readCatFromFile</span><span class="p">(</span><span class="nx">path</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">Cat</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">handle</span>: <span class="kt">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">FileHandle</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">openFile</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>

    <span class="kd">let</span> <span class="nx">content</span>: <span class="kt">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="kt">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">Either</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">handle</span><span class="p">,</span> <span class="nx">readFile</span><span class="p">);</span>

    <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This fails to compile due to a type mismatch. The error message we get is</p>
<blockquote>
<div><span class="docutils literal"><span class="pre">Type</span> <span class="pre">'Either&lt;Error,</span> <span class="pre">Either&lt;Error,</span> <span class="pre">string&gt;&gt;'</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">assignable</span> <span class="pre">to</span> <span class="pre">type</span>
<span class="pre">'Either&lt;Error,</span> <span class="pre">string&gt;'.</span></span></div></blockquote>
<p>Our functor falls short here. Functors can propagate an initial error through
the processing pipeline, but if every step in the pipeline can fail, functors
no longer work. In the following figure, the black square represents an
<span class="docutils literal"><span class="pre">Error</span></span>, and the white and black circles represent two types, such as
<span class="docutils literal"><span class="pre">FileHandle</span></span> and <span class="docutils literal"><span class="pre">string</span></span>.</p>
<img alt="../../../_images/bind1.png" class="align-center" src="http://vladris.com/blog/_images/bind1.png"/>
<p>We can’t use a functor in this case because the functor is defined to map a
function from a white circle to a black circle. Unfortunately, our function
returns a type already wrapped in an <span class="docutils literal"><span class="pre">Either</span></span> (an
<span class="docutils literal"><span class="pre">Either&lt;black</span> <span class="pre">square,</span> <span class="pre">black</span> <span class="pre">circle&gt;</span></span>). We need an alternative to <span class="docutils literal"><span class="pre">map()</span></span>
that can deal with this type of function.</p>
<p><span class="docutils literal"><span class="pre">map()</span></span> from <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">FileHandle&gt;</span></span> would need a function from
<span class="docutils literal"><span class="pre">FileHandle</span></span> to <span class="docutils literal"><span class="pre">string</span></span> to produce an <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">string&gt;</span></span>. Our
<span class="docutils literal"><span class="pre">readFile()</span></span> function, on the other hand, is from <span class="docutils literal"><span class="pre">FileHandle</span></span> to
<span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">string&gt;</span></span>.</p>
<p>This problem is easy to fix. We need a function similar to <span class="docutils literal"><span class="pre">map()</span></span> that goes
from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">U&gt;</span></span>. The standard name for such a function is
<span class="docutils literal"><span class="pre">bind()</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">Either</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">bind</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="p">,</span> <span class="nx">URight</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">value</span>: <span class="kt">Either</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">TRight</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">TRight</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">URight</span><span class="o">&gt;</span>
        <span class="p">)</span><span class="o">:</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nx">TLeft</span><span class="p">,</span> <span class="nx">URight</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">isLeft</span><span class="p">())</span> <span class="k">return</span> <span class="nx">Either</span><span class="p">.</span><span class="nx">makeLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">getLeft</span><span class="p">());</span>

        <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">getRight</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">func()</span></span> has a different type from the <span class="docutils literal"><span class="pre">func()</span></span> in <span class="docutils literal"><span class="pre">map()</span></span>. We can simply
return the result of <span class="docutils literal"><span class="pre">func()</span></span>, as it has the same type as the result of
<span class="docutils literal"><span class="pre">bind()</span></span>.</p>
<p>As we can see, the implementation is even simpler than the one for <span class="docutils literal"><span class="pre">map()</span></span>:
after we unpack the value, we simply return the result of applying <span class="docutils literal"><span class="pre">func()</span></span> to
it. Let’s use <span class="docutils literal"><span class="pre">bind()</span></span> to implement our <span class="docutils literal"><span class="pre">readCatFromFile()</span></span> function and get
the desired branchless error propagation behavior:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">readCatFromFile</span><span class="p">(</span><span class="nx">path</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">Cat</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">handle</span>: <span class="kt">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">FileHandle</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">openFile</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>

    <span class="kd">let</span> <span class="nx">content</span>: <span class="kt">Either</span><span class="o">&lt;</span><span class="nb">Error</span><span class="p">,</span> <span class="kt">string</span><span class="o">&gt;</span> <span class="o">=</span>
        <span class="nx">Either</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">handle</span><span class="p">,</span> <span class="nx">readFile</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">Either</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="nx">deserializeCat</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unlike the <span class="docutils literal"><span class="pre">map()</span></span> version, this code works. Applying <span class="docutils literal"><span class="pre">readFile()</span></span> to
<span class="docutils literal"><span class="pre">handle</span></span> gives us back an <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">string&gt;</span></span>. <span class="docutils literal"><span class="pre">deserializeCat()</span></span> has
the same return type as <span class="docutils literal"><span class="pre">readCatFromFile()</span></span>, so we simply return the result
of <span class="docutils literal"><span class="pre">bind()</span></span>.</p>
<p>This version seamlessly chains together <span class="docutils literal"><span class="pre">openFile()</span></span>, <span class="docutils literal"><span class="pre">readFile()</span></span>, and
<span class="docutils literal"><span class="pre">deserializeCat()</span></span> so that if any of the functions fails, the error gets
propagated as the result of <span class="docutils literal"><span class="pre">readCatFromFile()</span></span>. Again, branching is
encapsulated in the <span class="docutils literal"><span class="pre">bind()</span></span> implementation, so our processing function is
linear.</p>
</div>
<div class="section" id="difference-between-map-and-bind">
<h2>Difference between map() and bind()</h2>
<p>Before moving on to define monads, let’s take another simplified example and
contrast <span class="docutils literal"><span class="pre">map()</span></span> and <span class="docutils literal"><span class="pre">bind()</span></span>. We’ll again use <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, a generic type
that simply wraps a value of type <span class="docutils literal"><span class="pre">T</span></span>. Although this type is not particularly
useful, it is the simplest generic type we can have. We want to focus on how
<span class="docutils literal"><span class="pre">map()</span></span> and <span class="docutils literal"><span class="pre">bind()</span></span> work with values of types <span class="docutils literal"><span class="pre">T</span></span> and <span class="docutils literal"><span class="pre">U</span></span> in some
generic context, such as <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span> (or <span class="docutils literal"><span class="pre">T[]</span></span>, <span class="docutils literal"><span class="pre">U[]</span></span>; or
<span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span>, <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span>; or <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">T&gt;</span></span>, <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">U&gt;</span></span>
etc.).</p>
<p>For a <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, a functor (<span class="docutils literal"><span class="pre">map()</span></span>) takes a <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> and a function from
<span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span> and returns a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>. The problem is that we have scenarios
in which our functions are directly from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>. This is what
<span class="docutils literal"><span class="pre">bind()</span></span> is for. <span class="docutils literal"><span class="pre">bind()</span></span> takes a <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> and a function from <span class="docutils literal"><span class="pre">T</span></span> to
<span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span> and returns the result of applying the function to the <span class="docutils literal"><span class="pre">T</span></span> inside
<span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>.</p>
<img alt="../../../_images/bind2.png" class="align-center" src="http://vladris.com/blog/_images/bind2.png"/>
<p>If we have a function <span class="docutils literal"><span class="pre">stringify()</span></span> that takes a <span class="docutils literal"><span class="pre">number</span></span> and returns its
<span class="docutils literal"><span class="pre">string</span></span> representation, we can <span class="docutils literal"><span class="pre">map()</span></span> it on a <span class="docutils literal"><span class="pre">Box&lt;number&gt;</span></span> and get back
a <span class="docutils literal"><span class="pre">Box&lt;string&gt;</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">Box</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">s</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span>
    <span class="o">=</span> <span class="nx">Box</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="mf">42</span><span class="p">),</span> <span class="nx">stringify</span><span class="p">);</span>
</pre></div>
</div>
<p>If instead of <span class="docutils literal"><span class="pre">stringify()</span></span>, which goes from <span class="docutils literal"><span class="pre">number</span></span> to <span class="docutils literal"><span class="pre">string</span></span>, we have
a <span class="docutils literal"><span class="pre">boxify()</span></span> function that goes from <span class="docutils literal"><span class="pre">number</span></span> directly to <span class="docutils literal"><span class="pre">Box&lt;string&gt;`</span></span>,
<span class="docutils literal"><span class="pre">map()</span></span> won’t work. We’ll need <span class="docutils literal"><span class="pre">bind()</span></span> instead:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">Box</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">bind</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">boxify</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">b</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="o">=</span>
    <span class="nx">Box</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="mf">42</span><span class="p">),</span> <span class="nx">boxify</span><span class="p">);</span>
</pre></div>
</div>
<p>The result of both <span class="docutils literal"><span class="pre">map()</span></span> and <span class="docutils literal"><span class="pre">bind()</span></span> is still a <span class="docutils literal"><span class="pre">Box&lt;string&gt;</span></span>. We still
go from <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> to <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>; the difference is how we get there. In the
<span class="docutils literal"><span class="pre">map()</span></span> case, we need a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span>. In the <span class="docutils literal"><span class="pre">bind()</span></span> case,
we need a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>.</p>
</div>
<div class="section" id="the-monad-pattern">
<h2>The Monad Pattern</h2>
<p>A monad consists of <span class="docutils literal"><span class="pre">bind()</span></span> and one more, simpler function. This other
function takes a type <span class="docutils literal"><span class="pre">T</span></span> and wraps it into the generic type, such as
<span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, <span class="docutils literal"><span class="pre">T[]</span></span>, <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span>, or <span class="docutils literal"><span class="pre">Either&lt;Error,</span> <span class="pre">T&gt;</span></span>.  This function
is usually called <span class="docutils literal"><span class="pre">return()</span></span> or <span class="docutils literal"><span class="pre">unit()</span></span>.</p>
<p>A monad allows structuring programs generically while encapsulating away
boilerplate code needed by the program logic. With monads, a sequence of
function calls can be expressed as a pipeline that abstracts away data
management, control flow, or side effects.</p>
<p>Let’s look at a few examples of monads. We can start with our simple <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>
type and add <span class="docutils literal"><span class="pre">unit()</span></span> to it to complete the monad:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">Box</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">unit</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">export</span> <span class="kd">function</span> <span class="nx">bind</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">unit()</span></span> simply calls <span class="docutils literal"><span class="pre">Box</span></span>’s constructor to wrap the given value into an
instance of <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>. <span class="docutils literal"><span class="pre">bind()</span></span> unpacks the value from <span class="docutils literal"><span class="pre">Box</span></span> and calls
<span class="docutils literal"><span class="pre">func()</span></span> on it.</p>
<p>The implementation is very straightforward. Let’s look at the <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span>
monad functions:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">Optional</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">unit</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Optional</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">export</span> <span class="kd">function</span> <span class="nx">bind</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">optional</span>: <span class="kt">Optional</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">optional</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">())</span> <span class="k">return</span> <span class="k">new</span> <span class="nx">Optional</span><span class="p">();</span>

        <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">optional</span><span class="p">.</span><span class="nx">getValue</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">unit()</span></span> takes a value of type <span class="docutils literal"><span class="pre">T</span></span> and wraps it into an <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span>.
If the optional is empty, <span class="docutils literal"><span class="pre">bind()</span></span> returns an empty optional of type
<span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span>. If the optional contains a value, <span class="docutils literal"><span class="pre">bind()</span></span> return the
result of calling <span class="docutils literal"><span class="pre">func()</span></span> on it.</p>
<p>Very much as with functors, if a programming language can’t express higher
kinded types, we don’t have a good way to specify a <span class="docutils literal"><span class="pre">Monad</span></span> interface.
Instead, let’s think of monads as a pattern:</p>
<blockquote>
<div>A monad is a generic type <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span> for which we have a function like
<span class="docutils literal"><span class="pre">unit()</span></span>, that takes a value of type <span class="docutils literal"><span class="pre">T</span></span> and returns a value of
type <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span>, and a function like <span class="docutils literal"><span class="pre">bind()</span></span> that takes a value of
type <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span> and a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">H&lt;U&gt;</span></span>, and returns a
value of type <span class="docutils literal"><span class="pre">H&lt;U&gt;</span></span>.</div></blockquote>
<p>Bear in mind that because most languages use this pattern, without a way to
specify an interface for the compiler to check, in many instances the two
functions, <span class="docutils literal"><span class="pre">unit()</span></span> and <span class="docutils literal"><span class="pre">bind()</span></span>, may show up under different names.
You may hear the term <em>monadic</em>, as in <strong>monadic error handling</strong>, which means
that error handling follows the monad pattern.</p>
<p>Next, we’ll look at a few other examples.</p>
</div>
<div class="section" id="the-continuation-monad">
<h2>The Continuation Monad</h2>
<p>A promise represents the result of a computation that will happen sometime in
the future. <span class="docutils literal"><span class="pre">Promise&lt;T&gt;</span></span> is the promise of a value of type <span class="docutils literal"><span class="pre">T</span></span>. We can
schedule execution of asynchronous code by chaining promises, using the
<span class="docutils literal"><span class="pre">then()</span></span> function.</p>
<p>Let’s say we have a function that determines our location on the map. Because
this function will work with the GPS, it may take longer to finish, so we make
it asynchronous. It will return a promise of type <span class="docutils literal"><span class="pre">Promise&lt;Location&gt;</span></span>. Next,
we have a function that, given a location, will contact a ride-sharing service
to get us a <span class="docutils literal"><span class="pre">Car</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">getLocation</span><span class="p">()</span><span class="o">:</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">Location</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">hailRideshare</span><span class="p">(</span>
    <span class="nx">location</span>: <span class="kt">Location</span><span class="p">)</span><span class="o">:</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">Car</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">car</span>: <span class="kt">Promise</span><span class="o">&lt;</span><span class="nx">Car</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">getLocation</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">hailRideshare</span><span class="p">);</span>
</pre></div>
</div>
<p>When <span class="docutils literal"><span class="pre">getLocation()</span></span> returns, <span class="docutils literal"><span class="pre">hailRideshare()</span></span> will be invoked with its
result. This should look very familiar to you at this point. <span class="docutils literal"><span class="pre">then()</span></span> is just
how <span class="docutils literal"><span class="pre">Promise&lt;T&gt;</span></span> spells <span class="docutils literal"><span class="pre">bind()</span></span>!</p>
<p>we can also create an instantly resolved promise by using <span class="docutils literal"><span class="pre">Promise.resolve()</span></span>.
This takes a value and returns a resolved promise containing that value, which
is the <span class="docutils literal"><span class="pre">Promise&lt;T&gt;</span></span> equivalent of <span class="docutils literal"><span class="pre">unit()</span></span>.</p>
<p>Turns out chaining promises, an API available in virtually all mainstream
programming languages, is monadic. It follows the same pattern that we saw in
this section, but in a different domain. While dealing with error
propagation, our monad encapsulated checking whether we have a value that we
can continue operating on or have an error that we should propagate. With
promises, the monad encapsulates the intricacies of scheduling and resuming
execution. The pattern is the same, though.</p>
</div>
<div class="section" id="the-list-monad">
<h2>The List Monad</h2>
<p>Another commonly used monad is the list monad. Let’s look at an implementation
over sequences: a <span class="docutils literal"><span class="pre">divisors()</span></span> function that takes a number n and returns an
array containing all of its divisors except 1 and n itself.</p>
<p>This straightforward implementation starts from 2 and goes up to half of n,
and adds all numbers it finds that divide n without a remainder. There are
more efficient ways to find all divisors of a number, but we’ll stick to a
simple algorithm in this case:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">divisors</span><span class="p">(</span><span class="nx">n</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span><span class="p">[]</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mf">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">%</span> <span class="nx">i</span> <span class="o">==</span> <span class="mf">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s say we want to take an array of numbers and return an array
containing all their divisors. We don’t need to worry about dupes. One way to
do this is to provide a function that takes an array of input numbers,
applies <span class="docutils literal"><span class="pre">divisors()</span></span> to each of them, and joins the results of all the calls
to <span class="docutils literal"><span class="pre">divisors()</span></span> into a final result:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">allDivisors</span><span class="p">(</span><span class="nx">ns</span>: <span class="kt">number</span><span class="p">[])</span><span class="o">:</span> <span class="kt">number</span><span class="p">[]</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">ns</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">divisors</span><span class="p">(</span><span class="nx">n</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It turns out that this pattern is common. Let’s say that we have another
function, <span class="docutils literal"><span class="pre">anagrams()</span></span>, that generates all permutations of a string and
returns an array of strings. If we want to get the set of all anagrams of an
array of strings, we would end up implementing a very similar function:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">anagram</span><span class="p">(</span><span class="nx">input</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">[];</span>

<span class="kd">function</span> <span class="nx">allAnagrams</span><span class="p">(</span><span class="nx">inputs</span>: <span class="kt">string</span><span class="p">[])</span><span class="o">:</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">input</span> <span class="k">of</span> <span class="nx">inputs</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">anagram</span><span class="p">(</span><span class="nx">input</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">allAnagrams()</span></span> is very similar to <span class="docutils literal"><span class="pre">allDivisors()</span></span>.</p>
<p>Now let’s see whether we can replace <span class="docutils literal"><span class="pre">allDivisors()</span></span> and <span class="docutils literal"><span class="pre">allAnagrams()</span></span>
with a generic function. This function would take an array of <span class="docutils literal"><span class="pre">T</span></span>s and a
function from <span class="docutils literal"><span class="pre">T</span></span> to an array of <span class="docutils literal"><span class="pre">U</span></span>s, and return an array of <span class="docutils literal"><span class="pre">U</span></span>s:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">bind</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">inputs</span>: <span class="kt">T</span><span class="p">[],</span>
    <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">[])</span><span class="o">:</span> <span class="nx">U</span><span class="p">[]</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">U</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">input</span> <span class="k">of</span> <span class="nx">inputs</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">input</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">allDivisors</span><span class="p">(</span><span class="nx">ns</span>: <span class="kt">number</span><span class="p">[])</span><span class="o">:</span> <span class="kt">number</span><span class="p">[]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">ns</span><span class="p">,</span> <span class="nx">divisors</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">allAnagrams</span><span class="p">(</span><span class="nx">inputs</span>: <span class="kt">string</span><span class="p">[])</span><span class="o">:</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">inputs</span><span class="p">,</span> <span class="nx">anagram</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you’ve probably guessed, this is the <span class="docutils literal"><span class="pre">bind()</span></span> implementation for the list
monad. In the case of lists, <span class="docutils literal"><span class="pre">bind()</span></span> flattens the arrays returned by each
call of the given function into a single array. While the error-propagating
monad decides whether to propagate an error or apply a function and the
continuation monad wraps scheduling, the list monad combines a set of results
(a list of lists) into a single flat list. In this case, the box is a
sequence of values.</p>
<img alt="../../../_images/bind3.png" class="align-center" src="http://vladris.com/blog/_images/bind3.png"/>
<p>The <span class="docutils literal"><span class="pre">unit()</span></span> implementation is trivial. Given a value of type <span class="docutils literal"><span class="pre">T</span></span>, it
returns a list containing just that value. This monad generalizes to all kinds
of lists: arrays, linked lists, and iterator ranges.</p>
<blockquote>
<div><p><strong>Category theory</strong></p>
<p>Functors and monads come from category theory, a branch of mathematics that
deals with structures consisting of objects and arrows between these
objects. With these small building blocks, we can build up structures such
as functors and monads. We won’t go into its details now; we’ll just say
that multiple domains, like set theory and even type systems, can be
expressed in category theory.</p>
<p>Haskell is a programming language that took a lot of inspiration from
category theory, so its syntax and standard library make it easy to express
concepts such as functors, monads, and other structures. Haskell fully
supports higher kinded types.</p>
<p>Maybe because the building blocks of category theory are so simple, the
abstractions we’ve been talking about are applicable across so many domains.
We just saw that monads are useful in the context of error propagation,
asynchronous code, and sequence processing.</p>
<p>Although most mainstream languages still treat monads as patterns instead of
proper constructs, they are definitely useful structures that show up over
and over in different contexts.</p>
</div></blockquote>
</div>
<div class="section" id="other-monads">
<h2>Other Monads</h2>
<p>A couple of other common monads, which are popular in functional programming
languages with pure functions (functions that don’t have side effects) and
immutable data, are the state monad and the IO monad. We’ll provide only a
high-level overview of these monads, but if you decide to learn a functional
programming language such as Haskell, you will likely encounter them early in
your journey.</p>
<p>The state monad encapsulates a piece of state that it passes along with a
value. This monad enables us to write pure functions that, given a current
state, produce a value and an updated state. Chaining these together with
<span class="docutils literal"><span class="pre">bind()</span></span> allows us to propagate and update state through a pipeline without
explicitly storing it in a variable, enabling purely functional code to
process and update state.</p>
<p>The IO monad encapsulates side effects. It allows us to implement pure functions
that can still read user input or write to a file or terminal because the
impure behavior is removed from the function and wrapped in the IO monad.</p>
</div>
]]></description>
             <pubDate>Sat, 07 Sep 2019 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/09/06/higher-kinded-types-functors.html</link>
            <guid>http://vladris.com/blog/2019/09/06/higher-kinded-types-functors.html</guid>
            <title><![CDATA[Higher Kinded Types: Functors]]></title>
            <description><![CDATA[<h1>Higher Kinded Types: Functors</h1>
<p>This blog post is an excerpt from my book, <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>. The code samples
are in TypeScript. If you enjoy the article, you can use the discount code
<strong>vlri40</strong> for a 40% discount on the book.</p>
<div class="section" id="an-even-more-general-map">
<h2>An Even More General Map</h2>
<p>In the <a class="reference external" href="https://vladris.com/blog/2019/08/10/common-algorithms.html">previous post</a>
we saw a generic <span class="docutils literal"><span class="pre">map()</span></span> implementation working on iterators. Iterators
abstract data structure traversal, so <span class="docutils literal"><span class="pre">map()</span></span> can apply a function to
elements in any data structure.</p>
<img alt="../../../_images/map1.png" class="align-center" src="http://vladris.com/blog/_images/map1.png"/>
<p>In the figure, <span class="docutils literal"><span class="pre">map()</span></span> takes an iterator over a sequence, in this case a list
of circles, and a function which transforms a circle. <span class="docutils literal"><span class="pre">map()</span></span> applies the
function to each element in the sequence, and produces a new sequence with the
transformed elements.</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span><span class="o">*</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This implementation works on iterators, but we should be able to apply a
function of the form <span class="docutils literal"><span class="pre">(item:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> to other types too. Let’s take, as an
example, an <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span> type:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="nx">value</span>: <span class="kt">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">assigned</span>: <span class="kt">boolean</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value?</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">assigned</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">assigned</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">hasValue</span><span class="p">()</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">assigned</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">getValue</span><span class="p">()</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">assigned</span><span class="p">)</span> <span class="k">throw</span> <span class="nb">Error</span><span class="p">();</span>

        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It feels natural to be able to map a function <span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> over an
<span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span>. If the optional contains a value of type <span class="docutils literal"><span class="pre">T</span></span>, mapping the
function over it should return an <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span> containing the result of
applying the function. On the other hand, if the optional doesn’t contain a
value, mapping would result in an empty <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span>.</p>
<img alt="../../../_images/map2.png" class="align-center" src="http://vladris.com/blog/_images/map2.png"/>
<p>Let’s sketch out an implementation for this. We’ll put this function in a
namespace. Since TypeScript doesn’t support function overloading, in order to
have multiple functions with the same name, we need this so the compiler can
determine which function we are calling. Here’s the <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span> <span class="docutils literal"><span class="pre">map()</span></span>
implementation:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">Optional</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">optional</span>: <span class="kt">Optional</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">optional</span><span class="p">.</span><span class="nx">hasValue</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">optional</span><span class="p">.</span><span class="nx">getValue</span><span class="p">()));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">Optional</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">export</span></span> simply makes the function visible outside the namespace. If the
optional has a value, we extract it, pass it to <span class="docutils literal"><span class="pre">func()</span></span>, and use its result
to initialize an <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span>. If the optional is empty, we create a new
empty <span class="docutils literal"><span class="pre">Optional&lt;U&gt;</span></span>.</p>
<p>We can do something very similar with the TypeScript sum type <span class="docutils literal"><span class="pre">T</span></span> or
<span class="docutils literal"><span class="pre">undefined</span></span>. The <span class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></span> we just saw is a DIY version of such a type
that works even in languages which don’t support sum types natively, but
TypeScript does. Let’s see how we can map over a “native” optional type
<span class="docutils literal"><span class="pre">T</span> <span class="pre">|</span> <span class="pre">undefined</span></span>.</p>
<p>Mapping a function <span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> over <span class="docutils literal"><span class="pre">T</span> <span class="pre">|</span> <span class="pre">undefined</span></span> should apply the
function and return its result if we have a value of type <span class="docutils literal"><span class="pre">T</span></span>, or return
<span class="docutils literal"><span class="pre">undefined</span></span> if we start with <span class="docutils literal"><span class="pre">undefined</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">SumType</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">value</span>: <span class="kt">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">U</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These types can’t be iterated over, but it still makes sense for a <span class="docutils literal"><span class="pre">map()</span></span>
function to exist for them. Let’s define another simple generic type,
<span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>. This type simply wraps a value of type <span class="docutils literal"><span class="pre">T</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Can we map a function <span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> over this type? We can. As you might
have guessed, <span class="docutils literal"><span class="pre">map()</span></span> for <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> would return a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>: it will take
the value <span class="docutils literal"><span class="pre">T</span></span> out of <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, apply the function to it, and put the result
back into a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>.</p>
<img alt="../../../_images/map3.png" class="align-center" src="http://vladris.com/blog/_images/map3.png"/>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">Box</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are many generic types over which we can map functions. Why is this
useful? It’s useful because <span class="docutils literal"><span class="pre">map()</span></span>, just like iterators, provides another
way to decouple types which store data from functions which operate on that
data.</p>
</div>
<div class="section" id="processing-results-or-propagating-errors">
<h2>Processing Results or Propagating Errors</h2>
<p>As a concrete example, let’s take a couple of functions which process a
numerical value. We’ll implement a simple <span class="docutils literal"><span class="pre">square()</span></span>, a function which takes
a number as an argument and returns its square. We’ll also implement
<span class="docutils literal"><span class="pre">stringify()</span></span>, a function which takes a number as an argument and returns its
string representation:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">square</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span> <span class="o">**</span> <span class="mf">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s say we have a function <span class="docutils literal"><span class="pre">readNumber()</span></span>, which reads a numeric value
from a file. Since we are dealing with input, we might run into some problems:
what if the file doesn’t exist or can’t be opened? In that case,
<span class="docutils literal"><span class="pre">readNumber()</span></span> will return <span class="docutils literal"><span class="pre">undefined</span></span>. We won’t look at the implementation
of this function, the important thing for our example is its return type:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">readNumber</span><span class="p">()</span><span class="o">:</span> <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="cm">/* Implementation omitted */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we want to read a number and process it by applying <span class="docutils literal"><span class="pre">square()</span></span> to it first,
then <span class="docutils literal"><span class="pre">stringify()</span></span>, we need to ensure we actually have a numerical value as
opposed to <span class="docutils literal"><span class="pre">undefined</span></span>. A possible implementation is to convert from
<span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span> to just <span class="docutils literal"><span class="pre">number</span></span> using <span class="docutils literal"><span class="pre">if</span></span> statements wherever
needed:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">process</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="nx">readNumber</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">square</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have two functions that operate on numbers, but since our input can also be
<span class="docutils literal"><span class="pre">undefined</span></span>, we need to explicitly handle that case. This is not particularly
bad, but in general the less branching our code has, the less complex it is. It
is easier to understand, to maintain, and there are less opportunities for bugs.
Another way to look at this is that <span class="docutils literal"><span class="pre">process()</span></span> itself simply propagates
<span class="docutils literal"><span class="pre">undefined</span></span>, it doesn’t do anything useful with it. It would be better if we
can keep <span class="docutils literal"><span class="pre">process()</span></span> responsible for processing, and let someone else handle
error cases. How can we do this? With the <span class="docutils literal"><span class="pre">map()</span></span> we implemented for sum
types:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nx">SumType</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">value</span>: <span class="kt">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">U</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">process</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="nx">readNumber</span><span class="p">();</span>

    <span class="kd">let</span> <span class="nx">squaredValue</span> <span class="o">=</span> <span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">square</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">squaredValue</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Instead of explicitly checking for <span class="docutils literal"><span class="pre">undefined</span></span>, we call <span class="docutils literal"><span class="pre">map()</span></span> to apply
<span class="docutils literal"><span class="pre">square()</span></span> on the value. If it is <span class="docutils literal"><span class="pre">undefined</span></span>, <span class="docutils literal"><span class="pre">map()</span></span> will give us back
<span class="docutils literal"><span class="pre">undefined</span></span>. Just like with <span class="docutils literal"><span class="pre">square()</span></span>, we <span class="docutils literal"><span class="pre">map()</span></span> our <span class="docutils literal"><span class="pre">stringify()</span></span>
function on the <span class="docutils literal"><span class="pre">squaredValue</span></span>. If it is <span class="docutils literal"><span class="pre">undefined</span></span>, <span class="docutils literal"><span class="pre">map()</span></span> will return
<span class="docutils literal"><span class="pre">undefined</span></span>.</p>
<p>Now our <span class="docutils literal"><span class="pre">process()</span></span> implementation has no branching – the responsibility of
unpacking <span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span> into a <span class="docutils literal"><span class="pre">number</span></span> and checking for
<span class="docutils literal"><span class="pre">undefined</span></span> is handled by <span class="docutils literal"><span class="pre">map()</span></span>. <span class="docutils literal"><span class="pre">map()</span></span> is generic and can be used
across many other types (like <span class="docutils literal"><span class="pre">string</span> <span class="pre">|</span> <span class="pre">undefined</span></span>) and in many other
processing functions.</p>
<p>In our case, since <span class="docutils literal"><span class="pre">square()</span></span> is guaranteed to return a <span class="docutils literal"><span class="pre">number</span></span>, we can
create a small lambda which chains <span class="docutils literal"><span class="pre">square()</span></span> and <span class="docutils literal"><span class="pre">stringify()</span></span>, and pass
that to <span class="docutils literal"><span class="pre">map()</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">process</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="nx">readNumber</span><span class="p">();</span>

    <span class="k">return</span> <span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span>
        <span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">square</span><span class="p">(</span><span class="nx">value</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a functional implementation of <span class="docutils literal"><span class="pre">process()</span></span>, in which the error
propagation is delegated to <span class="docutils literal"><span class="pre">map()</span></span>. We’ll talk more about error handling
in a later blog post, when we will discuss monads. For now, let’s look at
another application of <span class="docutils literal"><span class="pre">map()</span></span>.</p>
</div>
<div class="section" id="mix-and-match-function-application">
<h2>Mix-and-match Function Application</h2>
<p>Without the <span class="docutils literal"><span class="pre">map()</span></span> family of functions, if we have a <span class="docutils literal"><span class="pre">square()</span></span> function
which squares a <span class="docutils literal"><span class="pre">number</span></span>, we would have to implement some additional logic to
get a <span class="docutils literal"><span class="pre">number</span></span> from a <span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span> sum type. Similarly, we would
have to implement some additional logic to get a value from a <span class="docutils literal"><span class="pre">Box&lt;number&gt;</span></span>,
and package it back in a <span class="docutils literal"><span class="pre">Box&lt;number&gt;</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">squareSumType</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">)</span>
    <span class="o">:</span> <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">square</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">squareBox</span><span class="p">(</span><span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">square</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So far this isn’t too bad. But what if we want something similar with
<span class="docutils literal"><span class="pre">stringify()</span></span>? We’ll again end up writing two functions which look a lot like
the previous ones:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">stringifySumType</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">)</span>
    <span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">stringifyBox</span><span class="p">(</span><span class="nx">box</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">box</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This starts to look like duplicate code, which is never good. If we have
<span class="docutils literal"><span class="pre">map()</span></span> functions available for <span class="docutils literal"><span class="pre">number</span> <span class="pre">|</span> <span class="pre">undefined</span></span> and <span class="docutils literal"><span class="pre">Box</span></span>, they
provide the abstraction to remove the duplicate code. We can pass either
<span class="docutils literal"><span class="pre">square()</span></span> or <span class="docutils literal"><span class="pre">stringify()</span></span> to either <span class="docutils literal"><span class="pre">SumType.map()</span></span> or to
<span class="docutils literal"><span class="pre">Box.map()</span></span>, no additional code needed:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">let</span> <span class="nx">x</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="o">=</span> <span class="mf">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">y</span>: <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="mf">42</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Box</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">));</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">SumType</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">square</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Box</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">square</span><span class="p">));</span>
</pre></div>
</div>
<p>Now let’s define this family of <span class="docutils literal"><span class="pre">map()</span></span> functions.</p>
</div>
<div class="section" id="functors-and-higher-kinded-types">
<h2>Functors and Higher Kinded Types</h2>
<p>What we just talked about in this section are <em>functors</em>.</p>
<p>A functor is a generalization of functions that perform mapping operations. For
any generic type like <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, a <span class="docutils literal"><span class="pre">map()</span></span> operation which takes a
<span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> and a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span> and produces a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span> is a
functor.</p>
<img alt="../../../_images/map4.png" class="align-center" src="http://vladris.com/blog/_images/map4.png"/>
<p>In the figure we have a generic type <span class="docutils literal"><span class="pre">H</span></span> which contains 0, 1, or more values
of some type <span class="docutils literal"><span class="pre">T</span></span>, and a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span>. In this case <span class="docutils literal"><span class="pre">T</span></span> is
an empty circle and <span class="docutils literal"><span class="pre">U</span></span> is a full circle. The <span class="docutils literal"><span class="pre">map()</span></span> functor unpacks the
<span class="docutils literal"><span class="pre">T</span></span> or <span class="docutils literal"><span class="pre">T</span></span>s from the <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span> instance, applies the function, then places
the result back into an <span class="docutils literal"><span class="pre">H&lt;U&gt;</span></span>.</p>
<p>Functors are extremely powerful concepts, but most mainstream languages do not
have a good way to express them. That’s because the general definition of a
functor relies on <em>higher kinded types</em>.</p>
<p>A generic type is a type which has a type parameter, for example a generic type
<span class="docutils literal"><span class="pre">T</span></span>, or a type like <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span>, have a type parameter <span class="docutils literal"><span class="pre">T</span></span>. A higher kinded
type, just like a higher-order function, represents a type parameter with
another type parameter. For example, <span class="docutils literal"><span class="pre">T&lt;U&gt;</span></span> or <span class="docutils literal"><span class="pre">Box&lt;T&lt;U&gt;&gt;</span></span>, have a type
parameter <span class="docutils literal"><span class="pre">T</span></span> which, in turn, has a type parameter <span class="docutils literal"><span class="pre">U</span></span>.</p>
<p>Since we don’t have a good way to express higher kinded types in TypeScript, C#,
or Java, we can’t define a construct using the type system to express a functor.
Languages like Haskell and Idris, with more powerful type systems, make these
definitions possible. In our case though, since we can’t enforce this capability
through the type system, we can think of it more as a pattern.</p>
<p>We can say a functor is any type <span class="docutils literal"><span class="pre">H</span></span> with a type parameter <span class="docutils literal"><span class="pre">T</span></span> (<span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span>)
for which we have a function <span class="docutils literal"><span class="pre">map()</span></span> which takes an argument of type <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span>,
and a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span>, and returns a value of type <span class="docutils literal"><span class="pre">H&lt;U&gt;</span></span>.</p>
<p>Alternately, if we want to be more object-oriented, we can make <span class="docutils literal"><span class="pre">map()</span></span> a
member function and say <span class="docutils literal"><span class="pre">H&lt;T&gt;</span></span> is a functor if it has a method <span class="docutils literal"><span class="pre">map()</span></span> which
takes a function from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">U</span></span> and returns a value of type <span class="docutils literal"><span class="pre">H&lt;U&gt;</span></span>.</p>
<p>To see exactly where the type system is lacking, we can try to sketch out an
interface for it. Let’s call this interface <span class="docutils literal"><span class="pre">Functor</span></span> and have it declare
<span class="docutils literal"><span class="pre">map()</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">interface</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can update <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> to implement this interface:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="k">implements</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code compiles, the only problem is that it isn’t specific enough. Calling
<span class="docutils literal"><span class="pre">map()</span></span> on <span class="docutils literal"><span class="pre">Box&lt;T&gt;</span></span> returns an instance of type <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>. But if we work
with <span class="docutils literal"><span class="pre">Functor</span></span> interfaces, we see that the <span class="docutils literal"><span class="pre">map()</span></span> declaration specifies
it returns a <span class="docutils literal"><span class="pre">Functor&lt;U&gt;</span></span>, not a <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>. This isn’t specific enough. We
need a way to specify, when we declare the interface, exactly what the return
type of <span class="docutils literal"><span class="pre">map()</span></span> will be (in this case <span class="docutils literal"><span class="pre">Box&lt;U&gt;</span></span>).</p>
<p>We would like to be able to say “this interface will be implemented by a type
<span class="docutils literal"><span class="pre">H</span></span> with a type argument <span class="docutils literal"><span class="pre">T</span></span>”. The following code shows how this declaration
would look like if TypeScript supported higher kinded types. It obviously
doesn’t compile:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">interface</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">H</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">H</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="k">implements</span> <span class="nx">Functor</span><span class="o">&lt;</span><span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Box</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Lacking this, let’s just think of our <span class="docutils literal"><span class="pre">map()</span></span> implementations as a pattern for
applying functions to generic types, or “values in some box”.</p>
</div>
<div class="section" id="functors-for-functions">
<h2>Functors for Functions</h2>
<p>Note that we also have functors over functions. Given a function with any number
of arguments that returns a value of type <span class="docutils literal"><span class="pre">T</span></span>, we can map a function which
takes a <span class="docutils literal"><span class="pre">T</span></span> and produces a <span class="docutils literal"><span class="pre">U</span></span> over it, and end up with a function which
takes the same inputs as the original function and returns a value of type
<span class="docutils literal"><span class="pre">U</span></span>. <span class="docutils literal"><span class="pre">map()</span></span> in this case is simply function composition.</p>
<img alt="../../../_images/map5.png" class="align-center" src="http://vladris.com/blog/_images/map5.png"/>
<p>Mapping a function over another function composes the two functions. The result
is a function which takes the same arguments as the original function and
returns a value of the second function’s return type. The two functions need to
be compatible – the second function must expect an argument of the same type as
the one returned by the original function.</p>
<p>As an example, let’s take a function which takes two arguments of type <span class="docutils literal"><span class="pre">T</span></span>,
and produces a value of type <span class="docutils literal"><span class="pre">T</span></span> and implement its corresponding <span class="docutils literal"><span class="pre">map()</span></span>.
This will return a function which takes two arguments of type <span class="docutils literal"><span class="pre">T</span></span> and returns
a value of type <span class="docutils literal"><span class="pre">U</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">namespace</span> <span class="nb">Function</span> <span class="p">{</span>
    <span class="k">export</span> <span class="kd">function</span> <span class="nx">map</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="nx">f</span><span class="o">:</span> <span class="p">(</span><span class="nx">arg1</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">arg2</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">,</span>
        <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="nx">arg1</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">arg2</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="nx">arg1</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">arg2</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">func</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">map()</span></span> takes a function <span class="docutils literal"><span class="pre">(T,</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">T</span></span>, and a function <span class="docutils literal"><span class="pre">T</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span> to map
over it. It returns a lambda function <span class="docutils literal"><span class="pre">(T,</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span>.</p>
<p>Let’s map <span class="docutils literal"><span class="pre">stringify()</span></span> over a function <span class="docutils literal"><span class="pre">add()</span></span>, which takes two numbers and
returns their sum. The result is a function which takes two numbers and returns
a string, the stringified result of adding the two numbers:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">result</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">add</span><span class="p">,</span> <span class="nx">stringify</span><span class="p">)(</span><span class="mf">40</span><span class="p">,</span> <span class="mf">2</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li><span class="docutils literal"><span class="pre">map()</span></span> generalizes beyond iterators, to other generic types</li>
<li>Functors encapsulate data “unboxing”, with applications in composition and
error propagation</li>
<li>With higher kinded types, we can express constructs like functors using
generics which themselves have type parameters</li>
</ul>
</div>
]]></description>
             <pubDate>Fri, 06 Sep 2019 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/08/10/common-algorithms.html</link>
            <guid>http://vladris.com/blog/2019/08/10/common-algorithms.html</guid>
            <title><![CDATA[Common Algorithms]]></title>
            <description><![CDATA[<h1>Common Algorithms</h1>
<p>This blog post is an excerpt from my book, <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>. The code samples
are in TypeScript. If you enjoy the article, you can use the discount code
<strong>vlri40</strong> for a 40% discount on the book.</p>
<div class="section" id="a-few-common-algorithms">
<h2>A Few Common Algorithms</h2>
<p>There are many algorithms commonly used to process a sequence of data. Let’s
list a few of them. We will not look at the implementation, just describe what
arguments besides the iterable they expect and how they process the data. We’ll
also mention some synonyms under which the algorithm might appear.</p>
<ul class="simple">
<li><span class="docutils literal"><span class="pre">map()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values, a function <span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">U</span></span>
and returns a sequence of <span class="docutils literal"><span class="pre">U</span></span> values applying the function to all the
elements in the sequence. It is also known as <span class="docutils literal"><span class="pre">fmap()</span></span>, <span class="docutils literal"><span class="pre">select()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">filter()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values, a predicate
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">boolean</span></span> and returns a sequence of <span class="docutils literal"><span class="pre">T</span></span> values containing
all the items for which the predicate returns true. It is also known as
<span class="docutils literal"><span class="pre">where()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">reduce()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values, an initial value of type
<span class="docutils literal"><span class="pre">T</span></span>, and an operation which combines two <span class="docutils literal"><span class="pre">T</span></span> values into one
<span class="docutils literal"><span class="pre">(x:</span> <span class="pre">T,</span> <span class="pre">y:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">T</span></span>. It returns a single value <span class="docutils literal"><span class="pre">T</span></span> after combining all the
elements in the sequence using the operation. It is also known as <span class="docutils literal"><span class="pre">fold()</span></span>,
<span class="docutils literal"><span class="pre">collect()</span></span>, <span class="docutils literal"><span class="pre">accumulate()</span></span>, <span class="docutils literal"><span class="pre">aggregate()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">any()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a predicate
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">boolean</span></span>. It returns true if any one of the elements of the
sequence satisfies the predicate.</li>
<li><span class="docutils literal"><span class="pre">all()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a predicate
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">boolean</span></span>. It returns true if all of the elements of the
sequence satisfy the predicate.</li>
<li><span class="docutils literal"><span class="pre">none()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a predicate
<span class="docutils literal"><span class="pre">(value:</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">boolean</span></span>. It returns true if none of the elements of the
sequence satisfy the predicate.</li>
<li><span class="docutils literal"><span class="pre">take()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a number <span class="docutils literal"><span class="pre">n</span></span>. It returns a
sequence consisting of the first <span class="docutils literal"><span class="pre">n</span></span> elements of the original sequence. It
is also known as <span class="docutils literal"><span class="pre">limit()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">drop()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a number <span class="docutils literal"><span class="pre">n</span></span>. It returns a
sequence consisting of all the elements of the original sequence except the
first <span class="docutils literal"><span class="pre">n</span></span>. The first <span class="docutils literal"><span class="pre">n</span></span> elements are dropped. It is also known as
<span class="docutils literal"><span class="pre">skip()</span></span>.</li>
<li><span class="docutils literal"><span class="pre">zip()</span></span> takes a sequence of <span class="docutils literal"><span class="pre">T</span></span> values and a sequence of <span class="docutils literal"><span class="pre">U</span></span> values. It
returns a sequence containing pairs of <span class="docutils literal"><span class="pre">T</span></span> and <span class="docutils literal"><span class="pre">U</span></span> values, effectively
“zipping” together the two sequences.</li>
</ul>
<p>There are many more algorithms for sorting, reversing, splitting and
concatenating sequences. The good news is that, because these algorithms are
so useful and generally applicable, we don’t need to implement them. Most
languages have libraries which provide these algorithms and more. For
JavaScript, there is the <span class="docutils literal"><span class="pre">underscore.js</span></span> package and the <span class="docutils literal"><span class="pre">lodash</span></span>
package, both providing a plethora of such algorithms (at the time of
writing, these libraries don’t support iterators, only the JavaScript
built-in array and object types). In Java, they are found in the
<span class="docutils literal"><span class="pre">java.util.stream</span> <span class="pre">package</span></span>. In C# they are in the <span class="docutils literal"><span class="pre">System.Linq</span></span>
namespace. In C++ they are found in the <span class="docutils literal"><span class="pre">&lt;algorithm&gt;</span></span> standard library
header.</p>
</div>
<div class="section" id="algorithms-instead-of-loops">
<h2>Algorithms Instead of Loops</h2>
<p>While you might be surprised, a good rule of thumb is to check, whenever you
find yourself writing a loop, whether there is a library algorithm or a
pipeline that can do the job. Usually we write loops to process a sequence –
exactly what the algorithms we talked about do.</p>
<p>The reason to prefer library algorithms to custom code in loops is that there
is less opportunity for mistakes: library algorithms are tried and tested,
implemented efficiently, and the code we end up with is easier to understand
as the operations are spelled out.</p>
</div>
<div class="section" id="implementing-a-fluent-pipeline">
<h2>Implementing a Fluent Pipeline</h2>
<p>Most libraries also provide a fluent API to chain algorithms together into a
pipeline. Fluent APIs are APIs based on method chaining, making the code much
easier to read. To see the difference between a fluent and a non-fluent API,
let’s take a look at a simple filter/reduce pipeline.</p>
<p>Let’s start with a simple implementation of the two algorithms. To implement
<span class="docutils literal"><span class="pre">filter()</span></span> we can use a generator. We take an <span class="docutils literal"><span class="pre">Itreable&lt;T&gt;</span></span> as the input
sequence and a predicate from <span class="docutils literal"><span class="pre">T</span></span> to <span class="docutils literal"><span class="pre">boolean</span></span>, and return another
sequence as an <span class="docutils literal"><span class="pre">IterableIterator&lt;T&gt;</span></span>. <span class="docutils literal"><span class="pre">ItreableIterator</span></span> is the return
type of all generators in TypeScript. The function will simply traverse the
sequence and for each element, if the predicate returns true, yield the
element to the caller:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="o">*</span><span class="nx">filter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">items</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nx">pred</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)</span>
    <span class="o">:</span><span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pred</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">reduce()</span></span> takes an <span class="docutils literal"><span class="pre">Iterable&lt;T&gt;</span></span> as the input sequence and an initial
value of type <span class="docutils literal"><span class="pre">T</span></span>. It also takes a function <span class="docutils literal"><span class="pre">(T,</span> <span class="pre">T)</span> <span class="pre">=&gt;</span> <span class="pre">T</span></span> which combines
(reduces) two values of type <span class="docutils literal"><span class="pre">T</span></span> into one. This function iterates over the
sequence and reduces all the elements to a single value, which it returns:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">function</span> <span class="nx">reduce</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">items</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nx">init</span>: <span class="kt">T</span><span class="p">,</span>
    <span class="nx">op</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">)</span>
    <span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">T</span> <span class="o">=</span> <span class="nx">init</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s look at how we could combine these algorithms into a pipeline which
sums up all even values of an array. We will pass the array to <span class="docutils literal"><span class="pre">filter()</span></span>
first, with a predicate which returns true for even numbers. Next, we will
reduce the resulting sequence using an initial value of 0 and the function
<span class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">=&gt;</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></span>:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">const</span> <span class="nx">sequence</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">6</span><span class="p">];</span>

<span class="kd">const</span> <span class="nx">result</span>: <span class="kt">number</span> <span class="o">=</span>
    <span class="nx">reduce</span><span class="p">(</span>
        <span class="nx">filter</span><span class="p">(</span>
            <span class="nx">sequence</span><span class="p">,</span>
            <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">%</span> <span class="mf">2</span> <span class="o">==</span> <span class="mf">0</span><span class="p">),</span>
        <span class="mf">0</span><span class="p">,</span>
        <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Even though we apply <span class="docutils literal"><span class="pre">filter()</span></span> first, then pass the result to <span class="docutils literal"><span class="pre">reduce()</span></span>,
if we read the code from left to right, we see <span class="docutils literal"><span class="pre">reduce()</span></span> before
<span class="docutils literal"><span class="pre">filter()</span></span>. It’s also a bit hard to make sense of which arguments go with
which function in the pipeline. Fluent APIs make the code much easier to read.
Currently, all our algorithms take an iterable as the first argument and
return an iterable. We can use object-oriented programming to improve our API.
We can put all our algorithms into a class which wraps an iterable. Then we
can call any of them without explicitly providing an iterable as the first
argument – the iterable is a member of the class. Let’s do this for
<span class="docutils literal"><span class="pre">map()</span></span>, <span class="docutils literal"><span class="pre">filter()</span></span>, and <span class="docutils literal"><span class="pre">reduce()</span></span>, by grouping them into a new
<span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> class wrapping an iterable:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">FluentIterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">iter</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="nx">filter</span><span class="p">(</span><span class="nx">pred</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">pred</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">reduce</span><span class="p">(</span><span class="nx">init</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">op</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">T</span> <span class="o">=</span> <span class="nx">init</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can create a <span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> out of an <span class="docutils literal"><span class="pre">Iterable&lt;T&gt;</span></span>, so we can
rewrite our filter/reduce pipeline into a more fluent form. We create a
<span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span>, call <span class="docutils literal"><span class="pre">filter()</span></span> on it, then we create a new
<span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> out of its result, and call <span class="docutils literal"><span class="pre">reduce()</span></span> on it:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">const</span> <span class="nx">sequence</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">6</span><span class="p">];</span>

<span class="kd">const</span> <span class="nx">result</span>: <span class="kt">number</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span>
        <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span>
            <span class="nx">sequence</span>
        <span class="p">).</span><span class="nx">filter</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">%</span> <span class="mf">2</span> <span class="o">==</span> <span class="mf">0</span><span class="p">)</span>
    <span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Now <span class="docutils literal"><span class="pre">filter()</span></span> appears before <span class="docutils literal"><span class="pre">reduce()</span></span>, and it’s very clear which
arguments go to which function. The only problem is we need to create a new
<span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> after each function call. We can improve our API by
having our <span class="docutils literal"><span class="pre">map()</span></span> and <span class="docutils literal"><span class="pre">filter()</span></span> functions return a <span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span>
instead of the default <span class="docutils literal"><span class="pre">IterableIterator&lt;T&gt;</span></span>. Note we don’t need to change
<span class="docutils literal"><span class="pre">reduce()</span></span>, because <span class="docutils literal"><span class="pre">reduce()</span></span> returns a single value of type <span class="docutils literal"><span class="pre">T</span></span>, not
an iterable.</p>
<p>Since we’re using generators, we can’t simply change the return type. Generators
exist to provide convenient syntax for functions, but they always return an
<span class="docutils literal"><span class="pre">IterableIterator&lt;T&gt;</span></span>. What we can do instead is to move the implementations
to a couple of private methods, <span class="docutils literal"><span class="pre">mapImpl()</span></span> and <span class="docutils literal"><span class="pre">filterImpl()</span></span>, and handle
the conversion from <span class="docutils literal"><span class="pre">IterableIterator&lt;T&gt;</span></span> to <span class="docutils literal"><span class="pre">FluentIterable&lt;T&gt;</span></span> in the
public <span class="docutils literal"><span class="pre">map()</span></span> and <span class="docutils literal"><span class="pre">reduce()</span></span> methods:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">FluentIterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">iter</span>: <span class="kt">Iterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">iter</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">map</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">FluentIterable</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">mapImpl</span><span class="p">(</span><span class="nx">func</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="o">*</span><span class="nx">mapImpl</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">filter</span><span class="o">&lt;</span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">pred</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">FluentIterable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">filterImpl</span><span class="p">(</span><span class="nx">pred</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="o">*</span><span class="nx">filterImpl</span><span class="p">(</span><span class="nx">pred</span><span class="o">:</span> <span class="p">(</span><span class="nx">item</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">IterableIterator</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">pred</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">reduce</span><span class="p">(</span><span class="nx">init</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">op</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">T</span> <span class="o">=</span> <span class="nx">init</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">value</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="nx">op</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this updated implementation, we can more easily chain the algorithms, as
each returns a <span class="docutils literal"><span class="pre">FluentIterable</span></span>, which contains all the algorithms as
methods:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">const</span> <span class="nx">sequence</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">5</span><span class="p">,</span> <span class="mf">6</span><span class="p">];</span>

<span class="kd">const</span> <span class="nx">result</span>: <span class="kt">number</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nx">FluentIterable</span><span class="p">(</span><span class="nx">sequence</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">%</span> <span class="mf">2</span> <span class="o">==</span> <span class="mf">0</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, in true fluent fashion, the code reads easily from left to right and we
can chain any number of algorithms that make up our pipeline with a very
natural syntax. Most algorithm libraries take a similar approach, making it
as easy as possible to chain multiple algorithms together.</p>
<p>Depending on the programming language, one downside of a fluent API approach
is that our <span class="docutils literal"><span class="pre">FluentIterable</span></span> ends up containing all the algorithms, so it is
difficult to extend - if it is part of a library, calling code can’t easily
add a new algorithm without modifying the class. C# provides extension
methods, which enable us to add methods to a class or interface without
modifying its code. Not all languages have such features though. That being
said, in most situations you should be using an existing algorithm library,
not implementing a new one from scratch.</p>
</div>
]]></description>
             <pubDate>Sat, 10 Aug 2019 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/07/16/a-switchless-state-machine.html</link>
            <guid>http://vladris.com/blog/2019/07/16/a-switchless-state-machine.html</guid>
            <title><![CDATA[A Switchless State Machine]]></title>
            <description><![CDATA[<h1>A Switchless State Machine</h1>
<p>This blog post is an excerpt from my book, <a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>.
The code samples are in TypeScript.</p>
<div class="section" id="early-programming-with-types">
<h2>Early Programming with Types</h2>
<p>While working on an early draft of the book, I wrote a small script to help me
keep the source code in sync with the text. The draft was written in the
popular Markdown format. I kept the source code in separate TypeScript files
so I could compile them and ensure that, even if I update the code samples,
they still work.</p>
<p>I needed a way to ensure that the Markdown text always contains the latest code
samples. The code samples always appear between a line containing <span class="docutils literal"><span class="pre">```ts</span></span> and
a line containing <span class="docutils literal"><span class="pre">```</span></span>. When generating HTML from the Markdown source,
<span class="docutils literal"><span class="pre">```ts</span></span> is interpreted as the beginning of a TypeScript code block, which
gets rendered using TypeScript syntax highlighting, while <span class="docutils literal"><span class="pre">```</span></span> marks the end
of that code block. The contents of these code blocks had to be inlined from
actual TypeScript source files which I could compile and validate outside of the
text.</p>
<blockquote>
<div><img alt="../../../_images/manuscript.png" class="align-center" src="http://vladris.com/blog/_images/manuscript.png"/>
</div></blockquote>
<p>The figure shows two TypeScript (.ts) files containing code samples which
should be inlined in the Markdown document between <span class="docutils literal"><span class="pre">```ts</span></span> and <span class="docutils literal"><span class="pre">```</span></span>
markers. The <span class="docutils literal"><span class="pre">&lt;!--</span> <span class="pre">...</span> <span class="pre">--&gt;</span></span> comments annotate the code samples for my
script.</p>
<p>To determine which code sample goes where, I relied on a small trick: Markdown
allows raw HTML in the document text. I annotated each code sample with an HTML
comment, for example <span class="docutils literal"><span class="pre">&lt;!--</span> <span class="pre">sample1</span> <span class="pre">--&gt;</span></span>. HTML comments do not get rendered, so
when converting Markdown to HTML, these became invisible. On the other hand, my
script could use these to determine which code sample to inline where.</p>
<p>Once all code samples were loaded from disk, I had to process each Markdown
document of the draft and produce an updated version as follows:</p>
<ul class="simple">
<li>In text processing mode, simply copy each line of the input text to the output
document as-is. Once a marker is encountered (<span class="docutils literal"><span class="pre">&lt;!--</span> <span class="pre">sample</span> <span class="pre">--&gt;</span></span>), grab the
corresponding code sample and switch to marker processing mode.</li>
<li>In marker processing mode, again copy each line of the input text to the
output document until we encounter a code block marker (<span class="docutils literal"><span class="pre">```ts</span></span>). Once the
code marker is encountered, output the latest version of the code sample as
loaded from the TypeScript file and switch to code processing mode.</li>
<li>In code processing mode, we already ensured the latest version of the code is
in the output document, so we can skip over the potentially outdated version
in the code block. That means we skip each line until we encounter the end of
code block marker (<span class="docutils literal"><span class="pre">```</span></span>). Then we switch back to text processing mode.</li>
</ul>
<p>With each run, the existing code samples in the document preceded by a
<span class="docutils literal"><span class="pre">&lt;!--</span> <span class="pre">...</span> <span class="pre">--&gt;</span></span> marker get updated to the latest version of the TypeScript
files on disk. Other code blocks that aren’t preceded by <span class="docutils literal"><span class="pre">&lt;!--</span> <span class="pre">...</span> <span class="pre">--&gt;</span></span> don’t
get updated as they are processed in text processing mode.</p>
<p>As an example, let’s take a <span class="docutils literal"><span class="pre">helloWorld.ts</span></span> code sample:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello world!"</span><span class="p">);</span>
</pre></div>
</div>
<p>We want to embed this in <span class="docutils literal"><span class="pre">Chapter1.md</span></span> and make sure it’s kept up to date.</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span/><span class="gh"># Chapter 1</span>

Printing "Hello world!".
&lt;!-- helloWorld --&gt;
<span class="sb">```ts</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello"</span><span class="p">);</span>
<span class="sb">```</span>
</pre></div>
</div>
<p>This is not quite up to date, the string here is <span class="docutils literal"><span class="pre">"Hello"</span></span>, not matching
<span class="docutils literal"><span class="pre">helloWorld.ts</span></span>.</p>
<p>This document gets processed line by line as follows:</p>
<ol class="arabic simple">
<li>In text processing mode, <span class="docutils literal"><span class="pre">"#</span> <span class="pre">Chapter</span> <span class="pre">1"</span></span> is copied to the output as-is.</li>
<li><span class="docutils literal"><span class="pre">""</span></span> (blank line) is copied to the output as-is.</li>
<li><span class="docutils literal"><span class="pre">"Printing</span> <span class="pre">"Hello</span> <span class="pre">world!"."</span></span> is copied to the output as-is.</li>
<li><span class="docutils literal"><span class="pre">"&lt;!--</span> <span class="pre">helloWorld</span> <span class="pre">--&gt;"</span></span> is copied to the output as-is. This is a marker
though, so we keep track of the code sample to be inlined
(helloWorld.ts) and switch to marker processing mode.</li>
<li><span class="docutils literal"><span class="pre">"```ts"</span></span> is copied to the output as-is. This is a code block marker, so
immediately after copying it to the output we also output the contents of
<span class="docutils literal"><span class="pre">helloWorld.ts</span></span>. We also switch to code processing mode.</li>
<li><span class="docutils literal"><span class="pre">"console.log("Hello");"</span></span> is skipped. We don’t copy lines in code
processing mode, as we are replacing them with the latest in the code
sample file.</li>
<li><span class="docutils literal"><span class="pre">```</span></span> is an end of code block marker. We insert it then switch back to
text processing mode.</li>
</ol>
</div>
<div class="section" id="state-machines">
<h2>State Machines</h2>
<p>The behavior of our text processing script is best modelled as a state machine.
A state machine has a set of states and a set of transitions between pairs of
states. The machine starts in a given state, also known as the <em>start state</em>,
then if certain conditions are met, it can transition to another state.</p>
<p>This is exactly what our text processor does, with its three processing modes.
Input lines are processed a certain way when in <em>text processing mode</em>. When
some condition is met (a <span class="docutils literal"><span class="pre">&lt;!--</span> <span class="pre">sample</span> <span class="pre">--&gt;</span></span> marker is encountered), our
processor transitions to the marker processing mode. Again, when some other
condition is met (<span class="docutils literal"><span class="pre">```ts</span></span> code block marker encountered), it transitions to
<em>code processing mode</em>. When the end of the code block marker is encountered
(<span class="docutils literal"><span class="pre">```</span></span>), it transitions back to <em>text processing mode</em>.</p>
<blockquote>
<div><img alt="../../../_images/state-machine.png" class="align-center" src="http://vladris.com/blog/_images/state-machine.png"/>
</div></blockquote>
<p>The figure shows a text processing state machine with the three states (text
processing, marker processing, code processing) and transitions between the
states based on input. Text processing is the initial state or start state.</p>
<p>Now that we modeled the solution, let’s look at how we would implement it. One
way to implement a state machine is by defining the set of states as an
enumeration, keeping track of the current state, and get the desired behavior
with a <span class="docutils literal"><span class="pre">switch</span></span> statement that covers all possible states. In our case, we can
define a <span class="docutils literal"><span class="pre">TextProcessingMode</span></span> enum.</p>
<p>Our <span class="docutils literal"><span class="pre">TextProcessor</span></span> class will keep track of the current state in a <span class="docutils literal"><span class="pre">mode</span></span>
property, and implement the switch statement in a <span class="docutils literal"><span class="pre">processLine()</span></span> method.
Depending on the state, this method will in turn invoke one of the three
processing methods, <span class="docutils literal"><span class="pre">processTextLine()</span></span>, <span class="docutils literal"><span class="pre">processMarkerLine()</span></span>, or
<span class="docutils literal"><span class="pre">processCodeLine()</span></span>. These functions will implement the text processing then,
when appropriate, transition to another state by updating the current state.</p>
<p>Processing a Markdown document consisting of multiple lines of text means
processing each line in turn using our state machine then returning the final
result to the caller:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">enum</span> <span class="nx">TextProcessingMode</span> <span class="p">{</span>
    <span class="nx">Text</span><span class="p">,</span>
    <span class="nx">Marker</span><span class="p">,</span>
    <span class="nx">Code</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">TextProcessor</span> <span class="p">{</span>
    <span class="k">private</span> <span class="nx">mode</span>: <span class="kt">TextProcessingMode</span> <span class="o">=</span> <span class="nx">TextProcessingMode</span><span class="p">.</span><span class="nx">Text</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">result</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">private</span> <span class="nx">codeSample</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="nx">processText</span><span class="p">(</span><span class="nx">lines</span>: <span class="kt">string</span><span class="p">[])</span><span class="o">:</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="nx">TextProcessingMode</span><span class="p">.</span><span class="nx">Text</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">processLine</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">processLine</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">mode</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">TextProcessingMode.Text</span>:
                <span class="kt">this.processTextLine</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nx">TextProcessingMode.Marker</span>:
                <span class="kt">this.processMarkerLine</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nx">TextProcessingMode.Code</span>:
                <span class="kt">this.processCodeLine</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">processTextLine</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"&lt;!--"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">loadCodeSample</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="nx">TextProcessingMode</span><span class="p">.</span><span class="nx">Marker</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">processMarkerLine</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"```ts"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">codeSample</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="nx">TextProcessingMode</span><span class="p">.</span><span class="nx">Code</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">processCodeLine</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"```"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="nx">TextProcessingMode</span><span class="p">.</span><span class="nx">Text</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">loadCodeSample</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Load sample based on marker, store in this.codeSample  */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We omitted the code to actually load a sample from an external file as it
isn’t particularly relevant to our state machine discussion. This
implementation works but it can be simplified if we use a pluggable function.</p>
<p>Note that all our text processing functions have the same signature: they
take a line of text as a <span class="docutils literal"><span class="pre">string</span></span> argument and return <span class="docutils literal"><span class="pre">void</span></span>. What if,
instead of having <span class="docutils literal"><span class="pre">processLine()</span></span> implement a big switch statement and
forward to the appropriate function, we make <span class="docutils literal"><span class="pre">processLine()</span></span> <em>be</em> one of
those functions?</p>
<p>Instead of implementing <span class="docutils literal"><span class="pre">processLine()</span></span> as a method, we can define it as a
property of the class with type <span class="docutils literal"><span class="pre">(line:</span> <span class="pre">string)</span> <span class="pre">=&gt;</span> <span class="pre">void</span></span> and initialize it
with <span class="docutils literal"><span class="pre">processTextLine()</span></span>. Then, in each of the three text processing methods,
instead of setting <span class="docutils literal"><span class="pre">mode</span></span> to a different enum value, we set <span class="docutils literal"><span class="pre">processLine()</span></span>
to a different method. In fact, we no longer need to externally keep track of
our state. We don’t even need an enum:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">TextProcessor</span> <span class="p">{</span>
    <span class="k">private</span> <span class="nx">result</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">private</span> <span class="nx">processLine</span><span class="o">:</span> <span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">processTextLine</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">codeSample</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="nx">processText</span><span class="p">(</span><span class="nx">lines</span>: <span class="kt">string</span><span class="p">[])</span><span class="o">:</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">processLine</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">processTextLine</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">processLine</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">processTextLine</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"&lt;!--"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">loadCodeSample</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">processLine</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">processMarkerLine</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">processMarkerLine</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"```ts"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">codeSample</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">processLine</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">processCodeLine</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">processCodeLine</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"```"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="nx">processLine</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">processTextLine</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">loadCodeSample</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Load sample based on marker, store in this.codeSample  */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second implementation gets rid of the <span class="docutils literal"><span class="pre">TextProcessingMode</span></span> enum, the
<span class="docutils literal"><span class="pre">mode</span></span> property, and the switch statement which forwarded processing to the
appropriate method. Instead of handling forwarding, <span class="docutils literal"><span class="pre">processLine()</span></span> now <em>is</em>
the appropriate processing method.</p>
<p>This implementation removes the need to keep track of states separately and
keep that in sync with the processing logic. If we ever wanted to introduce
a new state, the old implementation would’ve forced us to update the code in
several places. Besides implementing the new processing logic and state
transitions, we would’ve had to update the enum and add another case to the
switch statement. Our alternative implementation removes the need for that: a
state is represented purely by a function.</p>
</div>
<div class="section" id="state-machines-with-sum-types">
<h2>State Machines with Sum Types</h2>
<p>One caveat to this is that, for state machines with many states, capturing
states and even transitions explicitly might make the code easier to
understand. Even so, instead of using enums and switch statements, another
possible implementation is to represent each state as a separate type and the
whole state machine as a sum type of the possible states. This allows us to
break it apart into type-safe components. Below is an example of how we would
implement the above state machine using a sum type. The code is a bit more
verbose, so if possible, we should try the implementation we discussed so far,
but this is another alternative to a switch-based state machine.</p>
<p>Using a sum type, each state is represented by a different type, so we have a
<span class="docutils literal"><span class="pre">TextLineProcessor</span></span>, a <span class="docutils literal"><span class="pre">MarkerLineProcessor</span></span>, and a <span class="docutils literal"><span class="pre">CodeLineProcessor</span></span>.
Each of them keeps track of the processed lines so far in a result member and
provides a <span class="docutils literal"><span class="pre">process()</span></span> method to handle a line of text:</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span/><span class="kd">class</span> <span class="nx">TextLineProcessor</span> <span class="p">{</span>
    <span class="nx">result</span>: <span class="kt">string</span><span class="p">[];</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">result</span>: <span class="kt">string</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">process</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">TextLineProcessor</span> <span class="o">|</span> <span class="nx">MarkerLineProcessor</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"&lt;!--"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">MarkerLineProcessor</span><span class="p">(</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">loadCodeSample</span><span class="p">(</span><span class="nx">line</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="nx">loadCodeSample</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span>
        <span class="cm">/* Load sample based on marker, store in this.codeSample */</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">MarkerLineProcessor</span> <span class="p">{</span>
    <span class="nx">result</span>: <span class="kt">string</span><span class="p">[];</span>
    <span class="nx">codeSample</span>: <span class="kt">string</span><span class="p">[]</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">result</span>: <span class="kt">string</span><span class="p">[],</span> <span class="nx">codeSample</span>: <span class="kt">string</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">codeSample</span> <span class="o">=</span> <span class="nx">codeSample</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">process</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">MarkerLineProcessor</span> <span class="o">|</span> <span class="nx">CodeLineProcessor</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"```ts"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">codeSample</span><span class="p">);</span>

            <span class="k">return</span> <span class="k">new</span> <span class="nx">CodeLineProcessor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">CodeLineProcessor</span> <span class="p">{</span>
    <span class="nx">result</span>: <span class="kt">string</span><span class="p">[];</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">result</span>: <span class="kt">string</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">process</span><span class="p">(</span><span class="nx">line</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">CodeLineProcessor</span> <span class="o">|</span> <span class="nx">TextLineProcessor</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"```"</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>

            <span class="k">return</span> <span class="k">new</span> <span class="nx">TextLineProcessor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">processText</span><span class="p">(</span><span class="nx">lines</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">processor</span>: <span class="kt">TextLineProcessor</span> <span class="o">|</span> <span class="nx">MarkerLineProcessor</span>
        <span class="o">|</span> <span class="nx">CodeLineProcessor</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TextLineProcessor</span><span class="p">([]);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">processor</span> <span class="o">=</span> <span class="nx">processor</span><span class="p">.</span><span class="nx">process</span><span class="p">(</span><span class="nx">line</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">processor</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All our processors return a processor instance. Either <span class="docutils literal"><span class="pre">this</span></span>, if there is no
state change, or a new processor as state changes. The <span class="docutils literal"><span class="pre">processText()</span></span> runs
the state machine by calling <span class="docutils literal"><span class="pre">process()</span></span> on each line of text and updating
processor as state changes by reassigning it to the result of the method call.</p>
<p>Now the set of states is explicitly spelled out in the signature of the
processor variable, which can be a <span class="docutils literal"><span class="pre">TextLineProcessor</span></span> or a
<span class="docutils literal"><span class="pre">MarkerLineProcessor</span></span>, or a <span class="docutils literal"><span class="pre">CodeLineProcessor</span></span>.</p>
<p>The possible transitions are captured in the signatures of the <span class="docutils literal"><span class="pre">process()</span></span>
methods – for example <span class="docutils literal"><span class="pre">TextLineProcessor.process()</span></span> returns
<span class="docutils literal"><span class="pre">TextLineProcessor</span> <span class="pre">|</span> <span class="pre">MarkerLineProcessor</span></span>, meaning it can either stay in the
same state (<span class="docutils literal"><span class="pre">TextLineProcessor</span></span>) or transition to the <span class="docutils literal"><span class="pre">MarkerLineProcessor</span></span>
state. These state classes can have more properties and members if needed. This
implementation is slightly longer than the one relying on functions, so if we
don’t need the extra features, we are better off using the simpler solution.</p>
</div>
<div class="section" id="state-machine-implementation-recap">
<h2>State Machine Implementation Recap</h2>
<p>Let’s quickly review the alternative implementations discussed.</p>
<ul class="simple">
<li>The “classical” implementation of a state machine uses an enum to define all
the possible states, a variable of that enum type to keep track of the current
state, and a big switch statement to determine which processing should be
performed based on the current state. State transitions are implemented by
updating the current state variable. The drawback of this implementation is
that states are completely removed from the processing we want to run during
each state, so the compiler can’t prevent mistakes when we run the wrong
processing while in a given state. For example, nothing stops us from calling
<span class="docutils literal"><span class="pre">processCodeLine()</span></span> even when we’re in <span class="docutils literal"><span class="pre">TextProcessingCode.Text</span></span>. We also
have to maintain state and transitions as a separate enum, with the risk of
running  out of sync (for example we might add a new value to the enum but
forget to add a case for it in the switch statement).</li>
<li>The functional implementation represents each processing state as a function
and relies on a function property to track the current state. State
transitions are implemented by assigning the function property to another
state. This is a lightweight implementation which should work for many
cases. The drawbacks are sometimes we need to associate more information with
each state, and sometimes we might want to be explicit when declaring what
the possible states and transitions are.</li>
<li>The sum type implementation represents each processing state as a class and
relies on a variable representing the sum type of all the possible states to
keep track of the current state. State transitions are implemented by
re-assigning the variable to another state. This allows us to add additional
properties and members to each state and keep them grouped together. The
drawback is that the code is more verbose than the functional alternative.</li>
</ul>
</div>
]]></description>
             <pubDate>Tue, 16 Jul 2019 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2019/04/28/programming-with-types.html</link>
            <guid>http://vladris.com/blog/2019/04/28/programming-with-types.html</guid>
            <title><![CDATA[Programming with Types]]></title>
            <description><![CDATA[<h1>Programming with Types</h1>
<p>I’m happy to announce the early access launch of my book,
<a class="reference external" href="https://www.manning.com/books/programming-with-types">Programming with Types</a>.</p>
<p>This is the culmination of several years of geeking out on type systems and
software correctness. I’ve always liked to learn how to write better code, but
if I were to point out exactly when I started down this particular rabbit hole,
I’d say it was 2015.</p>
<p>I was switching teams at that point and decided to get up to speed on modern
C++. I started by watching C++ conference videos and was mind-blown by the
<a class="reference external" href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">C++ Seasoning</a>
talk Sean Parent gave at Going Native a couple of years before. That gave me a
completely different perspective on generic programming.</p>
<p>On a parallel thread, I was playing with Haskell and learning about the
advanced features of its type system. Programming in a functional language
makes it obvious how some of the features taken from granted in such
languages get adopted by more mainstream languages as time goes by. Closures,
sum types, and monads are slowly making their way to the mainstream.</p>
<div class="section" id="bibliography">
<h2>Bibliography</h2>
<p>In awe of the elegance of generics and trying to learn more about them, I
picked up Stepanov’s <a class="reference external" href="https://www.goodreads.com/book/show/23498372-from-mathematics-to-generic-programming">From Mathematics to Generic Programming</a>
and <a class="reference external" href="https://www.goodreads.com/book/show/6142482-elements-of-programming">Elements of Programming</a>.
I realized I need a refresher on abstract algebra, so I took a detour and
went through Pinter’s <a class="reference external" href="https://www.goodreads.com/book/show/8295305-a-book-of-abstract-algebra">A Book of Abstract Algebra</a>.</p>
<p>Getting a sense of the mathematical underpinnings of generics made things
much clearer for me. I wanted to get a similar understanding of the math
underlying the Haskell type system, namely category theory. A great
resource on category theory is Bartosz Milewski’s <a class="reference external" href="https://www.goodreads.com/book/show/33618151-category-theory-for-programmers">Category Theory for Programmers</a>.</p>
<p>Deeper still down the rabbit hole, I picked up Benjamin Pierce’s famous
<a class="reference external" href="https://www.goodreads.com/book/show/112252.Types_and_Programming_Languages">Types and Programming Languages</a>.
The book covers many aspects of type systems, from basic types and function
types, to subtyping, generics, and higher-kinded types. In fact, this is
exactly the progression my own book follows. Types and Programming Languages
is geared towards compiler writers. I wanted to write something that can
benefit any developer.</p>
</div>
<div class="section" id="from-theory-to-practice">
<h2>From Theory to Practice</h2>
<p>While learning more and more about type systems, I could tell the code I was
writing at work became better. There is a direct link between the more
theoretical realm of type system design and the day-to-day production software.
This isn’t a revolutionary discovery - all fancy type system features exist to
solve some real-world problems.</p>
<p>I had new insights which I could use and did my best to share them. I started
this blog and posted about various practical applications. I did hundreds of
code reviews and applied what I learned there. And here is where I found my
niche.</p>
<p>Not every practicing programmer has the time and patience to read
highly-theoretical books, with mathematical proofs. On the other hand, I could
tell that my time wasn’t wasted reading such books - they made me a better
software engineer. I figured there is room for a book which covers type
systems and the safety features they provide, with practical applications
anyone can use in their day jobs.</p>
</div>
<div class="section" id="id2">
<h2>Programming with Types</h2>
<p>The book starts with basic types and some of their common pitfalls: numerical
types tend to overflow or are subject to rounding errors, strings have several
encodings, and manipulating them naively causes all sorts of issues. There are
lesser known basic types, like the empty type and the unit type, which are not
as popular for some reason, even though they have great applications: as return
types for functions which never return, or don’t return anything meaningful.</p>
<p>After basic types, the book covers composition. Why record types are generally
better than tuples, what algebraic data types are about, and countless
applications of sum types. Functions should return either a valid value or an
error, never both. The variant design pattern, enabling double-dispatch, looks
different today than it did a few years ago.</p>
<p>Function types are discussed at length, from lambdas and the functional
staples <span class="docutils literal"><span class="pre">map</span></span>, <span class="docutils literal"><span class="pre">filter</span></span>, and <span class="docutils literal"><span class="pre">reduce</span></span>, to modern features of programming
languages like <span class="docutils literal"><span class="pre">yield</span></span> and <span class="docutils literal"><span class="pre">async</span></span>/<span class="docutils literal"><span class="pre">await</span></span>. The book shows modern takes
on the strategy and decorator design patterns, implemented more succinctly
using function types.</p>
<p>Subtyping is another major topic, covering not only the elements of object
oriented programming and how to use them effectively, but also variance, top
types, and bottom types. For example, we can use a bottom type to produce a
value out of nowhere. Mixins are controversial, as they are usually implemented
as multiple inheritance, but I believe they are extremely useful when designed
correctly.</p>
<p>The next major topic is generic programming. Generic data structures are
responsible for shaping the data, while algorithms are responsible for
processing data. Iterators are a bridge between data structures and algorithms,
allowing us to mix-and-match them. As an example, we can find an item in a tree
using the same code we use to find an item in a list.</p>
<p>Finally, the book covers higher-kinded types. These are higher-level
abstractions, generic types with generic arguments, which underpin concepts
like functors and monads. The joke goes that as soon as you understand monads,
you lose the ability to explain them. I’m taking it as a challenge.</p>
<p>Check out my book <a class="reference external" href="https://www.manning.com/books/programming-with-types">here</a>.</p>
</div>
]]></description>
             <pubDate>Sun, 28 Apr 2019 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/12/31/fold.html</link>
            <guid>http://vladris.com/blog/2018/12/31/fold.html</guid>
            <title><![CDATA[Fold]]></title>
            <description><![CDATA[<h1>Fold</h1>
<p>Most object-oriented programming languages represent object instances in memory
in two separate chunks. One of them contains the instance-specific state - the
class attributes. The other one contains the methods, which are actually shared
across instances. Let’s take as an example a simple type with a couple of
properties and a method:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">X</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">Y</span><span class="p">;</span>

    <span class="kt">double</span> <span class="nf">distanceToOrigin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If we take two distinct instances of <span class="docutils literal"><span class="pre">Point</span></span>, like <span class="docutils literal"><span class="pre">new</span> <span class="pre">Point(10,</span> <span class="pre">5)</span></span> and
<span class="docutils literal"><span class="pre">new</span> <span class="pre">Point(20,</span> <span class="pre">20)</span></span>, they have different <span class="docutils literal"><span class="pre">X</span></span> and <span class="docutils literal"><span class="pre">Y</span></span> coordinates, so those
need to be stored individually. On the other hand, the logic of
<span class="docutils literal"><span class="pre">distanceToOrigin</span></span> is the same for both objects. The method evaluates to
different results, because <span class="docutils literal"><span class="pre">this-&gt;X</span></span> and <span class="docutils literal"><span class="pre">this-&gt;Y</span></span> are different for the two
objects, but the code is the same.</p>
<p>Instead of storing separate copies of the code for each instance, the method
implementations are shared across objects. <span class="docutils literal"><span class="pre">distanceToOrigin</span></span> can return
different results for different objects because each invocation gets a different
<span class="docutils literal"><span class="pre">this</span></span> pointer to the state of each object. In fact, under the hood, every
class method gets an implicit <span class="docutils literal"><span class="pre">this</span></span> argument which represents the object on
which the method is invoked. Python makes that explicit, requiring all class
methods to implement a <span class="docutils literal"><span class="pre">self</span></span> argument in order to reference instance-specific
state.</p>
<p>There isn’t much difference between a method like <span class="docutils literal"><span class="pre">Point::distanceToOrigin</span></span>
and a free function which takes a <span class="docutils literal"><span class="pre">Point</span></span> as an argument:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">double</span> <span class="nf">distanceToOrigin</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The only difference is that a class member gets access to privates, while an
outside function doesn’t. Visibility aside, methods of a class are an
independent “chunk” shared across object instances and the state of each object
is another, separate “chunk”.</p>
<p>An interpretation of this is that, even though classes contain methods, object
instances of a given type can still be thought of as pure state. Our
<span class="docutils literal"><span class="pre">new</span> <span class="pre">Point(10,</span> <span class="pre">5)</span></span> is represented by a combination of the <span class="docutils literal"><span class="pre">Point</span></span> class,
which includes the method implementations and their memory layout etc. and
instance-specific state. The <span class="docutils literal"><span class="pre">Point</span></span> class includes the method
<span class="docutils literal"><span class="pre">distanceToOrigin</span></span> with an implicit <span class="docutils literal"><span class="pre">this</span></span> argument (and some additional
metadata).</p>
<p>With this view, a <span class="docutils literal"><span class="pre">Point</span></span> instance is a pair of values <span class="docutils literal"><span class="pre">X</span></span> and <span class="docutils literal"><span class="pre">Y</span></span>. Any
particular instance of <span class="docutils literal"><span class="pre">Point</span></span> is a member of the set
<span class="docutils literal"><span class="pre">{</span> <span class="pre">(X,</span> <span class="pre">Y)</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">∈</span> <span class="pre">double,</span> <span class="pre">Y</span> <span class="pre">∈</span> <span class="pre">double</span> <span class="pre">}</span></span>. The function <span class="docutils literal"><span class="pre">distanceToOrigin</span></span> can
be viewed as a function from this set (from the implicit <span class="docutils literal"><span class="pre">this</span></span> argument) to a
<span class="docutils literal"><span class="pre">double</span></span> value.</p>
<p><span class="docutils literal"><span class="pre">disntaceToOrigin</span> <span class="pre">:</span> <span class="pre">{</span> <span class="pre">(X,</span> <span class="pre">Y)</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">∈</span> <span class="pre">double,</span> <span class="pre">Y</span> <span class="pre">∈</span> <span class="pre">double</span> <span class="pre">}</span> <span class="pre">→</span> <span class="pre">double.</span></span></p>
<div class="section" id="operations-and-closures">
<h2>Operations and Closures</h2>
<p>A function that takes two arguments of type <span class="docutils literal"><span class="pre">Point</span></span> is called a binary
operation on the set. We can represent it as a function <span class="docutils literal"><span class="pre">f(Point,</span> <span class="pre">Point)</span></span> or,
equivalently, as an operation <span class="docutils literal"><span class="pre">Point</span> <span class="pre">⊙</span> <span class="pre">Point</span></span>. If the codomain of the
function is also a <span class="docutils literal"><span class="pre">Point</span></span>, for example let’s take a function like
<span class="docutils literal"><span class="pre">Point</span> <span class="pre">midPoint(Point</span> <span class="pre">x,</span> <span class="pre">Point</span> <span class="pre">y)</span></span>, which computes the middle point between
two given points, we call the operation <em>closed</em> over the set.</p>
<p>The notion of closure in algebra is different from the notion closure in
computer science, which deals with context captured in lambdas. In this case it
simply means an operation that combines a number of elements of a set into
another element of the set.</p>
<p>Since we can view any type as a set, and any function taking two arguments of a
type and returning another instance of that type as a closed binary operation on
the set, we can start talking about algebraic structures.</p>
</div>
<div class="section" id="magmas">
<h2>Magmas</h2>
<p>A magma is just a set with a closed operation, without any other constraints
imposed. If we have a magma, we can implement an algorithm like <span class="docutils literal"><span class="pre">fold</span></span> which,
given a set of values in the magma, combines them into a single value.</p>
<p>For example we can fold three <span class="docutils literal"><span class="pre">Point</span></span> instances <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span> into a
single <span class="docutils literal"><span class="pre">Point</span></span> using the <span class="docutils literal"><span class="pre">midPoint</span></span> function like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">Point</span> <span class="n">result</span> <span class="o">=</span> <span class="n">midPoint</span><span class="p">(</span><span class="n">midPoint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>We can sketch out a function that, given a set of objects of any type <span class="docutils literal"><span class="pre">T</span></span> and
an operation closed over <span class="docutils literal"><span class="pre">T</span></span>, produces a final value of type <span class="docutils literal"><span class="pre">T</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Op</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">T</span><span class="o">=</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">fold</span><span class="p">(</span><span class="n">It</span> <span class="n">begin</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">,</span> <span class="n">Op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function takes a pair of iterators which we use to traverse the set of
values of type <span class="docutils literal"><span class="pre">T</span></span>, an initial value of type <span class="docutils literal"><span class="pre">T</span></span>, and a binary operation
<span class="docutils literal"><span class="pre">Op</span></span>. We need an initial value of type <span class="docutils literal"><span class="pre">T</span></span> because if the set is empty,
we still need to return something from the function. That is, if the <span class="docutils literal"><span class="pre">for</span></span>
loop never executes, and we never apply <span class="docutils literal"><span class="pre">op</span></span>, we still need a <span class="docutils literal"><span class="pre">T</span></span> to return.
In this case we will simply return <span class="docutils literal"><span class="pre">init</span></span>.</p>
<p>Since a magma doesn’t impose any constraints on the operation, the order in
which we combine elements might be important. For example, for integers and
the subtraction operation, if we start with the set of number <span class="docutils literal"><span class="pre">1</span></span>, <span class="docutils literal"><span class="pre">2</span></span>, and
<span class="docutils literal"><span class="pre">3</span></span>, and an initial value of <span class="docutils literal"><span class="pre">1</span></span>, we can fold from left to right and get
<span class="docutils literal"><span class="pre">((1</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">-</span> <span class="pre">3</span></span>, or <span class="docutils literal"><span class="pre">-5</span></span>. On the other hand, we can start from right
to left, and fold <span class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">(2</span> <span class="pre">-</span> <span class="pre">(3</span> <span class="pre">-</span> <span class="pre">1))</span></span>, or <span class="docutils literal"><span class="pre">1</span></span>. Let’s call this verison
<span class="docutils literal"><span class="pre">foldRight</span></span> and look at a possible implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Op</span>
    <span class="k">typename</span> <span class="nc">T</span><span class="o">=</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">fold_right</span><span class="p">(</span><span class="n">It</span> <span class="n">begin</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">,</span> <span class="n">Op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">begin</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">it</span><span class="p">),</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that for an operation like addition, this is not the case: if we fold
<span class="docutils literal"><span class="pre">1</span></span>, <span class="docutils literal"><span class="pre">2</span></span>, and <span class="docutils literal"><span class="pre">3</span></span>, with an initial value of <span class="docutils literal"><span class="pre">1</span></span>, we get <span class="docutils literal"><span class="pre">7</span></span> regardless
of the direction and whether we make the initial value a left or a right
operand. Let’s zoom in on this.</p>
</div>
<div class="section" id="semigroups">
<h2>Semigroups</h2>
<p>If we have a set with a closed operation that is also associative, we have a
<em>semigroup</em>. For an <em>associative</em> operation, it doesn’t really matter what order
we apply multiple operations on. For example, for the set of strings and the
string concatenation operation, it doesn’t metter whether we append <span class="docutils literal"><span class="pre">foo</span></span> to
<span class="docutils literal"><span class="pre">bar</span></span>, then the result to <span class="docutils literal"><span class="pre">baz</span></span> or whether we concatenate <span class="docutils literal"><span class="pre">bar</span></span> with
<span class="docutils literal"><span class="pre">baz</span></span> first, then prepend <span class="docutils literal"><span class="pre">foo</span></span> to it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="p">(</span><span class="s">"foo"</span><span class="n">s</span> <span class="o">+</span> <span class="s">"bar"</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s">"baz"</span><span class="n">s</span> <span class="o">==</span> <span class="s">"foo"</span><span class="n">s</span> <span class="o">+</span> <span class="p">(</span><span class="s">"bar"</span><span class="n">s</span> <span class="o">+</span> <span class="s">"baz"</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>More formally, an opeartion is associative if, for any <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span>,
<span class="docutils literal"><span class="pre">(a</span> <span class="pre">⊙</span> <span class="pre">b)</span> <span class="pre">⊙</span> <span class="pre">c</span> <span class="pre">==</span> <span class="pre">a</span> <span class="pre">⊙</span> <span class="pre">(b</span> <span class="pre">⊙</span> <span class="pre">c)</span></span>. That being said, that’s not enough to make
our right fold redundant:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">elems</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"foo"</span><span class="n">s</span><span class="p">,</span> <span class="s">"bar"</span><span class="n">s</span><span class="p">,</span> <span class="s">"baz"</span><span class="n">s</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fold</span><span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elems</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"!"</span><span class="n">s</span><span class="p">,</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">});</span>
<span class="c1">// Prints !foobarbaz</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fold_right</span><span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elems</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">"!"</span><span class="n">s</span><span class="p">,</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">});</span>
<span class="c1">// Prints foobarbaz!</span>
</pre></div>
</div>
<p>It still matters whether our initial value is a left or right argument to our
operation. If for an operation we get the same result regardless of how we
arrange the operands, then we have a <em>commutative</em> operation. Integer addition
is an example of a commutative operation, where <span class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></span> is the same as
<span class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></span>. Note this is different than string concatenation, where
<span class="docutils literal"><span class="pre">"foo"s</span> <span class="pre">+</span> <span class="pre">"bar"s</span> <span class="pre">!=</span> <span class="pre">"bar"s</span> <span class="pre">+</span> <span class="pre">"foo"s</span></span>. A semigroup with a commutative operation
is called an <em>abelian semigroup</em>. Here we finally no longer need to distinguish
between <span class="docutils literal"><span class="pre">fold</span></span> and <span class="docutils literal"><span class="pre">fold_right</span></span> as they both produce the same result.</p>
<p>Let’s also look at that mandatory initial value.</p>
</div>
<div class="section" id="monoids">
<h2>Monoids</h2>
<p>The reason we require an initial value is that we need to return something in
case our set is empty, and we don’t always have a good default. That’s not
always the case. There are operations for which we have such a default, called
the <em>identity</em> of the opeartion. This value, combined with any other value using
the operation, leaves the other value unchanged. For string concatenation, the
identity is the empty string. For addition, the identity is <span class="docutils literal"><span class="pre">0</span></span>. In general,
we have <span class="docutils literal"><span class="pre">a</span> <span class="pre">⊙</span> <span class="pre">id</span> <span class="pre">==</span> <span class="pre">id</span> <span class="pre">⊙</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">a</span></span> for any <span class="docutils literal"><span class="pre">a</span></span>. This is what makes <span class="docutils literal"><span class="pre">id</span></span> an
identity.</p>
<p>A semigroup with an identity is a <em>monoid</em>. That’s a set with an associative
operation and an identity element. Note commutativity is not required. If the
operation is also commutative, then we have a <em>commutative monoid</em>.</p>
<p>If the default constructor of our type <span class="docutils literal"><span class="pre">T</span></span> creates an identiy, then we can
reimplement <span class="docutils literal"><span class="pre">fold</span></span> like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Op</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">T</span><span class="o">=</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">fold</span><span class="p">(</span><span class="n">It</span> <span class="n">begin</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">,</span> <span class="n">Op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">result</span><span class="p">{</span> <span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We no longer require an initial value to be passed in. That’s because, if we
really want to combine all elements with a certain value, we can do it after
calling <span class="docutils literal"><span class="pre">fold</span></span>. For example we can concatenate our strings and then append or
prepend our “!”s:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">elems</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"foo"</span><span class="n">s</span><span class="p">,</span> <span class="s">"bar"</span><span class="n">s</span><span class="p">,</span> <span class="s">"baz"</span><span class="n">s</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">folded</span> <span class="o">=</span> <span class="n">fold</span><span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elems</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">});</span>
<span class="c1">// folded is "foobarbaz"s</span>
</pre></div>
</div>
<p>Unlike the first implementation, this works for empty sets too:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">elems</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">folded</span> <span class="o">=</span> <span class="n">fold</span><span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elems</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">});</span>
<span class="c1">// folded is the empty string</span>
</pre></div>
</div>
<p>This version only works if we have an identity and if the default constructor
actually creates that identity. Note identity is a property related to the
operation, so we need to be careful. The default integer value is <span class="docutils literal"><span class="pre">0</span></span>, which
is the identity for addition, so we can very well sum numbers using the second
version of <span class="docutils literal"><span class="pre">fold</span></span>. On the other hand, we can’t use it for product:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">elems</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">fold</span><span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elems</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
    <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">});</span>
<span class="c1">// sum is 6</span>

<span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">fold</span><span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elems</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
    <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span> <span class="p">});</span>
<span class="c1">// product is 0</span>
</pre></div>
</div>
<p>If we default to <span class="docutils literal"><span class="pre">0</span></span> and multiply all numbers with it, our product becomes
<span class="docutils literal"><span class="pre">0</span></span>. On the other hand, if we do have a default identity, then <span class="docutils literal"><span class="pre">fold</span></span> and
<span class="docutils literal"><span class="pre">fold_right</span></span> give us the same result even if the operation is only
associative, without necessarily being commutative. That’s because, if our
initial value is an identity, it doesn’t matter whether it is a left or right
argument to our operation. By definition, <span class="docutils literal"><span class="pre">a</span> <span class="pre">⊙</span> <span class="pre">id</span> <span class="pre">==</span> <span class="pre">id</span> <span class="pre">⊙</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">a</span></span> so for a
set of values like <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span>, we get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>((id ⊙ a) ⊙ b) ⊙ c == (a ⊙ b) ⊙ c
</pre></div>
</div>
<p>From associativity, we get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>(a ⊙ b) ⊙ c == a ⊙ (b ⊙ c)
</pre></div>
</div>
<p>We can add another identity in there, since <span class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">c</span> <span class="pre">⊙</span> <span class="pre">id</span></span>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>a ⊙ (b ⊙ c) == (a ⊙ (b ⊙ (c ⊙ id)))
</pre></div>
</div>
<p>We started with how <span class="docutils literal"><span class="pre">fold</span></span> evaluates and ended up with how <span class="docutils literal"><span class="pre">fold_right</span></span>
evaluates. That means we don’t distinguish between a left to right or right to
left fold is either:</p>
<ul class="simple">
<li>The operation is associative and commutative (abelian semigroup)</li>
<li>The operation is associative and the initial value is the identity (monoid
with identity as initial value)</li>
</ul>
<p>If neither of these holds, it matters which way the fold happens as we get
different results.</p>
</div>
<div class="section" id="parallelized-fold">
<h2>Parallelized Fold</h2>
<p>Wihout going into too many details, we can also divide &amp; conquer a fold
operation, fold subsets in parallel, then merge the results. Associativity
allows us to do so, as we can split the set of values <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, <span class="docutils literal"><span class="pre">c</span></span>, and
<span class="docutils literal"><span class="pre">d</span></span> into <span class="docutils literal"><span class="pre">left_half</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">⊙</span> <span class="pre">b</span></span> and <span class="docutils literal"><span class="pre">right_half</span> <span class="pre">=</span> <span class="pre">c</span> <span class="pre">⊙</span> <span class="pre">d</span></span>, then combine the
two halves for the final result <span class="docutils literal"><span class="pre">left_half</span> <span class="pre">⊙</span> <span class="pre">right_half</span></span>. This is the same
thing as <span class="docutils literal"><span class="pre">(a</span> <span class="pre">⊙</span> <span class="pre">b)</span> <span class="pre">⊙</span> <span class="pre">(c</span> <span class="pre">⊙</span> <span class="pre">d)</span></span>. As long as the operation is associative, this
is the same as <span class="docutils literal"><span class="pre">((a</span> <span class="pre">⊙</span> <span class="pre">b)</span> <span class="pre">⊙</span> <span class="pre">c)</span> <span class="pre">⊙</span> <span class="pre">d</span></span> or <span class="docutils literal"><span class="pre">a</span> <span class="pre">⊙</span> <span class="pre">(b</span> <span class="pre">⊙</span> <span class="pre">(c</span> <span class="pre">⊙</span> <span class="pre">d))</span></span>.</p>
<p>Not all operations are associative though, as we saw before. Subtraction isn’t
for example. <span class="docutils literal"><span class="pre">(1</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">-</span> <span class="pre">(3</span> <span class="pre">-</span> <span class="pre">4)</span></span> is <span class="docutils literal"><span class="pre">0</span></span>. <span class="docutils literal"><span class="pre">((1</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">-</span> <span class="pre">3)</span> <span class="pre">-</span> <span class="pre">4</span></span> is <span class="docutils literal"><span class="pre">-8</span></span>.
We can only parallelize folding a semigroup, not any magma.</p>
<p>Here, since we are talking about dividing the input set, we can assume we have
more than zero elements in a subset (otherwise we wouldn’t divide it), so
whether we have an identity or not or whether we apply it to the left or the
right can be left to the top function which combines the partial results.</p>
</div>
<div class="section" id="alternatives">
<h2>Alternatives</h2>
<p>We covered traditional implementations of <span class="docutils literal"><span class="pre">fold</span></span> but let’s go over a couple of
alternative implementations. We could say that if the set is empty, we don’t
return anything, otherwise we take the first element as our initial value:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Op</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">T</span><span class="o">=</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">fold</span><span class="p">(</span><span class="n">It</span> <span class="n">begin</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">,</span> <span class="n">Op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>

    <span class="n">It</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">++</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As long as the operation is associative, the fold direction doesn’t matter. In
case we don’t have any value at all, we return <span class="docutils literal"><span class="pre">nullopt</span></span> to signal the absence
of a value.</p>
<p>Another option is to take a default value as an argument and return that in case
we have no elements to combine, but if we do, simply ignore that value instead
of combining it with the input elements:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Op</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">T</span><span class="o">=</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">fold</span><span class="p">(</span><span class="n">It</span> <span class="n">begin</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="n">def</span><span class="p">,</span> <span class="n">Op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="n">def</span><span class="p">;</span>

    <span class="n">It</span> <span class="n">it</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">++</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is similar to the previous implementation, but instead of an empty optional
we return a supplied value in case we don’t have anything to fold. This would
be interpreted as <em>fold or return def</em>, as opposed to our original
implementation, which was <em>fold with init</em>.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This post started with a discussion of how types can be viewed as sets and
functions as functions over those sets. We then covered a few abstract algebra
concepts as applied to the <span class="docutils literal"><span class="pre">fold</span></span> higher order function, looking in which
situations do <span class="docutils literal"><span class="pre">fold</span></span> and <span class="docutils literal"><span class="pre">fold_right</span></span> return the same result.</p>
<ul class="simple">
<li>A function <span class="docutils literal"><span class="pre">T</span> <span class="pre">f(T,</span> <span class="pre">T)</span></span> is a closed binary operation on the set <span class="docutils literal"><span class="pre">T</span></span></li>
<li>A set with a binary operation is called a magma. We can implement a <span class="docutils literal"><span class="pre">fold</span></span>
and a <span class="docutils literal"><span class="pre">fold_right</span></span> if we have a magma. Both functions need an initial value.</li>
<li>If the operation is also associative, we have a semigroup. Here it still
matters whether the initial value is applied on the left or the right, as the
results might be different.</li>
<li>If the operation is also commutative, we have an abelian semigroup. There is
no distinction between a left-to-right and a right-to-left fold for an abelian
semigroup.</li>
<li>If the operation has an identity, then we have a monoid. If we use the
identity as an initial value, then we again have no distinctino between a
left-to-right and a right-to-left fold.</li>
<li>We can paralllize fold to take subsets of the input set, combine them in
parallel, then combine the results. Associativity is the only requirement for
this, so we can parallelize folding a semigroup.</li>
<li>We also looked at a couple of alternative implementations which only require
a semigroup for the fold direction not to matter. The first one returns an
empty optional if there are no values to combine; the second returns a value
supplied as argument, without otherwise combining it.</li>
</ul>
</div>
]]></description>
             <pubDate>Mon, 31 Dec 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/11/18/notes-on-encoding-text.html</link>
            <guid>http://vladris.com/blog/2018/11/18/notes-on-encoding-text.html</guid>
            <title><![CDATA[Notes on Encoding Text]]></title>
            <description><![CDATA[<h1>Notes on Encoding Text</h1>
<p>In this post we will look at text encoding, from the half-a-century old ASCII
and its extensions to Unicode and the common UTF-16 and UTF-8 encodings. We’ll
cover a few basic text encoding concepts like code points, graphemes, and
surrogate pairs and see how we can stack emojis and combine them into intricate
glyphs.</p>
<div class="section" id="ascii">
<h2>ASCII</h2>
<p>The American Standard Code for Information Exchange, or ASCII, was developed in
the 60s. The standard encodes each character in 7 bits, so it has 128
characters. These include both the lowercase and uppercase letters of the
English alphabet, digits, punctuation, and a set of control characters like LF
(line feed, also known as <span class="docutils literal"><span class="pre">\n</span></span>), CR (carriage return, also known as <span class="docutils literal"><span class="pre">\r</span></span>) or
BEL (audible beep, or <span class="docutils literal"><span class="pre">\a</span></span>). The ASCII character set contains all characters
on a typewriter.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>0x00 to 0x1F - control characters
0x20 to 0x2F - symbols - SPACE ! " # $ % &amp; ' ( ) * + , - . /
0x30 to 0x39 - digits - 0 1 2 3 4 5 6 7 8 9
0x3A to 0x40 - symbols - : ; &lt; = &gt; ? @
0x41 to 0x5A - uppercase letters - A to Z
0x5B to 0x60 - symbols – [ \ ] ^ _ `
0x61 to 0x7A - lowercase letters - a to z
0x7B to 0x7E - symbols - { | } ~
0x7F - "delete" control character - DEL
</pre></div>
</div>
<div class="section" id="parity-bits">
<h3>Parity bits</h3>
<p>A byte is 8 bits wide, so the remaining bit was used as a <em>parity bit</em>. The
parity bit is 0 if the 7 bits encoding a character have an even number of 1s
and 1 if the bits encoding a character have an odd number of 1s. For example,
the letter <span class="docutils literal"><span class="pre">A</span></span> is encoded as <span class="docutils literal"><span class="pre">0x41</span></span>, or <span class="docutils literal"><span class="pre">1000001</span></span>. <span class="docutils literal"><span class="pre">1000001</span></span> has an even
number of bits so the parity bit is 0, thus <span class="docutils literal"><span class="pre">A</span></span> ends up being encoded on 8
bits as <span class="docutils literal"><span class="pre">01000001</span></span>. The letter <span class="docutils literal"><span class="pre">C</span></span> is encoded as <span class="docutils literal"><span class="pre">0x43</span></span>, or <span class="docutils literal"><span class="pre">1000011</span></span>,
so the parity bit is 1. <span class="docutils literal"><span class="pre">C</span></span> ends up being encoded on 8 bits as <span class="docutils literal"><span class="pre">11000011</span></span>.</p>
<p>The parity bit is used to check the consistency of the data: in a lossy
environment, a parity bit is a simple way to add extra validation. If the parity
bit does not have the expected value - for example it is 1 while the remaining 7
bits have an even number of bits set to 1 - it means that the data is corrupted.</p>
<p>This encoding was enough for English, but lacked other letters common in
European languages, for example accented letters like é or ć. It also could not
encode any other alphabets, like Arabic, Cyrillic, Hebrew and so on.</p>
</div>
</div>
<div class="section" id="extended-ascii-and-code-pages">
<h2>Extended ASCII and Code Pages</h2>
<p>The ASCII character set had numerous extensions which started to leverage the
8th bit to encode information instead of using it to check integrity. The
original 128 character stayed in the <span class="docutils literal"><span class="pre">0x0</span></span> - <span class="docutils literal"><span class="pre">0x7F</span></span> range, but with the
extra bit, an extended ASCII character set could encode 128 more characters
from <span class="docutils literal"><span class="pre">0x80</span></span> to <span class="docutils literal"><span class="pre">0xFF</span></span>.  Since ASCII received multiple such extensions,
these were distinguished by code pages. A code page defined what the <span class="docutils literal"><span class="pre">0x80</span></span> to
<span class="docutils literal"><span class="pre">0xFF</span></span> characters are.</p>
<p>IBM PC systems came with the popular <strong>code page 437</strong> which includes characters
for box-drawing like <span class="docutils literal"><span class="pre">║</span></span>, <span class="docutils literal"><span class="pre">╗</span></span>, and <span class="docutils literal"><span class="pre">╝</span></span>. Text-based user interface could
simulate windows, buttons and so on using these characters:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>╔════════════════════════════════════╗
║ Box-drawn window with progress bar ║
╟────────────────────────────────────╢
║  ██████████████████▓▒░░░░░░░░░░░░  ║
╚════════════════════════════════════╝
</pre></div>
</div>
<p>Another set of extensions was the <strong>ISO/IEC 8859</strong> standard consisting of 16
parts, each adding support for additional character and alphabets. For example,
part 1 was named <em>Latin-1 Western European</em> and added most characters required
by Western European languages (like accented letters), while part 5,
<em>Latin/Cyrillic</em> used the available 128 characters to encode the Cyrillic
alphabet.</p>
<p>While these code pages allowed new ranges of characters, each could only add
128 symbols, which didn’t scale well to the world’s written languages. For
perspective, Kanji has thousands of characters.</p>
</div>
<div class="section" id="unicode">
<h2>Unicode</h2>
<p>The Unicode standard aims to cover most of the world’s writing systems and
include additional symbols like emojis.</p>
<div class="section" id="code-points">
<h3>Code points</h3>
<p>Unicode introduces the notion of code points. Most code points are characters,
but some code points are used for formatting while some are unassigned as of
today and will be defined in future extensions of the standard. The total code
space of Unicode spans 1114112 code points, from <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0x10FFFF</span></span>.</p>
<p>The code space is divided into 17 planes, each consisting of a range of 65536
code points (from <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0xFFFF</span></span>, from <span class="docutils literal"><span class="pre">0x10000</span></span> to <span class="docutils literal"><span class="pre">0x1FFFF</span></span> and so
on until <span class="docutils literal"><span class="pre">0xF0000</span></span> to <span class="docutils literal"><span class="pre">0x10FFFF</span></span>). A Unicode code point is conventionally
referred to as <span class="docutils literal"><span class="pre">U+XXX</span></span> where <span class="docutils literal"><span class="pre">XXX</span></span> is the hexadecimal value of the code
point. For example the code point corresponding to the letter “a” which is
<span class="docutils literal"><span class="pre">0x61</span></span>, is referred to as <span class="docutils literal"><span class="pre">U+0061</span></span>.</p>
<p>Most programming languages allow strings to contain a Unicode escape sequence,
which gets interpreted as a Unicode code point. Such sequences start with <span class="docutils literal"><span class="pre">\x</span></span>
or <span class="docutils literal"><span class="pre">\u</span></span> followed by the hexadecimal value of the code point, for example in
JavaScript the Unicode escape for “a” is the string <span class="docutils literal"><span class="pre">"\u0061"</span></span>.</p>
<p>Not only does Unicode support a huge range of code points, it also defines
combining characters which, combined with other character, create new
characters. For example,  ́ (<span class="docutils literal"><span class="pre">U+0301</span></span>) is the combining acute accent. Combining
this with “a” (<span class="docutils literal"><span class="pre">U+0061</span></span>) by appending it after the letter (the string
<span class="docutils literal"><span class="pre">"\u0061\u0301"</span></span>) results in the character “á” while combining it with
“e” (<span class="docutils literal"><span class="pre">U+0065</span></span>) in the string <span class="docutils literal"><span class="pre">"\u0065\u0301"</span></span> results in the character
“é”.</p>
<p>Similarly, a skin tone modifier like dark skin tone, 🏿 (<span class="docutils literal"><span class="pre">U+1F3FF</span></span>) can be
appended to an emoji like the baby emoji 👶 (<span class="docutils literal"><span class="pre">U+1F476</span></span>) to get a baby with
a dark skin tone 👶🏿.</p>
</div>
<div class="section" id="graphemes">
<h3>Graphemes</h3>
<p>A grapheme is a graphical symbol that a user sees on the screen. Text rendering
is done through graphemes. Some graphemes correspond to a single code point,
like “a” corresponding to <span class="docutils literal"><span class="pre">U+0061</span></span>. Other graphemes correspond to a sequence
of code points, like 👶🏿, which corresponds to <span class="docutils literal"><span class="pre">U+1F476</span></span> then <span class="docutils literal"><span class="pre">U+1F3FF</span></span>.
There are also graphemes which can be obtained in multiple ways. The accented
“e” in the example above, “é”, can be obtained by combining the letter “e” with
the acute accent (<span class="docutils literal"><span class="pre">U+0065</span></span> then <span class="docutils literal"><span class="pre">U+0301</span></span>), but there is also an accented “e”
character “é” represented by the code point <span class="docutils literal"><span class="pre">U+00E9</span></span>. Both <span class="docutils literal"><span class="pre">U+0065</span> <span class="pre">U+0301</span></span>
and <span class="docutils literal"><span class="pre">U+00E9</span></span> resolve to the same grapheme.</p>
<p>Because of such equivalences, the standard defines a normalization procedure
which can convert equivalent texts to the same code point representation. There
are several ways to achieve this, which we’ll not cover in this blog post.</p>
<p>Combining and modifying characters can be stacked one after the other. For
example, the 👨‍❤️‍👨 emoji showing two man with a heart above is a
single grapheme but consists of the following sequence of code points: <span class="docutils literal"><span class="pre">U+1F468</span>
<span class="pre">U+200D</span> <span class="pre">U+2764</span> <span class="pre">U+FE0F</span> <span class="pre">U+200D</span> <span class="pre">U+1F468</span></span>. This is a combination of:</p>
<ul class="simple">
<li>The man emoji 👨 (<span class="docutils literal"><span class="pre">U+1F468</span></span>)</li>
<li>The zero-width joiner (<span class="docutils literal"><span class="pre">U+200D</span></span>) which does not have a stand-alone
representation but combines two emojis into a single one</li>
<li>The heavy black heart symbol ❤ (<span class="docutils literal"><span class="pre">U+2764</span></span>) - depending on which OS you are
reading this, it might or might not render as an emoji</li>
<li>The Variation Selector-16 character (<span class="docutils literal"><span class="pre">U+2764</span></span>) which also doesn’t have a
stand-alone representation but can be applied to code points which have both
a text and an emoji representation to select the emoji representation. This
ensures the heavy black heart symbol gets the emoji representation ❤️.</li>
<li>Another zero-width joiner (<span class="docutils literal"><span class="pre">U+200D</span></span>)</li>
<li>Another man emoji 👨 (<span class="docutils literal"><span class="pre">U+1F468</span></span>)</li>
</ul>
<p>The whole sequence results in a single grapheme.</p>
<p>One interesting thing to note is that splitting a string without being aware of
how the code points combine can change the representation of the text. This can
happen when breaking a line of text to fit on screen. In the above example,
even though we have 6 code points, we end up with a single grapheme, so when
dealing with rendering, it’s usually best to operate on graphemes not code
points/characters.</p>
</div>
</div>
<div class="section" id="encodings">
<h2>Encodings</h2>
<p>We talked about code points and graphemes, but how are the code points actually
encoded as bytes? With ASCII and the simple extensions, the encoding was easy,
as each byte encoded a character. Unicode has over a million code points, so
let’s look at how these get translated into bytes.</p>
<div class="section" id="utf-32">
<h3>UTF-32</h3>
<p>The most obvious way is to find the minimum number of bytes that can encode any
code point. Since code points range from <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0x10FFFF</span></span>, we need 21
bits to store all possible values (<span class="docutils literal"><span class="pre">0x10FFFF</span></span> in binary is
<span class="docutils literal"><span class="pre">0b100001111111111111111</span></span>).</p>
<p>Because most CPUs nowadays have a word size of at least 32-bits, the UTF-32
encoding rounds up the number of required bits from 21 to 32, thus representing
a code point using 4 bytes.</p>
<p>This encoding is very straight-forward, as any 4 bytes store the value of a
code point in a string, but it is also very space-inefficient. The leading bits
are always 0 and not only that, the code points representing common characters
and alphabets appear in the lower planes, so while an emoji like the woman
emoji 👩 (<span class="docutils literal"><span class="pre">U+1F469</span></span>) in binary is <span class="docutils literal"><span class="pre">0b11111010001101001</span></span>, thus requiring at
least 17 bits to represent, the code point for the letter “a” is <span class="docutils literal"><span class="pre">U+0061</span></span>,
same as the old ASCII representation. That is <span class="docutils literal"><span class="pre">0b1100001</span></span> in binary, requiring
only 7 bits.</p>
<p>To take advantage of this, several <em>variable-length</em> encodings were developed,
which use fewer bytes for code points representable with a smaller number of
bits, and more bytes for higher code point values. The two most common
encodings are UTF-16 and UTF-8.</p>
</div>
<div class="section" id="utf-16">
<h3>UTF-16</h3>
<p>UTF-16 encodes code points in either one or two 16-bit wide code units. The
code points in the range <span class="docutils literal"><span class="pre">U+0000</span></span> to <span class="docutils literal"><span class="pre">U+FFFF</span></span> are encoded directly as a
16-bit code unit, except the subrange <span class="docutils literal"><span class="pre">U+D800</span></span> to <span class="docutils literal"><span class="pre">U+DFFF</span></span> which we’ll talk
about shortly. This range corresponds to Plane 0, the <em>Basic Multilingual
Plane</em>, with code points to represent almost all modern languages.</p>
<p>Code points from other planes are encoded in UTF-16 using two code units, so 32
bits. Any code point in the range <span class="docutils literal"><span class="pre">U+10000</span></span> to <span class="docutils literal"><span class="pre">U+10FFFF</span></span> (or <span class="docutils literal"><span class="pre">0x10000</span></span> to
<span class="docutils literal"><span class="pre">0x10FFFF</span></span>) is encoded by subtracting <span class="docutils literal"><span class="pre">0x10000</span></span> leaving a value between
<span class="docutils literal"><span class="pre">0x0</span></span> and <span class="docutils literal"><span class="pre">0xFFFFF</span></span>. Values in this range can be represented in 20 bits. A
sequence of 10 bits can represent values in the range <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0x3FF</span></span>. The
20 bits are split into the first (most significant) 10 bits and the last (least
significant) 10 bits. The first 10 bits are added to <span class="docutils literal"><span class="pre">0xD800</span></span>, resulting in a
value in the range <span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDBFF</span></span>. This is represented in the first
16-bit code point. The last 10 bits are added to <span class="docutils literal"><span class="pre">0xDC00</span></span>, resulting in a
value in the range <span class="docutils literal"><span class="pre">0xDC00</span></span> to <span class="docutils literal"><span class="pre">0xDFFF</span></span>. This is represented in the second
16-bit code point.</p>
<p>Let’s take as an example the woman emoji 👩 (<span class="docutils literal"><span class="pre">U+1F469</span></span>). The UTF-16 encoding
goes as follows:</p>
<ul class="simple">
<li>Subtract <span class="docutils literal"><span class="pre">0x10000</span></span> from <span class="docutils literal"><span class="pre">0x1F469</span></span>, resulting in <span class="docutils literal"><span class="pre">0xF469</span></span>, or
<span class="docutils literal"><span class="pre">0b00001111010001101001</span></span> in 20 bits.</li>
<li>The first 10 bits, <span class="docutils literal"><span class="pre">0b0000111101</span></span>, or <span class="docutils literal"><span class="pre">0x3D</span></span>, are added to <span class="docutils literal"><span class="pre">0xD800</span></span>
which gives us <span class="docutils literal"><span class="pre">0xD83D</span></span>.</li>
<li>The remaining 10 bits, <span class="docutils literal"><span class="pre">0b0001101001</span></span>, or <span class="docutils literal"><span class="pre">0x69</span></span>, are added to <span class="docutils literal"><span class="pre">0xDC00</span></span>,
giving <span class="docutils literal"><span class="pre">0xDC69</span></span>.</li>
</ul>
<p>The two 16-bit code units for 👩 are <span class="docutils literal"><span class="pre">0xD83D</span></span> and <span class="docutils literal"><span class="pre">0xDC69</span></span>, or the byte
sequence <span class="docutils literal"><span class="pre">0xD8</span> <span class="pre">0x3D</span> <span class="pre">0xDC</span> <span class="pre">0x69</span></span>.</p>
<p><strong>Surrogate pairs</strong></p>
<p>We said that UTF-16 encodes all code points in Plane 0 using a single 16-bit
code unit, except the range <span class="docutils literal"><span class="pre">U+D800</span></span> to <span class="docutils literal"><span class="pre">U+DFFF</span></span>. That particular range is
reserved in the Unicode standard for UTF-16 surrogate pairs, so code points in
that range are unassigned and will never be assigned.</p>
<p>If we review the way UTF-16 encodes code points in code units, a 16-bit code
unit can be either:</p>
<ul class="simple">
<li>A value in the range <span class="docutils literal"><span class="pre">0x0</span></span> to <span class="docutils literal"><span class="pre">0xFFFF</span></span>, except the reserved range
<span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDFFF</span></span>. This value is a valid code point in Plane 0.</li>
<li>A value in the range <span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDBFF</span></span>, which represents the first 10
bits of a code point in another plane after subtracting <span class="docutils literal"><span class="pre">0x10000</span></span> and adding
<span class="docutils literal"><span class="pre">0xD800</span></span> to the first 10 bits</li>
<li>A value in the range <span class="docutils literal"><span class="pre">0xDC00</span></span> to <span class="docutils literal"><span class="pre">0xDFFF</span></span>, which represents the remaining
10 bits of a code point in another plane after subtracting <span class="docutils literal"><span class="pre">0x10000</span></span> and
adding <span class="docutils literal"><span class="pre">0xDC00</span></span> to the last 10 bits.</li>
</ul>
<p>Note that these ranges are disjoint - a value can appear in only one of them, so
each 16-bit code unit can unambiguously be identified, in isolation. For code
points like 👩, encoded as two 16-bit code units, the code units are called a
<em>surrogate pair</em>. The first code unit, in the range <span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDBFF</span></span> is
called the <em>high surrogate</em> while the second code unit, in the range <span class="docutils literal"><span class="pre">0xDC00</span></span>
to <span class="docutils literal"><span class="pre">0xDFFF</span></span> is called the <em>low surrogate</em>.</p>
<p>Since the Unicode standard and UTF-16 encoding evolved together, the range
<span class="docutils literal"><span class="pre">0xD800</span></span> to <span class="docutils literal"><span class="pre">0xDFFF</span></span> needed by the surrogate pairs was reserved in Plane 0
and the code points were kept unassigned. Without this, UTF-16 would have had
trouble encoding a code point in that range as it would become undistinguishable
from a surrogate.</p>
<p>UTF-16 is the default encoding used by Windows, Java, the .NET runtime, and
JavaScript. Another popular way to encode text is UTF-8.</p>
</div>
</div>
<div class="section" id="utf-8">
<h2>UTF-8</h2>
<p>UTF-8 uses 8-bit code units, so it encodes code points using one to four bytes.
To recap, Unicode code points can be represented in 21 bits, as their valid
range is between <span class="docutils literal"><span class="pre">0x0</span></span> and <span class="docutils literal"><span class="pre">0x10FFFF</span></span>.</p>
<p>UTF-8 encodes code points as follows:</p>
<ul class="simple">
<li>Code points in the range <span class="docutils literal"><span class="pre">U+0000</span></span> to <span class="docutils literal"><span class="pre">U+007F</span></span> are represented with a
single byte with the 8th (most significant) bit being 0: <span class="docutils literal"><span class="pre">0b0xxxxxxx</span></span>.</li>
<li>Code points in the range <span class="docutils literal"><span class="pre">U+0080</span></span> to <span class="docutils literal"><span class="pre">U+07FF</span></span> are represented with two
bytes. The first byte starts with the bits <span class="docutils literal"><span class="pre">0b110xxxxx</span></span>, the second byte is
<span class="docutils literal"><span class="pre">0x10xxxxxx</span></span>. Without the prefixes, there are 11 bits used to encode the
code point (count the number of <span class="docutils literal"><span class="pre">x</span></span>s ).</li>
<li>Code points in the range <span class="docutils literal"><span class="pre">U+0800</span></span> to <span class="docutils literal"><span class="pre">U+FFFF</span></span> are represented with three
bytes. The first byte starts with the prefix <span class="docutils literal"><span class="pre">0b1110xxxx</span></span>, the following two
bytes with <span class="docutils literal"><span class="pre">0b10xxxxxx</span></span>. This leaves 16 bits to encode the code point.</li>
<li>Code points in the range <span class="docutils literal"><span class="pre">U+10000</span></span> to <span class="docutils literal"><span class="pre">U+10FFFF</span></span> are represented with four
bytes. The first byte starts with the prefix <span class="docutils literal"><span class="pre">0b11110xxx</span></span>, the following
three bytes with <span class="docutils literal"><span class="pre">0b10xxxxxx</span></span>. This leaves 21 bits to encode the code point.</li>
</ul>
<p>This encoding has several interesting properties: for code points in lower
planes, it is more compact than UTF-16. UTF-16 requires either one or two
16-bit code units, while UTF-8 can use 8, 16, 24, or 32 bits depending on the
code point. Commonly used alphabets are in the lower planes, so usually fewer
bits are needed.</p>
<p>UTF-8 is also ASCII-compatible: the first 128 characters (<span class="docutils literal"><span class="pre">U+0000</span></span> to
<span class="docutils literal"><span class="pre">U+007F</span></span>), represented in 7 bits, are the same as the old ASCII encoding. An
ASCII string can be used directly as UTF-8 encoded text without any
transformations required.</p>
<p>Unlike UTF-16, which can uniquely distinguish each code unit as either a code
point, a high surrogate, or a low surrogate, with UTF-8 we cannot always
determine what a code unit is in isolation: <span class="docutils literal"><span class="pre">0b10110011</span></span> could be the second,
third, or fourth byte in a code point. This is a consequence of the more
compact encoding. On the other hand, with UTF-8 we can look at the bit prefix
and determine the length of the sequence:</p>
<ul class="simple">
<li>If the prefix of the byte is <span class="docutils literal"><span class="pre">0b0xxxxxxx</span></span>, we have an ASCII character</li>
<li>If the prefix is <span class="docutils literal"><span class="pre">0b110xxxxx</span></span>, we are looking at the first byte of a code
point encoded in 2 bytes</li>
<li>If the prefix is <span class="docutils literal"><span class="pre">0b1110xxxx</span></span>, we are expecting a sequence of 3 bytes</li>
<li>If the prefix is <span class="docutils literal"><span class="pre">0b11110xxx</span></span>, we are expecting a sequence of 4 bytes</li>
<li>If the prefix is <span class="docutils literal"><span class="pre">0b10xxxxxx</span></span>, we know we aren’t looking at the first byte
in a sequence, rather at a byte inside a sequence</li>
</ul>
<p>Note the bit patterns do not overlap. Beyond ASCII, the number of 1 bits in the
prefix coincides with the number of bytes used to encode the code point.</p>
<p>As an example, let’s take the same 👩 emoji and see how its encoding looks like
in UTF-8. 👩 is the code point <span class="docutils literal"><span class="pre">U+1F469</span></span>, so it requires 4 bytes. <span class="docutils literal"><span class="pre">0x1F469</span></span>
represented in binary with 21 bits is <span class="docutils literal"><span class="pre">0b000011111010001101001</span></span>.</p>
<p>We fill this into <span class="docutils literal"><span class="pre">0b11110xxx</span> <span class="pre">0b10xxxxxx</span> <span class="pre">0b10xxxxxx</span> <span class="pre">0b10xxxxxx</span></span>, which gives
us <span class="docutils literal"><span class="pre">0b11110000</span> <span class="pre">0b10011111</span> <span class="pre">0b10010001</span> <span class="pre">0b10101001</span></span>. In hexadecimal, this is
<span class="docutils literal"><span class="pre">0xF0</span> <span class="pre">0x9F</span> <span class="pre">0x91</span> <span class="pre">0xA9</span></span>. This is the encoding of our emoji in UTF-8.</p>
<p>UTF-8 is the default encoding used by Linux and macOS. It is also the standard
for the internet, with a majority of web pages using this encoding.</p>
<p>Another important thing to keep in mind when manipulating text is how it is
encoded. When reading a sequence of bytes from a file or a network connection,
we need to make sure we don’t mistakenly try to interpret UTF-8 encoded text as
UTF-16 encoded text or vice-versa. Since different systems default to different
encodings, this is a very plausible scenario.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post we looked at some common text encoding standards and concepts:</p>
<ul class="simple">
<li>ASCII, which encodes 128 characters</li>
<li>Extended ASCII, which encodes 256 characters<ul>
<li>Code page 437, with box-drawing characters</li>
<li>The ISO/IEC 8859 16-part standard with code pages for various alphabets</li>
</ul>
</li>
<li>Unicode<ul>
<li>Code points and planes</li>
<li>Graphemes and combining characters</li>
</ul>
</li>
<li>Encodings<ul>
<li>The inefficient UTF-32</li>
<li>UTF-16 and surrogate pairs</li>
<li>Popular UTF-8</li>
</ul>
</li>
</ul>
</div>
]]></description>
             <pubDate>Sun, 18 Nov 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/10/13/arithmetic-overflow-and-underflow.html</link>
            <guid>http://vladris.com/blog/2018/10/13/arithmetic-overflow-and-underflow.html</guid>
            <title><![CDATA[Arithmetic Overflow and Underflow]]></title>
            <description><![CDATA[<h1>Arithmetic Overflow and Underflow</h1>
<p>Arithmetic overflow happens when an arithmetic operation results in a value that
is outside the range of values representable by the expression’s type. For
example, the following C++ code prints <span class="docutils literal"><span class="pre">0</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">uint16_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">65535</span><span class="p">;</span>
<span class="n">x</span><span class="o">++</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">x</span></span> is an unsigned 16 bit integer, which can represent values between 0 and
65535. If <span class="docutils literal"><span class="pre">x</span></span> is 65535 and we increment it, the value becomes 65536 but that
value cannot be represented by a <span class="docutils literal"><span class="pre">uint16_t</span></span>. This is an overflow. In this
case, C++ wraps the value around and <span class="docutils literal"><span class="pre">x</span></span> becomes 0.</p>
<p>Similarly, an underflow occurs when an arithmetic operation generates a result
that is below the smallest representable value of the expression’s type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">uint16_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">x</span><span class="o">--</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p>The above prints 65535, as the result of decrementing 0 is -1, which cannot be
represented by an <span class="docutils literal"><span class="pre">uint16_t</span></span>.</p>
<p>Before we digging into overflow behavior, we need to understand how computers
represent numbers.</p>
<div class="section" id="number-representations">
<h2>Number Representations</h2>
<div class="section" id="arbitrarily-large-integers">
<h3>Arbitrarily large integers</h3>
<p>Python provides support for arbitrarily large integers: unlike C++, where the
bit width (number of bits used to represent a number) is fixed, we can have
integers of any size:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">print</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Prints</p>
<blockquote style="word-wrap:break-word">
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
</blockquote><p>Why don’t all languages provide such support? The answer is performance. The
underlying hardware the code runs on uses fixed-width integers, so performing
arithmetic on fixed-width integer types becomes a single CPU instruction. On
the other hand, supporting arbitrarily large integers usually involves writing
code to determine how many bits a given value or the result of an arithmetic
operation needs and convert that into an array of fixed-width integers large
enough to hold that value. The added overhead of this is non-trivial, so unlike
Python, most other mainstream languages offer only fixed-width integers and
support arbitrarily large integers only explicitly, via libraries.</p>
</div>
<div class="section" id="unsigned-integers">
<h3>Unsigned integers</h3>
<p>Unsigned integers are represented as a sequence of <span class="docutils literal"><span class="pre">N</span></span> bits, thus being able
to represent numbers between 0 and 2<sup>N</sup>-1. An unsigned 8-bit integer can
store any value between 0 and 255, an unsigned 16-bit integer can store any
value between 0 and 65535, an unsigned 32-bit integer between 0 and 4294967295,
and an unsigned 64-bit integer between 0 and 18446744073709551615.</p>
<p>Unsigned integer representation is trivial.</p>
</div>
<div class="section" id="signed-integers">
<h3>Signed integers</h3>
<p>Signed integers are usually represented in two’s complement.</p>
<p>Positive numbers are encoded the same as unsigned binary numbers described
above. Negative numbers are encoded as two’s complement of their absolute
value. For example, an 8-bit representation of -3 is 2<sup>8</sup>-3.</p>
<p>The most significant bit is always 1 for negative numbers and 0 for positive
numbers or 0.</p>
<p>With this representation, <span class="docutils literal"><span class="pre">N</span></span> bits can encode a signed integer between
2<sup>N-1</sup>-1 and -2<sup>N</sup>. So 8 bits can encode an integer between -128
and 127.</p>
</div>
</div>
<div class="section" id="handling-overflow">
<h2>Handling Overflow</h2>
<p>If the result of an arithmetic operation cannot fit the type, there are several
approaches we can take and different programming languages employ different
strategies. These are:</p>
<ul class="simple">
<li>Exceptions</li>
<li>Wrap-around</li>
<li>Saturation</li>
</ul>
<p>All of these approaches have their pros and cons.</p>
<div class="section" id="exceptions">
<h3>Exceptions</h3>
<p>The safest approach is to treat an arithmetic overflow as an exception. This
usually gets rid of security vulnerabilities and treats any overflow as an
exceptional scenario. In this case an exception is thrown (or an error returned)
whenever an arithmetic operation overflows or underflows.</p>
<p>This is usually desirable from a security/safety perspective, but the trade-off
is in performance: the downside of this approach is that all arithmetic
operations need to be checked for overflow (underlying hardware usually does not
do this natively) and exceptions need to be handled by callers.</p>
</div>
<div class="section" id="wrap-around">
<h3>Wrap-around</h3>
<p>The default behavior in C++, wrap-around simply continues from the smallest
possible value in case of overflow or from the largest possible value in case
of underflow. For unsigned integers, this is equivalent to modulo arithmetic.
For example, for an <span class="docutils literal"><span class="pre">int8_t</span></span>, which can represent values between -128 and 127,
wrap-around would make 127 + 1 be -128 and similarly -128 - 1 be 127.</p>
<p>This is usually the most efficient way to perform arithmetic as no checking is
involved. Most hardware uses wrap-around as it can simply discard overflowing
bits to achieve the result. The two’s complement representation of 127 is
<span class="docutils literal"><span class="pre">01111111</span></span>. The two’s complement representation of 128 is <span class="docutils literal"><span class="pre">10000000</span></span>. With
this representation, adding 1 to 127 naturally makes it 128.</p>
<p>This is also the most unsafe implementation as it can lead to unexpected
behavior and exploitable security holes<a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
</div>
<div class="section" id="saturation">
<h3>Saturation</h3>
<p>Saturation means clamping the value within the allowed range, so on overflow, we
would simply stop at the largest representable value. On underflow, we would
stop at the smallest representable value. In our 8-bit signed integer example,
we would now have 127 + 1 be 127 and -128 - 1 be -128. There are several
advantages with this approach: for one, the resulting values on overflow and
underflow are the closest to the “real” values we would get if operating without
constraints. A lot of physical systems naturally lend themselves to saturation.
Imagine, for example, a thermostat which can only operate within a range of
temperature.</p>
<p>The downsides of this approach are results which might be surprising and the
fact that properties of arithmetic operations like associativity no longer hold:
(120 + 10) + (-10) is 117, but 120 + (10 + (-10)) is 120.</p>
</div>
</div>
<div class="section" id="detecting-overflow-and-underflow">
<h2>Detecting Overflow and Underflow</h2>
<p>Let’s now see how we can tell whether an arithmetic operation overflow while
operating only within the range of values representable by a given type.</p>
<p>For a type which can represent any value between some <span class="docutils literal"><span class="pre">MIN</span></span> and <span class="docutils literal"><span class="pre">MAX</span></span>, we
observe that an addition overflow means <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span>, while an underflow
means <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">MIN</span></span> (note <span class="docutils literal"><span class="pre">a</span></span> and <span class="docutils literal"><span class="pre">b</span></span> can be negative, so adding them
could produce a value that would be under our minimum representable value).</p>
<p>We can detect overflow and underflow by checking, if <span class="docutils literal"><span class="pre">b</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, that
<span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MAX</span> <span class="pre">-</span> <span class="pre">b</span></span>, otherwise with <span class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>, that <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MIN</span> <span class="pre">-</span> <span class="pre">b</span></span>.</p>
<p>The reason this works is that, if <span class="docutils literal"><span class="pre">b</span></span> is greater than or equal to 0, we can
safely subtract it from <span class="docutils literal"><span class="pre">MAX</span></span> (if it were negative, subtracting it would cause
an overflow). So with this in mind, we are simply saying that <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span>
is equivalent to <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MAX</span> <span class="pre">-</span> <span class="pre">b</span></span> (subtracting <span class="docutils literal"><span class="pre">b</span></span> on both sides). We also
observe that <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></span> can never underflow if <span class="docutils literal"><span class="pre">b</span></span> is greater than or equal to
0 because, regardless how small <span class="docutils literal"><span class="pre">a</span></span> is, adding a positive number to it will
make it larger not smaller.</p>
<p>If <span class="docutils literal"><span class="pre">b</span></span> is less than 0, then by the same logic we cannot possibly overflow -
regardless how large <span class="docutils literal"><span class="pre">a</span></span> is, adding <span class="docutils literal"><span class="pre">b</span></span> to it would make it smaller. In this
case we only need to check for underflow. Here we observe that subtracting a
negative number from <span class="docutils literal"><span class="pre">MIN</span></span> is safe - it will increase <span class="docutils literal"><span class="pre">MIN</span></span>. So by
subtracting <span class="docutils literal"><span class="pre">b</span></span> on both sides of <span class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">MIN</span></span>, we get <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MIN</span> <span class="pre">-</span> <span class="pre">b</span></span>.</p>
<p>The following code implements these two checks:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"/>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">AdditionOverflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">AdditionUnderflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Detecting overflow or underflow for subtraction is very similar, as subtracting
<span class="docutils literal"><span class="pre">b</span></span> from <span class="docutils literal"><span class="pre">a</span></span> is the equivalent of adding <span class="docutils literal"><span class="pre">-b</span></span> to <span class="docutils literal"><span class="pre">a</span></span>, thus we only need
to adjust the checks. <span class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span> means <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MAX</span> <span class="pre">+</span> <span class="pre">b</span></span> if <span class="docutils literal"><span class="pre">b</span></span> is negative
(so we don’t cause an overflow during the check), while <span class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">MIN</span></span> means
<span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MIN</span> <span class="pre">+</span> <span class="pre">b</span></span> if <span class="docutils literal"><span class="pre">b</span></span> is greater than or equal to 0:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">SubtractionOverflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">SubtractionUnderflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Detecting overflow for multiplication is more interesting. <span class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span> can
happen if <span class="docutils literal"><span class="pre">b</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, and <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MAX</span> <span class="pre">/</span> <span class="pre">b</span></span> or when <span class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>,
<span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>, and <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MAX</span> <span class="pre">/</span> <span class="pre">b</span></span> (dividing <span class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">&gt;</span> <span class="pre">MAX</span></span> on both sides by <span class="docutils literal"><span class="pre">b</span></span>,
a negative number, flips the sign of the inequality).</p>
<p>Underflow can happen only when one of the numbers is negative and the other one
isn’t. So if <span class="docutils literal"><span class="pre">b</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>, and <span class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">MIN</span> <span class="pre">/</span> <span class="pre">b</span></span> or if <span class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">0</span></span>,
<span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">0</span></span>, and <span class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">MIN</span> <span class="pre">/</span> <span class="pre">b</span></span>.</p>
<p>We can implement the checks as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">MultiplicationOverflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="p">))</span>
        <span class="o">||</span> <span class="p">((</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">MultiplicationUnderflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="p">))</span>
        <span class="o">||</span> <span class="p">((</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">b</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note integer division cannot possibly underflow. The single overflow that can
happen is due to the fact that in two’s complement representation, we can
represent one more negative number than positives, as 0 is, in a sense, positive
with this representation (the sign bit is not set for 0). An 8-bit signed
integer can represent 128 positive values (0 to 127) and 128 negative values
(-1 to -128). Overflow can only happen when we change the sign of the smallest
possible value we can represent by dividing it with -1. -128 / -1 becomes 128,
which is an overflow. This is the only case we need to check for:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">DivisionOverflows</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that unsigned integers can never overflow, so once we confirm that <span class="docutils literal"><span class="pre">a</span></span>
is the smallest possible value and <span class="docutils literal"><span class="pre">b</span></span> is -1, we also check to ensure <span class="docutils literal"><span class="pre">a</span></span> is
not <span class="docutils literal"><span class="pre">0</span></span>.</p>
<p>We are explicitly not looking at division by 0, which is part of the same safe
arithmetic topic. This post focuses on overflow and underflow only.</p>
</div>
<div class="section" id="handling-overflow-and-underflow">
<h2>Handling Overflow and Underflow</h2>
<p>Now that we can detect overflows and underflows, we can implement a couple of
policies to handle them. Wrap-around is the default behavior in C++, so let’s
look at the other two possibilities. We will implement a couple of types
templated on an integer type <span class="docutils literal"><span class="pre">T</span></span>, with overflow and underflow handlers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Policy</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnOverflow</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The throwing policy looks like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">ArithmeticException</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nc">ArithmeticOverflowException</span> <span class="o">:</span> <span class="n">ArithmeticException</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nc">ArithmeticUnderflowException</span> <span class="o">:</span> <span class="n">ArithmeticException</span> <span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">ThrowingPolicy</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnOverflow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArithmeticOverflowException</span><span class="p">{};</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArithmeticUnderflowException</span><span class="p">{};</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The saturation policy is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">SaturationPolicy</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnOverflow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="safe-arithmetic">
<h2>Safe Arithmetic</h2>
<p>Now that we have all the required pieces, we can create a type that wraps an
integer type and implements all the arithmetic operations checking for overflow
or underflow. The type is templated on a policy for handling overflows and
underflows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="nc">Policy</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">Integer</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">AdditionOverflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnOverflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">AdditionUnderflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">return</span> <span class="p">{</span> <span class="n">value</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">constexpr</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">SubtractionOverflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnOverflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">SubtractionUnderflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">return</span> <span class="p">{</span> <span class="n">value</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">constexpr</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">MultiplicationOverflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnOverflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">MultiplicationUnderflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnUnderflow</span><span class="p">()</span> <span class="p">};</span>

        <span class="k">return</span> <span class="p">{</span> <span class="n">value</span> <span class="o">*</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">constexpr</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">Integer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Policy</span><span class="o">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">DivisionOverflows</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Policy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">OnOverflow</span><span class="p">();</span> <span class="p">}</span>

        <span class="k">return</span> <span class="p">{</span> <span class="n">value</span> <span class="o">/</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now we can wrap an integer type with this and perform safe arithmetic:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">Integer</span><span class="o">&lt;</span><span class="kt">int8_t</span><span class="p">,</span> <span class="n">ThrowingPolicy</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span> <span class="mi">64</span> <span class="p">};</span>
<span class="n">Integer</span><span class="o">&lt;</span><span class="kt">int8_t</span><span class="p">,</span> <span class="n">ThrowingPolicy</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span> <span class="mi">2</span> <span class="p">};</span>

<span class="c1">// Throws</span>
<span class="n">Integer</span><span class="o">&lt;</span><span class="kt">int8_t</span><span class="p">,</span> <span class="n">ThrowingPolicy</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a simple implementation for illustrative purposes. The <span class="docutils literal"><span class="pre">Integer</span></span> type
currently only defines addition, subtraction, multiplication, and division. A
complete implementation would handle multiple other operators, like pre and post
increment, implicit casting from <span class="docutils literal"><span class="pre">T</span></span> etc.</p>
<p>The generic overflow and underflow checks can be specialized for unsigned types
so that we don’t redundantly check for <span class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">0</span></span> for a type which cannot
represent negative numbers. Similarly, we wouldn’t worry, for example, about
addition underflowing for an unsigned type.</p>
<p>We can also extend our safe arithmetic to not only rely on the standard
<span class="docutils literal"><span class="pre">numeric_limits</span></span>, but also allow users to clamp values between user-defined
minimum and maximum values.</p>
<p>For a production-ready safe arithmetic library, I recommend you check out David
LeBlanc’s <a class="reference external" href="https://github.com/dcleblanc/SafeInt">SafeInt</a>.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This post covered arithmetic overflow and underflow, and ways to handle it. We
looked at:</p>
<ul class="simple">
<li>What arithmetic overflow and underflow are</li>
<li>Integer representations:<ul>
<li>Unsigned</li>
<li>Two’s complement</li>
</ul>
</li>
<li>Ways to deal with overflow/underflow:<ul>
<li>Exceptions</li>
<li>Wrap-around</li>
<li>Saturation</li>
</ul>
</li>
<li>How to detect overflow/underflow</li>
<li>Implementing a simple <span class="docutils literal"><span class="pre">Integer</span></span> wrapper that performs safe arithmetic</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>An example of how an attacker can exploit integer overflow is the
following <a class="reference external" href="https://www.kb.cert.org/vuls/id/945216">SSH1 vulnerability</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sat, 13 Oct 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/09/09/clean-code-types.html</link>
            <guid>http://vladris.com/blog/2018/09/09/clean-code-types.html</guid>
            <title><![CDATA[Clean Code: Types]]></title>
            <description><![CDATA[<h1>Clean Code: Types</h1>
<p>I recently revived my Clean Code tech talk which I put together a couple of
years ago and with which I started this blog:
<a class="reference external" href="https://vladris.com/blog/2016/01/04/clean-code-part-1.html">Clean Code - Part 1</a>
and <a class="reference external" href="https://vladris.com/blog/2016/01/07/clean-code-part-2.html">Clean Code - Part 2</a>.
I took the opportunity to completely revamp the talk and ended up with 3 parts:
<em>Algorithms</em>, <em>Types</em>, and <em>State</em>. The <em>Algorithms</em> is mostly covered by the
<a class="reference external" href="https://vladris.com/blog/2018/02/11/fibonacci.html">Fibonacci</a> post, so in
this post we will talk about <em>Types</em>.</p>
<div class="section" id="mars-climate-orbiter">
<h2>Mars Climate Orbiter</h2>
<p>The Mars Climate Orbiter crashed and disintegrated in the Mars atmosphere
because a component developed by Lockheed provided momentum measured in
pound-force seconds, while another component developed by NASA expected momentum
as Newton seconds.</p>
<p>We can image the component developed by NASA being something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Will not disintegrate as long as momentum &gt;= 2 N s</span>
<span class="kt">void</span> <span class="nf">trajectory_correction</span><span class="p">(</span><span class="kt">double</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">momentum</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="cm">/* N s */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">disintegrate</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also imagine the Lockheed component calling into the above with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="mf">1.5</span> <span class="cm">/* lbf s */</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A pound-force second (lbfs) is about 4.448222 Newton seconds (Ns). So from
Lockheed’s perspective, passing in 1.5 lbfs to <span class="docutils literal"><span class="pre">trajectory_correction</span></span> should
be just fine: 1.5 lbfs is about 6.672333 Ns, way above the 2 Ns threshold.</p>
<p>The problem is the interpretation of the data. The NASA component ends up
comparing lbfs to Ns without conversion, misinterpreting the lbfs input as Ns.
Since 1.5 is less than 2, the orbiter disintegrates. This is a known
anti-pattern called “primitive obsession”.</p>
</div>
<div class="section" id="primitive-obsession">
<h2>Primitive Obsession</h2>
<p>Primitive obsession happens when we use a primitive data type to represent a
value in the problem’s domain and causes situations like the above. Representing
zip codes as numbers, telephone numbers as strings, Ns and lbfs as <span class="docutils literal"><span class="pre">double</span></span>
are all examples of this.</p>
<p>A more type safe solution would have defined a simple <span class="docutils literal"><span class="pre">Ns</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Ns</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Ns</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ns</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can similarly define a simple <span class="docutils literal"><span class="pre">lbfs</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">lbfs</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">lbfs</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">lbfs</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can implement a type safe <span class="docutils literal"><span class="pre">trajectory_correction</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Will not disintegrate as long as momentum &gt;= 2 N s</span>
<span class="kt">void</span> <span class="nf">trajectory_correction</span><span class="p">(</span><span class="n">Ns</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">momentum</span> <span class="o">&lt;</span> <span class="n">Ns</span><span class="p">{</span> <span class="mi">2</span> <span class="p">})</span>
    <span class="p">{</span>
        <span class="n">disintegrate</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Calling this with <span class="docutils literal"><span class="pre">lbfs</span></span> as below fails to compile as the types are
incompatible:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">lbfs</span><span class="p">{</span> <span class="mf">1.5</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note how the meaning of the values, which used to be specified in comments
(<span class="docutils literal"><span class="pre">2</span> <span class="pre">/*</span> <span class="pre">Ns</span> <span class="pre">*/</span></span>, <span class="docutils literal"><span class="pre">/*</span> <span class="pre">lbfs</span> <span class="pre">*/</span></span>) gets pulled into the type system and expressed
in code (<span class="docutils literal"><span class="pre">Ns{</span> <span class="pre">2</span> <span class="pre">}</span></span>, <span class="docutils literal"><span class="pre">lbfs{</span> <span class="pre">1.5</span> <span class="pre">}</span></span>).</p>
<p>We can, of course, provide casting from <span class="docutils literal"><span class="pre">lbfs</span></span> to <span class="docutils literal"><span class="pre">Ns</span></span> as an explicit
operator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">lbfs</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="k">operator</span> <span class="n">Ns</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="mf">4.448222</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Equipped with this, we can call <span class="docutils literal"><span class="pre">trajectory_correction</span></span> via a static cast:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">trajectory_correction</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Ns</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lbfs</span><span class="p">{</span> <span class="mf">1.5</span> <span class="p">}));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This does the right thing of multiplying by the ratio. The cast can also be
made implicit (by using the <span class="docutils literal"><span class="pre">implicit</span></span> keyword instead), in which case it is
applied automatically. As a rule of thumb, it’s best to follow the Zen of
Python:</p>
<blockquote>
<div>Explicit is better than implicit</div></blockquote>
<p>The moral of the story is that nowadays we have very sophisticated type checkers
but we do need to provide them enough information to catch this type of errors.
That information comes from declaring types to represent our problem domain.
<a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
</div>
<div class="section" id="state-space">
<h2>State Space</h2>
<p>Bad things happen when our programs end up in a <em>bad state</em>. Types help us
narrow down the possibility of such bad states. One way to think about this is
to look at types as sets of possible values. For example <span class="docutils literal"><span class="pre">bool</span></span> is the set
<span class="docutils literal"><span class="pre">{true,</span> <span class="pre">false}</span></span> where a variable of the type can be one of the two values.
Similarly, <span class="docutils literal"><span class="pre">uint32_t</span></span> is the set <span class="docutils literal"><span class="pre">{0</span> <span class="pre">...</span> <span class="pre">4294967295}</span></span>. Looking at types
like this, we can define the <em>state space</em> of our program as the product of
the types of all live variables at a given point in time.</p>
<p>If we have a <span class="docutils literal"><span class="pre">bool</span></span> and an <span class="docutils literal"><span class="pre">uint32_t</span></span>, our state space is <span class="docutils literal"><span class="pre">{true,</span> <span class="pre">false}</span> <span class="pre">X</span>
<span class="pre">{0</span> <span class="pre">...</span> <span class="pre">4294967295}</span></span>. This simply means that the two variables can be in any of
their possible states and since we have two of them, our program can be in any
of their combined states.</p>
<p>This gets more interesting when we look at functions that initialize values:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">bool</span> <span class="nf">get_momentum</span><span class="p">(</span><span class="n">Ns</span><span class="o">&amp;</span> <span class="n">momentum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">some_condition</span><span class="p">())</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">momentum</span> <span class="o">=</span> <span class="n">Ns</span><span class="p">{</span> <span class="mi">3</span> <span class="p">};</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above example we take a <span class="docutils literal"><span class="pre">Ns</span></span> by reference and initialize it if some
condition is met. The function returns <span class="docutils literal"><span class="pre">true</span></span> if the value was properly
initialized. If the function cannot, for whatever reason, set the value, it
returns <span class="docutils literal"><span class="pre">false</span></span>.</p>
<p>Looking at this from the state space lens, our state space is the product
<span class="docutils literal"><span class="pre">bool</span> <span class="pre">X</span> <span class="pre">Ns</span></span>. If the function returns <span class="docutils literal"><span class="pre">true</span></span>, then <span class="docutils literal"><span class="pre">momentum</span></span> was set and
is in any one of the possible <span class="docutils literal"><span class="pre">Ns</span></span> values. The problem is that if the function
returns <span class="docutils literal"><span class="pre">false</span></span>, then <span class="docutils literal"><span class="pre">momentum</span></span> was not set. It is still in any one of the
possible <span class="docutils literal"><span class="pre">Ns</span></span> values, but it is not a valid value. Often times we have bugs
where we accidentally propagate such invalid state:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Ns</span> <span class="n">momenum</span><span class="p">;</span>

    <span class="n">get_momentum</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>

    <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What we should have done instead is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Ns</span> <span class="n">momentum</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">get_momentum</span><span class="p">(</span><span class="n">momentum</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">trajectory_correction</span><span class="p">(</span><span class="n">momentum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a better way though, where this can be enforced:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Ns</span><span class="o">&gt;</span> <span class="n">get_momentum</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">some_condition</span><span class="p">())</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_optional</span><span class="p">(</span><span class="n">Ns</span><span class="p">{</span> <span class="mi">3</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using an <span class="docutils literal"><span class="pre">optional</span></span>, this version of the function has a significantly smaller
state space: instead of <span class="docutils literal"><span class="pre">bool</span> <span class="pre">X</span> <span class="pre">Ns</span></span>, we have <span class="docutils literal"><span class="pre">Ns</span> <span class="pre">+</span> <span class="pre">1</span></span>. The function either
returns a valid <span class="docutils literal"><span class="pre">Ns</span></span> value or <span class="docutils literal"><span class="pre">nullopt</span></span> to denote the absence of a value.
Now it becomes impossible to have an invalid <span class="docutils literal"><span class="pre">Ns</span></span> that gets propagated
throughout the system. We can also no longer <em>forget</em> to check the return value
as an <span class="docutils literal"><span class="pre">optional&lt;Ns&gt;</span></span> is not implicitly convertible to an <span class="docutils literal"><span class="pre">Ns</span></span> - we need to
explicitly unpack it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">maybeMomentum</span> <span class="o">=</span> <span class="n">get_momentum</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">maybeMomentum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">trajectory_correction</span><span class="p">(</span><span class="o">*</span><span class="n">maybeMomentum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In general, we want our functions to return <strong>result or error</strong> not
<strong>result and error</strong>. This way we eliminate the states in which we have an error
but also an invalid result which might make its way in further computation.</p>
<p>From this point of view, throwing exceptions is OK as this follows the same
pattern: a function either returns a result <strong>or</strong> throws an exception.</p>
</div>
<div class="section" id="raii">
<h2>RAII</h2>
<p>RAII stands for <em>Resource Acquisition Is Initialization</em> but has more to do
with releasing resources. The name originated from C++ but the pattern can be
implemented in any language (see, for example, .NET’s <span class="docutils literal"><span class="pre">IDisposable</span></span>). RAII
ensures automatic cleanup of resources.</p>
<p>What are resources? A few examples: heap memory, database connections, OS
handles. In general, a resource is something we acquire from the outside world
and we need to release when it is no longer needed. That means executing some
form of free, delete, close etc. on the resource.</p>
<p>Since these resources are external, they are not directly expressed into our
type system. For example if we allocate some heap memory, we get a pointer on
which we have to call <span class="docutils literal"><span class="pre">delete</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{};</span>

<span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>

    <span class="cm">/* Use foo */</span>

    <span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But what happens if we forget or something prevents us from calling <span class="docutils literal"><span class="pre">delete</span></span>?</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>

    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case we no longer call <span class="docutils literal"><span class="pre">delete</span></span> and we leak the resource. In general,
we don’t want to perform such manual cleanup. For heap memory, we actually have
<span class="docutils literal"><span class="pre">unique_ptr</span></span> to help us manage it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">unique_ptr</span></span> is a stack object so whenever it goes out of scope (when the
function throws or during stack unwinding if an exception was thrown) its
destructor gets called. It’s destructor implements the call to <span class="docutils literal"><span class="pre">delete</span></span>. This
way, we no longer have to manually manage the memory resource - we hand it off
to a wrapper which owns it and handles releasing it.</p>
<p>Similar wrappers exist or can be created for any of the other resources (for
example a Windows OS <span class="docutils literal"><span class="pre">HANDLE</span></span> can be wrapped in a type where its destructor
would call <span class="docutils literal"><span class="pre">CloseHandle</span></span>.</p>
<p>The key takeaway is never to do manual resource cleanup - either use an existing
wrapper or, if none exists for your particular scenario, implement one.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This post started with a famous example of why typing is important, and covered
three important aspects of leveraging types to write safer code:</p>
<ul class="simple">
<li>Declaring and using stronger types (as opposed to primitive obsession).</li>
<li>Reducing state space, returning result or error instead of result and error.</li>
<li>RAII and automatic resource management.</li>
</ul>
<p>Types are great tools for implementing safer, reusable code.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>There is a great series of posts on Fluent C++ on <a class="reference external" href="https://www.fluentcpp.com/category/strong-types/">Strong Typing</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sun, 09 Sep 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/07/16/implementing-a-variant-type-in-csharp.html</link>
            <guid>http://vladris.com/blog/2018/07/16/implementing-a-variant-type-in-csharp.html</guid>
            <title><![CDATA[Implementing a Variant Type in C#]]></title>
            <description><![CDATA[<h1>Implementing a Variant Type in C#</h1>
<p>A variant, or discriminated union type <a class="footnote-reference" href="#id2" id="id1">[1]</a>, is a type that can hold a value of
any of a finite set of types. For example, a <span class="docutils literal"><span class="pre">Variant&lt;int,</span> <span class="pre">string&gt;</span></span> can hold
either an <span class="docutils literal"><span class="pre">int</span></span> or a <span class="docutils literal"><span class="pre">string</span></span> value. This is also known as a <em>sum type</em>, as
its domain is the sum of the <span class="docutils literal"><span class="pre">int</span></span> and <span class="docutils literal"><span class="pre">string</span></span> domains. Contrast this with
a <span class="docutils literal"><span class="pre">Tuple&lt;int,</span> <span class="pre">string&gt;</span></span>, also known as a <em>product type</em>, which holds <em>both</em> an
<span class="docutils literal"><span class="pre">int</span></span> and a <span class="docutils literal"><span class="pre">string</span></span> (so its domain is the product of the <span class="docutils literal"><span class="pre">int</span></span> and
<span class="docutils literal"><span class="pre">string</span></span> domains).</p>
<p>First, let’s look at how something like this would be achieved without a
<span class="docutils literal"><span class="pre">Variant</span></span> type. Let’s take an expression tree where a node can be either an
<span class="docutils literal"><span class="pre">int</span></span> value or an expression consisting of an operation (let’s say addition
and multiplication) and two operands which are in turn nodes. We could implement
this by starting with an <span class="docutils literal"><span class="pre">INode</span></span> base interface and deriving our types from
that:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="n">Op</span> <span class="p">{</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span> <span class="p">}</span>

<span class="k">interface</span> <span class="n">INode</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">ExpressionNode</span> <span class="p">:</span> <span class="n">INode</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Op</span> <span class="n">Op</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">INode</span> <span class="n">Left</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">INode</span> <span class="n">Right</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ValueNode</span> <span class="p">:</span> <span class="n">INode</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, but has a couple of drawbacks – first, to discriminate between the
types allowed to be part of the tree and the types that aren’t, we need to
establish a typing relationship and force every type of node in our tree to
implement a dummy <span class="docutils literal"><span class="pre">INode</span></span> interface. In the case of a value, even though we
just need an <span class="docutils literal"><span class="pre">int</span></span>, we must wrap it into a <span class="docutils literal"><span class="pre">ValueNode</span></span> class because
<span class="docutils literal"><span class="pre">int</span></span> itself does not implement <span class="docutils literal"><span class="pre">INode</span></span>.</p>
<p>Another drawback is that in many cases we want to restrict the types that can
participate in our system (in this case our expression tree). This is harder to
enforce via an interface, as one could always implement some other <span class="docutils literal"><span class="pre">class</span>
<span class="pre">FooNode</span> <span class="pre">:</span> <span class="pre">INode</span></span> and there is no compile-time way to prevent this node from
becoming part of our tree.</p>
<p>This is how the above tree would be declared if we had a <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="n">Op</span> <span class="p">{</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">Expression</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Op</span> <span class="n">Op</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">Left</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">Expression</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">Right</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>First, we no longer need an <span class="docutils literal"><span class="pre">INode</span></span>, as it would get replaced by
<span class="docutils literal"><span class="pre">Variant&lt;Expression,</span> <span class="pre">int&gt;</span></span>, which effectively translates to <em>it’s either an
Expression or an int</em>. There is also no room to sneak in another type without
being explicit about it. We do not need to wrap <span class="docutils literal"><span class="pre">int</span></span> into another class
either just to make it conform to our hierarchy, as a <span class="docutils literal"><span class="pre">Variant</span></span> can handle it
directly.</p>
<p>So how would we go about designing such a generic variant in C#?</p>
<div class="section" id="design-considerations">
<h2>Design Considerations</h2>
<p>Our variant implementation should satisfy a few requirements:</p>
<ul>
<li><p class="first">Since C# does not support variadic generic arguments, we want implementations
from <span class="docutils literal"><span class="pre">Variant&lt;T1&gt;</span></span>, holding a value of a single type, up to
<span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2,</span> <span class="pre">T3,</span> <span class="pre">T4,</span> <span class="pre">T5,</span> <span class="pre">T6,</span> <span class="pre">T7,</span> <span class="pre">T8&gt;</span></span>, holding a value of any of 8
types. This is in line with how other library types like <span class="docutils literal"><span class="pre">Tuple</span></span> are
implemented.</p>
</li>
<li><p class="first">We want to support implicit casting from one of the generic types to the
variant, as this enables assignment:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">We want to support explicit casting from a variant to any of its generic
types. Since a variant might hold a value of a different type, we should be
explicit in this case, as a mismatch between the actual held value and the
cast-to type would throw an <span class="docutils literal"><span class="pre">InvalidCastException</span></span>.</p>
</li>
<li><p class="first">We need an API to get the value of the variant as a given type. A type
mismatch between the given type and the one actually held by the variant would
result in an <span class="docutils literal"><span class="pre">InvalidCastException</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>

<span class="kt">int</span> <span class="k">value</span> <span class="p">=</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
<span class="kt">string</span> <span class="k">value</span> <span class="p">=</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span> <span class="c1">// throws InvalidCastException</span>
</pre></div>
</div>
</li>
<li><p class="first">We need an API to check if the value of the variant is of a certain type:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>

<span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span> <span class="c1">// false</span>
<span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span> <span class="c1">// true</span>
</pre></div>
</div>
</li>
<li><p class="first">We need to support variants where the same type appears several times, like
<span class="docutils literal"><span class="pre">Variant&lt;int,</span> <span class="pre">int&gt;</span></span>. There are legitimate use cases for this, for example an
API that would return either an error code or a value, both being of the same
type. For such cases, we need another way to explicitly set a value as the
first, second, and so on type, and an <span class="docutils literal"><span class="pre">Index</span></span> property that would tell us
which occurrence of the type it is (as <span class="docutils literal"><span class="pre">Get&lt;int&gt;()</span> <span class="pre">called</span> <span class="pre">on</span> <span class="pre">a</span> <span class="pre">Variant&lt;int,</span>
<span class="pre">int&gt;</span></span> would succeed in returning us an <span class="docutils literal"><span class="pre">int</span></span>, but we wouldn’t be able to
tell whether it got in there as a <span class="docutils literal"><span class="pre">T1</span> <span class="pre">or</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">T2</span></span>.</p>
</li>
<li><p class="first">We would also provide a non-generic <span class="docutils literal"><span class="pre">Get()</span></span> which returns an <span class="docutils literal"><span class="pre">object</span></span>, so
we can use pattern matching on a variant:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="kt">string</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"It's a string: "</span> <span class="p">+</span> <span class="n">s</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="kt">int</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"It's an int: "</span> <span class="p">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">We need to override equality: two variants are equivalent if they are the
same type (same generic parameters), they contain values of the same type at
the same index, and the contained values are equivalent:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant1</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>
<span class="n">Variant</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant2</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>

<span class="n">variant1</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="n">variant2</span><span class="p">);</span> <span class="c1">// true</span>
</pre></div>
</div>
</li>
</ul>
<p>Given these requirements, let’s see how an implementation would look like.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<div class="section" id="api">
<h3>API</h3>
<p>We’ll start with a <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span> and build up from there. Adding more
generic arguments becomes easy once this implementation is figured out. Starting
from the simpler <span class="docutils literal"><span class="pre">Variant&lt;T1&gt;</span></span> would not uncover some of the issues mentioned
above, like the need for an index and ability to handle <span class="docutils literal"><span class="pre">T1</span></span> and  <span class="docutils literal"><span class="pre">T2</span></span> being
the same type. Let’s define our API based on the requirements:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="c1">// Variant API</span>
    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Index</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="c1">// T1 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="c1">// T2 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="c1">// Equality</span>
    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NotImplementedException</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have the <span class="docutils literal"><span class="pre">Index</span></span> property which should be <span class="docutils literal"><span class="pre">0</span></span> if the variant is holding
a <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">1</span></span> if the variant is holding a <span class="docutils literal"><span class="pre">T2</span></span>. We’re using 0-based
indexing for this, though it is a bit awkward that generic arguments start, by
convention, from 1. This is in line with what other .NET types do, for example
<span class="docutils literal"><span class="pre">Tuple</span></span> provides a 0-based indexer.</p>
<p><span class="docutils literal"><span class="pre">It&lt;T&gt;()</span></span> allows callers to check if the variant is currently holding a
<span class="docutils literal"><span class="pre">T</span></span>, while <span class="docutils literal"><span class="pre">Get&lt;T&gt;()</span></span> should return a <span class="docutils literal"><span class="pre">T</span></span> or throw an
<span class="docutils literal"><span class="pre">InvalidCastException</span></span>. The non-generic version <span class="docutils literal"><span class="pre">Get()</span></span> simply returns an
<span class="docutils literal"><span class="pre">object</span></span>.</p>
<p>Below that, for both <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> we provide a constructor which takes a
<span class="docutils literal"><span class="pre">T1</span></span> (or <span class="docutils literal"><span class="pre">T2</span></span>) and places it in the variant, implicit casts from <span class="docutils literal"><span class="pre">T1</span></span> and
<span class="docutils literal"><span class="pre">T2</span></span> to <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span>, and explicit casts the other way around.</p>
<p>Finally, we override <span class="docutils literal"><span class="pre">Equals(object)</span></span> and <span class="docutils literal"><span class="pre">GetHashCode()</span></span> (it’s always a
good idea to override <span class="docutils literal"><span class="pre">GetHashCode</span></span> when overriding <span class="docutils literal"><span class="pre">Equals</span></span>).</p>
</div>
<div class="section" id="type-erasure">
<h3>Type erasure</h3>
<p>Let’s look at how we would store a value. Unlike a <span class="docutils literal"><span class="pre">Tuple&lt;T1,</span> <span class="pre">T2&gt;</span></span>, we don’t
want to store both a <span class="docutils literal"><span class="pre">T1</span></span> <em>and</em> a <span class="docutils literal"><span class="pre">T2</span></span>, rather we want either a <span class="docutils literal"><span class="pre">T1</span></span> <em>or</em>
a <span class="docutils literal"><span class="pre">T2</span></span>. In order to generalize this, we need a way to perform type-erasure,
which means a way to store any type (as we want a generic implementation), while
at the same type we need to keep track of the stored type so we can answer
<span class="docutils literal"><span class="pre">Is&lt;T&gt;()</span></span> properly. Let’s create a <span class="docutils literal"><span class="pre">VariantHolder</span></span> to handle this.</p>
<p>We could achieve this by storing everything as an <span class="docutils literal"><span class="pre">object</span></span>
(type-erasure) and a <span class="docutils literal"><span class="pre">Type</span></span> (for type information), like this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">sealed</span> <span class="k">class</span> <span class="nc">VariantHolder</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">object</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">private</span> <span class="n">Type</span> <span class="n">_itemType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">==</span> <span class="n">_itemType</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">VariantHolder</span><span class="p">(</span><span class="kt">object</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Item</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">_itemType</span> <span class="p">=</span> <span class="n">item</span><span class="p">.</span><span class="n">GetType</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can then implement our variant in terms of this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">VariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VariantHolder</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="cm">/* ...</span>
<span class="cm">       Same for T2, ignoring Equals() and GetHashCode() for now */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This implementation is not quite correct, as it stores too much type
information:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="p">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span>

<span class="cm">/* ... */</span>

<span class="n">Variant</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
<span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">Base</span><span class="p">&gt;();</span> <span class="c1">// == false!</span>
</pre></div>
</div>
<p>We are comparing the actual type of the item, though we should store it as one
of the generic types of the variant declaration. A better idea is to make our
<span class="docutils literal"><span class="pre">VariantHolder</span></span> itself generic:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">sealed</span> <span class="k">class</span> <span class="nc">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">VariantHolder</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Item</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This gets us rid of the extra <span class="docutils literal"><span class="pre">_itemType</span></span> member (we can use <span class="docutils literal"><span class="pre">typeof(T)</span></span> on
the generic parameter), but we have another problem: how do we declare this in
our <span class="docutils literal"><span class="pre">Variant</span></span>? If we make it a <span class="docutils literal"><span class="pre">VariantHolder&lt;T1&gt;</span></span>, then we won’t be able
to store a <span class="docutils literal"><span class="pre">T2</span></span> value and vice-versa. There is a way around this - we can
extract an interface:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IVariantHolder</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="kt">object</span> <span class="nf">Get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can declare that our <span class="docutils literal"><span class="pre">VariantHolder&lt;T&gt;</span></span> implements this interface (it
already does, as it has both a generic <span class="docutils literal"><span class="pre">Is</span></span> and a non-generic <span class="docutils literal"><span class="pre">Get</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">sealed</span> <span class="k">class</span> <span class="nc">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IVariantHolder</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="n">Item</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">VariantHolder</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Item</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And now we can implement our <span class="docutils literal"><span class="pre">Variant</span></span> in terms of an <span class="docutils literal"><span class="pre">IVariantHolder</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">IVariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">((</span><span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">variant</span><span class="p">).</span><span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="c1">// T1 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="c1">// T2 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;();</span>

    <span class="cm">/* ...</span>
<span class="cm">       Ignoring Equals() and GetHashCode() for now */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">Get&lt;T&gt;()</span></span> we use a cast to <span class="docutils literal"><span class="pre">VariantHolder&lt;T&gt;</span></span> as opposed to
<span class="docutils literal"><span class="pre">(T)_variantHolder.Get()</span></span> as this avoids an extra boxing operation if <span class="docutils literal"><span class="pre">T</span></span>
is a value type. This correctly throws <span class="docutils literal"><span class="pre">InvalidCastException</span></span> if called with
the wrong type. If we wanted to throw a different exception or add more details
to the exception, we could either wrap this cast in a try/catch and catch an
<span class="docutils literal"><span class="pre">InvalidCastException</span></span> or we could check the type using <span class="docutils literal"><span class="pre">Is&lt;T&gt;()</span></span> before
performing the cast.</p>
</div>
<div class="section" id="index-and-disambiguation">
<h3>Index and disambiguation</h3>
<p>The only problem with this implementation is that we cannot instantiate a
variant if <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> are the same:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Variant</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">variant</span> <span class="p">=</span> <span class="m">42</span><span class="p">;</span>
</pre></div>
</div>
<p>yields a compiler error: “Ambiguous user defined conversions”. If we try calling
the constructor:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">variant</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;(</span><span class="m">42</span><span class="p">);</span>
</pre></div>
</div>
<p>we get “The call is ambiguous between the following methods…”. If <span class="docutils literal"><span class="pre">T1</span></span> and
<span class="docutils literal"><span class="pre">T2</span></span> are the same type, there is no way to disambiguate between constructors
and casts. Because of this, we need to add our <span class="docutils literal"><span class="pre">Index</span></span> property and provide a
way to explicitly construct the variant with an index. First, let’s add
<span class="docutils literal"><span class="pre">Index</span></span> to our current implementation:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">IVariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Index</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">((</span><span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">variant</span><span class="p">).</span><span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">private</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">variant</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">Index</span> <span class="p">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;();</span>

    <span class="cm">/* ...</span>
<span class="cm">       Ignoring Equals() and GetHashCode() for now */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We added a read-only <span class="docutils literal"><span class="pre">Index</span></span> property, a private constructor that not only
sets the <span class="docutils literal"><span class="pre">IVariantHolder</span></span> but also the <span class="docutils literal"><span class="pre">Index</span></span>, and we updated our two
constructors, <span class="docutils literal"><span class="pre">Variant(T1</span> <span class="pre">item)</span></span> and <span class="docutils literal"><span class="pre">Variant(T2</span> <span class="pre">item)</span></span> to internally call
this private constructor with the correct index.</p>
<p>Now we have an <span class="docutils literal"><span class="pre">Index</span></span> property which accurately keeps track of the index of
the type stored, so for a <span class="docutils literal"><span class="pre">Variant&lt;int,</span> <span class="pre">int&gt;</span></span> we would be able to tell
whether we set the first or second <span class="docutils literal"><span class="pre">int</span></span>, but we still can’t disambiguate
between constructor calls if <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> are the same. We can solve this
by adding a couple of explicit factory methods:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make1</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">);</span>

<span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make2</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">);</span>
</pre></div>
</div>
<p>We could have provided a way for the callers to explicitly provide an index,
but it becomes hard to enforce that the index is in sync with the type. If
<span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> are the same, then the caller ultimately decides the index,
but if <span class="docutils literal"><span class="pre">T1</span></span> and <span class="docutils literal"><span class="pre">T2</span></span> are different, then <span class="docutils literal"><span class="pre">Variant</span></span> needs to decide the
index.</p>
<p>Providing <span class="docutils literal"><span class="pre">Make1</span></span> and <span class="docutils literal"><span class="pre">Make2</span></span> works, since <span class="docutils literal"><span class="pre">Make1</span></span> only accepts a <span class="docutils literal"><span class="pre">T1</span></span>
argument while <span class="docutils literal"><span class="pre">Make2</span></span> only accepts a <span class="docutils literal"><span class="pre">T2</span></span> argument. Thus, if they are the
same, the caller disambiguates by calling one of the methods and there is no
compilation issue. If they are different, calling one of them is the equivalent
of calling one of the constructors (there is no way to call <span class="docutils literal"><span class="pre">Make1</span></span> with a
<span class="docutils literal"><span class="pre">T2</span></span> argument).</p>
</div>
<div class="section" id="equality">
<h3>Equality</h3>
<p>Now the only remaining bit is overriding <span class="docutils literal"><span class="pre">Equals</span></span>, as we want two variants
containing equivalent values to be equivalent. In other words, given another
object, we would consider it equivalent if it has the same type as this object,
has the value <em>at the same index</em>, and the value of the other object is
equivalent to the value of this object:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="p">!(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;))</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

    <span class="kt">var</span> <span class="n">other</span> <span class="p">=</span> <span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;)</span><span class="n">obj</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">Index</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Index</span> <span class="p">&amp;&amp;</span> <span class="n">Get</span><span class="p">().</span><span class="n">Equals</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Overriding <span class="docutils literal"><span class="pre">Equals</span></span> usually means overriding <span class="docutils literal"><span class="pre">GetHashCode</span></span> in such a way
that equivalent objects hash to the same value. In our case, we can rely on the
value stored in the variant to implement this by simply delegating hashing to
it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
    <span class="p">=&gt;</span> <span class="n">Get</span><span class="p">().</span><span class="n">GetHashCode</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="multiple-generic-arguments">
<h3>Multiple generic arguments</h3>
<p>We have an implementation for a <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span> but we are looking at
providing variants from <span class="docutils literal"><span class="pre">Variant&lt;T1&gt;</span></span> all the way to <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2,</span> <span class="pre">T3,</span> <span class="pre">T4,</span>
<span class="pre">T5,</span> <span class="pre">T6,</span> <span class="pre">T7,</span> <span class="pre">T8&gt;</span></span>.</p>
<p>First, let’s look at what would be common to all of these. The API (<span class="docutils literal"><span class="pre">Is&lt;T&gt;</span></span>,
<span class="docutils literal"><span class="pre">Get&lt;T&gt;</span></span> etc.) is implemented in terms of <span class="docutils literal"><span class="pre">IVariantHolder</span></span>. Let’s extract
this into a base class. Since we are going to make all our variants derive from
it, it must be <span class="docutils literal"><span class="pre">public</span></span>, but we probably don’t want clients to derive from it
as it is an implementation detail, so we will provide an <span class="docutils literal"><span class="pre">internal</span></span>
constructor. This will make this class instantiable only within the assembly
declaring it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">VariantBase</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IVariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Index</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">((</span><span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">variant</span><span class="p">).</span><span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">internal</span> <span class="nf">VariantBase</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">variant</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">Index</span> <span class="p">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span> ends up containing only the constructors, casts, and
equality:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">VariantBase</span>
<span class="p">{</span>
    <span class="c1">// Calls base constructor</span>
    <span class="k">private</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// T1 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make1</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">);</span>

    <span class="c1">// T2 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make2</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">);</span>

    <span class="c1">// Equality</span>
    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="p">!(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;))</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">other</span> <span class="p">=</span> <span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;)</span><span class="n">obj</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">Index</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Index</span> <span class="p">&amp;&amp;</span> <span class="n">Get</span><span class="p">().</span><span class="n">Equals</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="n">Get</span><span class="p">().</span><span class="n">GetHashCode</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can even hoist <span class="docutils literal"><span class="pre">Equals</span></span> to our base class, since we can replace the <span class="docutils literal"><span class="pre">is</span></span>
check <span class="docutils literal"><span class="pre">!(obj</span> <span class="pre">is</span> <span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;)</span></span> with <span class="docutils literal"><span class="pre">GetType()</span> <span class="pre">!=</span> <span class="pre">obj.GetType()</span></span>:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">VariantBase</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IVariantHolder</span> <span class="n">variant</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Index</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">T</span> <span class="n">Get</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="p">=&gt;</span> <span class="p">((</span><span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">variant</span><span class="p">).</span><span class="n">Item</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">variant</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span>

    <span class="k">internal</span> <span class="nf">VariantBase</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">variant</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">Index</span> <span class="p">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">GetType</span><span class="p">()</span> <span class="p">!=</span> <span class="n">obj</span><span class="p">.</span><span class="n">GetType</span><span class="p">())</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

        <span class="kt">var</span> <span class="n">other</span> <span class="p">=</span> <span class="p">(</span><span class="n">VariantBase</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">Index</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">Index</span> <span class="p">&amp;&amp;</span> <span class="n">Get</span><span class="p">().</span><span class="n">Equals</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span>
        <span class="p">=&gt;</span> <span class="n">Get</span><span class="p">().</span><span class="n">GetHashCode</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now our <span class="docutils literal"><span class="pre">Variant&lt;T1,</span> <span class="pre">T2&gt;</span></span> contains only constructors and casts:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">VariantBase</span>
<span class="p">{</span>
    <span class="c1">// Calls base constructor</span>
    <span class="k">private</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">IVariantHolder</span> <span class="n">item</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// T1 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T1</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make1</span><span class="p">(</span><span class="n">T1</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">0</span><span class="p">);</span>

    <span class="c1">// T2 constructor, casts</span>
    <span class="k">public</span> <span class="nf">Variant</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">T2</span><span class="p">(</span><span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;</span> <span class="n">Make2</span><span class="p">(</span><span class="n">T2</span> <span class="n">item</span><span class="p">)</span>
        <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Variant</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">VariantHolder</span><span class="p">&lt;</span><span class="n">T2</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">),</span> <span class="m">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While C# doesn’t provide a way to implement variable number of generic
arguments, constructors and casts for all types are identical, so we can use a
<a class="reference external" href="https://docs.microsoft.com/en-us/visualstudio/modeling/design-time-code-generation-by-using-t4-text-templates">T4 text template</a>
to generate all this code. Our template would iterate for each type and emit the
C# code for these:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>&lt;#
for (int types = 1; types &lt;= 8; types++)
{
    // Comma-delimited string of types (eg. "T1, T2, T3")
    var args = String.Join(", ",
        Enumerable.Range(1, types).Select(i =&gt; "T" + i));

    // Type we are generating code for (eg. "Variant&lt;T1, T2, T3&gt;")
    var type = $"Variant&lt;{args}&gt;";
#&gt;

    public sealed class &lt;#= type #&gt; : VariantBase
    {
        private Variant(IVariantHolder item, byte index)
            : base(item, index)
        {}

&lt;#
    // For each type argument T1, T2, T3 etc.
    for (int i = 1; i &lt;= types; i++)
    {
#&gt;
        public Variant(T&lt;#= i #&gt; item)
            : base(new VariantHolder&lt;T&lt;#= i #&gt;&gt;(item), &lt;#= i - 1 #&gt;)
        {}

        public static implicit operator &lt;#= type #&gt;(T&lt;#= i #&gt; item)
            =&gt; new &lt;#= type #&gt;(item);

        public static explicit operator T&lt;#= i #&gt;(&lt;#= type #&gt; variant)
            =&gt; variant.Get&lt;T&lt;#= i #&gt;&gt;();

        public static &lt;#= type #&gt; Make&lt;#= i #&gt;(T&lt;#= i #&gt; item)
            =&gt; new &lt;#= type #&gt;(new VariantHolder&lt;T&lt;#= i #&gt;&gt;(item), &lt;#= i - 1 #&gt;);
&lt;#
    }
#&gt;
    }

&lt;#
}
#&gt;
</pre></div>
</div>
<p>I will not cover T4 templates in this blog post, just highlight that the
template above does generate all the <span class="docutils literal"><span class="pre">Variant&lt;&gt;</span></span> variations with the
appropriate constructors and cats.</p>
<p>I am currently working on a type library which includes this variant and some
other useful types: <a class="reference external" href="https://github.com/vladris/Maki">https://github.com/vladris/Maki</a>.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post we implemented a generic variant type in C#, going over:</p>
<ul class="simple">
<li>Variant types and how they are useful.</li>
<li>Requirements for a variant type.</li>
<li>Implementation:<ul>
<li>API.</li>
<li>Type erasure.</li>
<li>Disambiguating between similar generic arguments.</li>
<li>Overrides for <span class="docutils literal"><span class="pre">Equals</span></span> and <span class="docutils literal"><span class="pre">GetHashCode</span></span>.</li>
<li>Implementations for various numbers of generic arguments.</li>
</ul>
</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>See <a class="reference external" href="https://en.wikipedia.org/wiki/Tagged_union">“tagged union” on Wikipedia</a></td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Mon, 16 Jul 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/06/23/ioc-containers.html</link>
            <guid>http://vladris.com/blog/2018/06/23/ioc-containers.html</guid>
            <title><![CDATA[IoC Containers]]></title>
            <description><![CDATA[<h1>IoC Containers</h1>
<p>In this post I will go over the basics of IoC containers and walk through a very
simple C# implementation.</p>
<div class="section" id="motivation">
<h2>Motivation</h2>
<p>An inversion of control container is a component that encapsulates dependency
injection and lifetime management of other components <a class="footnote-reference" href="#id3" id="id1">[1]</a>. Assume we have some
well componentized code where classes work against interfaces:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">DoFoo</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">:</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">DoFoo</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Bar</span>
<span class="p">{</span>
    <span class="c1">// Coded against IFoo interface, so decoupled from</span>
    <span class="c1">// concrete Foo implementation</span>
    <span class="k">public</span> <span class="nf">Bar</span><span class="p">(</span><span class="n">IFoo</span> <span class="n">foo</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">foo</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to create an instance of <span class="docutils literal"><span class="pre">Bar</span></span>, we need to pass it some <span class="docutils literal"><span class="pre">IFoo</span></span>
object. We could do it by <span class="docutils literal"><span class="pre">new</span></span>-ing up a <span class="docutils literal"><span class="pre">Foo</span></span> object at the call site of
<span class="docutils literal"><span class="pre">Bar</span></span>’s constructor:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">bar</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">());</span>
</pre></div>
</div>
<p>This doesn’t scale very well though. Most classes require more than one
dependency, so we can’t realistically litter the code with:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">(</span><span class="k">new</span> <span class="n">C</span><span class="p">(),</span> <span class="k">new</span> <span class="n">D</span><span class="p">()),</span> <span class="k">new</span> <span class="n">E</span><span class="p">(</span><span class="k">new</span> <span class="n">D</span><span class="p">()));</span>
</pre></div>
</div>
<p>Factory functions address part of the problem. We can have, for example:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="n">IA</span> <span class="nf">MakeIA</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="p">(</span><span class="n">MakeIB</span><span class="p">(),</span> <span class="n">MakeIE</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another advantage of using factory functions instead of directly calling
constructors is that a factory can encapsulate lifetime of objects. Changing
from a new instance on every call to a singleton can be encapsulated in the
factory so callers of <span class="docutils literal"><span class="pre">MakeIA</span></span> don’t need to change.</p>
<p>We would then call <span class="docutils literal"><span class="pre">MakeIA</span></span> whenever we needed an <span class="docutils literal"><span class="pre">IA</span></span> instance. But where
do these factories belong? They do not belong with the concrete types they are
implementing, because having a static <span class="docutils literal"><span class="pre">MakeIA</span></span> on class <span class="docutils literal"><span class="pre">A</span></span> would still
require callers to reference <span class="docutils literal"><span class="pre">A</span></span> (as in <span class="docutils literal"><span class="pre">A.MakeIA()</span></span>). Since these
factories become the only places in the system where knowledge of which type
resolves to which interface, it makes sense to keep them together:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">class</span> <span class="nc">Factories</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">IA</span> <span class="nf">MakeIA</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="p">(</span><span class="n">MakeIB</span><span class="p">(),</span> <span class="n">MakeIE</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IB</span> <span class="nf">MakeIB</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="p">(</span><span class="n">MakeIC</span><span class="p">(),</span> <span class="n">MakeID</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IC</span> <span class="nf">MakeIC</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">C</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">ID</span> <span class="nf">MakeID</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">D</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">IE</span> <span class="nf">MakeIE</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">E</span><span class="p">(</span><span class="n">MakeID</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works pretty well: changing which concrete type binds to an interface
becomes a changed scoped to one of the factories. But maintaining this by hand
can become tedious. The good news is it can be automated, which is what an IoC
container does.</p>
</div>
<div class="section" id="a-basic-ioc-container">
<h2>A Basic IoC Container</h2>
<p>A very basic container would be able to bind a concrete implementation against
an interface and return an instance of the concrete implementation when asked
for an interface:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The simplest possible thing to pass to <span class="docutils literal"><span class="pre">Register</span></span> is a factory function, in
which case our container would have to maintain a mapping from type to
factory:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">_registeredTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is how it can be used:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">A</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(),</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;()));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">B</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(),</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;()));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">C</span><span class="p">());</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">D</span><span class="p">());</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">E</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;()));</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>This is fine, but still requires a lot of hand-maintenance. One of the main
features of a container is the ability to use reflection and resolve some of
these dependencies automatically. Given a type, we can find its first public
constructor by calling <span class="docutils literal"><span class="pre">GetConstructor</span></span> on it:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">param</span> <span class="k">in</span> <span class="k">typeof</span><span class="p">(</span><span class="n">A</span><span class="p">).</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">().</span><span class="n">GetParameters</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So given a type, we should be able to generate a factory function for it. A
simple way of doing it is by calling <span class="docutils literal"><span class="pre">Invoke</span></span> on the retrieved constructor
and attempting to retrieve all its arguments from the container:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">constructor</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span><span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
            <span class="n">param</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]()</span>
        <span class="p">).</span><span class="n">ToArray</span><span class="p">());</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now registering the interfaces becomes a lot easier:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">B</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">C</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">D</span><span class="p">));</span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">E</span><span class="p">));</span>

<span class="c1">// ...</span>

<span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>It’s usually a good idea to support registration by both type and factory
function, for cases where the construction is more involved or the types of the
constructor arguments, for various reasons, are not registered with the
container.</p>
<div class="section" id="efficient-construction">
<h3>Efficient Construction</h3>
<p>Calling <span class="docutils literal"><span class="pre">Invoke</span></span> on a <span class="docutils literal"><span class="pre">ConstructorInfo</span></span> is notoriously slow <a class="footnote-reference" href="#id4" id="id2">[2]</a>. There are
several strategies to make this invocation faster. One of them is by using
<span class="docutils literal"><span class="pre">System.Linq.Expressions</span></span>, which are a set of types that help declare and
compile lambdas at runtime:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">(</span>
        <span class="n">Expression</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span> <span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
            <span class="n">param</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
                <span class="k">return</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span>
                    <span class="n">Expression</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">Expression</span><span class="p">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">resolve</span><span class="p">.</span><span class="n">Target</span><span class="p">),</span> <span class="n">resolve</span><span class="p">.</span><span class="n">Method</span><span class="p">),</span>
                    <span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">))).</span><span class="n">Compile</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above implementation compiles a lambda which is equivalent to the
<span class="docutils literal"><span class="pre">Invoke</span></span> logic. There are several other techniques to dynamically generate
functions, including <span class="docutils literal"><span class="pre">Reflection.Emit</span></span> and
<span class="docutils literal"><span class="pre">System.Runtime.CompilerServices</span></span>. Another decision point is whether
resolution is done lazily or not. The above implementation is lazy, resolving
each constructor parameter does not require an entry for it in the container
when this particular lambda is compiled. The relevant line is:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
</pre></div>
</div>
<p>If we were to replace this with:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">];</span>
</pre></div>
</div>
<p>it would fail to compile the lambda when registering <span class="docutils literal"><span class="pre">A</span></span> unless all other
dependencies are already in the container. This approach is flexible, in that
type bindings can be resolved at runtime, but can incur a bit more overhead. An
alternative would be to register all types with the container first, then
generate the factories in a separate step. In that case, for each type, we
could map out exactly what calls need to be made to set it up based on
information already available to the container. Such an implementation gets
more complex, so I won’t go into the details, but worth noting that it is
possible.</p>
</div>
</div>
<div class="section" id="lifetimes">
<h2>Lifetimes</h2>
<p>Containers also encapsulate lifetime management. The most basic non-instance
lifetime is singleton, which means a unique instance during the lifetime of the
app. Let’s extend our container to also support resolving singletons. First we
need a way to wrap a factory into a function that only calls it once, then
caches the result:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">private</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">factory</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This relies on <span class="docutils literal"><span class="pre">Lazy</span></span> to ensure uniqueness. Now we can enable singleton
registrations for factories and types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">MarkSingleton</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
<span class="p">{</span>
    <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This effectively decorated the registered factory with the singleton logic.
There are various other lifetimes an object could require, for example:
threaded (where instances are cached per thread, so the same instance is always
returned on the same thread but not across threads), scoped (where there is an
API to mark beginning and end of a scope within which the same instance is
always returned, but another one gets created in another scope) etc.</p>
</div>
<div class="section" id="a-note-on-loading">
<h2>A Note on Loading</h2>
<p>One interesting observation made while profiling a .NET application is that a
container usually forces the loading of all referenced assembly. The .NET
runtime defers assembly loading until a method is called which references a
type in a not-yet-loaded assembly. This forces assembly loading as the runtime
needs the metadata of the type. When using an IoC container, all types are
usually registered as soon as the application boots, in which case all
assemblies get pulled in during registration time (as opposed to on-demand at a
later time).</p>
</div>
<div class="section" id="resources">
<h2>Resources</h2>
<p>The complete source code for the container in this blog post is:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span> <span class="n">_registeredTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">constructor</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span>

        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">(</span>
            <span class="n">Expression</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span> <span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
                <span class="n">param</span> <span class="p">=&gt;</span>
                <span class="p">{</span>
                    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">resolve</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span>
                    <span class="k">return</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span>
                        <span class="n">Expression</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">Expression</span><span class="p">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">resolve</span><span class="p">.</span><span class="n">Target</span><span class="p">),</span> <span class="n">resolve</span><span class="p">.</span><span class="n">Method</span><span class="p">),</span>
                        <span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">))).</span><span class="n">Compile</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">MarkSingleton</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span> <span class="p">=</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">T</span> <span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">factory</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">factory</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>I also recently open-sourced a minimal container <a class="reference external" href="https://github.com/microsoft/minioc">here</a>. That implementation includes support
for scoped lifetimes, but otherwise it is still very minimal. It was used in a
couple of small projects where constraints were around size/dependent assemblies
rather than feature richness.</p>
<p>For a popular open source container with many more features, check out <a class="reference external" href="https://autofac.org/">AutoFac</a>.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>In this post we went over a few IoC container basics:</p>
<ul class="simple">
<li>Motivation for containers.</li>
<li>A primitive container supporting factory registration.</li>
<li>Using reflection to support type registration.</li>
<li>Approaches to implementing constructor calls: <span class="docutils literal"><span class="pre">Inove</span></span>, <span class="docutils literal"><span class="pre">Linq.Expressions</span></span>,
others. Lazy resolution vs. generating constructor calls in a separate step.</li>
<li>Lifetime management and a singleton implementation.</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For a much more detailed treatment, see Martin Fowler’s
<a class="reference external" href="https://www.martinfowler.com/articles/injection.html">article</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>An interesting benchmark on <a class="reference external" href="https://stackoverflow.com/questions/35805609/performance-of-expression-compile-vs-lambda-direct-vs-virtual-calls">Stack Overflow</a></td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sat, 23 Jun 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/04/15/kami-2.html</link>
            <guid>http://vladris.com/blog/2018/04/15/kami-2.html</guid>
            <title><![CDATA[Kami 2]]></title>
            <description><![CDATA[<h1>Kami 2</h1>
<p><a class="reference external" href="https://itunes.apple.com/us/app/kami-2/id1133161444">Kami 2</a> is an iOS game
where the player folds colored paper with the goal of making the whole screen
have the same color. Each level has a set of colors and the player can pick any
of them, color a section, then repeat for a limited number of steps:</p>
<img alt="../../../_images/kami-animation.gif" class="align-center" src="http://vladris.com/blog/_images/kami-animation.gif"/>
<p>Some levels are fairly tricky. For example I got stuck on this one:</p>
<img alt="../../../_images/kami-screenshot.png" class="align-center" src="http://vladris.com/blog/_images/kami-screenshot.png"/>
<p>While the app can provide hints, a more interesting exercise is to see if we can
solve this with an algorithm. We can look at this as a graph problem. Each
colored section represents a node in the graph and we consider adjacent areas as
connected by edges:</p>
<img alt="../../../_images/kami-graph.png" class="align-center" src="http://vladris.com/blog/_images/kami-graph.png"/>
<p>Here is a more abstract representation of the same level:</p>
<img alt="../../../_images/graph.png" class="align-center" src="http://vladris.com/blog/_images/graph.png"/>
<p>The only information we care about is the color of each node and what other
nodes it is connected with.</p>
<p>A step in the game consists of choosing a color, picking a node to get colored
with the chosen colore, then merging the colored node with adjacent nodes of
the same (new) color. The game is won if the nodes get merged down to a single
node within the step limit.</p>
<p>A Python representation of the graph would look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">edges</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
</pre></div>
</div>
<p>We represent nodes as a dictionary where the key is the node id and the value is
the color of the node, and edge as a list of pairs of ids. The level diagramed above would be represented as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="s2">"Red"</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">5</span><span class="p">:</span> <span class="s2">"White"</span><span class="p">,</span>
            <span class="mi">6</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">7</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">8</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">9</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">10</span><span class="p">:</span> <span class="s2">"Red"</span><span class="p">,</span>
            <span class="mi">11</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">12</span><span class="p">:</span> <span class="s2">"White"</span><span class="p">,</span>
            <span class="mi">13</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">14</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
            <span class="mi">15</span><span class="p">:</span> <span class="s2">"White"</span><span class="p">,</span>
            <span class="mi">16</span><span class="p">:</span> <span class="s2">"Yellow"</span><span class="p">,</span>
            <span class="mi">17</span><span class="p">:</span> <span class="s2">"Red"</span><span class="p">,</span>
            <span class="mi">18</span><span class="p">:</span> <span class="s2">"Purple"</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">),</span>
        <span class="p">])</span>
</pre></div>
</div>
<p>We need a function that, for a given node id, enumerates all the connected
nodes. This is a member function of the graph:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>We also need a function that colors a node and merges it with adjacent nodes of
the same color. We can make this function return a new graph instance with the
applied updates. Its signature would be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
</pre></div>
</div>
<p>First it would have to determine the set of nodes that need to be merged after
coloring. That is the node that just got colored and adjacent nodes which have
the same color as its new color. By convention, when we merge nodes we keep the
smallest id:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
<span class="n">to_merge</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">]</span>
<span class="n">new_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">to_merge</span><span class="p">)</span>
</pre></div>
</div>
<p>The nodes of the new graph would be the same nodes as the old one, minus any
node in <span class="docutils literal"><span class="pre">to_merge</span></span>. Nodes in the <span class="docutils literal"><span class="pre">to_merge</span></span> list would be represented by the
node <span class="docutils literal"><span class="pre">new_n</span></span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">new_nodes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">new_n</span><span class="p">:</span> <span class="n">color</span> <span class="p">}</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
        <span class="n">new_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
</pre></div>
</div>
<p>We also need to build the new list of edges. We do this as follows: for each
edge, if both nodes are in <span class="docutils literal"><span class="pre">to_merge</span></span>, the edge does not exist in the new
graph so we discard it. If one node is in <span class="docutils literal"><span class="pre">to_merge</span></span>, we create a new edge
where the node in <span class="docutils literal"><span class="pre">to_merge</span></span> is replaced by <span class="docutils literal"><span class="pre">new_n</span></span>. If none of the nodes
is in <span class="docutils literal"><span class="pre">to_merge</span></span>, we keeep the edge:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">new_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
        <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">new_n</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))))</span>
    <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
        <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_n</span><span class="p">))))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
</pre></div>
</div>
<p>We keep the edge tuples sorted by node id to avoid duplication (for example
having both a <span class="docutils literal"><span class="pre">(1,</span> <span class="pre">3)</span></span> and a <span class="docutils literal"><span class="pre">(3,</span> <span class="pre">1)</span></span>). We return a graph consiting of
<span class="docutils literal"><span class="pre">new_nodes</span></span> and <span class="docutils literal"><span class="pre">new_edges</span></span>. The full implementation of <span class="docutils literal"><span class="pre">color</span></span> is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
    <span class="n">to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="n">to_merge</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">]</span>
    <span class="n">new_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">to_merge</span><span class="p">)</span>

    <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">{</span> <span class="n">new_n</span><span class="p">:</span> <span class="n">color</span> <span class="p">}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
            <span class="n">new_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

    <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span> <span class="ow">and</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
            <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">new_n</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))))</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">to_merge</span><span class="p">:</span>
            <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_n</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">)</span>
</pre></div>
</div>
<p>To solve a level we try coloring all of the nodes then recursively solve for the
new graph. If our graph has one node, we found a solution. If we run out of
steps, our candidate solution is not good so we backtrack:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node</span><span class="p">)]))</span>
        <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">steps</span> <span class="o">+</span> <span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">)],</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <span class="docutils literal"><span class="pre">graph</span></span> is the graph we are trying to solve, <span class="docutils literal"><span class="pre">steps</span></span> is the list of
actions in our solution, consisting of pairs of node id and color, and <span class="docutils literal"><span class="pre">n</span></span> is
the remaining number of steps.</p>
<p>Note that we don’t attempt to color a node with any random color, rather we want
to color it with the color of one of its adjacent nodes. The reason for this is
that such a coloring guarantees <em>some</em> nodes will get merged so we reduce the
total number of nodes with this step. If we were to color a node with a color
none of its adjacent nodes has, there would be nothing to merge so we would
waste a step without reducing the graph.</p>
<p>This solution works but is rather slow. One optimization we can do is to more
aggressively prune our search space: if at any point our graph has more colors
than the number of remaining steps + 1, we know we are down the wrong path and
need to backtrack. As an example, if we have four colors on the board: blue,
red, yellow, white, but we only have 2 steps left, no matter how the areas are
connected, we can never end up with a single color in 2 steps as we need to
recolor 3 areas.</p>
<p>We can implement this optimization by updating the <span class="docutils literal"><span class="pre">Graph</span></span> constructor to
keep track of the number of unique colors and update our <span class="docutils literal"><span class="pre">solve</span></span> function to
backtrack if we have more colors than steps + 1:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">edges</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
</pre></div>
</div>
<p>The update is the last line, which maintains the count of unique values in the
<span class="docutils literal"><span class="pre">nodes</span></span> dictionary. Updated <span class="docutils literal"><span class="pre">solve</span></span> looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">colors</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">node</span><span class="p">)]))</span>
        <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">steps</span> <span class="o">+</span> <span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">color</span><span class="p">)],</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We introduced a new <span class="docutils literal"><span class="pre">if</span></span> statement that returns if <span class="docutils literal"><span class="pre">graph.colors</span> <span class="pre">&gt;</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></span>.</p>
<p>Running this yields the following solution for the level:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">'Purple'</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s1">'White'</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">'Yellow'</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Purple'</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Red'</span><span class="p">)]</span>
</pre></div>
</div>
<p>So coloring node 10 with purple, then node 8 with white and so on solves the
level.</p>
<p>Another potential optimization which I did not implement could improve pruning
further by relying on the fact that coloring a node and merging it with adjacent
nodes removes at most two edges from a path. So if the shortest path between two
nodes in the graph is longer than twice the number of remaining steps, we would
again not be able to find a solution from the current state.</p>
<p>The full source code is available <a class="reference external" href="https://gist.github.com/vladris/c283de5d8a3289303c7aca258e9cbdb1">on GitHub</a>.</p>
]]></description>
             <pubDate>Sun, 15 Apr 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/02/11/fibonacci.html</link>
            <guid>http://vladris.com/blog/2018/02/11/fibonacci.html</guid>
            <title><![CDATA[Fibonacci]]></title>
            <description><![CDATA[<h1>Fibonacci</h1>
<p>This blog post looks at a few algorithms to generate Fibonacci numbers. For a
much better treatment of these algorithms, I recommend <a class="reference external" href="https://www.goodreads.com/book/show/23498372-from-mathematics-to-generic-programming">From Mathematics to
Generic Programming</a>.
The implementations are provided in poorly written Rust, as I’m just
learning the language.</p>
<p>Learning Rust and going through <a class="reference external" href="https://doc.rust-lang.org/book/second-edition/">The Rust Programming Language</a>,
I got to <a class="reference external" href="https://doc.rust-lang.org/book/second-edition/ch03-05-control-flow.html#summary">the end of chapter 3</a>,
where there are a few simple exercises. One of them is <em>Generate the nth
Fibonacci number</em>.</p>
<div class="section" id="the-fibonacci-sequence">
<h2>The Fibonacci Sequence</h2>
<p>The Fibonacci sequence is defined as the sequence <span class="math notranslate">\(F_n = F_{n-1} + F_{n-2}\)</span>
with the seed values <span class="math notranslate">\(F_0 = 0\)</span> and <span class="math notranslate">\(F_1 = 1\)</span>.</p>
<p>The first few values of the sequence are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,
89, 144, ….</p>
</div>
<div class="section" id="a-naive-algorithm">
<h2>A Naïve Algorithm</h2>
<p>Directly translating the definition above into an algorithm to compute the n-th
Fibonacci number yields:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>This algorithm works for very small <span class="docutils literal"><span class="pre">n</span></span> values but it is extremely inefficient
as it has exponential time complexity and linear space complexity (based on
stack depth). Since <span class="docutils literal"><span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">=</span> <span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">+</span> <span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">3)</span></span>, a call like
<span class="docutils literal"><span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">2)</span></span> is equivalent to <span class="docutils literal"><span class="pre">(fib(n</span> <span class="pre">-</span> <span class="pre">2)</span> <span class="pre">+</span> <span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">3))</span> <span class="pre">+</span>
<span class="pre">fib(n</span> <span class="pre">-</span> <span class="pre">2)</span></span>, so the same elements of the sequence end up being computed over
and over again.</p>
</div>
<div class="section" id="bottom-up-approach">
<h2>Bottom-Up Approach</h2>
<p>A better way to generate the nth Fibonacci number is to build it bottom-up,
starting from <span class="math notranslate">\(F_0\)</span> and <span class="math notranslate">\(F_1\)</span>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"/>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"/>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"/>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">b</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>Here we start with <span class="math notranslate">\(a = F_0, b = F_1\)</span> and with each iteration of the loop
we advance from <span class="math notranslate">\(a = F_k, b = F_{k+1}\)</span> to <span class="math notranslate">\(a = F_{k+1}, b = F_{k+2}\)</span>
until <span class="docutils literal"><span class="pre">b</span></span> becomes <span class="math notranslate">\(F_n\)</span>.</p>
<p>Compared to the first algorithm, this is highly efficient, as it has linear
complexity and requires constant space. There are faster ways to compute the nth
Fibonacci number though.</p>
</div>
<div class="section" id="matrix-form">
<h2>Matrix Form</h2>
<p>The Fibonacci sequence can also be described in matrix form as follows:</p>
<div class="math notranslate">
\[\begin{split}\begin{bmatrix}
    F_{k+2} \\
    F_{k+1}
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}
*
\begin{bmatrix}
    F_{k+1} \\
    F_k
\end{bmatrix}\end{split}\]</div>
<p>Note that the next pair of numbers in the sequence, <span class="math notranslate">\(F_{k+3}, F_{k+2}\)</span> can
be expressed as:</p>
<div class="math notranslate">
\[\begin{split}\begin{bmatrix}
    F_{k+3} \\
    F_{k+2}
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}
*
\begin{bmatrix}
    F_{k+2} \\
    F_{k+1}
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}
*
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}
*
\begin{bmatrix}
    F_{k+1} \\
    F_k
\end{bmatrix}\end{split}\]</div>
<p>Thus we have the formula:</p>
<div class="math notranslate">
\[\begin{split}\begin{bmatrix}
    F_n \\
    F_n - 1
\end{bmatrix}
=
\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}^{n-1}
*
\begin{bmatrix}
    F_1 \\
    F_0
\end{bmatrix}\end{split}\]</div>
<p>Since <span class="math notranslate">\(F_0 = 0\)</span> and <span class="math notranslate">\(F_1 = 1\)</span>, <span class="math notranslate">\(F_n\)</span> is the element at index
<span class="math notranslate">\((0, 0)\)</span> in:</p>
<div class="math notranslate">
\[\begin{split}\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}^{n-1}\end{split}\]</div>
<p>Assuming we have a function for exponentiating 2x2 matrices <span class="docutils literal"><span class="pre">exp2x2</span></span>, we can
implement an algorithm to compute the nth Fibonacci number like this:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fib3</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w"/>
<span class="w">    </span><span class="p">];</span><span class="w"/>

<span class="w">    </span><span class="n">exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>The complexity of this algorithm is given by the complexity of <span class="docutils literal"><span class="pre">exp2x2</span></span>. A
simple implementation of matrix exponentiation given a matrix multiplication
function <span class="docutils literal"><span class="pre">mul2x2</span></span> is:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">exp2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"/>
<span class="w">    </span><span class="p">];</span><span class="w"/>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul2x2</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>This function computes <span class="docutils literal"><span class="pre">a^n</span></span> by starting with the identity matrix and
multiplying it with a n times. The function for multiplying two 2x2 matrices is
trivial:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">mul2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="w"/>
<span class="w">    </span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>With <span class="docutils literal"><span class="pre">mul2x2</span></span> and <span class="docutils literal"><span class="pre">exp2x2</span></span>, our <span class="docutils literal"><span class="pre">fib3</span></span> algorithm has linear complexity,
which is determined by the number of times we call <span class="docutils literal"><span class="pre">mul2x2</span></span> in our
exponentiation function. There is a faster way to do exponentiation though:
observe that <span class="math notranslate">\(x^7 = x^4 * x^2 * x\)</span>. In general, any number <span class="docutils literal"><span class="pre">n</span></span> and can
be decomposed as a series of powers of two. So we can implement a
<span class="docutils literal"><span class="pre">fast_exp2x2</span></span> which works as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>if n == 1, return a
if n is even, return fast_exp2x2(a * a, n / 2)
if n is odd, return fast_exp2x2(a * a, (n - 1) / 2) * a
</pre></div>
</div>
<p>We stop when our exponent is 1 and return <span class="docutils literal"><span class="pre">a</span></span>. If <span class="docutils literal"><span class="pre">n</span></span> is even, we square the
base and halve the exponent (for example <span class="math notranslate">\(x^8 = (x*x)^4\)</span>). If <span class="docutils literal"><span class="pre">n</span></span> is
odd, we do the same but multiply by the base (for example <span class="math notranslate">\(x^9 = (x*x)^4 *
x\)</span>). This is a recursive algorithm which halves <span class="docutils literal"><span class="pre">n</span></span> at each step, so we have
logarithmic time and space complexity.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fast_exp2x2</span><span class="p">(</span><span class="n">mul2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"/>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>This is a very efficient way to compute the nth Fibonacci number. But where does
this fast exponentiation algorithm come from?</p>
</div>
<div class="section" id="ancient-egyptian-multiplication">
<h2>Ancient Egyptian Multiplication</h2>
<p>The ancient Egyptian multiplication algorithm comes from the <a class="reference external" href="RhindMathematicalPapyrus">Rhind Papyrus</a>
from around 1500 BC. The idea is very similar to our fast exponentiation
algorithm: we can implement a fast multiplication algorithm by relying on
addition and doubling (eg. <span class="math notranslate">\(x * 7 = x * 4 + x * 2 + x\)</span>).  The steps or our
<span class="docutils literal"><span class="pre">egyptian_mul</span></span> algorithm are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>if n == 1, return a
if n is even, return egyptian_mul(a + a, n / 2)
if n is odd, return egyptian_mul(a + a, (n - 1) / 2) + a
</pre></div>
</div>
<p>An implementation in Rust is:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">egyptian_mul</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">egyptian_mul</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"/>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>This multiplication algorithm relies only on addition, and multiplies <span class="docutils literal"><span class="pre">a</span></span> by
<span class="docutils literal"><span class="pre">n</span></span> in <span class="math notranslate">\(log(n)\)</span> steps.</p>
<p><span class="docutils literal"><span class="pre">egyptian_mul</span></span> and <span class="docutils literal"><span class="pre">fast_exp2x2</span></span> algorithms have the same structure since
they are fundamentally the same: they provide an efficient way to implement an
operation defined as applying another operation n times. Multiplication is, by
definition, repeated addition. Similarly, exponentiation is, by definition,
repeated multiplication. We can generalize these to an algorithm that given an
initial value <span class="docutils literal"><span class="pre">a</span></span> of any type <span class="docutils literal"><span class="pre">T</span></span>, an operation <span class="docutils literal"><span class="pre">op(T,</span> <span class="pre">T)</span> <span class="pre">-&gt;</span> <span class="pre">T</span></span>, and
<span class="docutils literal"><span class="pre">n</span></span>, the number of times to apply <span class="docutils literal"><span class="pre">op</span></span>, provides an efficient computation
using doubling and halving:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">op_n_times</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">op</span>: <span class="kp">&amp;</span><span class="nc">Op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"/>
<span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Copy</span><span class="p">,</span><span class="w"/>
<span class="w">          </span><span class="n">Op</span>: <span class="nb">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op_n_times</span>::<span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>We can express Egyptian multiplication (<span class="docutils literal"><span class="pre">egyptian_mul</span></span>) as addition applied
<span class="docutils literal"><span class="pre">n</span></span> times:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">egyptian_mul</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span>::<span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>Similarly, we can express fast matrix exponentiation (<span class="docutils literal"><span class="pre">fast_exp2x2</span></span>) as matrix
multiplication applied <span class="docutils literal"><span class="pre">n</span></span> times:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mul2x2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
</div>
<div class="section" id="industrial-strength-fibonacci">
<h2>Industrial Strength Fibonacci</h2>
<p>I wanted to benchmark the two interesting implementations: <span class="docutils literal"><span class="pre">fib2</span></span> and
<span class="docutils literal"><span class="pre">fib4</span></span>. The first exponential complexity implementation is highly inefficient
and even for small values of <span class="docutils literal"><span class="pre">N</span></span> (eg. <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">50</span></span>) it takes a long time to
complete. <span class="docutils literal"><span class="pre">fib3</span></span> has linear complexity like <span class="docutils literal"><span class="pre">fib2</span></span>, but while <span class="docutils literal"><span class="pre">fib2</span></span> just
performs additions and assignments on each iteration, <span class="docutils literal"><span class="pre">fib3</span></span> performs matrix
multiplication, which is more expensive. So <span class="docutils literal"><span class="pre">fib2</span></span> and <span class="docutils literal"><span class="pre">fib4</span></span> are more
interesting to look at.</p>
<p>Turns out that the Fibonacci sequence grows quite fast, the 100th Fibonacci
number is <span class="docutils literal"><span class="pre">354224848179261915075</span></span>, which does not fit in an <span class="docutils literal"><span class="pre">i32</span></span>. So let’s
update the implementations to use <span class="docutils literal"><span class="pre">num::BigUint</span></span>, an arbitrary precision
number. First is <span class="docutils literal"><span class="pre">fib2</span></span>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"/>

<span class="k">use</span><span class="w"> </span><span class="n">num</span>::<span class="n">bigint</span>::<span class="p">{</span><span class="n">BigUint</span><span class="p">,</span><span class="w"> </span><span class="n">ToBigUint</span><span class="p">};</span><span class="w"/>

<span class="k">fn</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BigUint</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"/>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span><span class="w"/>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"/>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">b</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">fib4</span></span>, we need to update <span class="docutils literal"><span class="pre">mul2x2</span></span> to work with <span class="docutils literal"><span class="pre">BigUint</span></span> array
references, so we don’t copy <span class="docutils literal"><span class="pre">BigUint</span></span> arrays:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">mul2x2</span><span class="p">(</span><span class="n">a</span>: <span class="kp">&amp;</span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="w"/>
<span class="w">    </span><span class="p">]</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>We also need to update our <span class="docutils literal"><span class="pre">op_n_times</span></span> so the operation now takes <span class="docutils literal"><span class="pre">&amp;T</span></span>
instead of <span class="docutils literal"><span class="pre">T</span></span>. Note this version still works with <span class="docutils literal"><span class="pre">i32</span></span> arrays and numbers,
but now the operation is expected to take two references instead of two values.
On the other hand we no longer require that <span class="docutils literal"><span class="pre">T</span></span> has the <span class="docutils literal"><span class="pre">Copy</span></span> trait:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">op_n_times</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">op</span>: <span class="kp">&amp;</span><span class="nc">Op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"/>
<span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">Op</span>: <span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op_n_times</span>::<span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span><span class="w"/>
<span class="w">    </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="n">result</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>Then we can update our <span class="docutils literal"><span class="pre">fib4</span></span> implementation to use <span class="docutils literal"><span class="pre">BigUint</span></span>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">fn</span> <span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span>: <span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mul2x2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="k">fn</span> <span class="nf">fib4</span><span class="p">(</span><span class="n">n</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BigUint</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"/>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"/>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()],</span><span class="w"/>
<span class="w">        </span><span class="p">[</span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()],</span><span class="w"/>
<span class="w">    </span><span class="p">];</span><span class="w"/>

<span class="w">    </span><span class="n">fast_exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">clone</span><span class="p">()</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>These two implementations work with arbitrarily large numbers, for example
<span class="docutils literal"><span class="pre">fib4(10_000)</span></span> is:</p>
<blockquote style="word-wrap:break-word">
33644764876431783266621612005107543310302148460680063906564769974680081442166662368155595513633734025582065332680836159373734790483865268263040892463056431887354544369559827491606602099884183933864652731300088830269235673613135117579297437854413752130520504347701602264758318906527890855154366159582987279682987510631200575428783453215515103870818298969791613127856265033195487140214287532698187962046936097879900350962302291026368131493195275630227837628441540360584402572114334961180023091208287046088923962328835461505776583271252546093591128203925285393434620904245248929403901706233888991085841065183173360437470737908552631764325733993712871937587746897479926305837065742830161637408969178426378624212835258112820516370298089332099905707920064367426202389783111470054074998459250360633560933883831923386783056136435351892133279732908133732642652633989763922723407882928177953580570993691049175470808931841056146322338217465637321248226383092103297701648054726243842374862411453093812206564914032751086643394517512161526545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562430701794976171121233066073310059947366875
</blockquote><p>We can benchmark these implementations using Rust’s built-in benchmarking:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="cp">#[bench]</span><span class="w"/>
<span class="k">fn</span> <span class="nf">fib4_bench</span><span class="p">(</span><span class="n">b</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">fib4</span><span class="p">(</span><span class="n">N</span><span class="p">));</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="cp">#[bench]</span><span class="w"/>
<span class="k">fn</span> <span class="nf">fib2_bench</span><span class="p">(</span><span class="n">b</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">fib2</span><span class="p">(</span><span class="n">N</span><span class="p">));</span><span class="w"/>
<span class="p">}</span><span class="w"/>
</pre></div>
</div>
<p>On my Surface Book, for <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">100</span></span>, we have:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>test tests::fib2_bench ... bench:       7,805 ns/iter (+/- 3,042)
test tests::fib4_bench ... bench:       6,140 ns/iter (+/- 356)
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1_000</span></span>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>test tests::fib2_bench ... bench:      89,131 ns/iter (+/- 28,346)
test tests::fib4_bench ... bench:      16,307 ns/iter (+/- 2,087)
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">10_000</span></span>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>test tests::fib2_bench ... bench:   2,121,140 ns/iter (+/- 132,448)
test tests::fib4_bench ... bench:     184,625 ns/iter (+/- 12,184)
</pre></div>
</div>
<p>For <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">100_000</span></span>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>test tests::fib2_bench ... bench: 128,769,418 ns/iter (+/- 5,198,789)
test tests::fib4_bench ... bench:   7,176,026 ns/iter (+/- 364,400)
</pre></div>
</div>
<p>While <span class="docutils literal"><span class="pre">fib2</span></span> and <span class="docutils literal"><span class="pre">fib4</span></span> start with about the same performance at
<span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">100</span></span>, for <span class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">100_000</span></span>, <span class="docutils literal"><span class="pre">fib4</span></span> is significantly faster. The
benchmark results don’t seem to reflect the algorithmic complexity of <span class="docutils literal"><span class="pre">fib2</span></span>
(linear) and <span class="docutils literal"><span class="pre">fib4</span></span> (logarithmic), I suspect because of the introduction of
<span class="docutils literal"><span class="pre">BigUint</span></span> and operations on large numbers. Still, the algorithm relying on
fast exponentiation performs many times faster on large Ns.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>This blog post covered:</p>
<ul class="simple">
<li>Algorithms to generate Fibonacci numbers: naïve recursive (exponential),
bottom-up (linear), matrix exponentiation (linear or logarithmic, depending on
the matrix exponentiation algorithm).</li>
<li>Ancient Egyptian multiplication and fast matrix exponentiation are the same
algorithm applied to different operations.</li>
<li>A generic algorithm of efficiently applying an operation n times.</li>
<li>Algorithms to generate Fibonacci numbers implemented with <span class="docutils literal"><span class="pre">BigUint</span></span> for
arbitrary precision numbers.</li>
<li>Benchmarking the <span class="docutils literal"><span class="pre">fib2</span></span> and <span class="docutils literal"><span class="pre">fib4</span></span> algorithms shows <span class="docutils literal"><span class="pre">fib4</span></span> to be much
better as <span class="docutils literal"><span class="pre">N</span></span> increases.</li>
</ul>
<p>My humble conclusion is that generating Fibonacci numbers is more than an
introductory exercise.</p>
</div>
]]></description>
             <pubDate>Sun, 11 Feb 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2018/01/27/notes-on-oop.html</link>
            <guid>http://vladris.com/blog/2018/01/27/notes-on-oop.html</guid>
            <title><![CDATA[Notes on OOP]]></title>
            <description><![CDATA[<h1>Notes on OOP</h1>
<p>I am not a huge fan of “pure” OOP. In this post I will cover a few non-pure OOP
concepts: subtyping wihtout inheritance, mixins, free functions, and types
without invariants. I will make a case for why multi-paradigm is needed and how
using a wider variety of concepts enables us to build simpler systems.</p>
<div class="section" id="duck-typing">
<h2>Duck typing</h2>
<blockquote>
<div>If it walks like a duck and it quacks like a duck, then it must be a duck.</div></blockquote>
<p>Let’s say we have a <span class="docutils literal"><span class="pre">Duck</span></span> class. A <span class="docutils literal"><span class="pre">Duck</span></span> quacks and waddles:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Duck</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Quack</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We have a function that uses a duck:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">Duck</span><span class="o">&amp;</span> <span class="n">duck</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">duck</span><span class="p">.</span><span class="n">Quack</span><span class="p">();</span>
    <span class="n">duck</span><span class="p">.</span><span class="n">Waddle</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The object-oriented way to implement subtyping is to inherit from the base
class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">UglyDuckling</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Duck</span> <span class="p">{</span> <span class="p">};</span>

<span class="c1">// ...</span>

<span class="n">UglyDuckling</span> <span class="n">uglyDuckling</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">uglyDuckling</span><span class="p">);</span>
</pre></div>
</div>
<p>We can call <span class="docutils literal"><span class="pre">foo</span></span> on an <span class="docutils literal"><span class="pre">UglyDuckling</span></span> since <span class="docutils literal"><span class="pre">UglyDuckling</span></span> inherits from
<span class="docutils literal"><span class="pre">Duck</span></span>. We have an <em>is-a</em> relationship, so we can substitute an
<span class="docutils literal"><span class="pre">UglyDuckling</span></span> for a <span class="docutils literal"><span class="pre">Duck</span></span>. The problem with this approach is that whenever
we want something that quacks and waddles, we need to inherit from <span class="docutils literal"><span class="pre">Duck</span></span>.
More generally, this type of polymorphism is achieved by implementing a set of
interfaces like, for example, <span class="docutils literal"><span class="pre">IComparable</span></span>, <span class="docutils literal"><span class="pre">IClonebale</span></span>, <span class="docutils literal"><span class="pre">IDisposable</span></span>
and so on. This makes things slightly complicated: what if we need something
that waddles, but we don’t care about quacking? Do we separate our duck into two
different interfaces? In general, do we add an interface for each behavior and
then pull groups of interfaces together to form more refined types?</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">IQuack</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Quack</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">IWaddle</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Duck</span> <span class="o">:</span> <span class="n">IQuack</span><span class="p">,</span> <span class="n">IWaddle</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Quack</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span> <span class="o">:</span> <span class="n">IWaddle</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This works, but has combinatorial complexity and we end up with deep hierarchies
which are difficult to reason about. There is another way to achieve this
though, using generic programming:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">UglyDuckling</span> <span class="c1">// No inheritance</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Quack</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Waddle</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duck</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">Duck</span><span class="o">&amp;</span> <span class="n">duck</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">duck</span><span class="p">.</span><span class="n">Quack</span><span class="p">();</span>
    <span class="n">duck</span><span class="p">.</span><span class="n">Waddle</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="n">UglyDuckling</span> <span class="n">uglyDuckling</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">uglyDuckling</span><span class="p">);</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">foo</span></span> here is a templated function which only cares that the type passed in
has a <span class="docutils literal"><span class="pre">Quack</span></span> and a <span class="docutils literal"><span class="pre">Waddle</span></span> member function. There is no inheritance
involved, but we can still substitute an <span class="docutils literal"><span class="pre">UglyDuckling</span></span> for a <span class="docutils literal"><span class="pre">Duck</span></span>. This
gets us rid of all the interfaces (we don’t need our <span class="docutils literal"><span class="pre">Penguin</span></span> to explicitly
implement an <span class="docutils literal"><span class="pre">IWaddle</span></span> interface, we just need it to provide a <span class="docutils literal"><span class="pre">Waddle</span></span>
member function). Our model becomes simpler - as long as a type supports the
behavior required by a function, it can be used with that function.</p>
</div>
<div class="section" id="mixins">
<h2>Mixins</h2>
<p>Lore has it that multiple inheritance is bad and it is by design not supported
in Java, C#, and such. On the other hand, mixins are extremely useful, and it
is a pity that we usually have to express them via inheritance. A mixin is a
type that provides some behavior which is <em>mixed in</em> or <em>included</em> into another
type. For example, if we use intrusive reference counting, we can isolate the
reference-counting behavior into its own type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">RefCounted</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">AddRef</span><span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">m_refCount</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Release</span><span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">m_refCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">RefCounted</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_refCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Then we can have other types for which we want intrusive reference counting
simply mixing in this behavior:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RefCounted</span> <span class="p">{</span> <span class="p">};</span>
</pre></div>
</div>
<p>Now <span class="docutils literal"><span class="pre">Foo</span></span> has <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> functions which can be called by a
generic smart pointer that expects managed types to expose these member
functions. While technically <span class="docutils literal"><span class="pre">Foo</span></span> inherits from <span class="docutils literal"><span class="pre">RefCounted</span></span>, conceptually
we only care that it includes the reference counting behavior. In such cases it
is perfectly fine to mix and match and include behavior defined across multiple
other types.</p>
</div>
<div class="section" id="the-case-for-free-functions">
<h2>The Case for Free Functions</h2>
<p>What is the difference between the following two <span class="docutils literal"><span class="pre">Print</span></span> functions?</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Data</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="p">.</span><span class="n">Data</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first is a member function, called with an implicit <span class="docutils literal"><span class="pre">this</span></span> argument which
points to the object instance, while the second is a free function called with
an explicit reference to a <span class="docutils literal"><span class="pre">Foo</span></span> object.</p>
<p>The member function approach leads to bloated objects as whenever we need some
additional processing of the type, we would have to add new member functions.
This contradicts the <em>Single Responsibility Principle</em> which states that each
class should have a single responsibility. Adding member functions like
<span class="docutils literal"><span class="pre">ToString</span></span>, <span class="docutils literal"><span class="pre">Serialize</span></span> etc. needlessly bloats a class.</p>
<p>In general, we only need member functions when these functions access private
members of the type. If <span class="docutils literal"><span class="pre">Data</span></span> was private in the above example, then the
free-function version wouldn’t have worked. As long as we can implement a
function that operates on a type without having to access its private member,
that function should not belong to the type. Depending on the language, we have
several options. We could put such functions in “helper” types:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">FooPrinter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C# provides extension methods as syntax sugar for this, which allow us to call
<span class="docutils literal"><span class="pre">foo.Print()</span></span> even though we implement the <span class="docutils literal"><span class="pre">Print</span></span> function as an extension
method:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">class</span> <span class="nc">FooPrinter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">this</span> <span class="n">Foo</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Still, the simplest thing to do is have a free function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</pre></div>
</div>
<p>Being forced to group everything inside classes yields messy code. Steve Yegge’s
<a class="reference external" href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Kingdom of Nouns</a>
is a classic on the topic.</p>
<div class="section" id="managers-and-utils">
<h3>Managers and Utils</h3>
<p>Because a purely object-oriented language forces developers to think in classes,
we more often than not end up with managers and utility classes, both being
horrible replacements for free-standing functions.</p>
<p>Managers usually show up once we have a nice object model for the problem space
but we need to implement a set of operations on said object model. Managers tend
to be singletons. For example, we have a <cite>Connection</cite> type that models a
connection to a peer:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Connection</span>
<span class="p">{</span>
    <span class="c1">// Open, Close, Send, Receive etc.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We also want someone to open new connections and close all opened connections.
Here is a purely object oriented <span class="docutils literal"><span class="pre">ConnectionManager</span></span>:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">ConnectionManager</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">ConnectionManager</span> <span class="n">_instance</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConnectionManager</span><span class="p">();</span>
    <span class="k">private</span> <span class="nf">ConnectionManager</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">ConnectionManager</span> <span class="nf">GetInstance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_instance</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Connection</span><span class="p">&gt;</span> <span class="n">_connections</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Connection</span><span class="p">&gt;();</span>

    <span class="k">public</span> <span class="n">Connection</span> <span class="nf">Make</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">connection</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Connection</span><span class="p">();</span>
        <span class="n">_connections</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">connection</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">CloseAll</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_connections</span><span class="p">.</span><span class="n">ForEach</span><span class="p">(</span><span class="n">connection</span> <span class="p">=&gt;</span> <span class="n">connection</span><span class="p">.</span><span class="n">Close</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This maintains the list of connections and can close all of them with a call to
<span class="docutils literal"><span class="pre">CloseAll()</span></span>. Besides being verbose to use (<span class="docutils literal"><span class="pre">ConnectionManager.GetInstance().Make()</span></span>, <span class="docutils literal"><span class="pre">ConnectionManager.GetInstance().Close()</span></span>),
this class does not make much sense. A non-OOP implementation would look like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// In .h file</span>
<span class="k">class</span> <span class="nc">Connection</span>
<span class="p">{</span>
    <span class="c1">// Open, Close, Send, Receive etc.</span>
<span class="p">};</span>

<span class="n">Connection</span><span class="o">&amp;</span> <span class="nf">Make</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">CloseAll</span><span class="p">();</span>

<span class="c1">// In .cpp file</span>
<span class="k">namespace</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">connections</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Connection</span><span class="o">&amp;</span> <span class="n">Make</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">connections</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Connection</span><span class="p">{});</span>
    <span class="k">return</span> <span class="n">connections</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">CloseAll</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">connection</span> <span class="p">:</span> <span class="n">connections</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">connection</span><span class="p">.</span><span class="n">Close</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">Make()</span></span> and <span class="docutils literal"><span class="pre">CloseAll()</span></span> do not need to be group in some manager. They can
be free functions living next to the <span class="docutils literal"><span class="pre">Connection</span></span> type, which is the only
context within which they make sense. The list of connections can be stored in a
variable scoped to the implementation .cpp file. “Managers” rarely make sense.</p>
<p>Utility classes are even worse: while a manager is usually tightly coupled to
the type it “manages”, “Utils” classes end up being dumping grounds of functions
that don’t seem to belong anywhere else. The biggest problem is that each of
these functions usually depends on some other component:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">FooUtils</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DoBar</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Dependency on Bar */</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DoBaz</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Dependency on Baz */</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now whoever takes a dependency on <span class="docutils literal"><span class="pre">FooUtils</span></span>, transitively takes a dependency
on both <span class="docutils literal"><span class="pre">Bar</span></span> and <span class="docutils literal"><span class="pre">Baz</span></span> too, even if they only really needed one of them.
If <span class="docutils literal"><span class="pre">DoBar()</span></span> and <span class="docutils literal"><span class="pre">DoBaz()</span></span> were free functions, taking a dependency on
<span class="docutils literal"><span class="pre">DoBar()</span></span> would transitively take a dependency on <span class="docutils literal"><span class="pre">Bar</span></span> only. “Utility”
types make layering a nightmare.</p>
</div>
</div>
<div class="section" id="when-to-use-classes">
<h2>When To Use Classes</h2>
<p>I am a big believer in multi-paradigm. If our only tool is a hammer, we can only
hammer things. While pure functional languages are elegant, they are too far
removed from the machine they run on (for example we can’t implement an in-place
<span class="docutils literal"><span class="pre">reverse</span></span> if all data is immutable). Similarly, if everything is an object, we
end up with too many classes and too many complicated relationships. Procedural
languages usually provide some way to group data via <span class="docutils literal"><span class="pre">struct</span></span> or <span class="docutils literal"><span class="pre">record</span></span>
types, so when are classes useful?</p>
<p>The answer is <em>for encapsulating</em> - classes enable us to declare private data
and control access to it. This is useful when the class needs to maintain
invariants, which could potentially be broken if external entities would be able
to change an object’s state. Let’s use a <span class="docutils literal"><span class="pre">Date</span></span> type as a made up example.
Made up because dates are usually implemented as a number representing a tick
count since some set start date, and information like <em>day</em>, <em>month</em>, and <em>year</em>
is derived from that. But let’s assume we have separate <em>day</em>, <em>month</em>, and
<em>year</em> fields. This type should maintain an invariant that it represents a valid
date, so we can’t have, for example, a June 31st. It’s hard to enforce the
invariant with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Date</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">day</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">month</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">year</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Alternately, we can implement a class with a constructor which ensures only
valid dates can be created:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Date</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Date</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">year</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">month</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">day</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">month</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">month</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="k">throw</span> <span class="cm">/* ... */</span>
        <span class="cm">/* Additional checks to ensure a valid date... */</span>
    <span class="p">}</span>

    <span class="kt">uint8_t</span> <span class="n">year</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_year</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint8_t</span> <span class="n">month</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_month</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint8_t</span> <span class="n">day</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_day</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">uint8_t</span> <span class="n">m_day</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">m_month</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">m_year</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If we want to add an <span class="docutils literal"><span class="pre">AddDays</span></span> function, we would create a member function
<a class="footnote-reference" href="#id2" id="id1">[1]</a> which would implement the algorithm that would know when adding a number of
days would increment the month and when incrementing the month would increment
the year, such that the invariant of always having a valid date is enforced.</p>
<p>On the other hand, a type which doesn’t need to maintain an invariant, say a
point in the plane, should not be implemented as a class:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>Inheritance is rarely warranted, and when used, it should mostly be used in the
context of mixins - with the intention of including behavior rather than
deriving and extending. Interfaces are sometimes useful at a component boundary,
though static, template-based polymorphism is preferred. A good design consists
of a set of independent classes which maintain invariants, and free functions
that operate on them. Structure (or record) types should be used when there is
no invariant to be maintained. Generic functions should be used when algorithms
can be generalized to multiple types as long as they satisfy some requirements
(as in the Duck Typing section above). This encourages reusable code and systems
of loosely-coupled components which can be more easily reasoned about in
isolation and reused when needed.</p>
<ul class="simple">
<li>Generic programming/compile-time polymorphism yields less complex models than
inheritance</li>
<li>While multiple inheritance is frowned upon, mixins provide a great way to add
behavior to a type. The problem is including this behavior is usually
syntactically equivalent with inheritance.</li>
<li>Free functions are great. Managers and Utils are bad and should be avoided.</li>
<li>Classes are useful when invariants need to be enforced. Encapsulation and
member functions maintain invariants.</li>
<li>A good design consists of loosely-coupled components and generic functions,
which can be reasoned about in isolation and freely combined to create complex
behavior.</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Or better yet a free function which takes a <span class="docutils literal"><span class="pre">Date</span></span> and returns a new
instance - immutability seems like a good idea in this case.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sat, 27 Jan 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/12/30/evens-before-odds.html</link>
            <guid>http://vladris.com/blog/2017/12/30/evens-before-odds.html</guid>
            <title><![CDATA[Evens before Odds]]></title>
            <description><![CDATA[<h1>Evens before Odds</h1>
<p>One of my go-to interview questions goes like this:</p>
<blockquote>
<div><p>Given an array of numbers, make it so the even numbers come before the odd
ones.</p>
<p>For example, for <span class="docutils literal"><span class="pre">{</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8</span> <span class="pre">}</span></span>, a possible output would be
<span class="docutils literal"><span class="pre">{</span> <span class="pre">8,</span> <span class="pre">2,</span> <span class="pre">6,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">3,</span> <span class="pre">7,</span> <span class="pre">1</span> <span class="pre">}</span></span>.</p>
</div></blockquote>
<p>This is not a trick question by any means, it is a straightforward problem with
a couple of straightforward solutions. Note the <em>possible output</em> wording and
the fact that evens and odds in the output do not preserve the relative order
they had in the input.</p>
<div class="section" id="a-space-inefficient-solution">
<h2>A Space-Inefficient Solution</h2>
<p>An easy solution is to traverse the input once and store all even numbers
encountered during the traversal into a separate array, then traverse it again
and do the same for the odd numbers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This solves the problem in <span class="docutils literal"><span class="pre">O(n)</span></span> linear time (two traversals of the input
array) and <span class="docutils literal"><span class="pre">O(n)</span></span> linear space - result is as large as input, so additional
space required grows linearly with the size of the input.</p>
<p>There are more efficient way of doing this in linear time and constant space.</p>
</div>
<div class="section" id="two-algorithms">
<h2>Two Algorithms</h2>
<p>There are a couple of ways we can solve this. One algorithm goes like this:</p>
<blockquote>
<div><p>Find the first odd number. Stop if we reached the end of the array.</p>
<p>Find the first event number after that odd number. Stop if we reached the
end of the array.</p>
<p>Swap them.</p>
<p>Repeat.</p>
</div></blockquote>
<p>Our loop invariant is that all numbers before the first odd number (which we
update during each iteration) are already in the right place. With each
iteration, we find another even number that appears after the first odd number
so we swap them, putting the even in the right place. We stop when we run out of
numbers to swap, either odd or even. An implementation of this algorithm looks
like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="c1">// Find first odd number</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="c1">// If we reached the end we're done</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Find the first even number after the first odd one</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">j</span><span class="p">;</span>

        <span class="c1">// If we reached the end we're done</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Swap and continue</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While the algorithm is fairly straight-forward, the devil is in the details - we
need to perform multiple checks to make sure we don’t run off the end of the
array. While interviewing, I’ve seen many bugs come up due to missing some of
these checks.</p>
<p>An interesting observation we can make is that once we found the first pair of
odd and even numbers, after we swap them, the new first odd number is right
after the even we just swapped, so we can hoist the first while statement out of
the main loop - we only need to find the first odd once, then we just increment
after each swap:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="c1">// Find the first odd number</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>

    <span class="c1">// If we reached the end we’re done</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Start after the first odd and until we reach the end</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If it’s an even number</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Swap with the first odd</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="c1">// Increment first odd position</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Another algorithm goes like this:</p>
<blockquote>
<div><p>Find the first odd number.</p>
<p>From the back, find the last even number.</p>
<p>Stop if the first odd number appears after the last even number.</p>
<p>Swap and repeat.</p>
</div></blockquote>
<p>Our loop invariant is that all numbers before the first odd and all numbers
after the last even are already in place. With each iteration, we move the first
odd and last even. We stop when the first odd appears after the last even, which
means all evens appear before the odds. Here is a possible implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="c1">// Find the first odd number</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="c1">// If the first odd occurs after the last even, stop</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Find the last even number</span>
        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="c1">// If the first odd occurs after the last even, stop</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// Swap and continue</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both of the above algorithms solve the problem in linear time and constant
space.</p>
<div class="section" id="test-cases">
<h3>Test Cases</h3>
<p>Some interesting test cases to validate the implementations:</p>
<ul class="simple">
<li>Our example input <span class="docutils literal"><span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8</span> <span class="pre">}</span></span></li>
<li>An empty vector <span class="docutils literal"><span class="pre">{</span> <span class="pre">}</span></span></li>
<li>A vector with a single even number <span class="docutils literal"><span class="pre">{</span> <span class="pre">2</span> <span class="pre">}</span></span></li>
<li>A vector with a single odd number <span class="docutils literal"><span class="pre">{</span> <span class="pre">1</span> <span class="pre">}</span></span></li>
<li>A vector consisting of all even number <span class="docutils literal"><span class="pre">{</span> <span class="pre">2,</span> <span class="pre">4,</span> <span class="pre">6</span> <span class="pre">}</span></span></li>
<li>A vector consisting of all odd numbers <span class="docutils literal"><span class="pre">{</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">5</span> <span class="pre">}</span></span></li>
</ul>
</div>
<div class="section" id="follow-up-odds-before-evens">
<h3>Follow Up: Odds before Evens</h3>
<p>My follow up question is</p>
<blockquote>
<div>What if we also want the ability to put odd numbers before even ones? How
would we extend our code?</div></blockquote>
<p>An answer I’m <strong>not</strong> looking for is <em>we copy/paste the function, rename it to</em>
<span class="docutils literal"><span class="pre">odds_before_evens</span></span> <em>and update the checks</em>.</p>
<p>A clever answer (which I’m also not looking for) is <em>we provide an</em>
<span class="docutils literal"><span class="pre">odds_before_evens</span></span> <em>which internally calls</em> <span class="docutils literal"><span class="pre">evens_before_odds</span></span> <em>, then
reverses the output</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">odds_before_evens</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">evens_before_odds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A common answer is <em>we add a flag</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">evensFirst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">evensFirst</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This kind of works, but the condition becomes very complicated.</p>
</div>
<div class="section" id="follow-up-primes-before-non-primes">
<h3>Follow Up: Primes before Non-Primes</h3>
<p>What if we also want to move prime numbers before non-prime numbers, given some
<span class="docutils literal"><span class="pre">bool</span> <span class="pre">is_prime(int)</span></span> primality-testing function?</p>
<p>We can keep adding flags and extending the <span class="docutils literal"><span class="pre">if</span></span> conditions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">Arrangement</span>
<span class="p">{</span>
    <span class="n">EvensBeforeOdds</span><span class="p">,</span>
    <span class="n">OddsBeforeEvens</span><span class="p">,</span>
    <span class="n">PrimesBeforeNonPrimes</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Arrangement</span> <span class="n">arrangement</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">EvensBeforeOdds</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">OddsBeforeEvens</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">PrimesBeforeNonPrimes</span> <span class="o">&amp;&amp;</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">EvensBeforeOdds</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">OddsBeforeEvens</span> <span class="o">&amp;&amp;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">arrangement</span> <span class="o">==</span> <span class="n">Arrangement</span><span class="o">::</span><span class="n">PrimesBeforeNonPrimes</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_prime</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This doesn’t scale very well though. What we actually want to do here is
abstract away the predicate based on which we move elements around:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">evens_before_odds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">odds_before_evens</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">primes_before_non_primes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">arrange_numbers</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">is_prime</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the algorithm remains the same: we have the exact same steps and loop
invariants, but we can parameterize the condition. With this abstraction, the
code actually becomes smaller and more readable.</p>
<p>This is about as far as I can get during an interview.</p>
</div>
</div>
<div class="section" id="partition">
<h2>Partition</h2>
<p>This is actually a well-known algorithm called a <em>partitioning algorithm</em>. A
partitioning algorithm moves elements that satisfy a predicate before elements
that don’t satisfy it. Let’s start with the above implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">partition</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="o">--</span><span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works for vectors, but what if we want to partition a doubly-linked list?
Can we abstract away the data structure we are partitioning? The answer is
<em>yes</em>. We can use iterators to access the data structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="o">--</span><span class="n">last</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">))</span>
            <span class="o">--</span><span class="n">last</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation is virtually the same. We get rid of <span class="docutils literal"><span class="pre">i</span></span> and <span class="docutils literal"><span class="pre">j</span></span>, as we
are using the iterators provided as arguments for traversal. The implementation
does not increase in complexity, but is now usable beyond vectors. For example
we can now partition a C-style array:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">evens_before_odds</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="useful-return">
<h3>Useful Return</h3>
<p>A useful return for our algorithm is the <em>partition point</em> - the position of the
first element that does not satisfy our predicate. We have this implicitly and
callers might be interested in it. To avoid making callers have to recompute it,
we should return it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

        <span class="o">--</span><span class="n">last</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">))</span>
            <span class="o">--</span><span class="n">last</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For example, <span class="docutils literal"><span class="pre">partition</span></span> is a key ingredient in quicksort:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Comp</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">quick_sort</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Comp</span> <span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Stop if we have no elements or one element</span>
    <span class="k">auto</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Swap pivot with last element</span>
    <span class="k">auto</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="o">--</span><span class="n">last</span><span class="p">);</span>

    <span class="c1">// Partition around pivot</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">comp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// Move pivot back in place</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

    <span class="c1">// Recursively sort left and right sides of the pivot</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>
    <span class="n">quick_sort</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">++</span><span class="n">last</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stl-implementations">
<h3>STL Implementations</h3>
<p>The <span class="docutils literal"><span class="pre">partition</span></span> algorithm we ended up with is fairly efficient, but it’s worth
taking a look at some of the highly-optimized STL implementations. This is the
MSVC STL implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span> <span class="o">++</span><span class="n">first</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="o">--</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">););</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="n">iter_swap</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note this performs the least possible amount of operations. It also seems to
favor <span class="docutils literal"><span class="pre">for</span></span> loops. Contrast this with the LLVM libc++ implementation, which
seems to favor <span class="docutils literal"><span class="pre">while</span></span> loops:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">do</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="o">--</span><span class="n">last</span><span class="p">)</span> <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">));</span>
        <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">);</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iterator-requirements-and-complexity">
<h3>Iterator Requirements and Complexity</h3>
<p>We focused on the second algorithm presented, which finds the first odd, last
even, and swaps them. We had another algorithm which was looking for <em>the first
even after the first odd</em> during each iteration. Let’s provide a generic
implementation for it too:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">);</span> <span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What is the difference?</p>
<p>The difference is that this algorithm only ever increments the iterators. That
means it only requires a <span class="docutils literal"><span class="pre">ForwardIterator</span></span>, as opposed to the other algorithm,
which finds the <em>last even</em> number starting from the <span class="docutils literal"><span class="pre">last</span></span> iterator, which
requires a <span class="docutils literal"><span class="pre">BidirectionalIterator</span></span>.</p>
<p>In other words, the algorithm requiring only a <span class="docutils literal"><span class="pre">ForwardIterator</span></span> works on a
singly-linked list (<span class="docutils literal"><span class="pre">forward_list</span></span>), while the other one can’t (we can only
traverse a singly-linked list forward in <span class="docutils literal"><span class="pre">O(1)</span></span> time, not backwards).</p>
<p>The MSVC STL implementation of the forward-iterator algorithm is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">);</span> <span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
            <span class="n">iter_swap</span><span class="p">(</span><span class="n">first</span><span class="o">++</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The libc++ one is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">,</span> <span class="n">tpyename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">partition</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">))</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="o">++</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">It</span> <span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="o">++</span><span class="n">next</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The reason both implementations are provided is that the <span class="docutils literal"><span class="pre">ForwardIterator</span></span>
version, while more generally applicable, is slightly less efficient. The
<span class="docutils literal"><span class="pre">BidirectionalIterator</span></span> version moves any element at most once, and since the
move is a swap, it means it performs at most <span class="docutils literal"><span class="pre">N</span> <span class="pre">/</span> <span class="pre">2</span></span> swaps where <span class="docutils literal"><span class="pre">N</span></span> is the
number of elements. The <span class="docutils literal"><span class="pre">ForwardIterator</span></span> version might perform more swaps, up
to <span class="docutils literal"><span class="pre">N</span></span>. For example, for the input <span class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">4</span></span>, during the first step, it would
swap <span class="docutils literal"><span class="pre">1</span></span> with <span class="docutils literal"><span class="pre">2</span></span>, ending up with <span class="docutils literal"><span class="pre">2</span> <span class="pre">1</span> <span class="pre">4</span></span>, then during the next step it
would swap <span class="docutils literal"><span class="pre">1</span></span> with <span class="docutils literal"><span class="pre">4</span></span>, ending up with <span class="docutils literal"><span class="pre">2</span> <span class="pre">4</span> <span class="pre">1</span></span>.</p>
</div>
</div>
<div class="section" id="in-c">
<h2>In C#</h2>
<p>Partitioning is not specific to the C++ language. The same implementation can be
used, for example, in C#, up to abstracting away data structure traversal:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">IListPartition</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">Partition</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">self</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">pred</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">last</span> <span class="p">=</span> <span class="n">self</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(;;)</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="p">!=</span> <span class="n">last</span> <span class="p">&amp;&amp;</span> <span class="n">pred</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">]))</span>
                <span class="p">++</span><span class="n">first</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="p">==</span> <span class="n">last</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

            <span class="p">--</span><span class="n">last</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="p">!=</span> <span class="n">last</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">pred</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">]))</span>
                <span class="p">--</span><span class="n">last</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="p">==</span> <span class="n">last</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">first</span><span class="p">;</span>

            <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">];</span>
            <span class="n">self</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="p">=</span> <span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">];</span>
            <span class="n">self</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The .NET <span class="docutils literal"><span class="pre">IEnumerator</span></span> does not allow us to mutate the data structure we are
enumerating over, so we cannot provide a generic <span class="docutils literal"><span class="pre">IEnumerable&lt;T&gt;</span></span> partition
algorithm that works in-place. Otherwise the implementation is pretty much
identical to the C++ one, as the algorithm is the same.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Moving even numbers before odd ones in a given array of numbers is an instance
of partition.</li>
<li>The algorithm can be generalized to work with an arbitrary predicate.</li>
<li>The algorithm can be generalized to work across any data structure as long as
it can be traversed with at least a <span class="docutils literal"><span class="pre">ForwardIterator</span></span>.</li>
<li>A <span class="docutils literal"><span class="pre">BidirectionalIterator</span></span> version performs at most <span class="docutils literal"><span class="pre">N</span> <span class="pre">/</span> <span class="pre">2</span></span> swaps (and
<span class="docutils literal"><span class="pre">N</span></span> applications of the predicate).</li>
<li>A <span class="docutils literal"><span class="pre">ForwardIterator</span></span> version performs at most <span class="docutils literal"><span class="pre">N</span></span> swaps (and <span class="docutils literal"><span class="pre">N</span></span>
applications of the predicate).</li>
<li>Both versions of the algorithm are part of the standard library
(<span class="docutils literal"><span class="pre">std::partition</span></span> algorithm).</li>
<li>The same algorithm can be implemented in other languages, as generic as the
available abstractions allow.</li>
</ul>
</div>
]]></description>
             <pubDate>Sat, 30 Dec 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/12/10/binary-relations.html</link>
            <guid>http://vladris.com/blog/2017/12/10/binary-relations.html</guid>
            <title><![CDATA[Binary Relations]]></title>
            <description><![CDATA[<h1>Binary Relations</h1>
<div class="section" id="definitions">
<h2>Definitions</h2>
<p>Given a set of objects <span class="docutils literal"><span class="pre">A</span></span>, a binary relation <span class="docutils literal"><span class="pre">R</span></span> on the set is defined as a
subset of <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">A</span></span>. The <em>characteristic function</em> <span class="docutils literal"><span class="pre">r</span></span> for <span class="docutils literal"><span class="pre">R</span></span> is the
function <span class="docutils literal"><span class="pre">r</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span> such that <span class="docutils literal"><span class="pre">r(x,</span> <span class="pre">y)</span></span> is <span class="docutils literal"><span class="pre">true</span></span> if
<span class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">in</span> <span class="pre">R</span></span>, and <span class="docutils literal"><span class="pre">false</span></span> if <span class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">R</span></span>. For a more natural
notation, we can use <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span> to denote <span class="docutils literal"><span class="pre">r(x,</span> <span class="pre">y)</span></span>.</p>
<p>More generally, a binary relation can be defined on a pair of sets <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">B</span></span> but
to keep things simple, we’ll only cover binary relations over a single set.</p>
<p>Binary relations may have several properties. A few interesting ones are:</p>
<ul class="simple">
<li>A binary relation is <em>reflexive</em> if for any <span class="docutils literal"><span class="pre">x</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span></li>
<li>A binary relation is <em>strict</em> or <em>irreflexive</em> if there is no <span class="docutils literal"><span class="pre">x</span></span> in <span class="docutils literal"><span class="pre">A</span></span>
for which <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span></li>
<li>A binary relation is <em>symmetric</em> if for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>
implies <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span></li>
<li>A binary relation is <em>antisymmetric</em> if for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>
and <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span> implies <span class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></span></li>
<li>A binary relation is <em>transitive</em> if for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, if
<span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span> and <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">z</span></span>, then <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">z</span></span></li>
<li>A binary relation is <em>total</em> if for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, either <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>,
<span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span>, or both (in other words, for any <span class="docutils literal"><span class="pre">x,</span> <span class="pre">y</span></span>, <span class="docutils literal"><span class="pre">~</span></span> imposes some
relation between them)</li>
</ul>
<div class="section" id="examples">
<h3>Examples</h3>
<p>The relation <em>is in the subtree rooted at</em> is a reflexive relation where <span class="docutils literal"><span class="pre">A</span></span>
is the set of nodes of a tree. For any pair of nodes <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span>, we can
establish whether <span class="docutils literal"><span class="pre">x</span></span> is in the subtree rooted at <span class="docutils literal"><span class="pre">y</span></span> or not, and for any
<span class="docutils literal"><span class="pre">x</span></span>, <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span> is <span class="docutils literal"><span class="pre">true</span></span>.</p>
<p>The relation <em>is parent of</em> in a tree is a strict relation: for any <span class="docutils literal"><span class="pre">x</span></span> in the
set of tree nodes <span class="docutils literal"><span class="pre">A</span></span>, <span class="docutils literal"><span class="pre">x</span></span> cannot be a parent of itself.</p>
<p>The relation <em>edge between</em> over the vertices of a non-directed graph is a
symmetric relation: for any <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span> vertices of the graph, if there is
an edge from <span class="docutils literal"><span class="pre">x</span></span> to <span class="docutils literal"><span class="pre">y</span></span>, the same edge exists from <span class="docutils literal"><span class="pre">y</span></span> to <span class="docutils literal"><span class="pre">x</span></span>, in other
words, if <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span> then <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span>.</p>
<p>The <em>is in the subtree rooted at</em> relation above is also antisymmetric: if for
a pair of nodes we can say <span class="docutils literal"><span class="pre">x</span></span> is in the subtree rooted at <span class="docutils literal"><span class="pre">y</span></span> and also
<span class="docutils literal"><span class="pre">y</span></span> is in the subtree rooted at <span class="docutils literal"><span class="pre">x</span></span>, it’s obvious that both <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span>
are, in fact, the root of the subtree, thus <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>.</p>
<p>The relation <em>is reachable from</em> over the vertices of a directed graph is a
transitive relation: if <span class="docutils literal"><span class="pre">x</span></span> is reachable from <span class="docutils literal"><span class="pre">y</span></span> and <span class="docutils literal"><span class="pre">y</span></span> is reachable
from <span class="docutils literal"><span class="pre">z</span></span>, then <span class="docutils literal"><span class="pre">x</span></span> is reachable from <span class="docutils literal"><span class="pre">z</span></span>.</p>
<p>All of the above examples are of total relations. An example of a non-total
relation is <em>is ancestor of</em> in a tree. <span class="docutils literal"><span class="pre">x</span></span> can be an ancestor of <span class="docutils literal"><span class="pre">y</span></span>, in
which case <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>, or <span class="docutils literal"><span class="pre">y</span></span> can be an ancestor of <span class="docutils literal"><span class="pre">x</span></span>, in which case
<span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span>, but it could also be that <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span> are in different subtrees,
so neither <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span> nor <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span> holds.</p>
</div>
</div>
<div class="section" id="preorder">
<h2>Preorder</h2>
<p>A <em>preorder</em> is a relation which is reflexive and transitive.</p>
<p>A preorder which is also symmetric is an <em>equivalence</em>. A preorder which is
antisymmetric is a <em>partial order</em>. More on those below.</p>
<p>An example of preorder is the <em>is reachable from</em> relation over a directed
graph in the example above. This relation is obviously reflexive and transitive,
but it is neither symmetric nor antisymmetric. If <span class="docutils literal"><span class="pre">x</span></span> is reachable from <span class="docutils literal"><span class="pre">y</span></span>,
it doesn’t mean that <span class="docutils literal"><span class="pre">y</span></span> is reachable from <span class="docutils literal"><span class="pre">x</span></span>, so symmetry is not
guaranteed. Similarly, if <span class="docutils literal"><span class="pre">x</span></span> is reachable from <span class="docutils literal"><span class="pre">y</span></span> and <span class="docutils literal"><span class="pre">y</span></span> is reachable
from <span class="docutils literal"><span class="pre">x</span></span>, it does not mean that <span class="docutils literal"><span class="pre">y</span></span> equals <span class="docutils literal"><span class="pre">x</span></span>.</p>
</div>
<div class="section" id="equivalence-and-equality">
<h2>Equivalence and Equality</h2>
<p>An <em>equivalence</em> relation <span class="docutils literal"><span class="pre">~</span></span> is a binary relation that is reflexive,
symmetric, and transitive. In other words, it is a preorder which also has the
symmetric property.</p>
<p>Such a relation partitions the set over which it is
defined into <em>equivalence classes</em> - groups of objects that are equivalent
based on the relation.</p>
<p>An example of equivalence is <em>same month</em> over a set of dates. This relation
is reflexive, since a date <span class="docutils literal"><span class="pre">d</span></span> has the same month as itself (<span class="docutils literal"><span class="pre">d</span> <span class="pre">~</span> <span class="pre">d</span></span>); is
symmetric, since if <span class="docutils literal"><span class="pre">d1</span></span> has the same month as <span class="docutils literal"><span class="pre">d2</span></span>, then <span class="docutils literal"><span class="pre">d2</span></span> has the
same month as <span class="docutils literal"><span class="pre">d1</span></span> (<span class="docutils literal"><span class="pre">d1</span> <span class="pre">~</span> <span class="pre">d2</span> <span class="pre">=&gt;</span> <span class="pre">d2</span> <span class="pre">~</span> <span class="pre">d1</span></span>); and transitive, since if <span class="docutils literal"><span class="pre">d1</span> <span class="pre">~</span>
<span class="pre">d2</span> <span class="pre">and</span> <span class="pre">d2</span> <span class="pre">~</span> <span class="pre">d3</span> <span class="pre">=&gt;</span> <span class="pre">d1</span> <span class="pre">~</span> <span class="pre">d3</span></span>.</p>
<p>This relation partitions our set of dates in the equivalence classes
corresponding to <em>dates in January</em>, <em>dates in February</em>, and so on. Note that
the dates for which the relation holds are equivalent, but not necessarily equal.</p>
<p>An <em>equality</em> relation is an equivalence relation which partitions the set <span class="docutils literal"><span class="pre">A</span></span>
consisting of <span class="docutils literal"><span class="pre">n</span></span> objects into exactly <span class="docutils literal"><span class="pre">n</span></span> equivalence classes. In other
words, for any <span class="docutils literal"><span class="pre">x</span></span> in <span class="docutils literal"><span class="pre">A</span></span>, only <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span> is <span class="docutils literal"><span class="pre">true</span></span>.</p>
</div>
<div class="section" id="partial-order-and-total-order">
<h2>Partial Order and Total Order</h2>
<p>A <em>partial order</em> relation <span class="docutils literal"><span class="pre">&lt;=</span></span> is a binary relation that is reflexive,
antisymmetric, and transitive. In other words, it is a preorder which also has
the antisymmetric property.</p>
<p>An example of a partial order is the <em>is subset of</em> relation. It is reflexive
(<span class="docutils literal"><span class="pre">A</span></span> is a subset of <span class="docutils literal"><span class="pre">A</span></span>), antisymmetric (if <span class="docutils literal"><span class="pre">A</span></span> is a subset of <span class="docutils literal"><span class="pre">B</span></span> and
<span class="docutils literal"><span class="pre">B</span></span> is a subset of <span class="docutils literal"><span class="pre">A</span></span>, then <span class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">B</span></span>), and transitive (if <span class="docutils literal"><span class="pre">A</span></span> is a
subset of <span class="docutils literal"><span class="pre">B</span></span> and <span class="docutils literal"><span class="pre">B</span></span> is a subset of <span class="docutils literal"><span class="pre">C</span></span>, then <span class="docutils literal"><span class="pre">A</span></span> is a subset of
<span class="docutils literal"><span class="pre">C</span></span>).</p>
<p>A <em>total order</em> relation is a partial order that is also total. The above
example relation <em>is subset of</em> is not total - there could be a pair of sets
<span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> such that neither is the subset of the other.</p>
<p>An example of a total order relation is <em>less than or equal to</em> for integers.</p>
</div>
<div class="section" id="weak-order-and-strict-weak-order">
<h2>Weak Order and Strict Weak Order</h2>
<p>A <em>weak order</em> relation <span class="docutils literal"><span class="pre">~</span></span> is a binary relation that is transitive and total.
This implies reflexivity (for any <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">y</span></span>, either <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">y</span></span>, <span class="docutils literal"><span class="pre">y</span> <span class="pre">~</span> <span class="pre">x</span></span>,
or both, so for <span class="docutils literal"><span class="pre">x</span></span> and <span class="docutils literal"><span class="pre">x</span></span> we have <span class="docutils literal"><span class="pre">x</span> <span class="pre">~</span> <span class="pre">x</span></span>). In other words, it is a
preorder which is also total.</p>
<p>An example of a weak order is <em>less than or equal absolute value</em> for complex
numbers. For any two complex numbers <span class="docutils literal"><span class="pre">c1</span></span> and <span class="docutils literal"><span class="pre">c2</span></span>, either <span class="docutils literal"><span class="pre">c1</span> <span class="pre">~</span> <span class="pre">c2</span></span> (
<span class="docutils literal"><span class="pre">|c1|</span> <span class="pre">&lt;=</span> <span class="pre">|c2|</span></span>), <span class="docutils literal"><span class="pre">c2</span> <span class="pre">~</span> <span class="pre">c1</span></span> (<span class="docutils literal"><span class="pre">|c2|</span> <span class="pre">&lt;=</span> <span class="pre">|c1|</span></span>), or both, so <span class="docutils literal"><span class="pre">~</span></span> is total.
We also have <span class="docutils literal"><span class="pre">c1</span> <span class="pre">~</span> <span class="pre">c2</span></span> and <span class="docutils literal"><span class="pre">c2</span> <span class="pre">~</span> <span class="pre">c3</span></span> implies <span class="docutils literal"><span class="pre">c1</span> <span class="pre">~</span> <span class="pre">c3</span></span> (<span class="docutils literal"><span class="pre">|c1|</span> <span class="pre">&lt;=</span> <span class="pre">|c2|</span></span>
and <span class="docutils literal"><span class="pre">|c2|</span> <span class="pre">&lt;=</span> <span class="pre">|c3|</span></span> implies <span class="docutils literal"><span class="pre">|c1|</span> <span class="pre">&lt;=</span> <span class="pre">|c3|</span></span>). Unlike a total order though, the
relation is not antisymmetric. We can have <span class="docutils literal"><span class="pre">c1</span> <span class="pre">~</span> <span class="pre">c2</span></span>, <span class="docutils literal"><span class="pre">c2</span> <span class="pre">~</span> <span class="pre">c1</span></span>, with
<span class="docutils literal"><span class="pre">c1</span></span> and <span class="docutils literal"><span class="pre">c2</span></span> distinct complex numbers (any two numbers with the same
absolute value but different components).</p>
<p>A <em>strict weak order</em> relation <span class="docutils literal"><span class="pre">&lt;</span></span> is a binary relation that is transitive and
strict (irreflexive).</p>
<p>An example of strict weak order is <em>less than</em> for integers.</p>
</div>
<div class="section" id="applications">
<h2>Applications</h2>
<p>Most programming languages provide a way to customize equality, inequality, and
comparison operators (<span class="docutils literal"><span class="pre">==</span></span>, <span class="docutils literal"><span class="pre">!=</span></span>, <span class="docutils literal"><span class="pre">&lt;</span></span>, <span class="docutils literal"><span class="pre">&lt;=</span></span>, <span class="docutils literal"><span class="pre">&gt;</span></span>, <span class="docutils literal"><span class="pre">&gt;=</span></span>). There is an
interesting point to be made about what equality <em>means</em> in this context. For
some types, this can simply mean comparing the bits and if they are the same,
the objects are equal. But we also have <em>logical equality</em> - two objects can
have different bitwise values but still be considered equal. Even more so for
comparing objects - comparing bit representations usually does not translate to
a meaningful comparison of objects.</p>
<p>Note though that any other function <span class="docutils literal"><span class="pre">bool</span> <span class="pre">r(const</span> <span class="pre">T&amp;</span> <span class="pre">m1,</span> <span class="pre">const</span> <span class="pre">T&amp;</span> <span class="pre">m2)</span></span> or
member function <span class="docutils literal"><span class="pre">bool</span> <span class="pre">r(const</span> <span class="pre">T&amp;</span> <span class="pre">other)</span></span> of <span class="docutils literal"><span class="pre">T</span></span> denotes a binary relation
on <span class="docutils literal"><span class="pre">T</span></span>.</p>
<p>Different algorithms require different types of relations to exist between
objects.</p>
<p>For example, we need at least a partial order relation to perform a topological
sort. That is, in an directed acyclic graph, we can sort the vertices such that
for every edge from <span class="docutils literal"><span class="pre">a</span></span> to <span class="docutils literal"><span class="pre">b</span></span>, <span class="docutils literal"><span class="pre">a</span></span> precedes <span class="docutils literal"><span class="pre">b</span></span> in the order. This can
be used, for example, on the dependency graph in a makefile to determine how to
sequence work.</p>
<p>Having an equivalence relation (eg. <span class="docutils literal"><span class="pre">==</span></span>), we can implement a linear search
algorithm to traverse a data structure and find an object equivalent to a given
object. The C++ standard library algorithm <span class="docutils literal"><span class="pre">find</span></span> is an example of such an
algorithm.</p>
<p>Having a total order relation (eg. <span class="docutils literal"><span class="pre">&lt;=</span></span>) or a strict weak order (eg. <span class="docutils literal"><span class="pre">&lt;</span></span>),
allows us to implement binary search over an ordered set of objects. A total
order or strict weak order relation also enables comparison sort algorithms.</p>
<p>Similarly, we need a total oreder or strict weak order to be able to determine a
minimum or a maximum element from a set of objects (<span class="docutils literal"><span class="pre">min_element</span></span> and
<span class="docutils literal"><span class="pre">max_element</span></span> algorithms in C++).</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>A binary relation <span class="docutils literal"><span class="pre">R</span></span> on a set <span class="docutils literal"><span class="pre">A</span></span> is a subset of <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">A</span></span>, denoted by a
characterisitc function <span class="docutils literal"><span class="pre">r</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">x</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span>.</li>
<li>A binary relation on a type <span class="docutils literal"><span class="pre">T</span></span> is denoted by either a free function of the
the form <span class="docutils literal"><span class="pre">bool</span> <span class="pre">r(const</span> <span class="pre">T&amp;,</span> <span class="pre">const</span> <span class="pre">T&amp;)</span></span> or a member function <span class="docutils literal"><span class="pre">bool</span>
<span class="pre">r(const</span> <span class="pre">T&amp;)</span></span>.</li>
<li>A binary relations may have several properties: it can be reflexive or strict,
symmetric or antisymmetric, transitive, total etc.</li>
<li>Depending on the properties it has, a relation can be, for example:<ul>
<li>A preorder (reflexive and transitive)</li>
<li>An equivalence (reflexive, symmetric, and transitive)</li>
<li>A partial order (reflexive, antisymmetric, and transitive)</li>
<li>A weak order (reflexive, transitive, and total)</li>
<li>A strict weak order (irreflexive, transitive, and total)</li>
</ul>
</li>
<li>Certain algorithms require the types they operate on to have relations with
certain properties.</li>
</ul>
</div>
]]></description>
             <pubDate>Sun, 10 Dec 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/11/09/notes-on-unit-testing.html</link>
            <guid>http://vladris.com/blog/2017/11/09/notes-on-unit-testing.html</guid>
            <title><![CDATA[Notes on Unit Testing]]></title>
            <description><![CDATA[<h1>Notes on Unit Testing</h1>
<p>This post covers my view on unit testing, why they are important, how to make
time for them, how much to test, and why I don’t believe in TDD. It draws from
my personal experience working on multiple software projects, small and large,
both on new code and legacy code, practices I tried to apply, what worked
well and not so well. While it is more highlevel and I do not provide code
snippets, this is by no means a purely theoretical essay.</p>
<div class="section" id="the-not-enough-time-fallacy">
<h2>The “not enough time” fallacy</h2>
<p>Engineers and engineering teams who are not “bought” on unit testing use the
excuse that there is not enough time to write unit tests. There is always a
deadline or pressure to ship and unit tests, not being “product” code, get lower
priority.</p>
<p>The problem is that we never get it right the first time - as we get a better
understanding of our problem space, we need to refine our solution, which
includes refactoring to better structure the code and redesign to accommodate
for new requirements. This is where unit tests become invaluable in ensuring
that such radical alterations of the codebase can be made safely and easily.</p>
<p>What I noticed first hand is that a team who is not disciplined about testing
starts by churning out a significant amount of code but over surprisingly little
time development slows down to a crawl because there is a lot of manual testing
involved in validating any change, nasty bugs come up, and since refactoring is
now scary (who knows what will break?), engineering debt keeps building up. On
the other hand, teams that author unit tests from the very beginning can
maintain a steady development pace indefinitely.</p>
<p>The funny thing is that engineers who worked in a code base with good test
coverage could never go back - they immediately see the benefits and are sold on
the practice - while engineers who haven’t done it know the theory, pay lip
service to it, but never have time to actually implement tests.</p>
</div>
<div class="section" id="making-time">
<h2>Making time</h2>
<p>There is, unfortunately, never enough time to do the right thing. My advice is
to make time: unit tests are part of feature development, so they should be
accounted for as such. Do not have separate tasks for implementing the feature
and writing the unit tests - these unit testing tasks are prime candidates to be
deprioritized and cut, after all, the feature <em>works</em>, right? Instead consider
testing as part of implementation, create a single task, and adjust estimates
accordingly. There is always pressure to ship, the job of a good engineer is to
not cave under this pressure, set expectations, and deliver a robust solution.
As mentioned above, the ability to keep a steady development pace makes the
average cost of authoring tests over time seem like nothing compared to the
alternative - a steady drop in development agility.</p>
<p>Advice to managers is to encourage a culture of quality and best practices.
Strategically, shipping next week vs the week after is not as important as
shipping in a couple of months vs shipping in a year, which is where the
brittleness of the codebase becomes a major factor. Reward good engineering
practices and you end up with well-engineered code.</p>
<p>That being, sometimes we <em>do</em> need to ship next week.</p>
</div>
<div class="section" id="mqs">
<h2>MQs</h2>
<p>In the old waterfall development days, we had several major milestones, each
spanning months of development: M1, M2 etc. As ship date came near, pressure
increased, and shortcuts were taken more often. In the end, ship dates were met,
but with a lot of compromises. What followed right after, when the team was
burned out after the final stretch, was the so call “quality milestone” or MQ.
Here, engineers were free to reduce debt while project managers went to define
the future version of the product.</p>
<p>I personally love the concept of MQ. While I don’t doubt the existence of
<em>purely agile</em> teams where everything is delivered after week-long sprints with
high quality, most businesses make promises to customers and must meet
deadlines. Sometimes the pressure increases enough that we knowingly take
engineering shortcuts:</p>
<blockquote>
<div><p>If I had a week, I’d do it the right way, but this works for now. I’ll come
back and fix it later.</p>
<p><em>- Every programmer in the world at some point</em></p>
</div></blockquote>
<p>After a hard deadline it’s the perfect time to schedule a mini-MQ - spend a week
or two recovering from burnout and reducing debt.</p>
<p>This expands beyond unit tests to things like refactoring and rearchitecting
code, automating manual processes, writing documentation etc.</p>
</div>
<div class="section" id="the-test-driven-development-fallacy">
<h2>The Test-Driven Development fallacy</h2>
<p>The other extreme is test-driven development. The premise of test-driven
development is that turning requirements into unit tests, then writing code to
make those tests pass is a solid approach to engineering. This sounds great in
theory but falls flat in practice.</p>
<p>Good software is correct, efficient, and maintainable. These qualities come from
a good understanding of the problem being solved and a thought-through solution,
not by making a set of test cases pass. An anecdote I like to reference when
discussing this is the Sudoku solver. Ron Jeffries, one of the founders of
extreme programming, wrote several blog posts in which he attempted to implement
a Sudoku solver using test-driven development <a class="reference external" href="http://xprogramming.com/articles/sudokumusings">here</a>,
<a class="reference external" href="http://xprogramming.com/articles/oksudoku">here</a>, <a class="reference external" href="http://xprogramming.com/articles/sudoku2">here</a>,
<a class="reference external" href="http://xprogramming.com/articles/sudoku4">here</a>, <a class="reference external" href="http://xprogramming.com/articles/sudoku5">here</a>,
and <a class="reference external" href="http://xprogramming.com/articles/roroncemore/">here</a>. The attempt failed.
Around the same time, Peter Norvig implemented a Sudoku solver and wrote a <a class="reference external" href="http://norvig.com/sudoku.html">blog
post</a> with a beautiful explanation of a
thorough approach to analyzing the problem and coming up with a good algorithm
to solve it. The point here is that a set of unit tests, no matter how
comprehensive, will not design an algorithm for you. The algorithm comes from
stepping back and thinking about the problem, which a test-centric approach
actively discourages.</p>
<p>The one good thing that TDD encourages is writing tests which initially fail,
then providing the implementation to make them pass, which ensures the tests
themselves are correct. We can always create a test that exercises a function
and then asserts a tautology (<span class="docutils literal"><span class="pre">Assert.IsTrue(true)</span></span>), which covers the code,
makes the test pass, but provides zero value. Having a test that fails when
invoked with a stub and passes when invoked with the real implementation avoids
this issue.</p>
</div>
<div class="section" id="tests-are-about-behavior-not-design">
<h2>Tests are about behavior, not design</h2>
<p>Almost forgotten across the industry nowadays is that software can be formally
proven correct. A given number of passing tests can only guarantee that for that
particular set of inputs, we get the expected output - which, in case of test
bugs, might not mean anything. The way to be 100% confident that the code does
what we think it does is to prove this fact formally. This is not always
feasible at scale, but for critical pieces of functionality, formalism is better
than test cases.</p>
<p>That doesn’t mean tests are not needed - as soon as a line of code changes (bug
fix, optimization, etc.), the formalism must be re-evaluated, and, outside
fringe programming languages, we can’t automatically detect when a proof no
longer holds. The point is that tests are about behavior not about design - we
design to solve the problem, we test to make sure that our solution does what we
expect it to do. <strong>Design comes first, tests come second, implementation is
third.</strong></p>
<p>Unit tests become valuable when we can make deep changes within our code and
ensure there is no observable change in output. This is invaluable to
engineering velocity.</p>
</div>
<div class="section" id="how-much-is-enough">
<h2>How much is enough?</h2>
<p>In terms of code coverage, I believe something around 90% can easily be achieved
with a minimum of effort. Full coverage is unrealistic because the code always
has some interaction with the world - making network calls, relying on time,
random numbers, IO etc. These are all interactions that can sporadically fail
and unit tests, by definition, must be 100% reliable. A testable design
abstracts all the world interactions under interfaces that can be mocked during
testing. This way, we end up with a thin layer that implements these interfaces
and forwards to the real OS/library functions. This thin layer should not
contain any logic beyond forwarding arguments since it is not really testable
and attempting to write unit tests against it ends up with an ongoing cost of
analyzing random test breaks due to failures in components outside of our
control. The other place where ROI is small is testing trivial code like
getters/setters. This is wasted engineering effort and provides questionably
little value. That being said, this layer should be at most 10% of the code
base, more likely somewhere in the 1-2% range for larger projects. Everything
else should be covered by unit tests.</p>
<p>There is also an interesting distinction between explicit vs implicit testing -
a function can be covered explicitly, by writing unit tests against it, or
implicitly, by writing unit tests against other functions that end up calling
this function. A good rule of thumb is to test against the interface not against
the private implementation. If you can’t reach the same amount of code coverage
by testing the public interface as you can by testing the implementation
details, it means you have dead code in the implementation - code that cannot be
reached from the public interface for any possible input. This code should be
removed not tested. Unit tests have a cost themselves - if we have tests
exercising a function and, during a refactoring, we change the signature of that
function, we have to go update all these tests. If any refactoring we make
breaks unit tests and requires us to fix them, engineering cost of maintaining
test coverage is increased needlessly.</p>
<p>Ideally, we should break and have to update tests when we break the interface
(the unit’s contract to the outside world). We should be able to freely move the
implementation guts around, as keeping tests green in this case is the ultimate
purpose of unit testing - ensuring output through the contract doesn’t break
during internal changes. A couple of gotchas here: if we feel we need to test an
implementation detail because it’s scarily complex, we have a code smell - that
implementation detail should be split into multiple, less scary pieces; if we
have a lot of implementation logic underneath a thin interface, we have another
smell - the component (unit) is too clever and should be split into multiple
components, which would necessarily pull some of the code to the interface
level.</p>
<p>The bottom line is that we can achieve +90% test coverage without taking
dependencies on implementation details.</p>
</div>
<div class="section" id="ease-of-testing">
<h2>Ease of testing</h2>
<p>Unit testing must be easy.</p>
<p>Authoring unit tests should be cheap. Running unit tests should be fast and 100%
reliable. Unit tests should be part of the engineering inner-loop -
code/compile/unit test. Code coverage should be easy to measure. Mocking should
be easy. If any of these points fall short, test coverage suffers. Good
infrastructure makes it easy to author and execute unit tests. This is key in
encouraging a team to use good engineering practices.</p>
<p>The other aspect of testing cost is design - code that is well componentized is
easily testable. Monolithic code, code that implements lots of branching for
various conditions, code that directly calls components outside of our control
(network, UI etc.), are all hard to test. This is not an excuse to bypass
testing, it’s a smell of the code itself.</p>
</div>
<div class="section" id="learned-hopelessness">
<h2>Learned hopelessness</h2>
<p>It’s easy to agree with all of the above but resign yourself to the fact that in
your organization things are different - the infrastructure is not there, the
culture is not there, there is no time. I believe that the most successful and
long-lived software projects have a codebase ridden with compromises and
outdated software practices, which is not a symptom of any problem, it’s the
result of implementing a successful business. It is our duty as software
craftsman to remove the compromises and update the outdated practices, question
the status quo and strive to make things better. Write unit tests!</p>
</div>
]]></description>
             <pubDate>Thu, 09 Nov 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/08/13/24.html</link>
            <guid>http://vladris.com/blog/2017/08/13/24.html</guid>
            <title><![CDATA[24]]></title>
            <description><![CDATA[<h1>24</h1>
<p>I recently learned about the <a class="reference external" href="https://en.wikipedia.org/wiki/24_Game">24 game</a>.
There are several variants of it, but the version I learned goes like this:</p>
<blockquote>
<div><p>Take out the face cards and jokers from a deck and deal four cards (aces or
number cards). Aces can be used either as 1 or as 11. Using addition,
subtraction, multiplication, and division, with any grouping of operations
(paranthesis can be added anywhere), try to come up with an expression that
uses all four cards once and equals 24. Division is fractional, so <span class="docutils literal"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">2</span></span>
is <span class="docutils literal"><span class="pre">2.5</span></span>.</p>
<p>For example for <span class="docutils literal"><span class="pre">A</span> <span class="pre">4</span> <span class="pre">5</span> <span class="pre">8</span></span> we have <span class="math notranslate">\((1 + 5) * (8 - 4)\)</span>.</p>
</div></blockquote>
<p>There is the problem of implementing an algorithm to find a solution given the
cards as input.</p>
<div class="section" id="brute-force">
<h2>Brute force</h2>
<p>A simple solution is to try all permutations of cards, all possible operations,
and all possible groupings.</p>
<p>In the general case, there are 24 ways to arrange the cards - permutations of 4
which is <span class="docutils literal"><span class="pre">4!</span></span>. Each ace doubles this number as we need to consider the case in
which we use it as 1 and the case in which we use it as 11.</p>
<p>There are 64 ways to combine operations, since we have 4 operations in 3
possitions, which means <span class="math notranslate">\(4^3\)</span> total.</p>
<p>We also have 5 possible groupings:</p>
<div class="math notranslate">
\[ \begin{align}\begin{aligned}(x_0 \odot x_1) \oplus (x_2 \otimes x_3)\\((x_0 \odot x_1) \oplus x_2) \otimes x_3\\(x_0 \odot (x_1 \oplus x_2)) \otimes x_3\\x_0 \odot ((x_1 \oplus x_2) \otimes x_3)\\x_0 \odot (x_1 \oplus (x_2 \otimes x_3))\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate">\(\odot, \oplus, \otimes\)</span> are placeholders for any operators (they
could potentially be the same operator).</p>
<p>A simple solver implementation looks like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">argv</span>

<span class="c1"># Transform arguments to numbers, replace 'A' and 'a' with [1, 11]</span>
<span class="n">args</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="s1">'aA'</span> <span class="k">else</span>
    <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]],</span> <span class="p">[])</span>

<span class="c1"># For every permutation of 4 arguments</span>
<span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="c1"># If we have more 1s and 11s then aces ignore this permutation</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">11</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">continue</span>

    <span class="c1"># For every possible combination of 3 operators</span>
    <span class="k">for</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="s1">'+-*/'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="c1"># For every possible grouping</span>
        <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'(</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)'</span><span class="p">,</span>
                    <span class="s1">'((</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">'</span><span class="p">,</span>
                    <span class="s1">'(</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">'</span><span class="p">,</span>
                    <span class="s1">'</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">))'</span><span class="p">,</span>
                    <span class="s1">'</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> ((</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)'</span><span class="p">]:</span>

            <span class="c1"># Place operands and operators in expression</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">ops</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If expression evaluates to 24, we found a solution</span>
                <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
                    <span class="n">exit</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="c1"># Ignore division by zero errors</span>
                <span class="k">pass</span>

<span class="c1"># If we get here we tried all combinations and couldn't</span>
<span class="c1"># find any solution</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'No solution'</span><span class="p">)</span>
</pre></div>
</div>
<p>We have ten possible cards (ace and number cards), and taking combination with
repetition of 4 cards, we have <span class="math notranslate">\(\frac{(n + r - 1)!}{r! * (n - 1)!}\)</span> for
<span class="math notranslate">\(n = 10, r = 4\)</span>, so a total of <span class="math notranslate">\(\frac{(10 + 4 - 1)!}{4! * (10 - 1)!}
= 715\)</span> possible games.</p>
<p>Feeding all possible games to the code above, we can see that there are 117
games which have no solution. The remaining 598 games are solvable.</p>
<p>We can optimize the above solution further by observing that we only need three
of the five groupings to cover all cases. Take, for example,
<span class="math notranslate">\(x_0 \odot ((x_1 \oplus x_2) \otimes x_3)\)</span>. Now if <span class="math notranslate">\(\odot\)</span> is a
commutative operation (addition or multiplication), we can rewrite this to the
equivalent <span class="math notranslate">\(((x_1 \oplus x_2) \otimes x_3) \odot x_0\)</span>, and since we any
way take all permuations of arguments and operators, this ends up getting
covered by the <span class="math notranslate">\(((x_0 \odot x_1) \oplus x_2) \otimes x_3\)</span> case. For
non-commutative operations, for example subtraction, notice that if we do have
a solution <span class="math notranslate">\(x_0 - ((x_1 \oplus x_2) \otimes x_3) = 24\)</span>, since <span class="math notranslate">\(x_0\)</span>
is at most 11, it means we need to subtract a negative number from it in order
to get 24. This implies that at least <span class="math notranslate">\(\oplus\)</span> or <span class="math notranslate">\(\otimes\)</span> is also
a subtraction. If <span class="math notranslate">\(\otimes\)</span> is a subtraction, we can rewrite the
expression <span class="math notranslate">\(x_0 - ((x_1 \oplus x_2) - x_3)\)</span> as <span class="math notranslate">\((x_0 + x_3) -
(x_1 \oplus x_2)\)</span>. If <span class="math notranslate">\(\otimes\)</span> is not a subtraction but <span class="math notranslate">\(\oplus\)</span>
is, we have <span class="math notranslate">\(x_0 - ((x_1 - x_2) \otimes x_3)\)</span> which is equivalent with
<span class="math notranslate">\(x_0 - (- (x_2 - x_1) \otimes x_3)\)</span>. If <span class="math notranslate">\(\otimes\)</span> is addition, this
becomes <span class="math notranslate">\(x_0 - (x_3 - (x_2 - x_1))\)</span> = <span class="math notranslate">\((x_0 - x_3) + (x_2 - x_1)\)</span>.
If <span class="math notranslate">\(\otimes\)</span> is multiplication or division, this becomes <span class="math notranslate">\(x_0 - (-
(x_2 - x_1) \otimes x_3)\)</span> = <span class="math notranslate">\(x_0 + ((x_2 - x_1) \otimes x_3)\)</span> =
<span class="math notranslate">\(((x_2 - x_1) \otimes x_3) + x_0\)</span>.</p>
<p>Similar rewrites can be done if <span class="math notranslate">\(\odot\)</span> is division by observing that we
would have to divide with a fractional number in order to get 24, so at least
one of <span class="math notranslate">\(\oplus\)</span> or <span class="math notranslate">\(\otimes\)</span> is also a division. This means we only
need the groupings</p>
<div class="math notranslate">
\[ \begin{align}\begin{aligned}(x_0 \odot x_1) \oplus (x_2 \otimes x_3)\\((x_0 \odot x_1) \oplus x_2) \otimes x_3\\(x_0 \odot (x_1 \oplus x_2)) \otimes x_3\end{aligned}\end{align} \]</div>
<p>to find all possible solutions. Our solution becomes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">argv</span>

<span class="n">args</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="s1">'aA'</span> <span class="k">else</span>
    <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]],</span> <span class="p">[])</span>

<span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">11</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">continue</span>

    <span class="k">for</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="s1">'+-*/'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'(</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)'</span><span class="p">,</span>
                    <span class="s1">'((</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">'</span><span class="p">,</span>
                    <span class="s1">'(</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">'</span><span class="p">]:</span>

            <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">ops</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
                    <span class="n">exit</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="k">pass</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'No solution'</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that for games without aces, we need to check 24 (<span class="math notranslate">\(4!\)</span>)
permutations of cards, 64 (<span class="math notranslate">\(4^3\)</span>) combinations of operators, and 3
groupings. That is <span class="math notranslate">\(4! * 4^3 * 3 = 4608\)</span> tests. For games with aces, we
double this number for each ace to account for both the 1 and 11 cases.</p>
</div>
<div class="section" id="minimizing-number-of-tests">
<h2>Minimizing Number of Tests</h2>
<p>A more interesting question is what is the minimum number of tests we need to
perform in order to correctly find a solution for all solvable games.</p>
<p>It is obvious that there are expressions which can never evaluate to 24 for any
game. For example <span class="math notranslate">\((x_0 - x_1) - x_2) - x_3\)</span>, since <span class="math notranslate">\(x_i \in \{1,
2, ... 11\}\)</span>.</p>
<p>It is also obvious that we perform a lot of redundant tests, since, for example,
all of the below expressions are equivalent for all possible inputs:</p>
<div class="math notranslate">
\[ \begin{align}\begin{aligned}(x_0 + x_1) + (x_2 + x_3)\\((x_0 + x_1) + x_2) + x_3\\(x_0 + (x_1 + x_2)) + x_3\\(x_0 + x_1) + (x_3 + x_2)\\((x_0 + x_1) + x_3) + x_2\\(x_0 + (x_1 + x_3)) + x_2\\...\end{aligned}\end{align} \]</div>
<p>and so on for all permutations of <span class="math notranslate">\(x_0, x_1, x_2, x_3\)</span>.</p>
<p>Let’s generate all possible permutations of cards, combinations of operators,
and groupings as above:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">itertools</span>

<span class="n">operands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span> <span class="c1"># 24 of these</span>
<span class="n">operators</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="s1">'+-*/'</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># 64 of these</span>
<span class="n">groupings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'(</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)'</span><span class="p">,</span>
             <span class="s1">'((</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">'</span><span class="p">,</span>
             <span class="s1">'(</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">)) </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">'</span><span class="p">]</span> <span class="c1"># 3 of these</span>
</pre></div>
</div>
<p>Note that here we are looking at all possible games so operands are permutations
of indexes from 0 to 3, not actual cards. We can also take all possible games as
combinations of 4 numbers from 1 to 11. Here we generate 1 and 11 games for each
ace, so we end up with 1001 possible games instead of 715:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1"># 1001 of these</span>
</pre></div>
</div>
<p>We can now write a function that, for a given game, generates all possible
expressions which evaluate to 24:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">solutions_for</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">operators</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">groupings</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">inp</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inp</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                            <span class="n">ops</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">inp</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">3</span><span class="p">]]))</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">exp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="sa">f</span><span class="s1">'x</span><span class="si">{</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">'</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="sa">f</span><span class="s1">'x</span><span class="si">{</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">'</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="sa">f</span><span class="s1">'x</span><span class="si">{</span><span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">'</span><span class="p">,</span>
                            <span class="n">ops</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="sa">f</span><span class="s1">'x</span><span class="si">{</span><span class="n">xs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                    <span class="k">pass</span>
</pre></div>
</div>
<p>This is very similar with the initial solution, except that we don’t have to
worry about aces (we assume they are already converted to either 1 or 11), and
we use the permutations of indexes to determine the order of terms as input is
going to always be in increasing order (as generated by
<span class="docutils literal"><span class="pre">itertools.combinations_with_replacement</span></span>). So instead of placing <span class="docutils literal"><span class="pre">inp[0],</span>
<span class="pre">op[0],</span> <span class="pre">inp[1],</span> <span class="pre">op[1],</span> <span class="pre">inp[2],</span> <span class="pre">op[2],</span> <span class="pre">inp[3]</span></span> in the expression to be evaluated
as we did in the initial solution, since <span class="docutils literal"><span class="pre">inp</span></span> is fixed, we come up with
permutations of operands from <span class="docutils literal"><span class="pre">operands</span></span>, so we are placing <span class="docutils literal"><span class="pre">inp[xs[0]],</span>
<span class="pre">op[0],</span> <span class="pre">inp[xs[1]],</span> <span class="pre">op[1],</span> <span class="pre">inp[xs[2]],</span> <span class="pre">op[2],</span> <span class="pre">inp[xs[3]]</span></span> in the expression
instead. We also return the expression replacing the operands with <span class="docutils literal"><span class="pre">x0,</span> <span class="pre">x1,</span> <span class="pre">x2,</span>
<span class="pre">x3</span></span> since we don’t care about their particular values, rather the expression
we are using.</p>
<p>For example calling:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="nb">list</span><span class="p">(</span><span class="n">solutions_for</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]))</span>
</pre></div>
</div>
<p>yields</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>['((x0 * x2) - x3) * x1', '(x1 * x2) - (x3 / x0)',
 '((x2 * x0) - x3) * x1', '((x2 / x0) * x3) - x1',
 '(x2 / (x0 / x3)) - x1', '(x2 * x1) - (x3 / x0)',
 '((x2 * x3) / x0) - x1', '(x2 * (x3 / x0)) - x1',
 '((x3 / x0) * x2) - x1', '(x3 / (x0 / x2)) - x1',
 '((x3 * x2) / x0) - x1', '(x3 * (x2 / x0)) - x1']
</pre></div>
</div>
<p>These are all possible expression which evaluate to 24 for the game <span class="docutils literal"><span class="pre">2</span> <span class="pre">4</span> <span class="pre">7</span> <span class="pre">8</span></span>.</p>
<p>We can compute the list of all expressions which evaluate to 24 for every
possible game:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">solutions_for</span><span class="p">(</span><span class="n">inp</span><span class="p">))</span>

    <span class="c1"># Only append the set of expressions to the list if</span>
    <span class="c1"># non-empty (if game has at least one solution)</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>We can take the union of the sets in <span class="docutils literal"><span class="pre">results</span></span> and get the set of all
expressions that evaluate to 24 for at least one game:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">expressions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="n">expressions</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>The size of this set is 1809. We are guaranteed that for any possible game, no
other expression evaluates to 24 since we generated all possible solutions for
all possible games. Which means we can test just these 1809 expression for any
game and determine whether it is solvable or not, which is better than our
original 4608 (or more for games with aces).</p>
<p>Here we eliminated all expressions which never evaluate to 24, but we still have
all the redundant tests in our set of expressions. It is also possible to have
an expression <span class="math notranslate">\(E_0\)</span> which solves all games some expression <span class="math notranslate">\(E_1\)</span>
solves, plus some other games. In which case we wouldn’t ever need to test using
<span class="math notranslate">\(E_1\)</span> since <span class="math notranslate">\(E_0\)</span> would still solve all games that <span class="math notranslate">\(E_1\)</span> would
solve.</p>
<p>More formally, <span class="docutils literal"><span class="pre">expressions</span></span> is our universe <span class="math notranslate">\(\mathcal{U}\)</span> of tests and
<span class="docutils literal"><span class="pre">results</span></span> is a set of sets <span class="math notranslate">\(R = \{ R_0, R_1 ... R_n \}\)</span> where
<span class="math notranslate">\(R_i \subset \mathcal{U} \space \forall i \in \{ 0, 1 ... n \}\)</span>. We want
to find the smallest set <span class="math notranslate">\(H \subset \mathcal{U}\)</span> such that <span class="math notranslate">\(H \cap
R_i \neq \varnothing \space \forall i \in \{ 0, 1 ... n \}\)</span>.</p>
<p>The good news is that this is actually a well known problem called <strong>the hitting
set problem</strong> <a class="footnote-reference" href="#id3" id="id2">[1]</a>. The bad news is this problem is NP-hard. Even with clever
pruning, trying out combinations of expressions to find the smallest <span class="math notranslate">\(H\)</span>
has factorial complexity and even for small sets it quickly reaches astronomical
numbers.</p>
</div>
<div class="section" id="approximation">
<h2>Approximation</h2>
<p>Since finding an optimal solution is too computationally expensive, we can at
least attempt to find a <em>good enough</em> solution.</p>
<p>The greedy algorithm which solves the hitting set problem works as follows:
build up the solution by selecting at each step the element which hits the
highest number of sets which were not hit so far.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># Start with an empty set</span>
<span class="n">min_expressions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># While we have unhit sets</span>
<span class="k">while</span> <span class="n">results</span><span class="p">:</span>
    <span class="n">min_expression</span><span class="p">,</span> <span class="n">max_hitting</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="mi">0</span>

    <span class="c1"># For each expression in our universe</span>
    <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
        <span class="n">hitting</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">result</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">hitting</span> <span class="o">&gt;</span> <span class="n">max_hitting</span><span class="p">:</span>
            <span class="n">min_expression</span><span class="p">,</span> <span class="n">max_hitting</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="n">hitting</span>

    <span class="c1"># We found the expression hitting most unhit sets</span>
    <span class="n">min_expressions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">min_expression</span><span class="p">)</span>

    <span class="c1"># Remove hit sets from results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span>
        <span class="n">min_expression</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
</pre></div>
</div>
<p>Interestingly enough, since we are working with sets and hashing is randomized
in Python, I got different results across different runs of this algorithm. For
cases where there are multiple max hitting sets (sets intersecting the same
number of other sets), we non-deterministically select one, since iteration over
sets is based on the randomized key order. I got solutions ranging from 110 to
114 expressions. This gives us an upper bound of 110 - we must perform at most
110 tests to find a solution for a game.</p>
<p>We can use the above code to generate a set of expressions and dump it into a
source file, together with the code to test input:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">argv</span>

<span class="n">expressions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">"(x3 + x1) * (x2 - x0)"</span><span class="p">,</span> <span class="s2">"((x2 * x3) - x0) / x1"</span><span class="p">,</span>
    <span class="s2">"(x3 + (x1 + x0)) * x2"</span><span class="p">,</span> <span class="s2">"(x0 - x3) * (x1 - x2)"</span><span class="p">,</span>
    <span class="s2">"(x1 * x0) + (x2 - x3)"</span><span class="p">,</span> <span class="s2">"((x2 * x0) * x3) - x1"</span><span class="p">,</span>
    <span class="s2">"(x3 + (x1 + x2)) + x0"</span><span class="p">,</span> <span class="s2">"(x2 * x0) + (x3 - x1)"</span><span class="p">,</span>
    <span class="s2">"((x0 / x1) * x2) * x3"</span><span class="p">,</span> <span class="s2">"(x1 * (x3 - x2)) + x0"</span><span class="p">,</span>
    <span class="s2">"((x3 + x2) - x0) + x1"</span><span class="p">,</span> <span class="s2">"(x0 * x1) * (x3 - x2)"</span><span class="p">,</span>
    <span class="s2">"(x1 * x0) - (x2 + x3)"</span><span class="p">,</span> <span class="s2">"(x3 / x1) * (x2 + x0)"</span><span class="p">,</span>
    <span class="s2">"((x2 + x1) + x3) * x0"</span><span class="p">,</span> <span class="s2">"(x3 - x0) / (x1 / x2)"</span><span class="p">,</span>
    <span class="s2">"(x3 + x1) * (x2 / x0)"</span><span class="p">,</span> <span class="s2">"(x1 * x3) + (x0 * x2)"</span><span class="p">,</span>
    <span class="s2">"((x3 * x1) + x2) + x0"</span><span class="p">,</span> <span class="s2">"((x0 - x2) + x1) * x3"</span><span class="p">,</span>
    <span class="s2">"((x3 / x0) + x2) * x1"</span><span class="p">,</span> <span class="s2">"(x3 + (x2 * x1)) - x0"</span><span class="p">,</span>
    <span class="s2">"(x1 * x3) - (x2 - x0)"</span><span class="p">,</span> <span class="s2">"(x1 * (x3 - x0)) - x2"</span><span class="p">,</span>
    <span class="s2">"((x2 + x1) * x3) / x0"</span><span class="p">,</span> <span class="s2">"(x0 * x3) - (x1 + x2)"</span><span class="p">,</span>
    <span class="s2">"(x1 + (x3 * x0)) * x2"</span><span class="p">,</span> <span class="s2">"(x0 * (x2 + x3)) - x1"</span><span class="p">,</span>
    <span class="s2">"(x1 * x3) - (x0 + x2)"</span><span class="p">,</span> <span class="s2">"(x3 - (x2 / x1)) * x0"</span><span class="p">,</span>
    <span class="s2">"(x0 - (x1 / x2)) * x3"</span><span class="p">,</span> <span class="s2">"(x3 * x0) + (x2 - x1)"</span><span class="p">,</span>
    <span class="s2">"((x3 / x0) + x1) + x2"</span><span class="p">,</span> <span class="s2">"(x3 + (x1 * x2)) + x0"</span><span class="p">,</span>
    <span class="s2">"(x0 + x2) * (x1 + x3)"</span><span class="p">,</span> <span class="s2">"(x0 * (x3 - x1)) + x2"</span><span class="p">,</span>
    <span class="s2">"((x0 + x3) * x1) * x2"</span><span class="p">,</span> <span class="s2">"(x2 * (x0 + x3)) / x1"</span><span class="p">,</span>
    <span class="s2">"(x2 - (x1 + x0)) * x3"</span><span class="p">,</span> <span class="s2">"(x3 * x2) - (x0 / x1)"</span><span class="p">,</span>
    <span class="s2">"((x0 + x3) * x1) + x2"</span><span class="p">,</span> <span class="s2">"((x0 * x3) + x1) - x2"</span><span class="p">,</span>
    <span class="s2">"(x2 + (x3 - x1)) * x0"</span><span class="p">,</span> <span class="s2">"(x2 * (x0 + x1)) + x3"</span><span class="p">,</span>
    <span class="s2">"((x2 + x3) * x0) + x1"</span><span class="p">,</span> <span class="s2">"(x0 - (x3 / x2)) * x1"</span><span class="p">,</span>
    <span class="s2">"((x0 + x2) - x3) * x1"</span><span class="p">,</span> <span class="s2">"((x3 / x2) + x0) * x1"</span><span class="p">,</span>
    <span class="s2">"(x1 / x0) + (x2 + x3)"</span><span class="p">,</span> <span class="s2">"((x1 * x0) - x2) * x3"</span><span class="p">,</span>
    <span class="s2">"((x0 + x1) + x2) * x3"</span><span class="p">,</span> <span class="s2">"(x2 * (x3 - x1)) - x0"</span><span class="p">,</span>
    <span class="s2">"((x2 * x1) - x0) * x3"</span><span class="p">,</span> <span class="s2">"((x3 - x1) * x2) + x0"</span><span class="p">,</span>
    <span class="s2">"(x3 / (x0 + x1)) * x2"</span><span class="p">,</span> <span class="s2">"((x1 * x0) + x3) + x2"</span><span class="p">,</span>
    <span class="s2">"(x3 + x0) * (x2 - x1)"</span><span class="p">,</span> <span class="s2">"(x2 - x0) * (x3 - x1)"</span><span class="p">,</span>
    <span class="s2">"((x3 / x0) * x2) + x1"</span><span class="p">,</span> <span class="s2">"((x2 * x1) - x0) - x3"</span><span class="p">,</span>
    <span class="s2">"(x0 + (x3 - x1)) * x2"</span><span class="p">,</span> <span class="s2">"(x0 * x2) / (x3 - x1)"</span><span class="p">,</span>
    <span class="s2">"((x3 * x2) - x1) / x0"</span><span class="p">,</span> <span class="s2">"(x2 - (x0 / x3)) * x1"</span><span class="p">,</span>
    <span class="s2">"(x3 - x2) * (x0 + x1)"</span><span class="p">,</span> <span class="s2">"(x0 * x2) - (x3 + x1)"</span><span class="p">,</span>
    <span class="s2">"((x2 - x0) * x3) + x1"</span><span class="p">,</span> <span class="s2">"(x1 * (x3 - x0)) + x2"</span><span class="p">,</span>
    <span class="s2">"(x1 * (x0 + x3)) - x2"</span><span class="p">,</span> <span class="s2">"((x0 + x1) * x3) + x2"</span><span class="p">,</span>
    <span class="s2">"((x1 - x2) + x3) * x0"</span><span class="p">,</span> <span class="s2">"((x3 - x1) * x2) * x0"</span><span class="p">,</span>
    <span class="s2">"((x2 + x1) - x3) * x0"</span><span class="p">,</span> <span class="s2">"(x1 + (x3 / x2)) * x0"</span><span class="p">,</span>
    <span class="s2">"(x2 / (x0 / x1)) + x3"</span><span class="p">,</span> <span class="s2">"(x2 / (x3 - x0)) * x1"</span><span class="p">,</span>
    <span class="s2">"(x3 * x1) - (x0 * x2)"</span><span class="p">,</span> <span class="s2">"((x1 + x0) * x2) * x3"</span><span class="p">,</span>
    <span class="s2">"(x1 - (x2 / x3)) * x0"</span><span class="p">,</span> <span class="s2">"(x2 + (x3 * x0)) + x1"</span><span class="p">,</span>
    <span class="s2">"((x2 * x3) + x1) / x0"</span><span class="p">,</span> <span class="s2">"(x3 - x0) * (x2 + x1)"</span><span class="p">,</span>
    <span class="s2">"(x1 * x3) + (x2 - x0)"</span><span class="p">,</span> <span class="s2">"(x3 * (x2 - x0)) - x1"</span><span class="p">,</span>
    <span class="s2">"(x0 + (x1 - x3)) * x2"</span><span class="p">,</span> <span class="s2">"(x1 * (x3 - x2)) - x0"</span><span class="p">,</span>
    <span class="s2">"(x0 + (x2 * x3)) - x1"</span><span class="p">,</span> <span class="s2">"(x2 + x3) / (x0 / x1)"</span><span class="p">,</span>
    <span class="s2">"(x0 * x3) / (x2 - x1)"</span><span class="p">,</span> <span class="s2">"(x2 - (x3 / x0)) * x1"</span><span class="p">,</span>
    <span class="s2">"(x0 - (x1 - x2)) * x3"</span><span class="p">,</span> <span class="s2">"(x3 + x1) + (x2 * x0)"</span><span class="p">,</span>
    <span class="s2">"((x3 - x1) - x0) * x2"</span><span class="p">,</span> <span class="s2">"(x1 * (x2 - x0)) - x3"</span><span class="p">,</span>
    <span class="s2">"(x2 + x0) * (x3 - x1)"</span><span class="p">,</span> <span class="s2">"((x3 - x1) * x2) / x0"</span><span class="p">,</span>
    <span class="s2">"((x1 * x3) - x2) * x0"</span><span class="p">,</span> <span class="s2">"((x1 + x3) * x0) - x2"</span><span class="p">,</span>
    <span class="s2">"((x3 - x2) + x0) * x1"</span><span class="p">,</span> <span class="s2">"((x2 * x0) - x3) * x1"</span><span class="p">,</span>
    <span class="s2">"(x2 * (x1 + x0)) - x3"</span><span class="p">,</span> <span class="s2">"(x0 + (x1 / x2)) * x3"</span><span class="p">,</span>
    <span class="s2">"((x2 - x1) * x3) + x0"</span><span class="p">,</span> <span class="s2">"((x2 / x1) + x3) * x0"</span><span class="p">,</span>
    <span class="s2">"(x1 * x0) - (x2 / x3)"</span><span class="p">,</span> <span class="s2">"((x3 * x0) - x1) * x2"</span><span class="p">,</span>
    <span class="s2">"((x2 - x0) * x1) + x3"</span><span class="p">,</span> <span class="s2">"((x1 + x0) * x3) - x2"</span><span class="p">,</span>
    <span class="s2">"(x1 * x0) / (x3 - x2)"</span><span class="p">,</span> <span class="s2">"(x3 * (x1 - x0)) - x2"</span>
<span class="p">]</span>

<span class="c1"># Since we no longer try all permutations of cards, we</span>
<span class="c1"># need to split inputs containing aces by replacing aces</span>
<span class="c1"># with both 1 and 11</span>
<span class="k">def</span> <span class="nf">get_input</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="s1">'A'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">]</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">'A'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">get_input</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">get_input</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">'11'</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

<span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">get_input</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]):</span>
    <span class="c1"># We also expect inputs to be in sorted order now</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="c1"># Replace x0 ... x3 with args[0] ... args[3]</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'x'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">pass</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'No solution'</span><span class="p">)</span>
</pre></div>
</div>
<p>We can test this by ensuring that we still see 117 games without solution when
we try to solve all 715 games, which is indeed the case. We reduced the number
of tests we perform on a game from 4608 to 110.</p>
</div>
<div class="section" id="unique-expressions">
<h2>Unique Expressions</h2>
<p>There are a couple of other interesting facts we can determine from the set of
all solutions for all games: the set of unique expressions and out of them, the
subset of expressions which are absolutely required in order to solve all
possible games.</p>
<p>By <em>unique expression</em> I mean picking an expression and eliminating all other
equivalent expressions from the set (for example keeping only
<span class="math notranslate">\(((x_0 + x_1) + x_2) + x_3\)</span> while dropping all other permutations and
groupings of addition). We can easily do this by defining equivalent expressions
as expressions which solve the exact same games. So if <span class="math notranslate">\(E_1\)</span> solves some
subset <span class="math notranslate">\(R_{E_1}\)</span> of <span class="math notranslate">\(R\)</span>, an expression <span class="math notranslate">\(E_2\)</span> is equivalent to
it if the set <span class="math notranslate">\(R_{E_2}\)</span> of games it solves is equal to <span class="math notranslate">\(R_{E_1}\)</span>. We
can define equivalence as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">equivalent</span><span class="p">(</span><span class="n">exp1</span><span class="p">,</span> <span class="n">exp2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exp1</span> <span class="ow">in</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">exp2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">exp1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">exp2</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
<p>With this function, we can go over our univese <span class="math notranslate">\(\mathcal{U}\)</span> of
expressions and eliminate all expressions which are the equivalent of another
expression:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">expressions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
<span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">):</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expressions</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">equivalent</span><span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span> <span class="n">expressions</span><span class="p">[</span><span class="n">i2</span><span class="p">]):</span>
            <span class="n">expressions</span> <span class="o">=</span> <span class="n">expressions</span><span class="p">[:</span><span class="n">i2</span><span class="p">]</span> <span class="o">+</span> <span class="n">expressions</span><span class="p">[</span><span class="n">i2</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">expressions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting set of unique expressions has 273 elements. This means these 273
expressions are enough to solve all possible games and, more so, adding any
other expression to this set would be redundant. This is a lower bound than our
original 1809 expressions which solve games, but higher than our previously
found bound of 110 expressions. Note that this data point is not useful in the
greedy algorithm shown in the previous section, since once that algorithm picks
an expression, it would automatically discard all other equivalent expressions,
since it eliminates all games which are solved by the picked expression from the
search space. This should put the problem in combinatorial perspective though,
as we need to select from 273 candidates to find the smallest hitting set.</p>
<p>Once we have eliminated equivalent expressions, we can update the set of game
results accordingly, by intersecting each <span class="math notranslate">\(R_i\)</span> with our new
<span class="math notranslate">\(\mathcal{U}\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
</pre></div>
</div>
<p>Now we can search <span class="math notranslate">\(R\)</span> for sets with a single element. This will give us
expressions which must be part of our solution, otherwise eliminating them would
cause a solvable game to appear as unsolvable:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">min_expressions</span><span class="p">,</span> <span class="n">games_with_unique_result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">min_expressions</span> <span class="o">=</span> <span class="n">min_expressions</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">games_with_unique_result</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Turns out there are 62 expressions which (ignoring equivalences) provide unique
solutions to games. They are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>{'(x1 + x2) - (x0 - x3)', '(x1 + x0) * (x2 * x3)',
 '((x1 + x0) - x2) * x3', '((x3 + x2) * x0) + x1',
 '(x0 + x3) * (x2 - x1)', '((x2 * x1) / x0) + x3',
 '((x3 - x1) * x2) - x0', '(x1 - (x3 / x2)) * x0',
 '((x1 * x0) - x2) - x3', '((x2 - x1) - x0) * x3',
 '((x1 * x0) - x3) + x2', '(x2 + (x1 / x0)) + x3',
 '((x1 + x3) - x2) * x0', '(x2 - (x3 - x0)) * x1',
 '(x2 + (x1 + x3)) + x0', '(x1 * x0) - (x2 / x3)',
 '(x3 + (x2 * x1)) - x0', '((x0 * x1) + x3) + x2',
 '(x2 + (x1 - x3)) * x0', '((x0 * x1) - x2) * x3',
 '(x2 * x0) + (x1 + x3)', '(x2 + (x3 * x0)) + x1',
 '((x0 * x3) - x1) + x2', '(x0 + (x2 - x1)) * x3',
 '((x3 * x1) - x2) - x0', '(x1 - x2) * (x0 - x3)',
 '((x3 - x0) - x1) * x2', '(x1 * (x2 - x0)) - x3',
 '(x0 / (x3 - x2)) * x1', '((x0 + x1) - x3) * x2',
 '((x3 - x1) + x0) * x2', '((x1 + x0) * x3) + x2',
 '((x1 + x0) * x3) - x2', '(x3 / x1) * (x2 + x0)',
 '((x3 - x1) * x0) + x2', '(x3 * (x2 - x0)) + x1',
 '((x0 + x2) + x1) * x3', '(x2 * (x0 + x1)) - x3',
 '(x2 * x1) / (x3 - x0)', '(x3 + x0) + (x1 * x2)',
 '(x0 + (x3 * x2)) - x1', '(x0 - x2) * (x1 - x3)',
 '((x2 + x3) * x1) / x0', '(x2 / x0) * (x3 + x1)',
 '(x3 * (x1 - x0)) - x2', '((x3 + x1) * x0) - x2',
 '((x0 + x3) * x1) - x2', '((x3 + x2) * x0) - x1',
 '(x3 + x0) / (x1 / x2)', '(x0 + x2) * (x3 - x1)',
 '(x2 * (x3 - x1)) + x0', '((x0 * x3) - x2) - x1',
 '((x1 * x2) - x3) - x0', '(x3 - (x1 - x2)) * x0',
 '(x2 * x3) / (x1 + x0)', '(x3 - x2) * (x0 + x1)',
 '(x0 / (x3 - x1)) * x2', '((x2 * x3) - x0) / x1',
 '(x2 * (x3 - x0)) / x1', '((x1 + x0) * x2) + x3',
 '(x1 * (x2 - x0)) + x3', '(x3 * (x2 - x1)) + x0'}
</pre></div>
</div>
<p>This is a lower bound for our problem, since at the very least we need these
expressions in order to correcly solve all possible games. We also computed the
number of games with a unique solution, which is 122. The remaining games are
either unsolvable or admit multiple solutions. Note we considered aces as 1s and
aces as 11s as distinct games in the above analysis. We could search for
equivalent games (number of 1s and 11s is the same) and see if we can eliminate
some expressions from the list above. This is left as an exercise to the reader.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>There are 715 distinct games in 24, with 117 of them unsolvable and the
remaining 598 having at least one solution.</li>
<li>A brute-force solution checks 4608 expressions (double for each ace) to
determine that a game is unsolvable.</li>
<li>Only 1809 expressions (out of the 4608) solve at least one game.</li>
<li>Finding the minimum number of expressions we need to check in order to find
whether a game has a solution is equivalent to the hitting set problem which
is NP-hard.</li>
<li>A greedy algorithm finds a set of 110 expressions which is enough to find a
solution for any solvable game.</li>
<li>Removing equivalent expressions, we are left with 273 expressions which all
solve at least one different game than any other. Out of these, 62 expressions
are unique solutions to 122 games, so they must necessarily be checked in
order to find solutions for all possible games.</li>
</ul>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Wikipedia explains the <a class="reference external" href="https://en.wikipedia.org/wiki/Set_cover_problem">set cover problem</a>
which is equivalent to the hitting set problem (one can be converted to
the other).</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sun, 13 Aug 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/07/20/idris-totality-dependent-types-proofs.html</link>
            <guid>http://vladris.com/blog/2017/07/20/idris-totality-dependent-types-proofs.html</guid>
            <title><![CDATA[Idris: Totality, Dependent Types, Proofs]]></title>
            <description><![CDATA[<h1>Idris: Totality, Dependent Types, Proofs</h1>
<p>Idris is a programming language inspired by Haskell, with a set of innovative
features to facilitate type safety and program correctness.
<a class="reference external" href="https://www.manning.com/books/type-driven-development-with-idris">Type Driven Development with Idris</a>
is a great introductory book which I highly recommend. In this post, I will try
to cover the features I was most impressed with, providing some simple code
samples. I will not cover syntax since most should be familiar from Haskell. If
you are not familiar with Haskell syntax, here is a nice <a class="reference external" href="https://matela.com.br/pub/cheat-sheets/haskell-ucs-0.4.pdf">syntax cheat sheet</a>.
If you are not interested in either Haskell or Idris syntax, start with the last
section of this post, <a class="reference internal" href="http://vladris.com/blog/2017/07/20/idris-totality-dependent-types-proofs.html#thoughts-about-the-future">Thoughts about the Future</a>.</p>
<div class="section" id="totality-checking">
<h2>Totality Checking</h2>
<p>A total function in Idris is a function which is defined for all possible inputs
and is guaranteed to produce a result in a finite amount of time <a class="footnote-reference" href="#id3" id="id1">[1]</a>. The
compiler obviously employs a heuristic, since the halting problem is
undecidable, but is usually close enough to the truth to guarantee correctness
from this point of view. It achieves this not by evaluating the function, but by
ensuring that every recursive branch converges to a halting branch.</p>
<p>Natural numbers are defined in Idris using Peano axioms, so it is easy to prove
things about them. Here is a minimal definition of natural numbers <a class="footnote-reference" href="#id4" id="id2">[2]</a>:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Nat'</span> <span class="ow">=</span> <span class="kt">Z</span> <span class="ow">|</span> <span class="kt">S</span> <span class="kt">Nat'</span>
</pre></div>
</div>
<p>This defines <span class="docutils literal"><span class="pre">Nat'</span></span> as a data type which can be constructed either as <span class="docutils literal"><span class="pre">Z</span></span>
(zero) or <span class="docutils literal"><span class="pre">S</span> <span class="pre">Nat'</span></span> (successor of another natural number). With this
definition, the compiler can easily determine the following function is total:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">f</span> <span class="ow">:</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="ow">()</span>
f <span class="kt">Z</span> <span class="ow">=</span> <span class="ow">()</span>
f <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> <span class="ow">=</span> f k
</pre></div>
</div>
<p>This function return a unit given <span class="docutils literal"><span class="pre">Z</span></span>, otherwise it recursively takes the
predecessor of the argument. This converges to the <span class="docutils literal"><span class="pre">Z</span></span> case. The following
function, on the other hand, is correctly identified as potentially
non-terminating:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">g</span> <span class="ow">:</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="ow">()</span>
g n <span class="ow">=</span> g <span class="ow">(</span><span class="kt">S</span> n<span class="ow">)</span>
</pre></div>
</div>
<p>These are trivial examples, but in general, having a compile-time check for
termination is a very powerful tool.</p>
</div>
<div class="section" id="dependent-types">
<h2>Dependent Types</h2>
<p>Dependent types are types computed from other types. To put it another way,
Idris has first-order types, meaning functions can take types as arguments and
return types as their output. Functions that compute types are evaluated at
compile time. This is similar to C++ metaprogramming, but without employing a
different syntax.</p>
<p>Before an example, we first need to define addition on naturals as follows:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="ow">(+)</span> <span class="ow">:</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="kt">Nat'</span>
<span class="ow">(+)</span> <span class="kt">Z</span> r <span class="ow">=</span> r
<span class="ow">(+)</span> <span class="ow">(</span><span class="kt">S</span> l<span class="ow">)</span> r <span class="ow">=</span> <span class="kt">S</span> <span class="ow">(</span>l <span class="ow">+</span> r<span class="ow">)</span>
</pre></div>
</div>
<p>Now we can declare a vector type consisting of a size (<span class="docutils literal"><span class="pre">Nat'</span></span>) and a type
argument:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Vect'</span> <span class="ow">:</span> <span class="kt">Nat'</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span> <span class="kr">where</span>
     <span class="nf">Nil</span> <span class="ow">:</span> <span class="kt">Vect'</span> <span class="kt">Z</span> a
     <span class="ow">(::)</span> <span class="ow">:</span> <span class="ow">(</span>x <span class="ow">:</span> a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="ow">(</span>xs <span class="ow">:</span> <span class="kt">Vect'</span> k a<span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">Vect'</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> a
</pre></div>
</div>
<p>Here <span class="docutils literal"><span class="pre">a</span></span> is a type argument. <span class="docutils literal"><span class="pre">Vect'</span></span> has two constructors: <span class="docutils literal"><span class="pre">Nil</span></span>,
creating a <span class="docutils literal"><span class="pre">Vect'</span></span> of size <span class="docutils literal"><span class="pre">Z</span></span> containing elements of type <span class="docutils literal"><span class="pre">a</span></span> (0
elements) and <span class="docutils literal"><span class="pre">(::)</span></span>, which concatenates an object of type <span class="docutils literal"><span class="pre">a</span></span> with a vector
of size <span class="docutils literal"><span class="pre">k</span></span> of <span class="docutils literal"><span class="pre">a</span></span> and produces a vector of size <span class="docutils literal"><span class="pre">S</span> <span class="pre">k</span></span> containing <span class="docutils literal"><span class="pre">a</span></span>.</p>
<p>Now to see dependent types in action, we can define <span class="docutils literal"><span class="pre">append'</span></span>, a function that
appends a vector to another vector:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">append'</span> <span class="ow">:</span> <span class="kt">Vect'</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> m a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> <span class="ow">(</span>n <span class="ow">+</span> m<span class="ow">)</span> a
append' <span class="kt">Nil</span> ys <span class="ow">=</span> ys
append' <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> ys <span class="ow">=</span> x <span class="ow">::</span> append' xs ys
</pre></div>
</div>
<p>The interesting part is the function signature - given a vector of size <span class="docutils literal"><span class="pre">n</span></span>
and a vector of size <span class="docutils literal"><span class="pre">m</span></span>, the resulting vector will have size <span class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">m</span></span>. This
information is captured in the declaration and the compiler knows to apply the
<span class="docutils literal"><span class="pre">(+)</span></span> defined above and type-check that this is indeed true for a given pair
of arguments.</p>
</div>
<div class="section" id="proofs">
<h2>Proofs</h2>
<p>We can also attempt to define a <span class="docutils literal"><span class="pre">reverse'</span></span> function, which recursively appends
the head of the vector to the reversed tail:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">reverse'</span> <span class="ow">:</span> <span class="kt">Vect'</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> n a
reverse' <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">Nil</span>
reverse' <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> <span class="ow">=</span> append' <span class="ow">(</span>reverse' xs<span class="ow">)</span> <span class="ow">[</span>x<span class="ow">]</span>
</pre></div>
</div>
<p>This doesn’t compile though. We get the following error message:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span/>When checking right hand side of reverse' with expected type
        Vect' (S k) a

Type mismatch between
        Vect' (k + S Z) a (Type of append' (reverse' xs) [x])
and
        Vect' (S k) a (Expected type)

Specifically:
        Type mismatch between
                k + S Z
        and
                S k
</pre></div>
</div>
<p>We are claiming the function returns a vector of the same length as the input
vector, but we haven’t proven enough theorems about our definition of natural
numbers to convince the type checker. In this particular case, the problem is
that the compiler expects an <span class="docutils literal"><span class="pre">S</span> <span class="pre">k</span></span> but finds an <span class="docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span>. We need to prove
that these are indeed equal (<span class="docutils literal"><span class="pre">successor</span> <span class="pre">of</span> <span class="pre">k</span></span> is the same as
<span class="docutils literal"><span class="pre">k</span> <span class="pre">+</span> <span class="pre">successor</span> <span class="pre">of</span> <span class="pre">Z</span></span>). Here is the proof:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">addOneProof</span> <span class="ow">:</span> <span class="ow">(</span>n <span class="ow">:</span> <span class="kt">Nat'</span><span class="ow">)</span> <span class="ow">-&gt;</span> <span class="kt">S</span> n <span class="ow">=</span> n <span class="ow">+</span> <span class="kt">S</span> <span class="kt">Z</span>
addOneProof <span class="kt">Z</span> <span class="ow">=</span> <span class="kt">Refl</span>
addOneProof <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> <span class="ow">=</span> cong <span class="ow">(</span>addOneProof k<span class="ow">)</span>
</pre></div>
</div>
<p>Proofs are functions. There are a few things worth noting here: first, the
return type of this function is an equality (our theorem). Given a natural
<span class="docutils literal"><span class="pre">n</span></span>, the function proves that the equality holds. <span class="docutils literal"><span class="pre">Refl</span></span> is the built-in
reflexivity constructor, which constructs <span class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></span>. For the <span class="docutils literal"><span class="pre">Z</span></span> case, we can
use <span class="docutils literal"><span class="pre">Refl</span></span> to say that <span class="docutils literal"><span class="pre">S</span> <span class="pre">Z</span> <span class="pre">=</span> <span class="pre">Z</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span> which is true by the definition of
<span class="docutils literal"><span class="pre">(+)</span></span>. For the <span class="docutils literal"><span class="pre">(S</span> <span class="pre">k)</span></span> case, we use <span class="docutils literal"><span class="pre">cong</span></span>. <span class="docutils literal"><span class="pre">cong</span></span> is a built in
function that states that equality holds after function application. It’s
signature is <span class="docutils literal"><span class="pre">cong</span> <span class="pre">:</span> <span class="pre">(a</span> <span class="pre">=</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">b</span></span>, which basically means if <span class="docutils literal"><span class="pre">a</span></span> is
equal to <span class="docutils literal"><span class="pre">b</span></span>, then <span class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></span> is equal to <span class="docutils literal"><span class="pre">f</span> <span class="pre">b</span></span>. In our case, we are saying
that if <span class="docutils literal"><span class="pre">addOneProof</span> <span class="pre">k</span></span> holds, then so does <span class="docutils literal"><span class="pre">addOneProof</span> <span class="pre">(S</span> <span class="pre">k)</span></span>, which
allows us to converge on the <span class="docutils literal"><span class="pre">Z</span></span> case.</p>
<p>We now have a proof that <span class="docutils literal"><span class="pre">S</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">S</span> <span class="pre">Z</span></span>. With this, we can prove that the
type <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(k</span> <span class="pre">+</span> <span class="pre">(S</span> <span class="pre">Z))</span> <span class="pre">a</span></span> can be rewritten as <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(S</span> <span class="pre">k)</span> <span class="pre">a</span></span>:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">reverseProof</span> <span class="ow">:</span> <span class="kt">Vect'</span> <span class="ow">(</span>k <span class="ow">+</span> <span class="ow">(</span><span class="kt">S</span> <span class="kt">Z</span><span class="ow">))</span> a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> <span class="ow">(</span><span class="kt">S</span> k<span class="ow">)</span> a
reverseProof <span class="ow">{</span>k<span class="ow">}</span> result <span class="ow">=</span> <span class="kr">rewrite</span> addOneProof k <span class="kr">in</span> result
</pre></div>
</div>
<p>There is some Idris-specific syntax here: <span class="docutils literal"><span class="pre">{k}</span></span> brings <span class="docutils literal"><span class="pre">k</span></span> from the function
declaration in scope, so we can refer to it in the function body even if it is
not passed in as an argument. The <span class="docutils literal"><span class="pre">rewrite</span> <span class="pre">...</span> <span class="pre">in</span></span> expression applies the
equality in the proof above to the input, in this case effectively rewriting
<span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(k</span> <span class="pre">+</span> <span class="pre">(S</span> <span class="pre">Z))</span> <span class="pre">a</span></span> to <span class="docutils literal"><span class="pre">Vect</span> <span class="pre">(S</span> <span class="pre">k)</span> <span class="pre">a</span></span>. Note these proofs are evaluated at
compile time and simply provide information to the type checker. With this
proof, we can implement reverse like this:</p>
<div class="highlight-idris notranslate"><div class="highlight"><pre><span/><span class="nf">reverse'</span> <span class="ow">:</span> <span class="kt">Vect'</span> n a <span class="ow">-&gt;</span> <span class="kt">Vect'</span> n a
reverse' <span class="kt">Nil</span> <span class="ow">=</span> <span class="kt">Nil</span>
reverse' <span class="ow">(</span>x <span class="ow">::</span> xs<span class="ow">)</span> <span class="ow">=</span> reverseProof <span class="ow">(</span>append' <span class="ow">(</span>reverse' xs<span class="ow">)</span> <span class="ow">[</span>x<span class="ow">])</span>
</pre></div>
</div>
<p>This is similar to the previous implementation, we just apply <span class="docutils literal"><span class="pre">reverseProof</span></span>
to the result of <span class="docutils literal"><span class="pre">append'</span></span>. This definition compiles.</p>
</div>
<div class="section" id="thoughts-about-the-future">
<h2>Thoughts About the Future</h2>
<p>Software development is generally driven by economics, where we more often than
not trade correctness for speed to market. But once the software is up and
running, correctness becomes an issue. As code increases in complexity, the
number of issues tends to increase, and the velocity with which changes can be
made without introducing regression drops dramatically. We have various
techniques that aim to maintain stability, like automated testing, but these are
not perfect: a test can prove that for a given input we get an expected output,
but cannot prove that for <em>any</em> input we would get the expected output.</p>
<p>On the other hand, we have solutions that do eliminate entire classes of issues.
An example is typing. Python, Ruby, and JavaScript, all dynamically typed, are
extremely expressive and make it very easy to whip up a proof of concept. But
there is an entire class of type errors which now turns into runtime issues. We
are notoriously bad at predicting what our code does, so the more help we get
from machines to ensure correctness, the better. In a strongly typed language,
even though it takes longer to convince the compiler that the code is type-safe,
this whole class of errors is eliminated. Language evolution over the years
tends to converge towards stronger typing: dynamic languages are augmented with
type checkers (Python has type hints, JavaScript has TypeScript etc.) and
statically typed languages are becoming less verbose as type inference evolves.
There will always be a need for a quick prototype, but code we want to deem
<em>reliable</em> should be typed. This includes a wide range of business-critical
applications where errors are very costly.</p>
<p>I see Idris as the next step beyond this. Totality checking allows the compiler
to guarantee termination, eliminating hangs from the code. First-order types
allows us to push more information to the type-checker, allowing for stricter
type-checking. Proofs, expressed as functions with regular syntax, allow the
compiler to provide formal verification of programs - here, as opposed to unit
tests, we are actually proving that we get the expected output for <em>any</em> input.
These are all tools for writing better, more correct code. As other functional
concepts got adopted over the years into more mainstream languages (for example
first-order functions, anonymous functions, algebraic types etc.), I expect (and
hope) these features to eventually be adopted too.</p>
<p>There is still a lot of room for improvement: writing proofs is tedious,
compiler errors are not always very clear, and, coming back to the speed to
market tradeoff, I doubt we will ever get to entire large applications formally
proven correct (barring some form of proof inference to speed things up by a
couple of orders of magnitude). That being said, I would love to have these
facilities as optional features in other languages and at least have the ability
to prove that the core functionality of a component does what it is supposed to
do, and get a compile break whenever a regression is introduced.</p>
<p>Programming languages are continuously evolving and the future looks exciting!</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Idris also supports functions that produce an infinite stream of values
which can be used with lazy evaluation. The full definition of totality
includes functions which don’t terminate but produce <span class="docutils literal"><span class="pre">Inf</span></span>. This
allows for non-terminating functions, but ensures non-termination is
intentional.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>I am using <span class="docutils literal"><span class="pre">'</span></span> to avoid naming conflicts with the built-in types and
functions. Idris already provides <span class="docutils literal"><span class="pre">Nat</span></span>, <span class="docutils literal"><span class="pre">Vect</span></span>, <span class="docutils literal"><span class="pre">append</span></span> and
<span class="docutils literal"><span class="pre">reverse</span></span>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Thu, 20 Jul 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/07/10/singletons.html</link>
            <guid>http://vladris.com/blog/2017/07/10/singletons.html</guid>
            <title><![CDATA[Singletons]]></title>
            <description><![CDATA[<h1>Singletons</h1>
<div class="section" id="singletons-are-evil">
<h2>Singletons are evil</h2>
<p>I will start off with a word of caution that singletons should be avoided.
Singleton is the object-oriented equivalent of a global variable – a piece of
state which anyone can grab and modify, which makes it hard to reason locally
about code and generates ugly dependency graphs. That being said, in a large
system there are situations where there is a legitimate need for global state or
some component that exposes a service to other components.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation</h2>
<p><a class="reference external" href="https://www.youtube.com/watch?v=23xDn3ReH7E">This CppCon lightning talk</a>
by Arno Lepisk covers some implementation alternatives, suggesting that in most
cases using a namespace and flat functions is the simplest and best way to
implement a singleton:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">namespace</span> <span class="n">Foo</span> <span class="p">{</span>

<span class="kt">void</span> <span class="nf">DoFoo</span><span class="p">();</span>

<span class="p">}</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">DoFoo</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">Foo</span><span class="o">&amp;</span> <span class="nf">UseFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>I completely agree with this, with the caveat that sometimes we do want to
inject dependencies and work against an interface instead of the actual
implementation, in which case the above approach might be insufficient. Note
that unless dependency injection is needed, the default should be a namespace
and flat functions.</p>
</div>
<div class="section" id="dependency-injection">
<h2>Dependency Injection</h2>
<p>Given an interface, an implementation, and a function to retrieve the singleton
like the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">IFoo</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">DoFoo</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">IFoo</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="n">IFoo</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">DoFoo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="p">};</span>

<span class="n">IFoo</span><span class="o">&amp;</span> <span class="nf">UseFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>a common mistake I see is components directly calling the function like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Component</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">UseFoo</span><span class="p">().</span><span class="n">DoFoo</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If the goal is to inject the dependency, for example have tests run against
<span class="docutils literal"><span class="pre">MockFoo</span></span>, this approach is not ideal. Code explicitly calls <span class="docutils literal"><span class="pre">UseFoo</span></span> so the
only way to switch implementation is to modify <span class="docutils literal"><span class="pre">UseFoo</span></span> and provide some
internal mechanism to change its return value. A better approach is to have the
client simply require an interface and provide that at construction time:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Component</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Component</span><span class="p">(</span><span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">UseFoo</span><span class="p">())</span>
        <span class="o">:</span> <span class="n">m_foo</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_foo</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">IFoo</span><span class="o">&amp;</span> <span class="n">m_foo</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that in the above example we can create <span class="docutils literal"><span class="pre">Component</span></span> with a <span class="docutils literal"><span class="pre">MockFoo</span></span>
implementation of <span class="docutils literal"><span class="pre">IFoo</span></span> or some other implementation, which is a better
decoupling than directly calling <span class="docutils literal"><span class="pre">UseFoo</span></span> inside the member functions of
<span class="docutils literal"><span class="pre">Component</span></span>.</p>
</div>
<div class="section" id="magic-statics">
<h2>Magic Statics</h2>
<p>By definition, a singleton should represent a unique object, so our <span class="docutils literal"><span class="pre">UseFoo</span></span>
needs to return the same reference on each call. Ensuring that concurrent calls
from multiple threads don’t cause problems was non-trivial until C++11, which
introduced “magic statics”. Quote from the C++ standard section 6.7:</p>
<blockquote>
<div>… such a variable [with static storage] is initialized the first time
control passes through its declaration; such a variable is considered
initialized upon the completion of its initialization. If the initialization
exits by throwing an exception, the initialization is not complete, so it
will be tried again the next time control enters the declaration. If control
enters the declaration concurrently while the variable is being initialized,
the concurrent execution shall wait for completion of the initialization.</div></blockquote>
<p>The standard now guarantees that a static would only ever be created once, and
the simple way to implement a singleton (for example according to Scott Meyer’s
<a class="reference external" href="https://www.goodreads.com/book/show/22800553-effective-modern-c">Effective Modern C++</a>)
is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">IFoo</span><span class="o">&amp;</span> <span class="nf">UseFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Foo</span> <span class="n">instance</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Or the heap-allocated version:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">IFoo</span><span class="o">&amp;</span> <span class="nf">UseFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="deterministic-shutdown">
<h2>Deterministic shutdown</h2>
<p>A more interesting problem which the above implementation doesn’t cover is
deterministic shutdown. A local static, once created, will be live for the
duration of the program, which might not always be desirable. Building on the
previous implementation, here is a singleton which we can also shutdown on
demand:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">Use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">instance</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_instance</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">m_instance</span><span class="p">;</span>
        <span class="p">}();</span>

        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">Free</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="n">m_instance</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_instance</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_instance</span><span class="p">;</span>

<span class="cm">/* ... */</span>

<span class="n">IFoo</span><span class="o">&amp;</span> <span class="nf">UseFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;::</span><span class="n">Use</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">FreeFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;::</span><span class="n">Free</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using this implementation, we can deterministically free the singleton on demand
via the <span class="docutils literal"><span class="pre">Free</span></span> function as opposed to having to wait for the program to get
unloaded, which can be useful in certain cases.</p>
</div>
<div class="section" id="atomics">
<h2>Atomics</h2>
<p>Magic statics provide an easy way to guarantee we end up with a single object,
but the code generated to support this is non-trivial. Disassembly of the
<span class="docutils literal"><span class="pre">UseFoo</span></span> above as compiled by Clang 4.0.0 with <span class="docutils literal"><span class="pre">-O3</span></span> flag:</p>
<div class="highlight-objdump notranslate"><div class="highlight"><pre><span/><span class="x">UseFoo():                             # @UseFoo()</span>
<span class="x">        push    rbx</span>
<span class="x">        mov     al, byte ptr [rip + guard variable for Singleton&lt;Foo&gt;::Use()::instance]</span>
<span class="x">        test    al, al</span>
<span class="x">        jne     .LBB0_6</span>
<span class="x">        mov     edi, guard variable for Singleton&lt;Foo&gt;::Use()::instance</span>
<span class="x">        call    __cxa_guard_acquire</span>
<span class="x">        test    eax, eax</span>
<span class="x">        je      .LBB0_6</span>
<span class="x">        mov     edi, 8</span>
<span class="x">        call    operator new(unsigned long)</span>
<span class="x">        mov     qword ptr [rax], vtable for Foo+16</span>
<span class="x">        mov     rdi, qword ptr [rip + Singleton&lt;Foo&gt;::m_instance]</span>
<span class="x">        mov     qword ptr [rip + Singleton&lt;Foo&gt;::m_instance], rax</span>
<span class="x">        test    rdi, rdi</span>
<span class="x">        je      .LBB0_5</span>
<span class="x">        mov     rax, qword ptr [rdi]</span>
<span class="x">        call    qword ptr [rax + 8]</span>
<span class="x">        mov     rax, qword ptr [rip + Singleton&lt;Foo&gt;::m_instance]</span>
<span class="x">.LBB0_5:</span>
<span class="x">        mov     qword ptr [rip + Singleton&lt;Foo&gt;::Use()::instance], rax</span>
<span class="x">        mov     edi, guard variable for Singleton&lt;Foo&gt;::Use()::instance</span>
<span class="x">        call    __cxa_guard_release</span>
<span class="x">.LBB0_6:</span>
<span class="x">        mov     rax, qword ptr [rip + Singleton&lt;Foo&gt;::Use()::instance]</span>
<span class="x">        pop     rbx</span>
<span class="x">        ret</span>
<span class="x">        mov     rbx, rax</span>
<span class="x">        mov     edi, guard variable for Singleton&lt;Foo&gt;::Use()::instance</span>
<span class="x">        call    __cxa_guard_abort</span>
<span class="x">        mov     rdi, rbx</span>
<span class="x">        call    _Unwind_Resume</span>
</pre></div>
</div>
<p>A lot of the generated code is the compiler implementing the guarantee that on
concurrent calls, a single intialization is performed. The <span class="docutils literal"><span class="pre">Singleton</span></span>
functions are inlined here since we are compiling with <span class="docutils literal"><span class="pre">-O3</span></span>. We can provide a
much more efficient implementation using an atomic pointer on architectures
where atomics are lock-free and we are not worried about redundantly calling the
constructor in the rare cases of concurrent access that requires
initialization:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">Use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_instance</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">instance</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>

        <span class="k">delete</span> <span class="n">instance</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_instance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">Free</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">m_instance</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_instance</span><span class="p">;</span>

<span class="cm">/* ... */</span>

<span class="n">IFoo</span><span class="o">&amp;</span> <span class="nf">UseFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;::</span><span class="n">Use</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">FreeFoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;::</span><span class="n">Free</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The disassembly of the above <span class="docutils literal"><span class="pre">UseFoo</span></span> (built with the same compiler and
<span class="docutils literal"><span class="pre">-O3</span></span> flag) is:</p>
<div class="highlight-objdump notranslate"><div class="highlight"><pre><span/><span class="x">UseFoo():                             # @UseFoo()</span>
<span class="x">        push    rax</span>
<span class="x">        mov     rcx, qword ptr [rip + Singleton&lt;Foo&gt;::m_instance]</span>
<span class="x">        test    rcx, rcx</span>
<span class="x">        jne     .LBB0_3</span>
<span class="x">        mov     edi, 8</span>
<span class="x">        call    operator new(unsigned long)</span>
<span class="x">        mov     rcx, rax</span>
<span class="x">        mov     qword ptr [rcx], vtable for Foo+16</span>
<span class="x">        xor     eax, eax</span>
<span class="x">        lock</span>
<span class="x">        cmpxchg qword ptr [rip + Singleton&lt;Foo&gt;::m_instance], rcx</span>
<span class="x">        je      .LBB0_3</span>
<span class="x">        mov     rax, qword ptr [rcx]</span>
<span class="x">        mov     rdi, rcx</span>
<span class="x">        call    qword ptr [rax + 8]</span>
<span class="x">        mov     rcx, qword ptr [rip + Singleton&lt;Foo&gt;::m_instance]</span>
<span class="x">.LBB0_3:</span>
<span class="x">        mov     rax, rcx</span>
<span class="x">        pop     rcx</span>
<span class="x">        ret</span>
</pre></div>
</div>
<p>This code might new the object multiple times, but is guaranteed to always
return the same instance and retrieving it is more efficient than relying on
statics, since it uses a compare-exchange to guarantee uniqueness. Many thanks
to my colleague Vladimir Morozov who suggested this approach.</p>
</div>
<div class="section" id="tri-state">
<h2>Tri-state</h2>
<p>We now have an efficient way to create and shutdown a singleton. If shutdown, a
subsequent call to <span class="docutils literal"><span class="pre">Use</span></span> would re-create the object. One optional feature we
can add is to enforce that once shutdown, a singleton should never be accessed
again. So instead of the two-state <em>not initialized</em> and <em>live</em>, we can use
three states: <em>not initialized</em>, <em>live</em>, <em>freed</em> and terminate if an access
is attempted in the <em>freed</em> state:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">uintptr_t</span> <span class="n">FreedSingleton</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">Use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">Get</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">FreedSingleton</span><span class="p">))</span>
            <span class="n">terminate</span><span class="p">();</span>

        <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">Free</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">FreedSingleton</span><span class="p">));</span>
        <span class="k">delete</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">T</span><span class="o">*</span> <span class="n">Get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_instance</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">instance</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>

        <span class="k">delete</span> <span class="n">instance</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">m_instance</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">m_instance</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_instance</span><span class="p">;</span>
</pre></div>
</div>
<p>We now have an efficient generic singleton which we can shutdown on-demand and
ensure clients never call after shutdown.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Try not to use singletons, singletons are evil</li>
<li>In most cases, a namespace and flat functions are enough, no need to
over-complicate things</li>
<li>If dependency injection is required, make sure dependency is properly injected
during construction as opposed to member functions directly calling the
singleton-retrieving function</li>
<li>Magic statics provide an easy way to implement singletons</li>
<li>Atomics are more efficient than magic statics when they are lock-free and we
aren’t worried about potentially having multiple constructor calls in race
cases</li>
<li>If needed, singletons can be extended with a shutdown mechanism</li>
<li>Three-state singletons can terminate on use-after-shutdown</li>
</ul>
</div>
]]></description>
             <pubDate>Mon, 10 Jul 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/04/07/data-structures-and-algorithms.html</link>
            <guid>http://vladris.com/blog/2017/04/07/data-structures-and-algorithms.html</guid>
            <title><![CDATA[Data Structures and Algorithms]]></title>
            <description><![CDATA[<h1>Data Structures and Algorithms</h1>
<p>“Data Structures and Algorithms” is one of the basic CS courses. Data structures
and algorithms are also the building blocks of software. In this post I will
give a quick overview of data structures, algorithms, and cover <em>iterators</em>,
which bridge the two together.</p>
<div class="section" id="data-structures">
<h2>Data Structures</h2>
<p>As the name implies, data structures provide a way of structuring data, in other
words, they maintain some set of relationships between the contained elements.
Data structures are built around expected access/update patterns and encapsulate
the inherent tradeoffs. For example, a queue models FIFO access (so accessing
the last inserted element requires dequeuing all elements which is <span class="docutils literal"><span class="pre">O(n)</span></span> for
<span class="docutils literal"><span class="pre">n</span></span> elements) while a stack models the opposite LIFO access (which can access
the last inserted element in <span class="docutils literal"><span class="pre">O(1)</span></span> but conversely makes accessing the first
element <span class="docutils literal"><span class="pre">O(n)</span></span> for <span class="docutils literal"><span class="pre">n</span></span> elements). A deque allows elements to be inserted and
removed from both front and back, but not from the middle. On the other hand,
inserting an element in a forward list (where each node starting form head has a
pointer to its successor) can be done anywhere, but requires a traversal of the
data structure up to the insertion point (<span class="docutils literal"><span class="pre">O(n)</span></span>).</p>
<p>More complex data structures exist which model more complex relationships
between elements, for example graphs and trees.</p>
<p>In practice, while there are always complex situations which require the use or
development of exotic data structure, I consider those to be exceptions - a few
basic data structures are enough to solve most problems. In fact, in most cases,
simple linear data structures like lists are sufficient.</p>
<p>It’s worth noting that the relationships and access patterns modeled by a data
structure do not have anything to do with the type of the contained data. A
queue of integers or a queue of strings work in exactly the same way. Generics
provide a great mechanism to separate the organizing structure from the data
itself. Thus the C++ <span class="docutils literal"><span class="pre">std::vector&lt;T&gt;</span></span> can provide a generic implementation of
a heap array for any type <span class="docutils literal"><span class="pre">T</span></span>, the same way a C# <span class="docutils literal"><span class="pre">List&lt;T&gt;</span></span> does. These
generic data structure model how the contained elements are laid out, but work
with any provided type.</p>
</div>
<div class="section" id="algorithms">
<h2>Algorithms</h2>
<p>The dictionary definition of an algorithm is:</p>
<blockquote>
<div>noun: a process or set of rules to be followed in calculations or other
problem-solving operations, especially by a computer.</div></blockquote>
<p>There is a set of basic functions we can put our data through: search,
partition, rotate, sort, map, reduce, filter and so on. These functions can be
implemented in several ways, depending on the characteristics of the input. For
example, we can search for an element in <span class="docutils literal"><span class="pre">O(log</span> <span class="pre">n)</span></span> time if our input is
sorted and we can access it from the “middle” at no extra cost. On the other
hand, given unsorted data or a data structure like a forward list which we can
only access through its head, search becomes an <span class="docutils literal"><span class="pre">O(n)</span></span> operation. The
implementations of these functions are what we call algorithms. In the examples
above the algorithms are <em>binary search</em> and <em>linear search</em>.</p>
<p>The same observation as with data structures applies: while there are complex
problems which require the development of brand new algorithms, in practice,
the vast majority of processing that we want to perform on our data can be
expressed either as a simple algorithm or a composition of simple algorithms.</p>
<p>It is also interesting to note that the algorithms themselves are not tied to a
particular data type either, rather they only require certain characteristics of
their input. So we can perform a search as long as there is some equivalence
relation defined for the input data. Similarly, we can perform a sort as long as
there is a total order relation defined on the input type. It doesn’t really
matter whether we search for numbers or strings, the steps we take are the same.</p>
<p>Generics help here too, since they allow us to conceptually separate the
implementation of the algorithm (the steps) from the data we are operating on.
So the C++ <span class="docutils literal"><span class="pre">std::partition</span></span> algorithm can partition any input – given by a
pair of forward iterators using any given predicate. Similarly, the C# LINQ
<span class="docutils literal"><span class="pre">Select</span></span> (known in most other languages as a <span class="docutils literal"><span class="pre">map</span></span> operation), transforms
all input values into output values given a mapping function from the input type
to the output type. We don’t need to implement a partition for ints, one for
strings, and one for dates, we need a generic partition which implements the
steps of the algorithm and works with any given data type.</p>
</div>
<div class="section" id="iterators-and-ranges">
<h2>Iterators and Ranges</h2>
<p>Iterators act as the bridge between data structures and algorithms. Iterators
traverse a given data structure in a linear fashion, such that an algorithm can
process the input in a consistent manner, regardless of the actual layout of the
data. Note the data structure itself does not need to be a linear one: a binary
tree can be traversed with a preorder iterator, or an inorder iterator, or a
postorder iterator.</p>
<p>Algorithms work on ranges of data, which can be defined as a pair of iterators
(beginning and end) or an iterator and the number of available elements
(beginning and length). I will cover some of the C++ iterator concepts since
they are the most fleshed out. Other languages usually rely on a subset of
these.</p>
<p><strong>Input iterators</strong> can only be advanced and are one-pass only. These map to
input streams, for example unbuffered keyboard input where data can be read
once, but a subsequent read would yield different data.</p>
<p><strong>Forward iterators</strong> extend input iterators to multiple passes. For example, a
forward iterator models traversal of a forward list. We can always re-start
traversal from any saved position, but we cannot move back (since nodes only
have links to successors, not predecessors).</p>
<p><strong>Bidirectional iterators</strong> extend forward iterators to bidirectional access.
For example, a bidirectional iterator models traversal of a doubly linked list.
Here, we can move from one node in either direction – to its predecessor or to
its successor.</p>
<p><strong>Random access iterators</strong> extend bidirectional iterators to random access,
meaning any element can be accessed in constant time. For example, a random
access iterator models traversal of an array. Here, we can access any element at
the same cost, since we don’t need to perform any traversal, simply index into
the array.</p>
<p>Depending on the implementation of a given algorithm, different iterator types
might be required. The same function can sometimes be implemented with several
algorithms, having a more efficient version work with more capable iterators and
an alternative algorithm for less capable iterators. For example we can
implement an <span class="docutils literal"><span class="pre">O(n</span> <span class="pre">log</span> <span class="pre">n)</span></span> quicksort with a random access iterator but we can
also implement an <span class="docutils literal"><span class="pre">O(n^2)</span></span> bubblesort that works with forward iterators.</p>
<p><span class="docutils literal"><span class="pre">IEnumerator&lt;T&gt;</span></span> in C# models a forward iterator. The (simplified) interface
is:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">Current</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">Reset</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This allows us to advance the iterator and to reset it to the initial position
and re-start traversal, which is exactly what a forward iterator does.</p>
<p>Lazy evaluation in some functional languages and generators (functions that
yield results) model input iterators which can be advanced in a single pass.</p>
<p>While most relevant operations can be implemented with input iterators, the
resulting algorithms are not very efficient. For example, with a bidirectional
iterator, <span class="docutils literal"><span class="pre">reverse</span></span> can be implemented in <span class="docutils literal"><span class="pre">O(1)</span></span> space by starting from both
ends and swapping elements. On the other hand, given an input iterator,
<span class="docutils literal"><span class="pre">reverse</span></span> requires <span class="docutils literal"><span class="pre">O(n)</span></span> space as elements need to be pushed onto a stack
and popped in reverse order.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<ul class="simple">
<li>Data structures model the relationship between elements and encapsulate access
patterns. Generic data structures provide a good abstraction decoupling the
structure of the data from the actual contianed data.</li>
<li>Algorithms implement operations over data. Algorithms are grouped together
based on the function or transformation they implement. Generic algorithms
abstract the operational steps from the input the algorithms operate on.</li>
<li>Iterators provide a bridge between data structures and algorithms. The more
capabilities an iterator has (ie. the more restrictions we impose on the
input), the more efficient the algorithm can be. Similarly, most operations
can be implemented in less efficent manners (time and space-wise) on iterators
with fewer capabilities (ie. fewer restrictions imposed on the input).</li>
</ul>
<p>Recommended reading:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.goodreads.com/book/show/23498372-from-mathematics-to-generic-programming">From Mathematics to Generic Programming</a>
by Alexander A. Stepanov and Daniel E. Rose</li>
<li><a class="reference external" href="https://www.goodreads.com/book/show/6142482-elements-of-programming">Elements of Programming</a>
by Alexander A. Stepanov and Paul McJones</li>
</ul>
</div>
]]></description>
             <pubDate>Fri, 07 Apr 2017 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/02/25/a-heterogeneous-event-store.html</link>
            <guid>http://vladris.com/blog/2017/02/25/a-heterogeneous-event-store.html</guid>
            <title><![CDATA[A Heterogeneous Event Store]]></title>
            <description><![CDATA[<h1>A Heterogeneous Event Store</h1>
<p>I recently stumbled upon a heterogeneous event collection which turned out to
pose an interesting design problem. We are using library code (we can’t change)
that provides a templated <span class="docutils literal"><span class="pre">Event</span></span> to which we can register callbacks and
which we can raise later to invoke the callbacks. The interface looks like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cm">/* Library code */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Event</span>
<span class="p">{</span>
    <span class="c1">// T is a callable object, like std::function</span>
    <span class="kt">void</span> <span class="nf">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Register a callback */</span> <span class="p">}</span>

    <span class="c1">// Raises the event and forwards the arguments to the callbacks</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Invoke all registered callbacks */</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A stub implementation that validates client code is typed properly would be:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Event</span>
<span class="p">{</span>
    <span class="c1">// T is a callable object, like std::function</span>
    <span class="kt">void</span> <span class="nf">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Register a callback */</span>
        <span class="n">_callback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Raises the event and forwards the arguments to the callbacks</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Invoke all registered callbacks */</span>
        <span class="n">_callback</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">_callback</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that unlike the real implementation, this only stores the last registered
event, but that is irrelevant for the purpose of this post. I’m providing the
code just to have something to compile against (otherwise <span class="docutils literal"><span class="pre">Raise</span></span> would
happily swallow any combination of arguments passed to it). In reality, a more
complex implementation would maintain a list of callbacks, but this is
sufficient for framing the design problem.</p>
<p>The event collection which was wrapping a set of library events looked like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">using</span> <span class="n">LaunchCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">SaveCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ExitCallback</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">OnLaunch</span><span class="p">(</span><span class="n">LaunchCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_launchEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">OnSave</span><span class="p">(</span><span class="n">SaveCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_saveEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">OnExit</span><span class="p">(</span><span class="n">ExitCallback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_exitEvent</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseLaunch</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_launchEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseSave</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fileName</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_saveEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RaiseExit</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_exitEvent</span><span class="p">.</span><span class="n">Raise</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span> <span class="n">m_launchEvent</span><span class="p">;</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span> <span class="n">m_saveEvent</span><span class="p">;</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;</span> <span class="n">m_exitEvent</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sample usage of the <span class="docutils literal"><span class="pre">EventStore</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">OnLaunch</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">OnSave</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">RaiseSave</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>Looking at <span class="docutils literal"><span class="pre">EventStore</span></span>, it’s obvious that there is a lot of repetition
involved: hooking up a new event involves aliasing a new callback, adding a new
member to the class, and adding the corresponding registration and <span class="docutils literal"><span class="pre">Raise</span></span>
member functions which end up being copy/pastes of the other ones. There must
be a better way!</p>
<p>An initial idea would be to use some sort of associative container (hopefully
something <a class="reference external" href="http://vladris.com/blog/2016/04/24/abusing-maps.html">better than an unordered_map</a>),
but there is an interesting complication due to the fact that some of the
various events are actually of different types. <span class="docutils literal"><span class="pre">Event&lt;std::function&lt;void()&gt;&gt;</span></span>
has a different type than <span class="docutils literal"><span class="pre">Event&lt;std::function&lt;void(const</span> <span class="pre">string&amp;)&gt;&gt;</span></span>. There
are potential workarounds to explore, like standardizing on a single type and
requiring clients to, for example, only use callbacks that do not take any
arguments. Another option would be to pass in some base object to each event
and let each callback re-interpret it. This takes us down the wrong path though.
We don’t need to do any runtime lookup - the initial code doesn’t.</p>
<p>From the repetition in <span class="docutils literal"><span class="pre">EventStore</span></span>, it should become apparent that we need
some form of templated <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> that would work for each type
of event we care about. A quick sketch of our function signatures should look
something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="cm">/* ??? */</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="cm">/* ??? */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Register callback to the appropriate event</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="cm">/* ??? */</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Raise the appropriate event, forwarding args to it</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is also clear that we need a way to store all of the events we need in our
class. Since they are of heterogeneous types, we can’t store them in a map or
equivalent, but we don’t need to. <span class="docutils literal"><span class="pre">std::tuple</span></span> was build exactly for this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>Now the only remaining question is how to templatize our two member functions to
enable a lookup in the tuple. One approach would be to use an enum:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">EventType</span> <span class="o">:</span> <span class="kt">size_t</span>
<span class="p">{</span>
    <span class="n">LaunchEvent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">SaveEvent</span><span class="p">,</span>
    <span class="n">ExitEvent</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Given this enum, we can templatize on its values:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">EventType</span> <span class="n">eventType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">eventType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="n">EventType</span> <span class="n">eventType</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">eventType</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">LaunchCallback</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">Event</span><span class="o">&lt;</span><span class="n">SaveCallback</span><span class="o">&gt;</span><span class="p">,</span>
               <span class="n">Event</span><span class="o">&lt;</span><span class="n">ExitCallback</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Callers can use this new implementation like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">LaunchEvent</span><span class="o">&gt;</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">Raise</span><span class="o">&lt;</span><span class="n">EventType</span><span class="o">::</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>With this implementation, we preserve the ability to have polymorphic events but
only need to implement the <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> functions. Adding a new
event type now only requires aliasing the callback, adding an enum member, and
extending our member tuple by adding the new <span class="docutils literal"><span class="pre">Event</span></span> to it.</p>
<p>The only drawback of this approach is the fact that we need to manually keep the
enum and the tuple in sync. This is not too bad, because if we try to call
<span class="docutils literal"><span class="pre">std::get</span></span> with a number higher than the size of the tuple, we get a compile
time error. If we accidentally swap two events, if they are of incompatible
types (for example <span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span> and <span class="docutils literal"><span class="pre">Event&lt;SaveCallback&gt;</span></span>, as one
expects callbacks of type <span class="docutils literal"><span class="pre">std::function&lt;void()&gt;</span></span> and the other expects
<span class="docutils literal"><span class="pre">std::function&lt;void(const</span> <span class="pre">std::string&amp;)&gt;</span></span>), we get a compile-time error
because <span class="docutils literal"><span class="pre">Register</span></span> and <span class="docutils literal"><span class="pre">Raise</span></span> calls would fail to compile (attempting to
pass in callback/arguments of incompatible types). If we accidentally swap two
events of the same type, (<span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span> and <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span>,
since both <span class="docutils literal"><span class="pre">LaunchCallback</span></span> and <span class="docutils literal"><span class="pre">ExitCallback</span></span> are aliased to the same
<span class="docutils literal"><span class="pre">std::function&lt;void()&gt;</span></span>), runtime behavior is equivalent, it just makes
reading the code confusing. Now we end up storing launch callbacks inside what
we called <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span> and vice-versa. Runtime is not affected, as we
would also raise <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span> by calling
<span class="docutils literal"><span class="pre">Raise&lt;EventType::LaunchEvent&gt;</span></span>, but it’s not ideal. We could drop the aliases
altogether and simply have:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
           <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>This solves the above issues but is not very readable. There are other options,
like picking different names for the aliases - instead of naming the event, have
them name the type of callback. Either way, effectively what we are doing is a
mapping from an enum into a set of <span class="docutils literal"><span class="pre">Event</span></span> types. We can actually push more
information to the type system and get rid of the need to do this mapping. We do
that by making sure our events are always of different types, even if the
callback signatures are the same. One way of achieving this is wrapping
<span class="docutils literal"><span class="pre">Event</span></span> and defining different types for each of our events:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">EventWrapper</span>
<span class="p">{</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">m_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">LaunchEvent</span> <span class="o">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">SaveEvent</span> <span class="o">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">ExitEvent</span> <span class="o">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
</pre></div>
</div>
<p>Note this is type information used only by the compiler and doesn’t bring any
runtime overhead to our code. Inheritance is used here just so we don’t have to
repeat declaring <span class="docutils literal"><span class="pre">m_event</span></span>, we could have just as well declared each struct
independently. Now we can update the member tuple to store an event of each of
these types:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="p">,</span> <span class="n">SaveEvent</span><span class="p">,</span> <span class="n">ExitEvent</span><span class="o">&gt;</span> <span class="n">m_events</span><span class="p">;</span>
</pre></div>
</div>
<p>Since they are of different types, we no longer need an enum to index into the
tuple, we can do it by type (note <span class="docutils literal"><span class="pre">std::get</span></span> indexed by type requires that the
tuple contains distinct types, which is not the case for <span class="docutils literal"><span class="pre">Event&lt;LaunchCallback&gt;</span></span>
and <span class="docutils literal"><span class="pre">Event&lt;ExitCallback&gt;</span></span>, but it is for <span class="docutils literal"><span class="pre">LaunchEvent</span></span> and <span class="docutils literal"><span class="pre">ExitEvent</span></span>):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Callback</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">Callback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">Callback</span></span> template argument in <span class="docutils literal"><span class="pre">Register</span></span> can be deduced once <span class="docutils literal"><span class="pre">T</span></span> is
specified. The full implementation is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">EventWrapper</span>
<span class="p">{</span>
    <span class="n">Event</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">m_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">LaunchEvent</span> <span class="o">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">SaveEvent</span> <span class="o">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">ExitEvent</span> <span class="o">:</span> <span class="n">EventWrapper</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">EventStore</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Callback</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Register</span><span class="p">(</span><span class="n">Callback</span><span class="o">&amp;&amp;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callback</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">Raise</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_events</span><span class="p">).</span><span class="n">m_event</span><span class="p">.</span><span class="n">Raise</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="p">,</span> <span class="n">SaveEvent</span><span class="p">,</span> <span class="n">ExitEvent</span><span class="o">&gt;</span> <span class="n">m_events</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Callers can use it like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">EventStore</span> <span class="n">store</span><span class="p">;</span>

<span class="c1">// Register a couple of callbacks</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">LaunchEvent</span><span class="o">&gt;</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>
<span class="n">store</span><span class="p">.</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Do stuff */</span> <span class="p">});</span>

<span class="c1">// Raise an event</span>
<span class="n">store</span><span class="p">.</span><span class="n">Raise</span><span class="o">&lt;</span><span class="n">SaveEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Some file name"</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, adding a new event requires declaring a new struct and adding it
to the tuple. Since we are retrieving the event by its type, no mapping is
involved.</p>
]]></description>
             <pubDate>Sat, 25 Feb 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2017/02/20/memory-management.html</link>
            <guid>http://vladris.com/blog/2017/02/20/memory-management.html</guid>
            <title><![CDATA[Memory Management]]></title>
            <description><![CDATA[<div class="section" id="memory-management">
<h1>Memory Management</h1>
<p>Memory management involves handling memory resources allocated for a certain
task, ensuring that the memory is freed once it is no longer needed so it can
be reused for some other task. If the memory is not freed in a timely manner,
the system might run out of resources or incur degraded performance. A memory
resource that is never freed once no longer needed is called a leak - the
resource becomes unusable, usually for the duration of the process. Another
issue is <em>use after free</em>, in which a memory resource that was already freed
is used as if it wasn’t. This usually causes unexpected behavior as the code
is trying to read, modify or wrongly interpret data at a memory location.
Memory management can be <em>manual</em> - with code explicitly handling
deallocation, or <em>automatic</em>, in which memory gets freed once no longer needed
by an automated process.</p>
<div class="section" id="manual-memory-management">
<h2>Manual Memory Management</h2>
<p>Manual memory management is efficient, since allocations and deallocations
don’t incur any overhead. In C:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_Foo</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span>

<span class="p">...</span>

<span class="n">free</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>The disadvantage of this approach, and the main reason automatic memory
management models were invented, is that this puts the developer in charge of
making sure memory doesn’t leak and that it is not used after it is freed. As
the complexity of the code increases, this becomes increasingly difficult. As
pointers are passed around the system and get stored in various data structures,
it becomes difficult to know given some pointer that is no longer needed
whether: a) this was the very last piece of code that actually needed to access
the location pointed to by this pointer, in which case the memory should be
freed, and b) whether the memory this pointer is pointing to is still valid and
hasn’t been freed previously.</p>
</div>
<div class="section" id="automatic-memory-management">
<h2>Automatic Memory Management</h2>
<p>Automatic memory management attempts to move the responsibility of tracking
when a memory resource is no longer needed (and handling its deallocation) from
the developer to the system. Such a system is called <em>garbage collected</em>, as
memory that is no longer needed (“garbage”) is reclaimed by the system
automatically. The two most popular methods used to automatically free memory
are <em>tracing garbage collectors</em> and <em>reference counting</em>.</p>
<div class="section" id="tracing-garbage-collector">
<h3>Tracing Garbage Collector</h3>
<p>Tracing garbage collectors work by tracing references to objects on the heap
and checking whether a given resource allocated on the heap has at least one
reference path to it from the stack. If such a path exists, it means that from
the stack (an argument to a function, a local variable), there is a way to
perform a set of dereference and access the memory resource. If such a path
doesn’t exist, it means the memory is unreachable, so regardless of how
executing code accesses other objects on the heap, there is no way to access
this resource - which means the memory can be safely deallocated.</p>
<p>For example, a naïve tracing garbage collection algorithm, <em>mark-and-sweep</em>,
involves adding an “in-use” bit to each memory resource allocated then, during
collection, following all references starting from the stack and marking each as
“in-use”. Once all used resources are marked, the sweep stage involves walking
the whole heap and for each memory resource, if not marked as “in-use”, freeing
it.</p>
<p>Tracing garbage collectors are used by many popular runtimes, like JVM and .NET.
In C#:</p>
<div class="highlight-C# notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Bar</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">struct</span> <span class="nc">Foo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">bar</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>

    <span class="c1">// there is no stack variable pointing to the Bar object, but it can</span>
    <span class="c1">// still be reached through foo (foo.bar), so there exists a path from</span>
    <span class="c1">// the stack to it, meaning code can still access it.</span>
<span class="p">}</span>

<span class="c1">// foo goes out of scope which means neither foo nor its member Bar can be</span>
<span class="c1">// accessed any longer, so they can be safely collected</span>
</pre></div>
</div>
<p>There are a couple of disadvantages with the tracing GC approach: first, the
system needs to ensure memory resources are not being allocated while a garbage
collection is taking place. This means code execution is paused during
collection, which obviously impacts performance. The second disadvantage of
this approach is that the system is not as lean as other memory management
models: memory resources are kept allocated longer than really needed, for the
time interval between the last reference to them goes out of scope until the
actual collection is performed.</p>
</div>
<div class="section" id="reference-counting">
<h3>Reference Counting</h3>
<p>An alternative to tracing garbage collectors is reference counting. As the name
implies, a memory resource in such a system has an associated reference count -
the number of references to it. As soon as the last reference goes out of scope,
when the reference count reaches zero, the memory can be safely deallocated.
Unlike tracing, reference counting is performed as code executes: the count of a
given memory resource is automatically increased with each assignment where the
resource is on the right-hand-side, and is automatically decreased whenever a
reference goes out of scope.</p>
<p>Python manages memory using reference counting:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>

<span class="c1"># allocate Foo, its reference count is 1</span>
<span class="n">foo1</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="c1"># reference count is 2 after assignment</span>
<span class="n">foo2</span> <span class="o">=</span> <span class="n">foo1</span>

<span class="o">...</span>
<span class="c1"># once foo1 and foo2 go out of scope, reference count becomes 0 and memory</span>
<span class="c1"># is automatically freed</span>
</pre></div>
</div>
<p>C++ smart pointers work in a similar manner:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="p">...</span>

<span class="c1">// foo1 is a shared_ptr pointing to a Foo stored on the heap. Reference</span>
<span class="c1">// count for the Foo object is 1</span>
<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// reference count becomes 2 after assignment</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>

<span class="p">...</span>
<span class="c1">// Once foo1 and foo2 go out of scope, reference count becomes 0 and memory</span>
<span class="c1">// is automatically freed</span>
</pre></div>
</div>
<p>The main advantages over tracing garbage collection are the fact that execution
doesn’t need to be paused in order to reclaim memory and that resources are
deallocated as soon as they are no longer used (once reference count becomes 0).
There are also several disadvantages with this approach: first, each memory
resource needs to store an additional reference count and updating the reference
count in a multi-threaded environment needs to be performed atomically. Second,
and most important, this memory management model does not handle <em>reference
cycles</em>.</p>
<p>Reference cycles occur when two heap objects hold references to each other even
after no longer being reachable from the stack. In this case, a tracing garbage
collector would mark the objects as being unreachable and deallocate them, but
simple reference counting would not be able to identify this - from that point
of view, each object is being referred to by another object thus it should not
be collected. Example of reference cycle in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span> <span class="k">pass</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(),</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">other</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
<span class="c1"># a.other holds a reference to b, b.other holds a reference to a</span>
<span class="c1"># even when a and b go out of scope, the "other" attributes still hold references</span>
<span class="c1"># to the objects so their reference count would not drop to 0</span>
</pre></div>
</div>
<p>A similar example in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">foo1</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo2</span><span class="p">;</span>
<span class="n">foo2</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>
<span class="c1">// there are two references to each Foo object: foo1 and foo2-&gt;other for the first</span>
<span class="c1">// object, foo2 and foo1-&gt;other for the second object. Even if the foo1 and foo2</span>
<span class="c1">// variables go out of scope, neither of the objects would be collected due to the</span>
<span class="c1">// extra reference</span>
</pre></div>
</div>
<p>Python and C++ solve this problem in different ways: Python supplements reference
counting with a tracing garbage collector. So while most of the memory
management is done via reference counting, a tracing garbage collector is still
employed to clean up cycles like in the above example. This hybrid approach has
he pros and cons of both of the mechanisms discussed above. C++ avoids the
execution pauses a tracing garbage collectors would create by, instead,
leveraging <em>weak references</em>. Weak or non-owning references point to an object
but do not prevent it from being collected when all <em>strong</em> references go away.
There are several ways to express a non-owning reference, with different
advantages and drawbacks:</p>
<ul class="simple">
<li>A <span class="docutils literal"><span class="pre">&amp;</span></span> reference has to be assigned on construction and cannot be re-assigned
after being bound to an object. If used after the underlying object was
destroyed, it causes undefined behavior.</li>
<li>A <span class="docutils literal"><span class="pre">*</span></span> pointer can be <span class="docutils literal"><span class="pre">nullptr</span></span>-initialized and assigned later or
re-assigned. Similarly, if used after the pointed-to object was destroyed,
causes undefined behavior.</li>
<li>A <span class="docutils literal"><span class="pre">weak_ptr&lt;T&gt;</span></span> is a standard library type implementing a non-owning
reference. A <span class="docutils literal"><span class="pre">weak_ptr</span></span> can be converted to a <span class="docutils literal"><span class="pre">shared_ptr</span></span> (using  its
<span class="docutils literal"><span class="pre">lock()</span></span> method). If there is no strong (<span class="docutils literal"><span class="pre">shared_ptr</span></span>) reference to an
object it gets destroyed, regardless of how many <span class="docutils literal"><span class="pre">weak_ptr</span></span> instances point
to it. But once a <span class="docutils literal"><span class="pre">weak_ptr</span></span> successfully locks an object, it creates a
strong reference which ensures the object is kept alive. The drawback of
using <span class="docutils literal"><span class="pre">weak_ptr</span></span> is additional overhead: the control block of a smart
pointer needs to store both strong and weak reference count (with similar
atomic reference counting), and, even if an object gets destroyed because all
strong references went out of scope, the control block stays alive until all
weak references go away too.</li>
</ul>
<p>Updating the <span class="docutils literal"><span class="pre">Foo</span></span> struct in the example above to use a <span class="docutils literal"><span class="pre">weak_ptr</span></span> instead,
the reference cycle is avoided:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">foo2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">foo1</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo2</span><span class="p">;</span>
<span class="n">foo2</span><span class="o">-&gt;</span><span class="n">other</span> <span class="o">=</span> <span class="n">foo1</span><span class="p">;</span>
<span class="c1">// now the two Foo objects have only one strong reference to them through</span>
<span class="c1">// the foo1 and foo2 variables The other pointers are weak references which</span>
<span class="c1">// won't prevent the objects from being destroyed when foo1 and foo2 go out</span>
<span class="c1">// of scope</span>
</pre></div>
</div>
</div>
<div class="section" id="ownership-and-lifetimes">
<h3>Ownership and Lifetimes</h3>
<p>An alternative way to think about heap objects is in terms of <em>ownership</em> and
<em>lifetime</em>. In this model, a heap object is uniquely owned by some other object
and gets freed automatically when the owner is destructed. In C++, this is
achieved through <span class="docutils literal"><span class="pre">unique_ptr</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">struct</span> <span class="nc">Bar</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// this creates a Foo object on the heap, owned by bar</span>
<span class="p">}</span>
<span class="c1">// the heap object gets freed once bar gets freed</span>
</pre></div>
</div>
<p>Ownership of the object can be transferred by moving the <span class="docutils literal"><span class="pre">unique_ptr</span></span>. The
main advantage of this model is that it has no overhead - unlike tracing memory
which involves pausing execution or reference counting which involves atomic
count of references, a <span class="docutils literal"><span class="pre">unique_ptr</span></span> is just a wrapper over a pointer.</p>
<p>Unique pointers cannot be copied though (by definition, otherwise there would
no longer denote unique ownership), so when other code needs to access the heap
object, it would need to get a reference from the owning object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">UseFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>

<span class="n">UseFoo</span><span class="p">(</span><span class="o">*</span><span class="n">bar</span><span class="p">.</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>The problem with this approach is that if another object ends up holding on to a
reference which outlives the owning object, the reference becomes dangling and
refers to an object which was already freed. This becomes the equivalent of a
<em>use after free</em>, so here is where the concept of <em>lifetime</em> becomes important:
none of the non-owning references of a uniquely owned heap object should outlive
the object.</p>
<p>Unfortunately in C++ this has to be handled through sensical design and is
mostly left up to the developer. Rust on the other hand provides strong static
analysis and lifetime annotations to ensure such issues do not occur. In fact,
the default in Rust is to have uniquely owned objects which can be “borrowed”
when needed and static analysis ensures no dangling references appear. In C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">struct</span> <span class="nc">Bar</span><span class="p">{</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">bar</span><span class="p">.</span><span class="n">foo</span> <span class="o">=</span> <span class="o">*</span><span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// bar.foo is now a dangling pointer since Foo was freed</span>
</pre></div>
</div>
<p>The above example used a pointer for simplicity, since a <span class="docutils literal"><span class="pre">&amp;</span></span> reference
(<span class="docutils literal"><span class="pre">Foo&amp;</span></span>) needs to be bound at construction time, but same applies for
that type of reference: once an object gets freed, &amp; references and
non-owning pointers to it are left dangling. On the other hand, this does
not compile in Rust:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="k">struct</span> <span class="nc">Bar</span><span class="o">&lt;'</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="o">'</span><span class="na">a</span> <span class="nc">Foo</span><span class="w"/>
<span class="p">}</span><span class="w"/>

<span class="o">..</span><span class="p">.</span><span class="w"/>

<span class="kd">let</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"/>
<span class="p">{</span><span class="w"/>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{};</span><span class="w"/>
<span class="w">    </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">foo</span>: <span class="kp">&amp;</span><span class="nc">foo</span><span class="w"> </span><span class="p">};</span><span class="w"/>
<span class="p">}</span><span class="w"/>
<span class="c1">// compiler correctly shows `foo` dropped here while still borrowed</span>
</pre></div>
</div>
<p>In Rust, the compiler ensures dangling references (“borrowed” objects) do not
exist once owning object goes out of scope.</p>
<p>It seems that in most cases, the best approach to memory management is to use
the latter model of ownership and lifetimes which comes with no runtime
overhead and handle the dangling reference problem through static analysis.
The advantages of this approach extend beyond the runtime cost of other
automatic memory management techniques to a model which also works well in a
multi-threaded environment, eg. if we only allow the owner of an object to
modify it, we can eliminate certain data races. From a systems design
perspective it is also an advantage to have a clear understanding of ownership
throughout the system.</p>
</div>
</div>
</div>
<div class="section" id="summary">
<h1>Summary</h1>
<p>This post covered several memory management techniques, outlining their pros
and cons:</p>
<ul class="simple">
<li>Manual - human error prone</li>
<li>Automatic using a tracing garbage collector - safe but comes with runtime
overhead</li>
<li>Automatic using reference counting - smaller runtime cost than a tracing
garbage collector but needs additional mechanisms to deal with reference
cycles</li>
<li>Concepts of ownership and lifetime - no runtime overhead, but should be
supplemented by static analysis to avoid dangling references</li>
</ul>
</div>
]]></description>
             <pubDate>Mon, 20 Feb 2017 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/12/03/notes-on-error-handling.html</link>
            <guid>http://vladris.com/blog/2016/12/03/notes-on-error-handling.html</guid>
            <title><![CDATA[Notes on Error Handling]]></title>
            <description><![CDATA[<h1>Notes on Error Handling</h1>
<p>I recently read Joe Duffy’s excellent blog post
<a class="reference external" href="http://joeduffyblog.com/2016/02/07/the-error-model/">The Error Model</a>. Joe
worked on Midori and has some great insights on error model design. I wanted to
write down a couple of personal notes on error handling.</p>
<div class="section" id="using-the-type-system">
<h2>Using the Type System</h2>
<p>Before even talking about error scenarios, it’s worth pointing out that there
are categories of errors where the type system helps if not to eliminate them,
at least to scope them and prevent them from propagating unchecked throughout
the system.</p>
<div class="section" id="arguments">
<h3>Arguments</h3>
<p>In many cases, an error means the value of some variable has an invalid value.
If this invalid value is passed down to called functions, it can manifests
itself deep in the stack when it could’ve been caught earlier. A simple example
would be move directions for a game - let’s say the player can move <span class="docutils literal"><span class="pre">Up</span></span>,
<span class="docutils literal"><span class="pre">Down</span></span>, <span class="docutils literal"><span class="pre">Left</span></span>, or <span class="docutils literal"><span class="pre">Right</span></span>. This can be encoded as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">int</span> <span class="n">UP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">LEFT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">DOWN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">RIGHT</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="p">...</span>

<span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="n">player</span> <span class="n">player</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">UP</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_up</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">LEFT</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_left</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">DOWN</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_down</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">RIGHT</span><span class="p">:</span> <span class="n">player</span><span class="p">.</span><span class="n">move_right</span><span class="p">();</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="c1">// direction should only be 0, 1, 2, 3</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but ultimately a caller can still pass any int value to this function which
would end up in the default branch as a direction the code doesn’t know how to
handle. The alternative is, of course:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">direction</span>
<span class="p">{</span>
    <span class="n">up</span><span class="p">,</span>
    <span class="n">left</span><span class="p">,</span>
    <span class="n">down</span><span class="p">,</span>
    <span class="n">right</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="n">direction</span> <span class="n">direction</span><span class="p">,</span> <span class="n">player</span> <span class="n">player</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, the type system ensures direction can only possibly hold one of
the allowed values. This is a trivial example but there are many more
interesting ones. Take for example some connection which, if opened, can receive
data and close and, if not opened, can be opened. This can be modelled like
this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="nf">open</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection already opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="nf">close</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection not opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">receive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_opened</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error, connection not opened */</span> <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">is_opened</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we have to handle various cases where we try to perform an open-connection
operation on a connection that hasn’t been opened yet, and vice-versa. Another
way to model this (as of C++17) is using a variant and separate types for open
and closed connections:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">opened_connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="nf">close</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="k">auto</span> <span class="nf">receive</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">closed_connection</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="nf">open</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">closed_connection</span><span class="p">,</span> <span class="n">opened_connection</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, as long as we have a <span class="docutils literal"><span class="pre">closed_connection</span></span> instance, we can only perform
closed-connection operations and as long as we have an <span class="docutils literal"><span class="pre">open_connection</span></span>
instance, we can only perform opened-connection operations. The error states we
had to handle above go away as the type system ensures we can never call
<span class="docutils literal"><span class="pre">receive</span></span> on a closed connection etc.</p>
</div>
<div class="section" id="return-values">
<h3>Return Values</h3>
<p>The type system can also be leveraged to embellish return types as an
alternative to using return codes. For example, assume we have a function which
parses a phone number provided by the user into some <span class="docutils literal"><span class="pre">phone_number_t</span></span> used
internally. There are a few ways to implement this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">phone_number_t</span> <span class="nf">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span> <span class="c1">// assume we can construct a phone_number_t from a valid string</span>
    <span class="k">else</span>
        <span class="k">throw</span> <span class="n">invalid_phone_number</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not ideal though, since exception should really be exceptional (more on
this below), and user providing invalid input should be a completely valid
scenario. The alternative would be to use a return code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">bool</span> <span class="nf">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">phone_number_t</span><span class="o">&amp;</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, but calling code is uglier:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">phone_number</span> <span class="o">=</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
</pre></div>
</div>
<p>now becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">phone_number_t</span> <span class="n">phone_number</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">phone_number</span><span class="p">);</span>
</pre></div>
</div>
<p>We can also end up in a bad state if we forget to check the return value. The
alternative is to encode the information that we either have a
<span class="docutils literal"><span class="pre">phone_number_t</span></span> or an invalid number in a type. In C++ we have (as of C++17)
<span class="docutils literal"><span class="pre">optional&lt;T&gt;</span></span> for this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">optional</span><span class="o">&lt;</span><span class="n">phone_number_t</span><span class="o">&gt;</span> <span class="n">parse_phone_number</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phone_number_t</span><span class="o">::</span><span class="n">is_valid</span><span class="p">(</span><span class="n">input</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nullopt</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">phone_number_t</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not quite a return error code and cannot really be ignored - there is no
implicit case from <span class="docutils literal"><span class="pre">optional&lt;T&gt;</span></span> to <span class="docutils literal"><span class="pre">T</span></span>, so callers need to explicitly
handle the case when the operation failed. Calling this is as natural as the
throwing version, but does not rely on exceptions <a class="footnote-reference" href="#id3" id="id1">[1]</a>. This is also called
<em>monadic error handling</em> and is widely employed by functional languages. I find
this a good alternative to throwing exceptions as long as it is well scoped and
error checks don’t have to pollute too many functions in the call stack.</p>
</div>
</div>
<div class="section" id="preconditions">
<h2>Preconditions</h2>
<p>Preconditions are conditions that should be satisfied upon entering a function
to ensure the function works as expected. When a function is called but the
preconditions are not met, it is not an error, it is a developer bug. The
recommended way of handling such a situation is, if possible, to crash
immediately. The reason for crashing is that calling a function with
preconditions not being met means the system is an invalid state and attempting
recovery is usually not worth it. Crashing on the other hand would provide
developers with dumps to help understand how the system got into this state and
fix the underlying bug.</p>
<p>The alternative to this is undefined behavior - calling a function without
meeting the preconditions cannot guarantee anything about the execution of the
function. Undefined behavior is used extensively throughout the C++ standard
<a class="footnote-reference" href="#id4" id="id2">[2]</a>. While failing fast is the preferred approach, sometimes it is unfeasible
to check preconditions at runtime: for example a precondition of binary search
is that it searches over an ordered range. Performing a binary search takes
logarithmic time but validating that a range is ordered takes linear time, so
adding this check would negatively impact the run time of the algorithm. In this
case, it is OK to say that we cannot provide any guarantees on what the function
will do. Debug-time asserts are a middle ground solution, since we can afford to
perform more expensive checks in debug builds to deterministically fail when
preconditions are not met. That being said, if the check is not prohibitively
expensive, it should be performed on all build flavors and immediately fail (via
<span class="docutils literal"><span class="pre">std::terminate</span></span> or equivalent).</p>
<p>What should not be done is treating such a state as an error - this is a bug in
the code and throwing an exception or returning some error result would just
leak the bug and make it impact more of the system. There really isn’t anything
useful to do with such an error - it only tells us that there is an issue in the
code and we are now in a state we should never be in. At this point we don’t
know which component originated the error and we cannot deterministically
recover - we might abort the current operation but there is no guarantee that
this would bring us back to a valid state. We are in undefined behavior land,
where crashing is the best option.</p>
</div>
<div class="section" id="recoverable-errors">
<h2>Recoverable Errors</h2>
<p>We covered several ways to handle errors by either eliminating invalid states at
compile-time or by failing fast when in an invalid state. There are, on the
other hand, classes of errors from which we can legitimately recover, which
brings us to exception and error codes.</p>
<div class="section" id="exceptions">
<h3>Exceptions</h3>
<p>I am a big fan of handling exceptional states using exceptions over returning
error codes. For one, the code is more readable: instead of reserving the return
type of a function to signal success or failure and resort to out parameters,
functions can be declared in a natural way. We also end up with less code
overall as instead of having to check error codes inside all functions in the
call stack in order to propagate back an error, we simply throw it from the top
of the stack and catch it where we can deal with it. This approach also composes
better - take, for example, a generic algorithm that takes some throwing
function. Since we supply the predicate, we know what exception it can throw and
we can catch it in the code that invokes the generic algorithm, keeping this
invisible to the algorithm:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">UnaryFunction</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryFunction</span> <span class="n">f</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">UnaryFunction</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
        <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If our predicate returns an error code instead, the generic algorithm must be
aware of this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">UnaryFunction</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="n">UnaryFunction</span> <span class="n">f</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that here we are also making an assumption that 0 means success, which is
an arbitrary decision for a plug-in function.</p>
<p>That being said, I want to reiterate that exceptions should only be used for
exceptional cases. The readability advantage gained with exceptions is lost if
they are abused. It’s great if the callee throws one or two exception types
which the caller catches and handles. On the other hand, if we have to resort to
catch-all <span class="docutils literal"><span class="pre">catch</span> <span class="pre">(...)</span></span> and we have so many possible exception types coming
out of a function that we can’t keep track of them, the code actually becomes
harder to reason about.</p>
<p>An example and a counter-example: when reading a file with a set schema
generated by our application, we expect it to be in a valid format. If it isn’t,
it means some data corruption occurred but this should really be an exceptional
case. If we encounter such data corruption, we can throw an exception and let
the caller handle the fact that we cannot interpret this file. On the other
hand, when reading user input, we should never throw an exception if input is
not conforming - this should be a much more common scenario of user error.</p>
</div>
<div class="section" id="return-codes">
<h3>Return Codes</h3>
<p>There are cases which are not exceptional enough to warrant an exception but
where some error information needs to be propagated through the call stack.
Take, for example, a compiler which encounters an invalid token while parsing a
file. Since this is user input, it should not be treated as an exception. On the
other hand, simply using an optional and failing to parse without providing
additional information is also not ideal. In this case we probably want to
return additional information around the encountered error.</p>
<p>In this case we would return the error rather than throw it, but I would still
prefer an embellished type like Rust’s <span class="docutils literal"><span class="pre">Result</span></span> and return an
<span class="docutils literal"><span class="pre">std::variant&lt;T,</span> <span class="pre">Error&gt;</span></span> (as of C++17). In general I consider bad practice
returning an <span class="docutils literal"><span class="pre">int</span></span> or an <span class="docutils literal"><span class="pre">HRESULT</span></span> which would afterwards have to be decoded
to understand the actual error. For simple cases, if no other information
besides success/failure has to be returned, a <span class="docutils literal"><span class="pre">bool</span></span> would suffice, or an
<span class="docutils literal"><span class="pre">enum</span></span> or <span class="docutils literal"><span class="pre">struct</span></span> which contains the expected error information. Such an
error type can be composed with a valid return type using a variant which brings
us back to monadic error-handling.</p>
<p>My general rule of thumb is to use exceptions for really exceptional situations,
which keeps the code cleaner as long as the number of exception types is
managable, and use monadic error handling when errors are expected, as long as
these can be scoped to a limited number of functions (repeated error checking
all over the place is messy, error-prone, and makes code hard to read).</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We went over various ways of handling errors:</p>
<ul class="simple">
<li>Declaring types that restrict the range of values a variable can take to
eliminate invalid states at compile-time</li>
<li>Monadic error handling using embelished return types</li>
<li>Failing fast when preconditions of a function are not met</li>
<li>Throwing exceptions in exceptional cases</li>
<li>Returning strongly typed errors when errors are not exceptional</li>
</ul>
<p>There is still a fair amount of controversy around what is <em>the right way</em> of
handling errors. My personal take on this is that there are tradeoffs that come
with each approach and rather than saying “always use exceptions” or “never use
exceptions”, it’s more a matter of choosing <em>the right tool for the job</em>. I
tried to list some of the possible approaches with their pros and cons, and how
I employ them. Your mileage may vary depending on your specific language,
runtime, problem domain, application type etc.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This is the recommended way of <a class="reference external" href="https://doc.rust-lang.org/book/error-handling.html">handling errors in Rust</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>See Chandler Carruth’s CppCon talk <a class="reference external" href="https://www.youtube.com/watch?v=yG1OZ69H_-o">Garbage In, Garbage Out</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sat, 03 Dec 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/10/16/notes-on-types.html</link>
            <guid>http://vladris.com/blog/2016/10/16/notes-on-types.html</guid>
            <title><![CDATA[Notes on Types]]></title>
            <description><![CDATA[<h1>Notes on Types</h1>
<div class="section" id="type-systems">
<h2>Type Systems</h2>
<p>A good type system can eliminate entire categories of errors in a program and
simply make invalid code not compile. Before digging into types, below are a few
common distinctions between the type systems of various programming languages:</p>
<div class="section" id="dynamic-typing-vs-static-typing">
<h3>Dynamic Typing vs Static Typing</h3>
<p>In a statically typed language, the types are determined at compile time so if a
function was declared as only accepting a certain type <span class="docutils literal"><span class="pre">T</span></span> but we attempt to
pass it an unrelated type <span class="docutils literal"><span class="pre">U</span></span>, the program is considered invalid. This is
invalid C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">sqr</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">sqr</span><span class="p">(</span><span class="s">"not an int"</span><span class="p">);</span> <span class="c1">// does not compile</span>
</pre></div>
</div>
<p>On the other hand, in a dynamically typed language, we do not perform any
compile time checks and, if the data we get is of an unexpected type, we treat
it as a runtime error. Below is a Python function that squares a number:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">sqr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
<span class="o">...</span>
<span class="n">sqr</span><span class="p">(</span><span class="s2">"not an int"</span><span class="p">)</span>
<span class="c1"># runs but fails with TypeError: unsupported operand type(s)</span>
<span class="c1"># for ** or pow(): 'str' and 'int'</span>
</pre></div>
</div>
<p>Some of the interesting features of dynamic languages are <em>duck typing</em> (“if it
walks like a duck, and it quacks like a duck…”) and <em>monkey patching</em>. Duck
typing means that accessing a member of an object works as long as that object
has such a member, regardless of the type of the object. In Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"bar"</span><span class="p">)</span>

<span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Foo</span><span class="p">(),</span> <span class="n">Bar</span><span class="p">()]]</span> <span class="c1"># prints "foo" and "bar"</span>
</pre></div>
</div>
<p>This can’t work in a statically typed language where, at the bare minimum, we
would have to add some form of constraint for the types in the list to ensure
they contain a <span class="docutils literal"><span class="pre">func()</span></span> method we can call.</p>
<p>Monkey patching refers to the ability to change the structure of an object at
runtime. For example we can swap the <span class="docutils literal"><span class="pre">func</span></span> method from an instance of <span class="docutils literal"><span class="pre">foo</span></span>
with another function like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"foo"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func_bar</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"bar"</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="c1"># prints "foo"</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func_bar</span>
<span class="n">obj</span><span class="o">.</span><span class="n">func</span><span class="p">()</span> <span class="c1"># prints "bar"</span>
</pre></div>
</div>
<p>These are useful capabilities, but the tradeoff is a whole class of type errors
which a statically typed language would’ve caught.</p>
<p>As a side note, the fact that dynamic languages don’t need to specify types
makes them more terse. That being said, the
<a class="reference external" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner algorithm W</a>
can infer the types of a program in linear time with respect to the source size.
So while Python is starting to support type annotations for better static
analysis and TypeScript provides a way for writing type-safe JavaScript, C++ has
better and better type inference, while in Haskell (which has one of the
strongest static type systems) type annotations are mostly optional.</p>
</div>
<div class="section" id="strong-typing-vs-weak-typing">
<h3>Strong Typing vs Weak Typing</h3>
<p>At a high level, a strongly typed language does not implicitly convert between
unrelated types. This is good in most situations as implicit conversions are
often meaningless or have surprising effects - for example, adding a number to
a list of characters. This can either result in runtime errors or garbage data.
In contrast, a strongly typed language will not accept code that attempts to do
this.</p>
<p>In Python, which is strongly typed, this doesn’t work:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">foo</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="c1"># foo is "foo"</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="s2">" bar"</span> <span class="c1"># foo is "foo bar"</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">+</span> <span class="mi">5</span> <span class="c1"># TypeError: Can't convert 'int' object to str implicitly</span>
</pre></div>
</div>
<p>It works just fine in JavaScript though:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span/><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s2">"foo"</span><span class="p">;</span> <span class="c1">// foo is "foo"</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">+</span> <span class="s2">" bar"</span><span class="p">;</span> <span class="c1">// foo is "foo bar"</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">+</span> <span class="mf">5</span><span class="p">;</span> <span class="c1">// foo is "foo bar5"</span>
</pre></div>
</div>
<p>Note type strength is not an either/or - C++, while considered strongly typed,
still allows several implicit casts between types (eg. pointer to bool). Some
languages are more strict about converting between types implicitly, others less
so.</p>
</div>
<div class="section" id="dynamic-polymorphism-vs-static-polymorphism">
<h3>Dynamic Polymorphism vs Static Polymorphism</h3>
<p>Another difference to note is between static and dynamic polymorphism. Dynamic
polymorphism happens at runtime, when calling a function on a base type gets
resolved to the actual function of the deriving type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">foo</span> <span class="o">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">bar</span> <span class="o">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">call_func</span><span class="p">(</span><span class="n">base</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">foo</span><span class="p">{});</span> <span class="c1">// prints "foo"</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">bar</span><span class="p">{});</span> <span class="c1">// prints "bar"</span>
</pre></div>
</div>
<p>In the above case, we effectively have a single function <span class="docutils literal"><span class="pre">call_func</span></span> which
takes a reference to a <span class="docutils literal"><span class="pre">base</span></span> struct. The compiler generates a v-table for
<span class="docutils literal"><span class="pre">struct</span> <span class="pre">base</span></span> and a call to <span class="docutils literal"><span class="pre">func()</span></span> on <span class="docutils literal"><span class="pre">base</span></span> involves a v-table jump to
the actual implementation of the function, which is different between the
inheriting types <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span>.</p>
<p>Contrast this with the static alternative:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">foo</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">bar</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bar"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">call_func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">foo</span><span class="p">{});</span> <span class="c1">// prints "foo"</span>
<span class="n">call_func</span><span class="p">(</span><span class="n">bar</span><span class="p">{});</span> <span class="c1">// prints "bar"</span>
</pre></div>
</div>
<p>In this case there is no relationship between <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span> and no v-table
is needed. On the other hand, we no longer have a single <span class="docutils literal"><span class="pre">call_func</span></span>, we have
a templated function which is instantiated for both <span class="docutils literal"><span class="pre">foo</span></span> and <span class="docutils literal"><span class="pre">bar</span></span> types.
This is all done at compile-time, the advantage being faster code, the drawback
being compiler needs to be aware of all the types involved - we can no longer
“inject” types implementing an interface at runtime. When calling <span class="docutils literal"><span class="pre">call_func</span></span>,
we need to have both the definition of the function and the declaration of the
type we’re passing in visible.</p>
</div>
</div>
<div class="section" id="types">
<h2>Types</h2>
<p>During the rest of this post, I will talk about types in the context of a
statically and strongly typed language, with a focus on static polymorphism.
This pushes as much as possible of the type checking to the compilation stage,
so many of the runtime issues of less strict languages become invalid syntax.</p>
<p>I will focus on C++ and cover some of the new C++17 feature which enable or make
some of these concepts easier to work with. That being said, since this post
focuses on types, I will also provide examples in Haskell, as Haskell can
express these concepts much more succinctly.</p>
<div class="section" id="type-basics">
<h3>Type Basics</h3>
<p>Let’s start with the definition of a type: <em>a type represents the set of
possible values</em>. For example, the C++ type <span class="docutils literal"><span class="pre">uint8_t</span></span> represents the set of
integers from 0 to 255. Effectively this means that a variable of a given type
can only have values from within that set.</p>
</div>
<div class="section" id="interesting-types">
<h3>Interesting Types</h3>
<p>Since we defined a type as a set of possible values, we can talk about the
cardinality of a type, in other words the number of values in the set. Based on
cardinality, there are a few interesting classes of types to talk about:</p>
</div>
<div class="section" id="empty-type">
<h3>Empty Type</h3>
<p>The first interesting type to talk about is the type that represents the empty
set, with <span class="docutils literal"><span class="pre">|T|</span> <span class="pre">=</span> <span class="pre">0</span></span>.</p>
<p>In Haskell, this type is named <span class="docutils literal"><span class="pre">Void</span></span>. Since Haskell is a functional language,
all functions must return a value, so it does not make sense to have a function
that returns <span class="docutils literal"><span class="pre">Void</span></span> - the same way it doesn’t make sense to define a
mathematical function with the empty set as its codomain. We do have an
<span class="docutils literal"><span class="pre">absurd</span></span> function though, which maps the empty set to any value:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="nf">absurd</span> <span class="ow">::</span> <span class="kt">Void</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>This function cannot be called though.</p>
<p>In C++, the absence of a value is represented as the <span class="docutils literal"><span class="pre">void</span></span> type. Since C++ is
not purely functional, we can define functions that don’t return anything. We
can even say that a function does not take any arguments by putting a <span class="docutils literal"><span class="pre">void</span></span>
between the parenthesis:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the equivalent of:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span>
</pre></div>
</div>
<p>Note though that we cannot have a <em>real</em> argument of type <span class="docutils literal"><span class="pre">void</span></span>, that is a
compile error as it doesn’t make any sense - we would be mandating the function
takes a value from the empty set. So we can say <span class="docutils literal"><span class="pre">foo(void)</span></span> but not
<span class="docutils literal"><span class="pre">foo(void</span> <span class="pre">arg)</span></span>, or even <span class="docutils literal"><span class="pre">foo(int</span> <span class="pre">arg,</span> <span class="pre">void)</span></span>.</p>
</div>
<div class="section" id="unit-type">
<h3>Unit Type</h3>
<p>The next interesting class consists of types with cardinality 1. A type <span class="docutils literal"><span class="pre">T</span></span>
with <span class="docutils literal"><span class="pre">|T|</span> <span class="pre">=</span> <span class="pre">1</span></span> is called a <em>unit</em> or <em>singleton type</em>. A variable of such a
type can only ever have a single possible value. In Haskell, the anonymous
representation is the empty tuple <span class="docutils literal"><span class="pre">()</span></span>. Here is an example of a function that
maps anything to this type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="nf">unit</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">unit</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Of course, we can declare our own singleton types. Below is a custom
<span class="docutils literal"><span class="pre">Singleton</span></span> type and an equivalent unit function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Singleton</span> <span class="ow">=</span> <span class="kt">Singleton</span>
<span class="nf">unit</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Singleton</span>
<span class="nf">unit</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Singleton</span>
</pre></div>
</div>
<p>In C++, the anonymous representation of a singleton is an empty <span class="docutils literal"><span class="pre">std::tuple</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As can be seen from the above, Haskell makes it easier to define a function that
takes an argument of any type, as it provides syntactic sugar for type
parameters (<span class="docutils literal"><span class="pre">a</span></span> in our example). In C++, the equivalent declaration involves a
template, but they boil down to the same thing. The non-anonymous C++
representation is a struct which doesn’t contain anything. All instances of such
a struct are equivalent:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">singleton</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">singleton</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sum-types">
<h3>Sum Types</h3>
<p>Here, things get a bit more interesting: a <span class="docutils literal"><span class="pre">sum</span> <span class="pre">type</span></span> is a type which can
represent a value from any of the types it sums. So given type <span class="docutils literal"><span class="pre">A</span></span> and type
<span class="docutils literal"><span class="pre">B</span></span>, the type <span class="docutils literal"><span class="pre">S</span></span> summing up <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> is <span class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:</span> <span class="pre">i</span> <span class="pre">∈</span> <span class="pre">A</span> <span class="pre">U</span> <span class="pre">B</span> <span class="pre">}</span></span>.
So a variable of type <span class="docutils literal"><span class="pre">S</span></span> could have any value in <span class="docutils literal"><span class="pre">A</span></span> or any value in <span class="docutils literal"><span class="pre">B</span></span>.
<span class="docutils literal"><span class="pre">S</span></span> is called a sum type because its cardinality is the sum of the
cardinalities of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span>, <span class="docutils literal"><span class="pre">|S|</span> <span class="pre">=</span> <span class="pre">|A|</span> <span class="pre">+</span> <span class="pre">|B|</span></span>.</p>
<p>Sum types are great, because they allow us to build up more complex types from
simpler ones. Once we have unit types, we can build up more complex types out
of them by summing them. For example, a boolean type which can be either
<span class="docutils literal"><span class="pre">true</span></span> or <span class="docutils literal"><span class="pre">false</span></span> can be thought of as the sum of the singleton <span class="docutils literal"><span class="pre">true</span></span>
type and the singleton <span class="docutils literal"><span class="pre">false</span></span> type. In Haskell, a boolean is defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">True</span> <span class="o">|</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Similarly, a <span class="docutils literal"><span class="pre">Weekday</span></span> type can be defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Weekday</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
</pre></div>
</div>
<p>Theoretically, numerical types could also be defined as huge sum types of every
possible value they can represent. Of course, this is impractical, but we can
reason about them the same way we reason about other sum types, we don’t have to
treat them as a special case.</p>
<p>In C++, an equivalent of the above is an <span class="docutils literal"><span class="pre">enum</span> <span class="pre">class</span></span>. <span class="docutils literal"><span class="pre">bool</span></span> is a built-in
type with special syntax, but we could define an equivalent as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">enum</span> <span class="k">class</span> <span class="nc">Boolean</span>
<span class="p">{</span>
    <span class="n">True</span><span class="p">,</span>
    <span class="n">False</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It’s easy to see how a <span class="docutils literal"><span class="pre">Weekday</span></span> definition would look like. Things get more
interesting when we throw type parameters into the mix. In Haskell, we have the
<span class="docutils literal"><span class="pre">Either</span></span> type, which is declared as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</pre></div>
</div>
<p>An instance of this could be either a <span class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></span>, where <span class="docutils literal"><span class="pre">a</span></span> is a type itself,
which means it can be any of the values of <span class="docutils literal"><span class="pre">a</span></span>, or it can be <span class="docutils literal"><span class="pre">Right</span> <span class="pre">b</span></span>, with
any of the values of <span class="docutils literal"><span class="pre">b</span></span>. In Haskell we use pattern-matching to operate on
such a type, so we can declare a simple function that tells us whether we were
given a <span class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></span> like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="nf">isLeft</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isLeft</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isLeft</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>This might not look like much, but of course we can compose more complex
functions. For example, say we have a function <span class="docutils literal"><span class="pre">foo</span></span> that takes an <span class="docutils literal"><span class="pre">a</span></span> and
returns an <span class="docutils literal"><span class="pre">a</span></span>, a function <span class="docutils literal"><span class="pre">bar</span></span> that takes a <span class="docutils literal"><span class="pre">b</span></span> and returns a <span class="docutils literal"><span class="pre">b</span></span>. We
can then write a <span class="docutils literal"><span class="pre">transform</span></span> function which takes an <span class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></span> and,
depending on the contained type, it applies the appropriate function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="c1">-- Implementation of foo and bar not provided in this example</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">bar</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">bar</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>This is way beyond the capabilities of a C++ <span class="docutils literal"><span class="pre">enum</span> <span class="pre">class</span></span>. The old way of
implementing something like this in C++ was using a union and a tag enum to keep
track of which is the actual type we’re working with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Declaration of A and B not provided in this example</span>
<span class="k">struct</span> <span class="nc">A</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Either</span>
<span class="p">{</span>
    <span class="n">Either</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ab</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">::</span><span class="n">isA</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Either</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ab</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">::</span><span class="n">isB</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">A</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">B</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">ab</span><span class="p">;</span>

    <span class="k">enum</span> <span class="k">class</span> <span class="nc">tag</span>
    <span class="p">{</span>
        <span class="n">isA</span><span class="p">,</span>
        <span class="n">isB</span>
    <span class="p">}</span> <span class="n">tag</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Our implementation of transform would look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Implementation of A and B not provided in this example</span>
<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">B</span> <span class="nf">bar</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>

<span class="n">Either</span> <span class="nf">transform</span><span class="p">(</span><span class="n">Either</span> <span class="n">either</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">Either</span><span class="o">::</span><span class="n">tag</span><span class="o">::</span><span class="nl">isA</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">ab</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">Either</span><span class="o">::</span><span class="n">tag</span><span class="o">::</span><span class="nl">isB</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bar</span><span class="p">(</span><span class="n">either</span><span class="p">.</span><span class="n">ab</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our <span class="docutils literal"><span class="pre">Either</span></span> type definition is obviously much more verbose than what we had
in Haskell, and it doesn’t even support type parameters - at this point it only
works with <span class="docutils literal"><span class="pre">struct</span> <span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">struct</span> <span class="pre">B</span></span>, while the Haskell version works for
any <span class="docutils literal"><span class="pre">a</span></span> and <span class="docutils literal"><span class="pre">b</span></span> types. The other major problem is that, while unions provide
efficient storage for different types (the size of the union is the size of the
maximum contained type), it is up to the implementer to make sure we don’t try
to read an <span class="docutils literal"><span class="pre">A</span></span> as a <span class="docutils literal"><span class="pre">B</span></span> or vice-versa. That means we need to keep our tag in
sync with what we put in the type and respect it when accessing the value of the
union.</p>
<p>C++17 introduces a better, safer, parameterized type for this: <span class="docutils literal"><span class="pre">std::variant</span></span>.
Variant takes any number of types as template arguments and stores an instance
of any one of those types. Using variant, we can re-write the above as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">either</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">([](</span><span class="k">auto</span> <span class="n">e</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
    <span class="p">},</span> <span class="n">either</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a lot of new syntax, so let’s break it down: <span class="docutils literal"><span class="pre">std::variant&lt;A,</span> <span class="pre">B&gt;</span></span> is
the new C++17 sum type. In this case, we specify it holds either <span class="docutils literal"><span class="pre">A</span></span> or <span class="docutils literal"><span class="pre">B</span></span>
(but it can hold an arbitrary number of types).</p>
<p><span class="docutils literal"><span class="pre">std::visit</span></span> is a function that applies the visitor function given as its
first argument to the variants given as its subsequent arguments. In our
example, this effectively expands to applying the lambda to
<span class="docutils literal"><span class="pre">std::get&lt;0&gt;(either)</span></span> and <span class="docutils literal"><span class="pre">std::get&lt;1&gt;(either)</span></span>.</p>
<p><span class="docutils literal"><span class="pre">if</span> <span class="pre">constexpr</span></span> is also a new C++17 construct which evaluates the if expression
at compile time and discards the else branch from the final object code. So in
this example, we determine at compile time whether the type we are being called
with is <span class="docutils literal"><span class="pre">A</span></span> or <span class="docutils literal"><span class="pre">B</span></span> and apply the correct function based on that. Something
very similar can be achieved with templates and <span class="docutils literal"><span class="pre">enable_if</span></span>, but this syntax
makes for more readable code.</p>
<p>Note that with this version we can simply prepend a <span class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;typename</span> <span class="pre">A,</span>
<span class="pre">typename</span> <span class="pre">B&gt;</span></span> and make the whole function generic, as in the Haskell example. It
doesn’t read as pretty (because we don’t have good pattern matching syntax in
the language), but this is the new, type safe way of implementing and working
with sum types, which is a major improvement.</p>
</div>
<div class="section" id="product-types">
<h3>Product Types</h3>
<p>With sum types out of the way, the remaining interesting category is that of
<em>product types</em>. Product types combine the values of several other types into
one. For types <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span>, we have <span class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">(a,</span> <span class="pre">b)</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">∈</span> <span class="pre">A,</span> <span class="pre">b</span> <span class="pre">∈</span> <span class="pre">B</span> <span class="pre">}</span></span>, so
<span class="docutils literal"><span class="pre">|P|</span> <span class="pre">=</span> <span class="pre">|A|</span> <span class="pre">x</span> <span class="pre">|B|</span></span>.</p>
<p>In Haskell, the anonymous version of product types is represented by tuples,
while the named version is represented by records. An example of a <span class="docutils literal"><span class="pre">perimeter</span></span>
function which computes the perimeter of a rectangle defined by two points,
where each point is a tuple of numbers:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="nf">perimeter</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">n</span>
<span class="nf">perimeter</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span>
</pre></div>
</div>
<p>The named version would declare a <span class="docutils literal"><span class="pre">Point</span></span> type with <span class="docutils literal"><span class="pre">Int</span></span> coordinates and
use that instead:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="nf">perimeter</span> <span class="ow">::</span> <span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">perimeter</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">))</span>
</pre></div>
</div>
<p>The C++ equivalents are <span class="docutils literal"><span class="pre">std::tuple</span></span> for anonymous product types and
<span class="docutils literal"><span class="pre">struct</span></span> for named types:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Anonymous</span>
<span class="kt">int</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span>
        <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// Named</span>
<span class="k">struct</span> <span class="nc">point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">perimeter</span><span class="p">(</span><span class="n">point</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While sum types allow us to express values from multiple types into one, product
types allow us to express values from several types together. Empty, unit, sum,
and product types are the building blocks of a type system.</p>
</div>
<div class="section" id="bonus-optional-types">
<h3>Bonus: Optional Types</h3>
<p>An optional type is a type that can hold any of the values of another type, or
not hold any value, which is usually represented as a singleton. So an optional
is effectively a sum type between a given type and a singleton representing
“doesn’t hold a value”. In other words, the cardinality of an optional for a
type <span class="docutils literal"><span class="pre">T</span></span> is <span class="docutils literal"><span class="pre">|O|</span> <span class="pre">=</span> <span class="pre">|T|</span> <span class="pre">+</span> <span class="pre">1</span></span>.</p>
<p>In Haskell, an optional is the famous <span class="docutils literal"><span class="pre">Maybe</span></span> type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>A function that operates on <span class="docutils literal"><span class="pre">Maybe</span></span> could say “only apply <span class="docutils literal"><span class="pre">foo</span></span> if the
optional contains an <span class="docutils literal"><span class="pre">a</span></span>”:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span/><span class="c1">-- Implementation of foo not provided in this example</span>
<span class="nf">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">transform</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">transform</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">transform</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>The new C++17 equivalent is the <span class="docutils literal"><span class="pre">optional</span></span> type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Implementation of foo not provided in this example</span>
<span class="n">A</span> <span class="nf">foo</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">nullopt</span> <span class="o">?</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">nullopt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This might read a bit like the pointer implementation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">A</span><span class="o">*</span> <span class="nf">transform</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">?</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is a key difference though: the type contained in the optional is part of
the object, so it is not allocated dynamically the way we would allocate a
pointer. <span class="docutils literal"><span class="pre">nullopt</span></span> is a helper object of the singleton type <span class="docutils literal"><span class="pre">nullopt_t</span></span>.</p>
<p>Types are important because a big part of programming effectively consits of
designing and composing types. Having a good understanding of the fundamentals
leads to better, safer, and saner code.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We started by outlining some of the basic principles of type systems:</p>
<ul class="simple">
<li>Static and dynamic typing</li>
<li>Weak and strong typing</li>
<li>Static and dynamic polymorphism</li>
</ul>
<p>Then we went over the building block types of a type system, with Haskell and
C++ examples:</p>
<ul class="simple">
<li>Empty types (cardinality 0)</li>
<li>Unit types (cardinality 1)</li>
<li>Sum types (<span class="docutils literal"><span class="pre">S</span></span> of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></span>)</li>
<li>Product types (<span class="docutils literal"><span class="pre">P</span></span> of <span class="docutils literal"><span class="pre">A</span></span> and <span class="docutils literal"><span class="pre">B</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">x</span> <span class="pre">B</span></span>)</li>
<li>Optional types (<span class="docutils literal"><span class="pre">O</span></span> of <span class="docutils literal"><span class="pre">A</span></span> has cardinality <span class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">1</span></span>)</li>
</ul>
</div>
<div class="section" id="further-reading">
<h2>Further Reading</h2>
<p>Ben Dean had an excellent talk at CppCon this year, <a class="reference external" href="https://www.youtube.com/watch?v=ojZbFIQSdl8">Using Types Effectively</a>. Another great talk about type
design from CppCon is <a class="reference external" href="https://www.youtube.com/watch?v=632a-DMM5J0">C++, Abstract Algebra and Practical Applications</a> by Robert Ramey. And then there
is Bartosz Milewski <a class="reference external" href="https://bartoszmilewski.com/">blog</a> about Haskell,
C++, and category theory.</p>
</div>
]]></description>
             <pubDate>Sun, 16 Oct 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/10/09/composable-generators.html</link>
            <guid>http://vladris.com/blog/2016/10/09/composable-generators.html</guid>
            <title><![CDATA[Composable Generators]]></title>
            <description><![CDATA[<h1>Composable Generators</h1>
<p>One of the most exciting features coming to C++ are coroutines. In this post,
I will give a quick overview of how they are used today in C# to support
generators and go over a few possible ways to bring the composability of Linq to
the C++ world.</p>
<div class="section" id="generators-in-c">
<h2>Generators in C#</h2>
<p>I will not go into the nitty-gritty details of coroutines, but in short, they
are resumable functions – functions that can be suspended/resumed. Coroutines
enable lazy evaluation, with two major applications: easy to read
multi-threading (with async/await syntax in C#) and generators (with yield
return syntax in C#). In this post, I will focus on generators and how they
compose.</p>
<p>I will start with a C# example since Linq is, in my opinion, the golden
standard for creating a processing pipeline, at least for non-functional
languages. Linq is implemented as a set of extension methods for
<span class="docutils literal"><span class="pre">IEnumerable</span></span>, and enables some very readable chaining of operations. For
example, let’s get the first 100 natural numbers, filter out the odds, then
square the remaining list.</p>
<p>The wrong way of doing this would be something like:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetNumbers</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">GetNumbers</span><span class="p">();</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main problem with the above is that all the logic is inlined into
<span class="docutils literal"><span class="pre">GetNumbers</span></span>, so things don’t decompose very well – for example what if we
also want a function that squares the odd numbers? We would either duplicate the
looping and squaring logic, or make the predicate we use to filter out things an
input to the function. Same goes for the iterating logic and for the squaring.
Luckily, we have Linq, which does just that:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span>
        <span class="n">Enumerable</span><span class="p">.</span><span class="n">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">).</span>
        <span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">).</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To illustrate the magic of generators, instead of relying on
<span class="docutils literal"><span class="pre">Enumerable.Range</span></span>, let’s introduce a function that generates numbers
forever:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">Count</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our code would then become:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span>
        <span class="n">Count</span><span class="p">().</span>
        <span class="n">Take</span><span class="p">(</span><span class="m">100</span><span class="p">).</span>
        <span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">).</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">item</span> <span class="p">+</span> <span class="s">" "</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While not strictly necessary in this particular case, infinite generators cannot
exist without lazy evaluation, a feature of many functional languages. Lazy
evaluation has some very practical applications as it allows processing of data
as it becomes available, instead of waiting for everything to be ready before
moving on to the next step. While the 100 natural numbers example might not
sound so useful, imagine rendering frames in a streaming video as they arrive
over the network. Linq is great because it provides a clean separation between
the generic algorithms (<span class="docutils literal"><span class="pre">Where</span></span>, <span class="docutils literal"><span class="pre">Select</span></span> etc.) and the problem-specific
operations which are passed in as arguments. Linq operations also compose well,
so they can be chained together to form pipelines.</p>
</div>
<div class="section" id="id1">
<h2>Generators in C++</h2>
<p>While coroutines haven’t made it into the C++17 standard itself, they are coming
as a technical specification, with MSVC already supporting them (code samples
below compile with VS 2015 Update 3). The main syntax additions are the new
<span class="docutils literal"><span class="pre">co_await</span></span>, <span class="docutils literal"><span class="pre">co_return</span></span>, and <span class="docutils literal"><span class="pre">co_yield</span></span> keywords. The first two are used
for creating and awaiting tasks (which I won’t cover in this post), while
<span class="docutils literal"><span class="pre">co_yield</span></span> is used in generators.</p>
<p>Here is a lazy counter in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="nf">count_to</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">count_to</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the return type of <span class="docutils literal"><span class="pre">count_to</span></span> is a <span class="docutils literal"><span class="pre">generator&lt;int&gt;</span></span> (currently in the
experimental namespace). <span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span> is the type implicitly created by the
compiler when encountering a <span class="docutils literal"><span class="pre">co_yield</span></span>. Also worth noting that range-based
for loops work over generators, as they expose <span class="docutils literal"><span class="pre">begin()</span></span> and <span class="docutils literal"><span class="pre">end()</span></span>
methods. The type annotation for the <span class="docutils literal"><span class="pre">count_to</span></span> return type above is not
really needed, I added it just to clarify what the complier will generate in
this case.</p>
<p><span class="docutils literal"><span class="pre">generator</span></span> itself is pretty bare-boned, it doesn’t provide all the algorithms
that Linq adds to <span class="docutils literal"><span class="pre">IEnumerable</span></span>. So if we wanted to do something like the
above pipeline, we would need some algorithms. Here’s one way of implementing
some of them:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="nf">count</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">co_yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here I switched from Linq’s <span class="docutils literal"><span class="pre">Select</span></span> and <span class="docutils literal"><span class="pre">Where</span></span> to the more commonly used
<span class="docutils literal"><span class="pre">map</span></span> and <span class="docutils literal"><span class="pre">filter</span></span>, but they effectively implement the same thing. While
this implementation is pretty-straight forward, it doesn’t compose well at all:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">map</span><span class="p">(</span>
            <span class="n">filter</span><span class="p">(</span>
                <span class="n">take_n</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="mi">100</span><span class="p">),</span>
                <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}),</span>
            <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Definitely not like the nice chaining of Linq. So what gives? Why doesn’t
generator come out-of-the-box with <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">map</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> and all the
other useful algorithms? Well, according to the
<a class="reference external" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>,
these algorithms don’t belong in <span class="docutils literal"><span class="pre">generator</span></span> – <span class="docutils literal"><span class="pre">generator</span></span> encapsulates the
lazy evaluation of the coroutine, it wouldn’t be the right place for algorithms.
It’s also worth noting that Linq methods are not part of <span class="docutils literal"><span class="pre">IEnumerable</span></span>, they
are <a class="reference external" href="https://msdn.microsoft.com/en-us/library/bb383977.aspx">extension methods</a>.
C++ doesn’t support extension methods, so we would need a slightly different
design to achieve better chaining.</p>
</div>
<div class="section" id="decorator">
<h2>Decorator</h2>
<p>The next idea comes from pure OOP - let’s create a decorator over <span class="docutils literal"><span class="pre">generator</span></span>
that exposes these algorithms. First, let’s declare our decorator as
<span class="docutils literal"><span class="pre">enumerable&lt;T&gt;</span></span> and change our algorithms to work with the new type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">enumerable</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation looks pretty much like before, except that now we are getting
and returning <span class="docutils literal"><span class="pre">enumerable&lt;T&gt;</span></span> instead of <span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span>. In this case the
type annotation is mandatory, as by default the complier would create a
<span class="docutils literal"><span class="pre">generator&lt;T&gt;</span></span>.</p>
<p>We can then implement our enumerable to wrap a generator and expose member
functions which forward to the above algorithms:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">enumerable</span>
<span class="p">{</span>
    <span class="c1">// Needed by compiler to create enumerable from co_yield</span>
    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>

    <span class="n">enumerable</span><span class="p">(</span><span class="n">promise_type</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">)</span> <span class="o">:</span> <span class="n">_gen</span><span class="p">(</span><span class="n">promise</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">enumerable</span><span class="p">(</span><span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">_gen</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>

    <span class="n">enumerable</span><span class="p">(</span><span class="k">const</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_gen</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">auto</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_gen</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">take_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">pred</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">_gen</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A few things to note: we declare a <span class="docutils literal"><span class="pre">promise_type</span></span> and have a constructor which
takes a promise as an argument. This is required by the compiler when creating
the object on <span class="docutils literal"><span class="pre">co_yield</span></span>. We follow the same semantics as generator, since
that is what we are wrapping – support only move-constructor, no
copy-constructor. All the member algorithms do a destructive move on <span class="docutils literal"><span class="pre">*this</span></span>.
This is intentional, as once we iterate over the encapsulated generator, it is
no longer valid. Since we don’t expose a copy-constructor, we move out of
<span class="docutils literal"><span class="pre">*this</span></span> when passing the generator to an algorithm. For completeness, we can
also provide a function which converts from a generator to an enumerable:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">to_enumerable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">enumerable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works, and we can now compose algorithms by chaining the calls:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">to_enumerable</span><span class="p">(</span><span class="n">count</span><span class="p">()).</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}).</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Still, it is not ideal – first, we need to explicitly tell the compiler
everywhere to return our type with <span class="docutils literal"><span class="pre">co_yield</span></span> instead of the default
generator, and we need to handle conversions to and from the standard library
generator. The enumerable algorithms compose well, but we’ll have trouble
composing with functions that work with generators. Also, having a huge class
consisting solely of algorithms is not the best design, especially in a language
where free functions are first class citizens.</p>
</div>
<div class="section" id="pipe-operator">
<h2>Pipe Operator</h2>
<p>An alternative approach, which the
<a class="reference external" href="http://www.boost.org/doc/libs/1_62_0/libs/range/doc/html/index.html">Boost Ranges library</a>
takes, is to overload <span class="docutils literal"><span class="pre">|</span></span>, the “pipe” operator, so we can compose our calls
like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">count</span><span class="p">()</span> <span class="o">|</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">|</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span> <span class="o">|</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One way we can get this working is to first create a type that wraps an
algorithm and an <span class="docutils literal"><span class="pre">operator|</span></span> implementation between a lhs <span class="docutils literal"><span class="pre">generator</span></span> and a
rhs of our type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">filter_t</span>
<span class="p">{</span>
    <span class="n">filter_t</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Predicate</span> <span class="n">_pred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <span class="docutils literal"><span class="pre">filter_t</span></span> holds the <span class="docutils literal"><span class="pre">Predicate</span></span> we want to use, and <span class="docutils literal"><span class="pre">operator|</span></span>
applies it on the given <span class="docutils literal"><span class="pre">generator</span></span>. This works, but we wouldn’t be able to
instantiate <span class="docutils literal"><span class="pre">filter_t</span></span> with a lambda like in the above chaining example
without specifying the Predicate type in the call. If we want to leverage type
deduction, we can create a simple helper function that creates a <span class="docutils literal"><span class="pre">filter_t</span></span>
from a given argument:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this we can call <span class="docutils literal"><span class="pre">|</span> <span class="pre">filter(/*</span> <span class="pre">predicate</span> <span class="pre">*/)</span></span> on a generator and get back
a filtered generator. Full implementation for <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> and <span class="docutils literal"><span class="pre">map</span></span>
would be:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">take_n_t</span>
<span class="p">{</span>
    <span class="n">take_n_t</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">_n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">_n</span><span class="p">)</span>
                <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">_n</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">take_n_t</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">take_n_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">filter_t</span>
<span class="p">{</span>
    <span class="n">filter_t</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Predicate</span> <span class="n">_pred</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">filter_t</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">map_t</span>
<span class="p">{</span>
    <span class="n">map_t</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span> <span class="o">:</span> <span class="n">_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
            <span class="k">co_yield</span> <span class="n">_op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">BinaryOperation</span> <span class="n">_op</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lhs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">map_t</span><span class="o">&lt;</span><span class="n">BinaryOperation</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">rhs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">map_t</span><span class="o">&lt;</span><span class="n">BinaryOperation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach, we can apply our algorithms over a generator without having
to introduce a different type. They also compose very nicely, the only slightly
odd thing being using the <span class="docutils literal"><span class="pre">|</span></span> operator (though as I mentioned, there is a
precedent for this in Boost and chances are it might show up in other places in
the future).</p>
</div>
<div class="section" id="unified-call-syntax">
<h2>Unified Call Syntax</h2>
<p>One thing that would’ve made things even easier but unfortunately was not
approved for C++17 is <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4165.pdf">unified call syntax</a>.
At a high level, unified call syntax would make the compiler try to resolve
<span class="docutils literal"><span class="pre">x.f()</span></span> to <span class="docutils literal"><span class="pre">f(x)</span></span> if <span class="docutils literal"><span class="pre">decltype(x)</span></span> doesn’t have an <span class="docutils literal"><span class="pre">f()</span></span> member function
but there is a free function <span class="docutils literal"><span class="pre">f(decltype(x))</span></span>. Similarly, if no
<span class="docutils literal"><span class="pre">f(decltype(x))</span></span> exists but <span class="docutils literal"><span class="pre">decltype(x)</span></span> has a member function <span class="docutils literal"><span class="pre">f()</span></span>,
<span class="docutils literal"><span class="pre">f(x)</span></span> would resolve to the member function call <span class="docutils literal"><span class="pre">x.f()</span></span>.</p>
<p>If it’s not obvious, unified call syntax would allow us to easily create
extension methods. We would be able to revert our algorithm code to the first
version:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">take_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">filter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="k">co_yield</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">,</span> <span class="n">BinaryOperation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">gen</span><span class="p">)</span>
        <span class="k">co_yield</span> <span class="n">op</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But now this becomes very composable as calling <span class="docutils literal"><span class="pre">take_n</span></span>, <span class="docutils literal"><span class="pre">filter</span></span> or
<span class="docutils literal"><span class="pre">map</span></span> on a generator would resolve to the free functions if the <span class="docutils literal"><span class="pre">generator</span></span>
itself does not have them as members:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">count</span><span class="p">().</span>
        <span class="n">take_n</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span>
        <span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}).</span>
        <span class="n">map</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above currently does not compile but it should (disclaimer: slight tweaks
might be required) if unified call syntax becomes part of the standard.</p>
</div>
<div class="section" id="in-summary">
<h2>In Summary</h2>
<p>We went over a couple of alternatives to implement some common algorithms over
C++ generators with a focus on composability:</p>
<ul class="simple">
<li>Stand-alone functions are simple but don’t compose very well</li>
<li>Using a decorator works, but is not ideal from a design point of view and not
very idiomatic</li>
<li>Using the pipe operator for chaining and helper types for the algorithms is
the best approach today</li>
<li>Unified call syntax would simplify things a lot, enabling a mechanism to
implement these algorithms as extension methods</li>
</ul>
</div>
]]></description>
             <pubDate>Sun, 09 Oct 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/08/17/concepts-and-modules.html</link>
            <guid>http://vladris.com/blog/2016/08/17/concepts-and-modules.html</guid>
            <title><![CDATA[Concepts and Modules]]></title>
            <description><![CDATA[<h1>Concepts and Modules</h1>
<p>As a follow up to my previous post, I want to talk about two major new C++
features that keep not making it into the standard, namely <em>Concepts</em> and
<em>Modules</em>. These would have a significant impact on the code examples I
provided while discussing dependency injectiojn, so here’s a quick peek into the
future:</p>
<div class="section" id="concepts">
<h2>Concepts</h2>
<p>One way to think about concepts is that concepts are to templates what
interfaces are to classes. Similarly to how interfaces specify a contract which
implementing types must satisfy, concepts specify a contract which template
argument types must satisfy. The main difference is that interfaces/classes
enable runtime polymorphism while concepts/templates enable polymorphism at
compile-time.</p>
<p>Runtime polymorphism:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Our interface</span>
<span class="k">struct</span> <span class="nc">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// One implementation</span>
<span class="k">class</span> <span class="nc">V6Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Another implementation</span>
<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A function that works against the interface</span>
<span class="kt">void</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">IEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StartEngines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">V6Engine</span> <span class="n">v6engine</span><span class="p">;</span>
    <span class="n">V8Engine</span> <span class="n">v8engine</span><span class="p">;</span>

    <span class="c1">// calls Start() on V6Engine instance passed as IEngine</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v6engine</span><span class="p">);</span>
    <span class="c1">// calls Start() on V8Engine instance passed as IEngine</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v8engine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we have a single <span class="docutils literal"><span class="pre">StartEngine</span></span> function which works against an
interface. Calling <span class="docutils literal"><span class="pre">Start()</span></span> for that interface involves a virtual function
call, which means that at runtime, given an object of a type implementing
<span class="docutils literal"><span class="pre">IEngine</span></span>, the code needs to figure out which function of the implementing
type to call. For <span class="docutils literal"><span class="pre">V6Engine</span></span>, <span class="docutils literal"><span class="pre">IEngine::Start()</span></span> is <span class="docutils literal"><span class="pre">V6Engine::Start();</span></span>
for <span class="docutils literal"><span class="pre">V8Engine</span></span>, <span class="docutils literal"><span class="pre">IEngine::Start()</span></span> is <span class="docutils literal"><span class="pre">V8Engine::Start()</span></span>. Our classes
have a vtable - a table containing this mapping, so a virtual call looks up the
actual function to call in the vtable.</p>
<p>This is the “classical” object-oriented way of dispatching calls. The advantage
of this approach is that it works across binaries <a class="footnote-reference" href="#id3" id="id1">[1]</a> (we can export
<span class="docutils literal"><span class="pre">StartEngine</span></span> from a shared library and pass in an external <span class="docutils literal"><span class="pre">IEngine</span></span>
implementation to it), the disadvantage is the extra redirection - implementing
classes must have a vtable and call resolution involves jumping through it.</p>
<p>Compile-time polymorphism:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// One implementation</span>
<span class="k">class</span> <span class="nc">V6Engine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Another implementation</span>
<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A generic function</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TEngine</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">TEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">StartEngines</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">V6Engine</span> <span class="n">v6engine</span><span class="p">;</span>
    <span class="n">V8Engine</span> <span class="n">v8engine</span><span class="p">;</span>

    <span class="c1">// calls Start() on V6Engine, this instantiates</span>
    <span class="c1">// StartEngine&lt;V6Engine&gt;(V6Engine&amp; engine)</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v6engine</span><span class="p">);</span>
    <span class="c1">// calls Start() on V8Engine, this instantiates</span>
    <span class="c1">// StartEngine&lt;V8Engine&gt;(V8Engine&amp; engine)</span>
    <span class="n">StartEngine</span><span class="p">(</span><span class="n">v8engine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A few differences to note here: we don’t have an <span class="docutils literal"><span class="pre">IEngine</span></span> interface anymore
and the two types we use, <span class="docutils literal"><span class="pre">V6Engine</span></span> and <span class="docutils literal"><span class="pre">V8Engine</span></span>, no longer have virtual
functions. Calling <span class="docutils literal"><span class="pre">V6Engine::Start()</span></span> or <span class="docutils literal"><span class="pre">V8Engine::Start()</span></span> now no longer
involves a virtual call. The two <span class="docutils literal"><span class="pre">StartEngine</span></span> calls are actually made to
different functions now - at compile time, whenever the compiler encounters a
call to <span class="docutils literal"><span class="pre">StartEngine</span></span> with a new type, it instantiates the template, meaning
it creates a new function based on that template with the template type as the
provided type. We actually end up with one function that can start a
<span class="docutils literal"><span class="pre">V6Engine</span></span> and one that can start <span class="docutils literal"><span class="pre">V8Engine</span></span>, both produced from the same
template.</p>
<p>This is compile-time polymorphism, the advantage being that everything is
determined during build - no virtual calls etc., the disadvantage being that
the compiler needs to have a definition of the template available whenever it
needs to create a new instance <a class="footnote-reference" href="#id4" id="id2">[2]</a>. In this case we can’t encapsulate what
happens inside <span class="docutils literal"><span class="pre">StartEngine</span></span> if we want others to be able to call the
function.</p>
<div class="section" id="with-concepts">
<h3>With Concepts</h3>
<p>The above works just fine, the problem being that, in general, if you have
a templated function, it’s not obvious what contracts do the types it expects
need to satisfy. For example, our <span class="docutils literal"><span class="pre">StartEngine</span></span> expects that the given type
has a <span class="docutils literal"><span class="pre">Start()</span></span> function it can call. This isn’t obvious from the function
declaration though. Also, compiler errors when templates cannot be instantiated
are notoriously hard to decipher. The proposed solution to both of the above
are concepts. Here is how an engine concept would look like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TEngine</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="nc">bool</span> <span class="n">Engine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">requires</span><span class="p">(</span><span class="n">TEngine</span> <span class="n">engine</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">()</span> <span class="p">};</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This defines the <span class="docutils literal"><span class="pre">Engine</span></span> concept to require any type satisfying it to have a
<span class="docutils literal"><span class="pre">Start()</span></span> function and a <span class="docutils literal"><span class="pre">Stop()</span></span> function. <span class="docutils literal"><span class="pre">StartEngine</span></span> would then be
able to explicitly say what kind of types it expects:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="n">Engine</span> <span class="n">TEngine</span><span class="o">&gt;</span> <span class="n">StartEngine</span><span class="p">(</span><span class="n">TEngine</span><span class="o">&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is now clear from the function declaration that <span class="docutils literal"><span class="pre">StartEngine</span></span> expects a
type satisfying the <span class="docutils literal"><span class="pre">Engine</span></span> concept. We can look at the concept definition to
see what we need to implement on our type. The compiler would also be able to
issue much clearer errors when the type we pass in is missing one of the concept
requirements.</p>
<p>Unfortunately, while several proposals for concepts have been put forward in the
past years, they weren’t approved to be part of the C++17 standard. That being
said, it’s fairly certain that they will eventually make it into the standard.</p>
</div>
</div>
<div class="section" id="modules">
<h2>Modules</h2>
<p>Another noteworthy feature are modules: currently, the <span class="docutils literal"><span class="pre">#include</span></span> directive
textually includes the given file into the source file being compiled. This has
a lot of build-time overhead (same header files get compiled over and over as
they are included in various source files) and forces us to be extra-careful in
how we scope things: what goes in a header file vs. what goes in a source file
etc.</p>
<p>Modules aim to replace the header/source file split and provide a better way to
group components and expose functionality. For example, here is a header/source
file pair from my previous post:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// ICar.h</span>
<span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">struct</span> <span class="nc">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
<span class="n">Car</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span>

<span class="c1">// Car.cpp</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using modules, we would have:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">module</span> <span class="n">Car</span><span class="p">;</span>

<span class="k">import</span> <span class="n">Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">struct</span> <span class="nc">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is now a single file where we import the <span class="docutils literal"><span class="pre">Engine</span></span> module (instead of
<span class="docutils literal"><span class="pre">#include</span></span>), we provide the interface and concrete implementation, the factory
function, and we mark publicly-visible declarations with the <span class="docutils literal"><span class="pre">export</span></span> keyword.</p>
<p>Like Concepts, Modules haven’t made it into the C++17 standard, but MSVC has a
working implementation as of VS2015 Update 1.</p>
</div>
<div class="section" id="dependency-injection-in-the-future">
<h2>Dependency Injection in the Future</h2>
<p>So putting the above together, here is how dependency injection in C++ might
look like in the not too far future:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Engine.m</span>
<span class="k">module</span> <span class="n">Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TEngine</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="nc">bool</span> <span class="n">Engine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">requires</span><span class="p">(</span><span class="n">TEngine</span> <span class="n">engine</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Start</span><span class="p">()</span> <span class="p">};</span>
        <span class="p">{</span> <span class="n">engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">()</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// V8Engine.m</span>
<span class="k">module</span> <span class="n">V8Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// start the engine }</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// stop the engine }</span>
<span class="p">};</span>

<span class="c1">// Car.m</span>
<span class="k">module</span> <span class="n">Car</span><span class="p">;</span>

<span class="k">import</span> <span class="n">Engine</span><span class="p">;</span>
<span class="k">import</span> <span class="n">V8Engine</span><span class="p">;</span>

<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="n">Engine</span> <span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">requires</span> <span class="n">DefaultConstructible</span><span class="o">&lt;</span><span class="n">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Explicit instantiation exported from this module so clients</span>
<span class="c1">// won't have to re-instantiate the template for V8Engine type</span>
<span class="k">export</span> <span class="k">class</span> <span class="nc">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>This can be used as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">import</span> <span class="n">Car</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
<span class="n">car</span><span class="p">.</span><span class="n">Drive</span><span class="p">();</span>
</pre></div>
</div>
<p>This would be the equivalent of Dependency Injection with Templates I mentioned
in the previous post.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>As long as binaries are compiled with the same compiler. Otherwise the
code produced by different compilers might have different vtable layouts
and different name mangling.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Other disadvantages are slower compile times and potential code bloat,
as each template instantiation gets translated into a new function.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Wed, 17 Aug 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/07/06/dependency-injection-in-c.html</link>
            <guid>http://vladris.com/blog/2016/07/06/dependency-injection-in-c.html</guid>
            <title><![CDATA[Dependency Injection in C++]]></title>
            <description><![CDATA[<h1>Dependency Injection in C++</h1>
<p>In this post, I will switch gears from functional C++ to object oriented C++ and
talk about dependency injection.</p>
<p>Let’s start with a simple example: take a <span class="docutils literal"><span class="pre">Car</span></span> class with a <span class="docutils literal"><span class="pre">Drive()</span></span>
method. Let’s say this class contains a <span class="docutils literal"><span class="pre">V8Engine</span></span> attribute with <span class="docutils literal"><span class="pre">Start()</span></span>
and <span class="docutils literal"><span class="pre">Stop()</span></span> methods. An initial implementation might look like this:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">V8Engine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="dependency-injection-with-interfaces">
<h2>Dependency Injection with Interfaces</h2>
<p>In the above example, <span class="docutils literal"><span class="pre">Car</span></span> is tightly coupled to <span class="docutils literal"><span class="pre">V8Engine</span></span>, meaning we
can’t create a car without a concrete engine implementation. If we want the
ability to swap various engines or use a mock engine during testing, we could
reverse the dependency by creating an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and decoupling
<span class="docutils literal"><span class="pre">Car</span></span> from the concrete <span class="docutils literal"><span class="pre">V8Engine</span></span> implementation. This way, we only expose
an <span class="docutils literal"><span class="pre">IEngine</span></span> interface and a factory function. <span class="docutils literal"><span class="pre">Car</span></span> can work against that:</p>
<p><em>IEngine.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="nc">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">();</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">V8Engine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* start the engine */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* stop the engine */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">MakeV8Engine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="notes">
<h2>Notes</h2>
<div class="section" id="a-note-on-headers">
<h3>A note on headers</h3>
<p>Headers simply get textually included in each compilation unit by the
<span class="docutils literal"><span class="pre">#include</span></span> directive. It is not mandatory to provide a header file for each
class declaration. If a class can be scoped to a single source file, then it
doesn’t need a header declaration (for example the <span class="docutils literal"><span class="pre">V8Engine</span></span> class above
does not need a V8Engine.h header corresponding to the V8Engine.cpp). It is also
a good idea to have public headers and internal headers: public headers contain
the public API surface and can be included by other parts of the system, while
internal headers are only used within the component and should not be included
by external code.</p>
<p>Default should be the least visible: try to keep everything inside the cpp file
(like V8Engine.cpp). If that is not enough, an internal header might do. A
declartion should be pulled into a public header only when external components
need to reference it.</p>
</div>
<div class="section" id="a-note-on-interfaces">
<h3>A note on interfaces</h3>
<p>It’s a good idea to declare a default virtual destructor: if a deriving type has
a destructor, it won’t get called if we store an upcast pointer to the interface
unless the interface declares a virtual destructor. Note a destructor does not
to be expicitly defined - compiler might generate a default one.</p>
<p>MSVC compiler provides a <span class="docutils literal"><span class="pre">__declspec(novtable)</span></span> <a class="footnote-reference" href="#id2" id="id1">[1]</a> custom attribute which
tells the compiler not to generate a vtable for pure abstract classes. This
reduces code size. Below is the <span class="docutils literal"><span class="pre">IEngine</span></span> declaration with this attribute:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">novtable</span><span class="p">)</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Stop</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IEngine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>I won’t include it in the code samples in this post, but it’s worth keeping in
mind when working with MSVC.</p>
</div>
<div class="section" id="a-note-on-factory-functions">
<h3>A note on factory functions</h3>
<p>When working with interfaces as opposed to concrete types, we use factory
functions to get object instances. Below is a possible naming convention, taking
object ownership into account:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">MakeFoo</span><span class="p">();</span>
<span class="n">IFoo</span><span class="o">&amp;</span> <span class="nf">UseFoo</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span> <span class="n">GetFoo</span><span class="p">();</span>
</pre></div>
</div>
<p>The first function, <span class="docutils literal"><span class="pre">MakeFoo</span></span>, returns a unique pointer, passing ownership to
the caller. Like in the example above, the <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> can be moved into the
object, which ends up owning it. Use a Make when each call creates a new
instance.</p>
<p>The second function implies there already exists an <span class="docutils literal"><span class="pre">IFoo</span></span> object which is
owned by someone else, with the guarantee that it will outlive the caller. In
that case, there is no need for pointers and we can simply return a reference to
the object. This can be used, for example, for singletons. Below is an example
of a singleton <span class="docutils literal"><span class="pre">Engine</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">IEngine</span><span class="o">&amp;</span> <span class="nf">UseEngine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The third function, <span class="docutils literal"><span class="pre">GetFoo</span></span>, implies shared ownership - we get an object that
other objects might hold a reference to, but we don’t have the lifetime
guarantee a singleton would give us, so we need to use a shared pointer to make
sure the object is kept alive long enough.</p>
</div>
</div>
<div class="section" id="mocking">
<h2>Mocking</h2>
<p>Since <span class="docutils literal"><span class="pre">Car</span></span> now works with an <span class="docutils literal"><span class="pre">IEngine</span></span> interface, in test code we can mock
the engine:</p>
<p><em>Test.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span> <span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can also expose <span class="docutils literal"><span class="pre">Car</span></span> as a simple interface, hiding its implementation
details, in which case we would end up with the following:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"IEngine.h"</span><span class="cp"/>

<span class="k">struct</span> <span class="nc">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
         <span class="c1">// drive</span>
         <span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would become:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">car</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="c1">// Test ICar without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note this allows the caller to pass in any <span class="docutils literal"><span class="pre">IEngine</span></span>. We provide an
out-of-the-box <span class="docutils literal"><span class="pre">V8Engine</span></span> but other engines can be injected when <span class="docutils literal"><span class="pre">Car</span></span> gets
constructed. The headers IEngine.h and ICar.h are public per our above
defintion.</p>
<p>In general, it’s great if we can get the rest of the component code and unit
tests to work against the interface. Sometimes though we might need to know more
about the actual implementation inside our component, even if externally we only
expose an interface. In that case, we can add an internal Car.h header:</p>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
         <span class="o">:</span> <span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em> becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="kt">void</span> <span class="n">Car</span><span class="o">::</span><span class="n">Drive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="c1">// drive</span>
    <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span> <span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can include the internal header, and, while not necessarily recommended,
we can cast <span class="docutils literal"><span class="pre">ICar</span></span> to <span class="docutils literal"><span class="pre">Car</span></span> inside the component:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">icar</span> <span class="o">=</span> <span class="n">MakeCar</span><span class="p">(</span><span class="n">MakeV8Engine</span><span class="p">());</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">car</span><span class="p">);</span>
</pre></div>
</div>
<p>Another trick if needing access to internals (again, not something necessarily
recommended), is to make the unit test class testing <span class="docutils literal"><span class="pre">Car</span></span> a friend of the
<span class="docutils literal"><span class="pre">Car</span></span> class, in which case it can access its private members.</p>
<p>In summary, with this approach we are able to:</p>
<ul class="simple">
<li>Hide implementation details in the .cpp files</li>
<li>Work against abstract interfaces</li>
<li>Inject dependencies during object construction</li>
</ul>
</div>
<div class="section" id="dependecy-injection-with-templates">
<h2>Dependecy Injection with Templates</h2>
<p>An alternative to the above is to use templates. In this case, we would have to
provide the implementation inside the header file, as code needs to be available
when templates get instantiated:</p>
<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">class</span> <span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Start</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>V8Engine.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note <span class="docutils literal"><span class="pre">Car</span></span> is implemented in the header and <span class="docutils literal"><span class="pre">V8Engine</span></span> is also a publicly
visible header. Now we can create an instance of <span class="docutils literal"><span class="pre">Car</span></span> like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="p">...</span>

<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>
</pre></div>
</div>
<p>Mocking the engine in test code would look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>

<span class="k">class</span> <span class="nc">MockEngine</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* mock logic */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Car</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span> <span class="n">car</span><span class="p">;</span>

    <span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach we are able to:</p>
<ul class="simple">
<li>Inject dependencies during template instantiation</li>
<li>No need for virtual calls (note <span class="docutils literal"><span class="pre">TEngine</span></span> is not an interface, so calls can
be resolved at compile-time)</li>
<li><span class="docutils literal"><span class="pre">Car&lt;T&gt;</span></span> can be default-constructed</li>
</ul>
<p>A drawback here is we expose the implementation details of <span class="docutils literal"><span class="pre">Car</span></span> inside the
header file and we have to make this publicly visible.</p>
</div>
<div class="section" id="hybrid-approach">
<h2>Hybrid Approach</h2>
<p>We can use a hybrid approach if we don’t need an externally injected <span class="docutils literal"><span class="pre">Engine</span></span>.
Say our component provides a <span class="docutils literal"><span class="pre">V8Engine</span></span>, a <span class="docutils literal"><span class="pre">V6Engine</span></span>, and we have a
<span class="docutils literal"><span class="pre">MockEngine</span></span> used during testing. We have the same componentization
requirements but don’t need to expose all the details to consumers. In that case
we could have something like this:</p>
<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>

<span class="k">struct</span> <span class="nc">ICar</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ICar</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
</pre></div>
</div>
<p><em>Car.h (internal)</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">"ICar.h"</span><span class="cp"/>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Drive</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
        <span class="c1">// drive</span>
        <span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">TEngine</span> <span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><em>Car.cpp</em>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="cp">#include</span> <span class="cpf">"Car.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"V8Engine.h"</span><span class="cp"/>
<span class="cp">#include</span> <span class="cpf">"V6Engine.h"</span><span class="cp"/>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV8Car</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span> <span class="n">MakeV6Car</span><span class="p">();</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V6Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Test would remain the same as in the example above, where we worked against a
<span class="docutils literal"><span class="pre">Car</span></span> type (not an <span class="docutils literal"><span class="pre">ICar</span></span>) which we instantiate with a <span class="docutils literal"><span class="pre">MockEngine</span></span>.</p>
<p>With this approach:</p>
<ul class="simple">
<li>Our external API is an interface</li>
<li>Internally we still inject the dependency using a template</li>
</ul>
<p>With this approach, we do have an interface and virtual calls for <span class="docutils literal"><span class="pre">Car</span></span> but
not for <span class="docutils literal"><span class="pre">TEngine</span></span> types. One drawback with this approach is that consumers
cannot inject their own Engine type: we can only create cars with engines that
are known within our component.</p>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We decoupled <span class="docutils literal"><span class="pre">Car</span></span> from <span class="docutils literal"><span class="pre">V8Engine</span></span> and looked at three ways of injecting
the dependency:</p>
<ul class="simple">
<li>Using interfaces, where dependency is injected at runtime during object
creation</li>
<li>Using templates, where dependency is injected at compile-time during template
instantiation</li>
<li>A hybrid approach which uses templates internally but exposes only interfaces
publicly</li>
</ul>
<p>Each of these approaches has pros and cons, the tradeoffs mostly being around
encapsulation (how much of the component code we expose publicly), runtime
(templates are instantiated at compile-time so no virtual calls etc.), type
constraints (with templates we don’t require engines to implement a particular
<span class="docutils literal"><span class="pre">IEngine</span></span> interface), and flexibility (with the hybrid approach we can’t
inject an external engine, we can only use what the component has available
internally).</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For more details on <span class="docutils literal"><span class="pre">novtable</span></span>, see <a class="reference external" href="https://msdn.microsoft.com/en-us/library/k13k85ky.aspx">MSDN</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Wed, 06 Jul 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/04/24/abusing-maps.html</link>
            <guid>http://vladris.com/blog/2016/04/24/abusing-maps.html</guid>
            <title><![CDATA[(Ab)using Maps]]></title>
            <description><![CDATA[<h1>(Ab)using Maps</h1>
<div class="section" id="mapping-pattern">
<h2>Mapping pattern</h2>
<p>Using hash maps (or dictionaries, or lookups) is a very natural way of coding in
some languages, especially dynamic languages, where usually an object can be
treated as a map itself, to which attributes and methods can be added or removed
at runtime.</p>
<p>In practice though, maps are often used to convert a value of one type into a
value of a different type. It is not uncommon to have very small maps like</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>Here it is useful to make a distinction between the pattern and the data
structure. The coding pattern itself is great - mapping a value from a type to
a value of another type should definitely be declarative. Below is a
counterexample of non-declarative mapping:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">Bar</span> <span class="nf">barFromFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="o">==</span> <span class="n">foo3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bar3</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is really ugly. As I mentioned in <a class="reference internal" href="http://vladris.com/blog/2016/01/04/clean-code-part-1.html#clean-code-1"><span class="std std-ref">Clean Code - Part 1</span></a>, branching should be
avoided whenever possible, and this is a good opportunity to use a declarative
approach as opposed to a bunch of branching logic. That being said, while the
mapping pattern is great, in C++ the data structure most developers default to
is not the optimal one for this.</p>
</div>
<div class="section" id="the-problem-with-unordered-map">
<h2>The problem with unordered_map</h2>
<p>If you are coding in C++, odds are you care a little bit about the runtime
footprint of your code. In that case, you might be surprised to learn that,
while an <span class="docutils literal"><span class="pre">unordered_map</span></span> in C++ (or a lookup or hash map or dictionary in any
other language) has an average lookup cost of <span class="docutils literal"><span class="pre">O(1)</span></span>, there are better ways to
implement the above pattern.</p>
<p>A map in C++ is implemented as a red-black tree containing buckets of hashed
values. Calling <span class="docutils literal"><span class="pre">at()</span></span> on a map implies the given key has to be hashed and
the tree traversed to find the value. Calling <span class="docutils literal"><span class="pre">[]</span></span> on an inexistent key will
add it to the data structure, which might trigger a rebalancing of the tree.
There is a lot of work happening under the hood, and while this makes sense for
an <span class="docutils literal"><span class="pre">unordered_map</span></span> of arbitrarily large size, for small lookups it is a lot
of overhead.</p>
</div>
<div class="section" id="alternatives">
<h2>Alternatives</h2>
<p>An alternative to <span class="docutils literal"><span class="pre">unordered_map</span></span> provided by the boost library is
<span class="docutils literal"><span class="pre">flat_map</span></span> <a class="footnote-reference" href="#id3" id="id1">[1]</a>. This has similar semantics to an <span class="docutils literal"><span class="pre">unordered_map</span></span>, but the
key-values are stored in a contiguous data structure so traversing it is more
efficient than walking a tree.</p>
<p>In general, there are a couple of approaches for keeping a hash map in a linear
data structure:</p>
<ul class="simple">
<li>The keys can be kept sorted, which has <span class="docutils literal"><span class="pre">O(N)</span></span> worst case insertion since it
might require all elements to be moved to fit a new one and <span class="docutils literal"><span class="pre">O(logN)</span></span> lookup
(binary search)</li>
<li>The keys can be kept unsorted, which has <span class="docutils literal"><span class="pre">O(1)</span></span> insertion (simple append) but
<span class="docutils literal"><span class="pre">O(N)</span></span> lookup (linear search)</li>
</ul>
<p>For very small-sized lookups, the cost of hashing itself might out-weight a
linear traversal, so for a small N</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>performs worse than</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
    <span class="n">fooBarMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span>
    <span class="n">fooBarMap</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
    <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">foo</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
<p>On my machine (using MSVC 2015 STL implementation), for an N of 5, <span class="docutils literal"><span class="pre">find_if</span></span>
on a vector is about twice as fast as the equivalent <span class="docutils literal"><span class="pre">unordered_map</span></span> lookup.</p>
</div>
<div class="section" id="initialization-cost">
<h2>Initialization cost</h2>
<p>There’s event more hidden cost: <span class="docutils literal"><span class="pre">std::vector</span></span> manages a dynamic array which is
allocated on the heap. Having an <span class="docutils literal"><span class="pre">std::vector</span></span> initialized with key-values as
described above, even if more efficent than an <span class="docutils literal"><span class="pre">unordered_map</span></span>, still has
some associated cost in terms of heap allocations (albeit smaller than
<span class="docutils literal"><span class="pre">unordered_map</span></span>). <span class="docutils literal"><span class="pre">std::array</span></span> is a much better suited container for cases
when the key-values are known at compile time, as <span class="docutils literal"><span class="pre">std::array</span></span> simply wraps a
regular array which is not allocated on the heap. So a more efficient (in terms
of initialization cost) way of declaring such a look up is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">arrray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>We can still apply the <span class="docutils literal"><span class="pre">std::find_if</span></span> algorithm on this array, but we skip a
heap allocation. Depending on the template types used, we might be able to skip
any allocations whatsoever (if both types are trivial <a class="footnote-reference" href="#id4" id="id2">[2]</a>). For example, note
that <span class="docutils literal"><span class="pre">std::string</span></span>, similarly to a vector, wraps a heap-allocated <span class="docutils literal"><span class="pre">char*</span></span>
and constructing it requires heap allocations. <span class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></span> to a string
literal on the other hand is just a pointer to the <span class="docutils literal"><span class="pre">.rodata</span></span> segment. So this</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="s">"foo1"</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo2"</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo3"</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>performs three heap allocations (for <span class="docutils literal"><span class="pre">"foo1"</span></span>, <span class="docutils literal"><span class="pre">"foo2"</span></span>, and <span class="docutils literal"><span class="pre">"foo3"</span></span>),
while the (mostly) equivalent</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">Bar</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="s">"foo1"</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo2"</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"foo3"</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>shouldn’t perform any allocations.</p>
</div>
<div class="section" id="associative-array">
<h2>associative_array</h2>
<p>Since in practice maps are often used to implement the above described pattern
of mapping a value from one type to a value of a different type for a small
set of known values, it would be great to combine the efficiency of an array
with the nice lookup semantics of an <span class="docutils literal"><span class="pre">unordered_map</span></span> conatiner.</p>
<p>I propose a generic container of the following shape:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="nc">TKey</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">T</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span>
    <span class="k">typename</span> <span class="nc">KeyEqual</span> <span class="o">=</span> <span class="n">key_equal</span><span class="o">&lt;</span><span class="n">TKey</span><span class="o">&gt;&gt;</span>
<span class="k">struct</span> <span class="nc">associative_array</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">m_array</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">keq_equal</span></span> should simply resolve to <span class="docutils literal"><span class="pre">==</span></span> for most types, but be
specialized for strings types (to use <span class="docutils literal"><span class="pre">strcmp</span></span>, <span class="docutils literal"><span class="pre">wcscmp</span></span> etc.) and allow
clients to specialize their own <span class="docutils literal"><span class="pre">key_equal</span></span> when needed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">key_equal</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="nc">key_equal</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="c1">// specializations for wchar_t and const variations of the above</span>
</pre></div>
</div>
<p>Satisfying the container concept is fairly easy (eg. <span class="docutils literal"><span class="pre">size()</span></span> would return
<span class="docutils literal"><span class="pre">N</span></span>, iterators over the member array are trivial to implement etc.), the only
interesting methods are <span class="docutils literal"><span class="pre">find()</span></span>, <span class="docutils literal"><span class="pre">at()</span></span>, and <span class="docutils literal"><span class="pre">operator[]</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="p">...</span>
<span class="k">struct</span> <span class="nc">associative_array</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
            <span class="n">begin</span><span class="p">(),</span>
            <span class="n">end</span><span class="p">(),</span>
            <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">KeyEqual</span><span class="p">{}(</span><span class="n">key</span><span class="p">,</span> <span class="n">elem</span><span class="p">.</span><span class="n">first</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">end</span><span class="p">())</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"..."</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">TKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">find()</span></span> wraps <span class="docutils literal"><span class="pre">std::find_if</span></span> leveraging <span class="docutils literal"><span class="pre">KeyEqual</span></span> (with default
implementation as <span class="docutils literal"><span class="pre">key_equal</span></span>), <span class="docutils literal"><span class="pre">at()</span></span> wraps a bounds-checked <span class="docutils literal"><span class="pre">find</span></span>,
while <span class="docutils literal"><span class="pre">operator[]</span></span> does not check bounds. <span class="docutils literal"><span class="pre">const</span></span> implementations of the
above are also needed (identical except returning <span class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></span>).</p>
<p>Such a container would have similar semantics to <span class="docutils literal"><span class="pre">std::unordered_map</span></span> (minus
the ability to add elements given a key not already present in the container)
and the same performance profile of <span class="docutils literal"><span class="pre">std::array</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">associative_array</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">fooBarMap</span> <span class="o">=</span> <span class="p">{{</span>
    <span class="p">{</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">bar1</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">bar2</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">foo3</span><span class="p">,</span> <span class="n">bar3</span> <span class="p">}</span>
<span class="p">}};</span>

<span class="p">...</span>

<span class="k">auto</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">fooBarMap</span><span class="p">[</span><span class="n">foo</span><span class="p">];</span>
</pre></div>
</div>
<p>Note the only syntax difference between above and <span class="docutils literal"><span class="pre">unordered_map</span></span> is the
container type, the extra size <span class="docutils literal"><span class="pre">N</span></span> which needs to be specified at
declaration time, and an extra pair of curly braces. In practice, this should
have a significantly better lookup time than an unordered_map for a small N
(linear time, but since N is small and no hashing or heap traversal occurs,
should clock better than a map lookup) and virtually zero initialization time
- depending on the <span class="docutils literal"><span class="pre">TKey</span></span> and <span class="docutils literal"><span class="pre">T</span></span> types used, it is possible to declare
an <span class="docutils literal"><span class="pre">associative_array</span></span> as a <span class="docutils literal"><span class="pre">constexpr</span></span> fully evaluated at compile-time.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Boost <span class="docutils literal"><span class="pre">flat_map</span></span> documentation is <a class="reference external" href="http://www.boost.org/doc/libs/1_56_0/doc/html/boost/container/flat_map.html">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>For more details on trivial types, see the <a class="reference external" href="http://www.cplusplus.com/reference/type_traits/is_trivial/">is_trivial type trait</a>.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Sun, 24 Apr 2016 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/03/11/arguments-and-smart-pointers.html</link>
            <guid>http://vladris.com/blog/2016/03/11/arguments-and-smart-pointers.html</guid>
            <title><![CDATA[Arguments and Smart Pointers]]></title>
            <description><![CDATA[<h1>Arguments and Smart Pointers</h1>
<p>For efficiency reasons, C++ had a myriad of ways to pass data around. A
function can take arguments in several forms:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</pre></div>
</div>
<p>No to mention adding <span class="docutils literal"><span class="pre">const</span></span> and smart pointers into the mix.</p>
<p>And speaking of pointers, we have raw pointers, <span class="docutils literal"><span class="pre">unique_ptr</span></span>, <span class="docutils literal"><span class="pre">shared_ptr,</span></span>
<span class="docutils literal"><span class="pre">CComPtr</span></span>/<span class="docutils literal"><span class="pre">ComPtr</span></span> (for Windows COM objects), and, if you are working in
older codebases, <span class="docutils literal"><span class="pre">auto_ptr</span></span>, and maybe even some homebrewed refcounted
pointers.</p>
<p>All of this might seem a bit daunting and make C++ seem more complicated than
it really is. One way to think about it is from the ownership perspective:
objects are resources and the key question is “who owns this resource?”. This
should dictate both how a particular resource is allocated (and released) and
the shape function arguments should take. Lifetime is also an important
consideration - a resource shouldn’t be released while other components expect
it to be available, but it should be released as soon as it is no longer
needed.</p>
<p>In this post I will try to cover the various ways in which resources can be
allocated, owned, and passed around.</p>
<div class="section" id="stack-objects-and-passing-arguments">
<h2>Stack Objects and Passing Arguments</h2>
<p>The simplest, clearest thing to do is allocate objects on the stack. A stack
object doesn’t involve any pointers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The variable <span class="docutils literal"><span class="pre">bar</span></span> of type <span class="docutils literal"><span class="pre">Bar</span></span> is created on the stack. Once the stack
frame is popped (once the function is done executing, either through a normal
return or due to an exception) the object goes away. This is the easiest, safest
thing to do. The only reasons we wouldn’t always do this are time and space
requirements: lifetime-wise, we might want to somehow use <span class="docutils literal"><span class="pre">bar</span></span> after
<span class="docutils literal"><span class="pre">foo()</span></span> returns - for example we might want to pass it around to some other
object that wants to use at a later time; in terms of space, stack memory is
more limited than the heap, so large objects are better kept on the heap to
avoid overflow.</p>
<div class="section" id="pass-by-value">
<h3>Pass by value</h3>
<p>One way to get around the lifetime requirement is to pass the object by value:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="n">Bar</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// hands bar off to some other object</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s assume for this example that <span class="docutils literal"><span class="pre">do_suff</span></span> takes the argument and sticks it
into some global object which will use it as some future time.</p>
<p>The above code will simply create a copy of the object, so whatever <span class="docutils literal"><span class="pre">do_suff</span></span>
gets won’t be the original resource which gets freed once the function returns,
rather a copy of it. Copying an object costs both run time and space, but if
neither are a big concern, this is a great, safe way of ensuring resources don’t
get released before we’re done with them.</p>
</div>
<div class="section" id="move">
<h3>Move</h3>
<p>C++11 introduces a cheaper way of achieving this, through move semantics:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;&amp;</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// hands bar off to some other object</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With move semantics, the resource is actually <em>moved</em> into the <span class="docutils literal"><span class="pre">do_suff</span></span>
function. Once this happens, the original object is left in an undefined state
and shouldn’t be used anymore. This approach is usually employed when we have a
sink argument - we <em>sink</em> <span class="docutils literal"><span class="pre">bar</span></span> to its final resting place somewhere and
<span class="docutils literal"><span class="pre">foo()</span></span> no longer cares about it after passing it down to <span class="docutils literal"><span class="pre">do_stuff</span></span>.</p>
<p>One thing to keep in mind is that <span class="docutils literal"><span class="pre">move</span></span> is not magic, so <span class="docutils literal"><span class="pre">Bar</span></span> needs to
declare a <a class="reference external" href="http://en.cppreference.com/w/cpp/language/move_constructor">move constructor</a>
in order for this to do what we expect it to do. If Bar doesn’t declare a move
constructor, the above becomes a simple copy <a class="footnote-reference" href="#id4" id="id1">[1]</a>.</p>
</div>
<div class="section" id="pass-by-reference">
<h3>Pass by reference</h3>
<p>On the flipside, when we care about the size, so that we don’t want to create a
copy of the object, but we aren’t worried about the lifetime - meaning the
object we pass to <span class="docutils literal"><span class="pre">do_stuff</span></span> won’t have to outlive the function call, we can
pass by reference:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_suff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span> <span class="c1">// bar is only used within do_suff</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_suff</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note the <span class="docutils literal"><span class="pre">const</span></span> above - this means <span class="docutils literal"><span class="pre">do_suff</span></span> will use <span class="docutils literal"><span class="pre">bar</span></span> but won’t
modify it. By default, arguments should be marked as <span class="docutils literal"><span class="pre">const</span></span> unless the
function does indeed need to alter the object. Regardless of constness, in this
case we pass a reference to <span class="docutils literal"><span class="pre">bar</span></span> as an argument, which is very cheap (a
reference has the same size as a pointer). The only caveat is that <span class="docutils literal"><span class="pre">do_stuff</span></span>
should not pass this to some other object that outlives the function call (eg. a
global object which tries to use it later), because as soon as <span class="docutils literal"><span class="pre">foo</span></span> returns,
the reference becomes invalid.</p>
</div>
<div class="section" id="pass-by-pointer">
<h3>Pass by pointer</h3>
<p>A pointer argument would look like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">*</span> <span class="n">bar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A good rule of thumb is to not do this. The difference between passing by
reference and by pointer in this case is that a pointer can be null, while a
reference can’t. So passing by pointer here automatically brings the need to
perform null checks to ensure bad things don’t happen. You would need to make a
very good argument to convince me during code review that using a pointer
instead of a reference is appropriate. Unless working against a legacy API which
can’t be changed, I highly discourage use of raw pointers.</p>
</div>
<div class="section" id="summary">
<h3>Summary</h3>
<p>In summary, when designing an API:</p>
<ol class="arabic simple">
<li>Take argument by value if copying it is not a concern</li>
<li>Take argument by <span class="docutils literal"><span class="pre">const&amp;</span></span> if it’s not a sink argument, meaning we don’t
need to refer to it passed the function call</li>
<li>Take argument by reference (<span class="docutils literal"><span class="pre">&amp;</span></span>) if 2) but the API needs to modify it</li>
<li>Take argument by <span class="docutils literal"><span class="pre">&amp;&amp;</span></span> if it’s a sink argument, the type has a move
constructor, and copying it is expensive</li>
<li>Don’t pass raw pointers around</li>
</ol>
</div>
</div>
<div class="section" id="heap-objects-and-smart-pointers">
<h2>Heap Objects and Smart Pointers</h2>
<p>In all of the examples above, <span class="docutils literal"><span class="pre">bar</span></span> was an object created on the stack. This
works great in some cases, but some objects are simply too big to fit on the
stack, or it doesn’t make sense for them to do so (if, for example, we want to
vary their size at runtime). In this case, we allocate the object on the heap
and keep a pointer to it.</p>
<p>Once we start working with heap objects, ownership becomes even more important:
unlike stack objects, which get automatically destroyed when their stack frame
gets popped, heap objects need to be explicitly deleted. This responsibility
should be with the <em>owner</em> of the object.</p>
<div class="section" id="unique-pointer">
<h3>Unique pointer</h3>
<p>A unique pointer (<span class="docutils literal"><span class="pre">std::unique_ptr</span></span>) is a wrapper around a raw pointer which
will automatically delete the heap object when it goes out of scope itself:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// ptrBar goes out of scope =&gt; heap object gets deleted</span>
</pre></div>
</div>
<p>The above call to <span class="docutils literal"><span class="pre">make_unique</span></span> allocates an instance of Bar on the heap and
wraps the pointer to it into the unique pointer <span class="docutils literal"><span class="pre">ptrBar</span></span>. Now <span class="docutils literal"><span class="pre">ptrBar</span></span>
<em>owns</em> the object and as soon as ptrBar goes out of scope, the heap object is
also deleted.</p>
<p>Unique pointers cannot be copied, so we can never accidentally have more than
one single <span class="docutils literal"><span class="pre">unique_ptr</span></span> pointing to the same heap object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar2</span> <span class="o">=</span> <span class="n">ptrBar</span><span class="p">;</span> <span class="c1">// Won't compile</span>
</pre></div>
</div>
<p>Of course, if we <em>really</em> want to, we can get the raw pointer out of <span class="docutils literal"><span class="pre">ptrBar</span></span>
using <span class="docutils literal"><span class="pre">get()</span></span> and we can initialize a <span class="docutils literal"><span class="pre">unique_ptr</span></span> from a raw pointer -</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Please don't do this</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar2</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
</div>
<p>but this is very bad - now both pointers think they have sole ownership of the
resource, and as soon as one goes out of scope, using the other one leads to
undefined behavior. In general, the same way there are very few good reasons to
use raw pointers, there are very few good reasons to call <span class="docutils literal"><span class="pre">get()</span></span> on a smart
pointer.</p>
</div>
<div class="section" id="shared-pointer">
<h3>Shared pointer</h3>
<p>Sometimes, we do need to have several pointers pointing to the same heap object.
In this case, we can use shared pointers. Shared pointers pointing to the same
heap object keep a common reference count. Whenever a new shared pointer is
created for that particular heap object, the reference count is incremented.
Whenever a shared pointer for that heap object goes out of scope, the reference
count is decremented. Once the last shared pointer goes out of scope, the heap
object is deleted.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="c1">// one pointer to a Bar object on the heap (ref count = 1)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptrBar2</span><span class="p">(</span><span class="n">ptrBar1</span><span class="p">);</span>
        <span class="c1">// second shared pointer (ref count = 2)</span>
    <span class="p">}</span>
    <span class="c1">// ptrBar2 goes out of scope (ref count = 1)</span>
<span class="p">}</span>
<span class="c1">// ptrBar1 goes out of scope (ref count = 0) =&gt; heap object is deleted</span>
</pre></div>
</div>
<p>Shared pointers incur a bit more overhead than unique pointers - reference
counting needs to be atomic to account for multi-threaded environments, which
comes with a runtime cost. The reference count itself also needs to be stored
somewhere, which is a small space cost. Unique pointers don’t have these time
and space costs since they don’t need to count references - there is always only
one pointer to the object.</p>
<p>Costs aside, shared pointers also don’t make the ownership clear - there are
several instances “owning” the heap resource at the same time, which can
potentially alter it and step on each other’s toes. In general, prefer unique
pointers to shared pointers whenever possible.</p>
</div>
<div class="section" id="raw-pointer">
<h3>Raw pointer</h3>
<p>Avoid using raw pointers. Raw pointers don’t express ownership, so they don’t
offer the same guarantees that a) the resource pointed to gets properly cleaned
up and b) the resource pointed to is still valid at a given time. This leads to
dereferencing invalid memory and double-deletes (trying to free the same heap
object multiple times), which means undefined behavior. Also, don’t mix smart
and raw pointers - the smart pointers will keep doing their job happily, with
the potential of making the raw pointers invalid.</p>
</div>
<div class="section" id="com-pointers">
<h3>COM pointers</h3>
<p>On Windows, COM uses a different reference counting mechanism: the base
<span class="docutils literal"><span class="pre">IUnknown</span></span> interface declares <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> methods, which
implementations are expected to use to keep track of the reference count.
<span class="docutils literal"><span class="pre">CComPtr</span></span> (in ATL) and <span class="docutils literal"><span class="pre">ComPtr</span></span> (in WRL) are the COM smart pointers. They
call <span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> on the owned object, and the owned object is
supposed to delete itself once its reference count drops to 0. Note that COM
uses a slightly different mechanism than the standard library shared pointers -
instead of the smart pointer keeping track of the reference count in the control
block and deleting the object once the last reference goes away, COM objects are
expected to keep track of their reference count themselves through the
<span class="docutils literal"><span class="pre">AddRef</span></span> and <span class="docutils literal"><span class="pre">Release</span></span> methods and self-delete when the last reference goes
away (through <span class="docutils literal"><span class="pre">Release</span></span> call). The COM smart pointers only need to call
<span class="docutils literal"><span class="pre">Release</span></span> when they go out of scope.</p>
<p>It’s not a good idea to have both standard library and COM pointers point to the
same object, as each might decide to delete the object at different times -
<span class="docutils literal"><span class="pre">shared_ptr</span></span> looks at the <span class="docutils literal"><span class="pre">shared_ptr</span></span> refcount while COM objects look at
their internal reference count. So a <span class="docutils literal"><span class="pre">shared_ptr</span></span> might decide to delete an
object while a <span class="docutils literal"><span class="pre">ComPtr</span></span> still expects it to be valid or vice-versa. In
general, when working with COM objects, use COM smart pointers.</p>
</div>
<div class="section" id="auto-ptr">
<h3>auto_ptr</h3>
<p><span class="docutils literal"><span class="pre">auto_ptr</span></span> is a deprecated smart pointer. Unless working with an old compiler
and standard library, use <span class="docutils literal"><span class="pre">unique_ptr</span></span> or <span class="docutils literal"><span class="pre">shared_ptr</span></span> instead.</p>
</div>
<div class="section" id="other-smart-pointers">
<h3>Other smart pointers</h3>
<p>Old code bases might have custom smart pointer implementations, for the simple
fact that automatic memory management is always a good idea, and there is C++
code that predates the introduction of smart pointers into the standard library.
When interoperating with legacy code, use whatever works, but when writing new
code, do prefer standard library smart pointers to homebrewed ones.</p>
</div>
<div class="section" id="id2">
<h3>Summary</h3>
<p>In summary, when creating objects:</p>
<ol class="arabic simple">
<li>Create them on the stack if feasible (note that standard library types
like <span class="docutils literal"><span class="pre">std::vector</span></span> and <span class="docutils literal"><span class="pre">std::string</span></span> internally keep their data on
the heap, but they fit perfectly well on the stack, so you don’t need to
create an <span class="docutils literal"><span class="pre">std::vector</span></span> on the heap just because you are planning to
store a lot of elements in it - the vector manages a heap array
internally already).</li>
<li>Use a <span class="docutils literal"><span class="pre">unique_ptr</span></span> when creating them on the heap, to make ownership
obvious.</li>
<li>Use a <span class="docutils literal"><span class="pre">shared_ptr</span></span> only when <span class="docutils literal"><span class="pre">unique_ptr</span></span> isn’t sufficient (review
your design first, might be a design issue).</li>
<li>Use COM smart pointers like <span class="docutils literal"><span class="pre">CComPtr</span></span> when dealing with COM.</li>
<li>Don’t use <span class="docutils literal"><span class="pre">auto_ptr</span></span> or other old constructs unless working with legacy
code/compiler.</li>
<li>Don’t use raw pointers.</li>
</ol>
</div>
</div>
<div class="section" id="passing-smart-pointers-as-arguments">
<h2>Passing Smart Pointers as Arguments</h2>
<p>We covered passing arguments and smart pointers. Now combining the two, how do
we pass heap objects as arguments? Turns out Herb Sutter has
<a class="reference external" href="http://bit.ly/227Na5c">a great post</a> on this exact topic on his blog. I can’t
hope to explain better than him, so go read his post. I will try to summarize:</p>
<div class="section" id="pass-by-reference-the-pointed-to-type">
<h3>Pass by reference the pointed-to type</h3>
<p>Rather than forcing callers to use <span class="docutils literal"><span class="pre">unique_ptr</span></span> or <span class="docutils literal"><span class="pre">shared_ptr</span></span> by
specifying the smart pointer type (which makes assumptions about ownership),
just ask for a reference to the pointed-to-type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="o">*</span><span class="n">ptrBar</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Herb also mentions raw pointer to the underlying type if the argument can be
null, but as I mentioned above, I’d rather stick to references and discourage
use of raw pointers as a general rule of thumb.</p>
</div>
<div class="section" id="pass-smart-pointer-by-value">
<h3>Pass smart pointer by value</h3>
<p>Passing a <span class="docutils literal"><span class="pre">unique_ptr</span></span> by value implies a sink argument - since a
<span class="docutils literal"><span class="pre">unique_ptr</span></span> cannot be copied, it has to be <span class="docutils literal"><span class="pre">std::move</span></span>’d in. Interestingly,
Scott Meyers has <a class="reference external" href="http://bit.ly/1WgkvEh">a post</a> on his blog where he
disagrees with this and argues that arguments of move-only types should be
specified as <span class="docutils literal"><span class="pre">&amp;&amp;</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span> <span class="c1">// sink</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Passing a <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value implies the function wants to partake in the
ownership - in other words, will keep somewhere a reference to the object after
the function returns, but unlike the above <span class="docutils literal"><span class="pre">unique_ptr</span></span> example, it won’t have
exclusive ownership of the resource:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptrBar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">do_stuff</span><span class="p">(</span><span class="n">ptrBar</span><span class="p">);</span> <span class="c1">// copy-constructs another shared_ptr which shares ownership of the heap object</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pass-smart-pointer-by-reference">
<h3>Pass smart pointer by reference</h3>
<p>Only expect a smart pointer by non-const reference if the function is going to
modify the smart pointer itself (eg. by making it point to a different object).
In my experience, this is a rare occurrence.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Implies this function modifies the pointer itself.</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span>
</pre></div>
</div>
<p>There is no good reason to expect a <span class="docutils literal"><span class="pre">const&amp;</span></span> to a <span class="docutils literal"><span class="pre">unique_ptr</span></span>, just reference
the underlying type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// void do_stuff(const unique_ptr&lt;Bar&gt;&amp; ptrBar);</span>
<span class="c1">// No reason to use the above as opposed to</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>
</pre></div>
</div>
<p>Expect <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">shared_ptr</span></span> only if the function <em>might</em> create a copy
of the smart pointer. If the function would never create a copy of the pointer,
simply use <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type. If the function would always copy the
pointer, expect <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="c1">// Might or might not share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;&amp;</span> <span class="n">ptrBar</span><span class="p">);</span>

<span class="c1">// Will never share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">);</span>

<span class="c1">// Will always share ownership</span>
<span class="kt">void</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">ptrBar</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3>Summary</h3>
<p>A summary of the summary:</p>
<ol class="arabic simple">
<li>Take argument by <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type if you only care about the heap
object, not about the pointer.</li>
<li>Take <span class="docutils literal"><span class="pre">unqiue_ptr</span></span> by <span class="docutils literal"><span class="pre">&amp;&amp;</span></span> to transfer ownership.</li>
<li>Take <span class="docutils literal"><span class="pre">shared_ptr</span></span> argument by value to partake in ownership.</li>
<li>Take smart pointer by (non-const) reference only if you are going to
modify the smart pointer itself.</li>
<li>No need for <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">unique_ptr</span></span> (just take <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type)</li>
<li>Take <span class="docutils literal"><span class="pre">const&amp;</span></span> to <span class="docutils literal"><span class="pre">shared_ptr</span></span> only if unknown whether function wants
ownership (take by <span class="docutils literal"><span class="pre">&amp;</span></span> to underlying type if function never wants
ownership, <span class="docutils literal"><span class="pre">shared_ptr</span></span> by value if function always wants ownership).</li>
</ol>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Move constructors can be implicitly declared by the compiler if certain
conditions are met, see <a class="reference external" href="http://en.cppreference.com/w/cpp/language/move_constructor#Implicitly-declared_move_constructor">here</a>
for details.</td></tr>
</tbody>
</table>
</div>
</div>
]]></description>
             <pubDate>Fri, 11 Mar 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/01/07/clean-code-part-2.html</link>
            <guid>http://vladris.com/blog/2016/01/07/clean-code-part-2.html</guid>
            <title><![CDATA[Clean Code - Part 2]]></title>
            <description><![CDATA[<h1>Clean Code - Part 2</h1>
<p>In <a class="reference external" href="http://vladris.com/blog/2016/01/04/clean-code-part-1">Part 1</a> I talked about writing less code and
writing simple code. In this post I will cover writing stateless code and
writing readable code.</p>
<div class="section" id="write-stateless-code">
<h2>Write Stateless Code</h2>
<blockquote>
<div><p>A <strong>pure function</strong> is a <strong>function</strong> where the return value is only
determined by its input values, without observable side effects. This is
how <strong>functions</strong> in math work: <span class="docutils literal"><span class="pre">Math.cos(x)</span></span> will, for the same value
of <span class="docutils literal"><span class="pre">x</span></span>, always return the same result.</p>
<p><em>Source:</em> <a class="reference external" href="http://www.sitepoint.com/functional-programming-pure-functions/">SitePoint</a></p>
</div></blockquote>
<p>Things break when a program gets into a “bad state”. There are a couple of ways
to make this less likely to happen: making data immutable and writing functions
that don’t have side-effects (<em>pure</em> functions).</p>
<div class="section" id="immutable-data">
<h3>Immutable data</h3>
<p>If something shouldn’t change, mark it as immutable and let the compiler enforce
that. A good rule of thumb is to mark things as <span class="docutils literal"><span class="pre">const</span></span> (<span class="docutils literal"><span class="pre">const&amp;</span></span>,
<span class="docutils literal"><span class="pre">const*</span></span> etc.) and/or <span class="docutils literal"><span class="pre">readonly</span></span> by default, and make them mutable only when
truly needed <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>A simple example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">StringUtil</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Both <span class="docutils literal"><span class="pre">StringUtil::Concat1</span></span> and <span class="docutils literal"><span class="pre">StringUtil::Concat2</span></span> return the same thing
for the same input, the difference being that <span class="docutils literal"><span class="pre">Concat2</span></span>, as opposed to
<span class="docutils literal"><span class="pre">Concat1</span></span>, modifies its first argument. In a bigger function, such a change
might be introduced accidentally and have unexpected consequences down the line.</p>
<p>A simple way to address this is by explicitly marking the arguments as
<span class="docutils literal"><span class="pre">const</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">struct</span> <span class="nc">StringUtil</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat1</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Concat2</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="k">return</span> <span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span> <span class="c1">// Won't compile - can't call append on str1</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this case, <span class="docutils literal"><span class="pre">Concat2</span></span> won’t compile, so we can rely on the compiler to
eliminate this type of unintended behavior.</p>
<p>Another example: a simple <span class="docutils literal"><span class="pre">UpCase</span></span> function which calls <span class="docutils literal"><span class="pre">toupper</span></span> on each
character of the given string, upcasing it in place:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">UpCase</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">);</span>
        <span class="n">string</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Calling it with</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">char</span><span class="o">*</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">UpCase</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span>
</pre></div>
</div>
<p>will lead to a crash at runtime - the function will try to call <span class="docutils literal"><span class="pre">toupper</span></span> on
the characters of <span class="docutils literal"><span class="pre">myString</span></span>. The problem is that <span class="docutils literal"><span class="pre">myString</span></span> is a <span class="docutils literal"><span class="pre">char*</span></span>
to a string literal which gets compiled into the read-only data segment of the
binary. This cannot be modified.</p>
<p>To catch this type of errors at compile-time, we again only need to mark the
immutable data as such:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">"Foo"</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">UpCase</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span> <span class="c1">// Won't compile - can't call UpCase on myString</span>
</pre></div>
</div>
<p>In contrast with the previous example, the argument to <span class="docutils literal"><span class="pre">UpCase</span></span> is mutable by
design (the API is modifying the string in-place), but marking <span class="docutils literal"><span class="pre">myString</span></span> as
<span class="docutils literal"><span class="pre">const</span></span> tells the complier this is non-mutable data, so it can’t be used with
this API.</p>
</div>
<div class="section" id="pure-functions">
<h3>Pure functions</h3>
<p>Another way to reduce states is to use pure functions. Unfortunately there isn’t
a lot of syntax-level support for this in C++ and C# (C++ supports <span class="docutils literal"><span class="pre">const</span></span>
member functions, which guarantee at compile time that calling the member
function on an instance of the type won’t change the attributes of that
instance) <a class="footnote-reference" href="#id6" id="id2">[2]</a></p>
<p>This goes back to the recommendation from Part 1 of using generic algorithms and
predicates rather than implementing raw loops. In many cases, traversal state is
encapsulated in the library algorithm or in an iterator, and predicates ideally
don’t have side-effects.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span>
                <span class="n">Where</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">).</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>Above code (also from Part 1) doesn’t hold any state: traversal is handled by
the Linq methods, the predicates are pure.</p>
<p>In general, try to encapsulate state in parts of the code built to manage state,
and keep the rest stateless. Note that immutable data and pure functions are
also an advantage in concurrent applications, since they can’t generate race
conditions.</p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Prefer pure functions to stateful functions and, if state is needed, keep it
contained</li>
<li>By default mark everything as <span class="docutils literal"><span class="pre">const</span></span> (or <span class="docutils literal"><span class="pre">readonly</span></span>), and only remove
the constraint when mutability is explicitly needed</li>
</ul>
</div>
</div>
<div class="section" id="write-readable-code">
<h2>Write Readable Code</h2>
<blockquote>
<div><p>In computer science, the <strong>expressive power</strong> (also called
<strong>expressiveness</strong> or expressivity) of a language is the breadth of ideas
that can be represented and communicated in that language […]</p>
<ul class="simple">
<li>regardless of ease (theoretical expressivity)</li>
<li><strong>concisely and readily</strong> (practical expressivity)</li>
</ul>
<p><em>Source:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Expressive_power_(computer_science)">Wikipedia</a></p>
</div></blockquote>
<p>Code is read many more times than it is written/modified, so it should be
optimized for readability. What I mean by this is making the intent of the code
clear at a glance - this includes giving good descriptive names to variables,
functions, and types, adding useful comments where appropriate (a comment should
describe what the code does if it is non-obvious; a comment like <span class="docutils literal"><span class="pre">foo();</span> <span class="pre">//</span> <span class="pre">calls</span> <span class="pre">foo()</span></span>
is not a useful comment), and in general structure the code for easy reading.</p>
<p>For a counterexample, think back on a piece of code you read that elicited a
WTF. That’s the kind of code you don’t want to write.</p>
<p>I won’t insist much here, since there are countless books and industry best
practices for improving code readability.</p>
<p>Another way to make the code more readable is to have a good knowledge of the
language you are using. The strength of a language lies in its particularities,
so use them whenever appropriate. This means writing <a class="reference external" href="http://stackoverflow.com/questions/84102/what-is-idiomatic-code">idiomatic code</a>,
which implies knowledge of the language idioms. Don’t write C++ code like C
code, write it like C++ code. Don’t write C# code as C++, write it as C# etc.</p>
<p>Also, keep up to date on the language. Language syntax evolves to address needs,
so in general modern syntax introduces simpler, better ways to implement things
than old syntax. Take object allocation and initialization in C++ as an example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span/><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">));</span>
<span class="n">init</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">deinit</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the C way of allocating and initializing a structure on the heap, then
deinitializing and freeing it. Allocation and initialization are separate steps,
with opportunity to leak both memory (by omitting the <span class="docutils literal"><span class="pre">free</span></span> call) and
managed resources (by omitting the <span class="docutils literal"><span class="pre">deinit</span></span> call). Not to mention opportunity
to end up with an initialized struct (by omitting the <span class="docutils literal"><span class="pre">init</span></span> call), or
accidental double-initialization, double-deinitialization, double-free etc.</p>
<p>C++ introduced classes, and the following syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">...</span>
<span class="k">delete</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">new</span></span> both allocates memory and calls the constructor, while <span class="docutils literal"><span class="pre">delete</span></span> calls
the destructor then releases the memory. Many of the problems in the C example
go away, but there is still the problem of leaking the resource by omitting the
<span class="docutils literal"><span class="pre">delete</span></span> call, and the issue of calling <span class="docutils literal"><span class="pre">delete</span></span> twice on the same memory
address.</p>
<p>To address these issues, smart pointers were introduced in the language:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">());</span>
</pre></div>
</div>
<p>Smart pointers encapsulate reference counting (how many <span class="docutils literal"><span class="pre">shared_ptr</span></span> objects
point to the same memory address), and automatically release the resource when
the last reference goes away. This gets rid of most problems, but there is an
even better way of allocating heap objects:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="k">auto</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">make_shared</span></span> has the advantage of improved performance, by allocating memory
in a single operation for both the object and the shared pointer’s own control
block <a class="footnote-reference" href="#id7" id="id3">[3]</a>. It also prevents leaks due to interleaving <a class="footnote-reference" href="#id8" id="id4">[4]</a>. So as the C++
language evolved, new constructs appeared to address potential problems. Keeping
up to date with these updates, and incorporating them into your code will reduce
the opportunity for bugs, make the code more concise, and thus more readable.</p>
<div class="section" id="beautiful-code">
<h3>Beautiful Code</h3>
<p>I encourage you to not stop at writing <em>working</em> code, rather strive to write
<em>beautiful</em> code. I have the following quote from <a class="reference external" href="http://www.goodreads.com/book/show/5608045-apprenticeship-patterns">Apprenticeship Patterns</a>
on the wall behind my monitors, so I can see it while I work:</p>
<blockquote>
<div>There’s always a better/faster/smarter way to do what you’re currently doing</div></blockquote>
<p>So don’t stop as soon as something works, ask yourself <em>is this the best way to
implement this?</em></p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Come up with good names</li>
<li>Write meaningful comments</li>
<li>Keep up to date with your language</li>
<li>Don’t just write working code, write beautiful code.</li>
</ul>
</div>
</div>
<div class="section" id="epilogue">
<h2>Epilogue</h2>
<p>As I was working on putting together the talk that inspired this post, I
realized there are a few more rules of thumb which I could cover. The current
working draft is:</p>
<ul class="simple">
<li>Write safe code</li>
<li>Write leakproof code</li>
<li>Write responsive code</li>
<li>Write testable code</li>
</ul>
<p>Sometime in the future I hope to continue the series with the above, in the
meantime, I’ll leave you with this one sentence summary:</p>
<blockquote>
<div><p>Always code as if the person who ends up maintaining your code is a violent psychopath who
knows where you live</p>
<p><em>Source:</em> <a class="reference external" href="http://blog.codinghorror.com/coding-for-violent-psychopaths/">Coding Horror</a></p>
</div></blockquote>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>At the time of this writing, there is an <a class="reference external" href="https://github.com/dotnet/roslyn/issues/7626">active proposals</a>
to extend the C# language with an <span class="docutils literal"><span class="pre">immutable</span></span> keyword.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>C# has a <span class="docutils literal"><span class="pre">PureAttribue</span></span> in the <span class="docutils literal"><span class="pre">System.Diagnostics.Contracts</span></span>
namespace (purity not compiler-enforced) and there is an <a class="reference external" href="https://github.com/dotnet/roslyn/issues/7561">active proposal</a>
to add a keyword for it too.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>This is a non-binding requirement in the standard, meaning a standard
library implementation doesn’t <em>have to</em> do this, but most implementations
will. You can read more about it <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">here</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Interleaving occurs since call order is not guaranteed. For example, in
<span class="docutils literal"><span class="pre">bar(std::share_ptr&lt;Foo&gt;(new</span> <span class="pre">foo()),</span> <span class="pre">baz())</span></span>, there is no guarantee that
call order will be <span class="docutils literal"><span class="pre">new</span> <span class="pre">foo()</span></span>, then the shared pointer’s constructor, then
<span class="docutils literal"><span class="pre">baz()</span></span>. Calls might get interleaved and executed as <span class="docutils literal"><span class="pre">new</span> <span class="pre">foo()</span></span>, then
<span class="docutils literal"><span class="pre">baz()</span></span>, then the shared pointer constructor, in which case an exception
thrown by <span class="docutils literal"><span class="pre">baz()</span></span> would leak the newly allocated <span class="docutils literal"><span class="pre">Foo</span></span> object, since the
shared pointer didn’t get ownership of it yet.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Thu, 07 Jan 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2016/01/04/clean-code-part-1.html</link>
            <guid>http://vladris.com/blog/2016/01/04/clean-code-part-1.html</guid>
            <title><![CDATA[Clean Code - Part 1]]></title>
            <description><![CDATA[<span id="clean-code-1"/><h1>Clean Code - Part 1</h1>
<p>These posts are based on a Clean Code talk I did for my team a few months ago,
which, in turn, was inspired by the advice I gave to some of our summer
interns as four rules of thumb for writing cleaner code:</p>
<ul class="simple">
<li>Write less code</li>
<li>Write simple code</li>
<li>Write stateless code</li>
<li>Write readable code</li>
</ul>
<p>I will cover the first two points in this post and the remaining two in Part 2.
I’m talking about C++ and C# throughout, but most of this should be applicable
to any object-oriented or multi-paradigm language.</p>
<div class="section" id="write-less-code">
<h2>Write Less Code</h2>
<blockquote>
<div><p>The number of defects found in open source projects was 0.45 defects/1,000
lines of code, while the industry’s average is around 1 defect per 1,000
lines of code for companies not using automated testing such as static
analysis.</p>
<p><em>Source:</em> <a class="reference external" href="http://www.infoq.com/news/2012/03/Defects-Open-Source-Commercial">InfoQ</a></p>
</div></blockquote>
<p>A great way to have fewer bugs is to have fewer lines of code! What I mean by
this is that churning out many lines of code is by no means a measure of
productivity yet, unfortunately, most developers still feel great when, at the
end of the day, we wrote <em>insert high number</em> LoC.</p>
<div class="section" id="how-to-write-less-code">
<h3>How to write less code?</h3>
<p>Two points to keep in mind: first, don’t reinvent the wheel - don’t write code
if there is an existing library, internal to your company or open-source, that
already does what needs to be done. Case in point, we refactored some code for
a project (C#), extracted some interfaces, componentized things, and wrote a
bunch of unit tests. All of this was great, except we ended up with a bunch of
handcrafted stub classes: for</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IMyComponent</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Foo</span><span class="p">();</span>
    <span class="kt">int</span> <span class="nf">Bar</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">Baz</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>we had</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">MyComponentStub</span> <span class="p">:</span> <span class="n">IMyComponent</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Baz</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">myComponentStub</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyComponentStub</span><span class="p">();</span>
</pre></div>
</div>
<p>and so on. Implementing these stubs was tedious, needless work - we integrated
<a class="reference external" href="https://github.com/Moq/moq4">Moq</a> , a mocking library, and the above code
turned into:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">using</span> <span class="nn">Moq</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">var</span> <span class="n">myComponentStub</span> <span class="p">=</span> <span class="n">Mock</span><span class="p">.</span><span class="n">Of</span><span class="p">&lt;</span><span class="n">IMyComponent</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>Moq uses reflection to stub out interfaces at run-time, so simply adopting the
library helped us get rid of a lot of code.</p>
<p>The second way to write less code is to know the standard library of your
language of choice. Many times, a block of code can be replaced with a simple
library call. For C++, pay particular attention to the STL <span class="docutils literal"><span class="pre">&lt;algorithm&gt;</span></span> header
and for C#, <span class="docutils literal"><span class="pre">System.Linq</span></span>. Both contain many of useful algorithms which can
replace a lot of code.</p>
<p>I also recommend watching Sean Parent’s <a class="reference external" href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">C++ Seasoning</a>
talk, one of the best tech talks I’ve seen. The example he gives in the talk
(from the Chrome codebase) shows how a couple of lines of STL code can be used
instead of a whole convoluted function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="n">PanelBar</span><span class="o">::</span><span class="n">RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span>

  <span class="c1">// First, find the index of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span> <span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Next, check if the panel has moved to the other side of another panel.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">center_x</span> <span class="o">=</span> <span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">center_x</span> <span class="o">&lt;=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span> <span class="o">||</span>
        <span class="n">i</span> <span class="o">==</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">panel</span> <span class="o">!=</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If it has, then we reorder the panels.</span>
        <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">];</span>
        <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Find the total width of the panels to the left of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">total_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fixed_index</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span> <span class="o">==</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">total_width</span> <span class="o">+=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="mi">-1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">new_fixed_index</span> <span class="o">=</span> <span class="n">fixed_index</span><span class="p">;</span>

  <span class="c1">// Move panels over to the right of the fixed panel until all of the ones</span>
  <span class="c1">// on the left will fit.</span>
  <span class="kt">int</span> <span class="n">avail_width</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">&gt;</span> <span class="n">avail_width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_fixed_index</span><span class="o">--</span><span class="p">;</span>
    <span class="n">CHECK_GE</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">total_width</span> <span class="o">-=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Reorder the fixed panel if its index changed.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_fixed_index</span> <span class="o">!=</span> <span class="n">fixed_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
    <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
    <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">new_fixed_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Now find the width of the panels to the right, and move them to the</span>
  <span class="c1">// left as needed.</span>
  <span class="n">total_width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">total_width</span> <span class="o">+=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">avail_width</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">total_width</span> <span class="o">&gt;</span> <span class="n">avail_width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_fixed_index</span><span class="o">++</span><span class="p">;</span>
    <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">total_width</span> <span class="o">-=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Do the reordering again.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_fixed_index</span> <span class="o">!=</span> <span class="n">fixed_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
    <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
    <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">new_fixed_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Finally, push panels to the left and the right so they don't overlap.</span>
  <span class="kt">int</span> <span class="n">boundary</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">reverse_iterator</span> <span class="n">it</span> <span class="o">=</span>
       <span class="c1">// Start at the panel to the left of 'new_fixed_index'.</span>
       <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">new_fixed_index</span><span class="p">);</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">),</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">boundary</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_fixed_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Panel</span><span class="o">*</span> <span class="n">panel</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span> <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">boundary</span> <span class="o">+</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span>
                  <span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">-</span> <span class="n">kBarPadding</span><span class="p">),</span>
                  <span class="n">kAnimMs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span> <span class="o">+</span> <span class="n">kBarPadding</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>becomes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="n">PanelBar</span><span class="o">::</span><span class="n">RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span> <span class="n">fixed_panel</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span>

  <span class="c1">// First, find the index of the fixed panel.</span>
  <span class="kt">int</span> <span class="n">fixed_index</span> <span class="o">=</span> <span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span> <span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span> <span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Next, check if the panel has moved to the left side of another panel.</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">)</span> <span class="o">+</span> <span class="n">fixed_index</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">),</span> <span class="n">f</span><span class="p">,</span> <span class="n">center_x</span><span class="p">,</span>
    <span class="p">[](</span><span class="k">const</span> <span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">){</span> <span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>

  <span class="c1">// If it has, then we reorder the panels.</span>
  <span class="n">rotate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Code snippets borrowed from Sean Parent’s slides, I highly recommend watching the
whole talk.</p>
<p>The key takeaway here is that there could be a standard library implementation or
an external module that can greatly simplify your work and it’s a good practice
to always ask yourself <em>“do I really need to write this?”</em></p>
</div>
</div>
<div class="section" id="write-simple-code">
<h2>Write Simple Code</h2>
<p>First, a few notes on cyclomatic complexity from Wikipedia:</p>
<blockquote>
<div><p>Cyclomatic complexity is a software metric (measurement), used to indicate
the complexity of a program. It is a quantitative measure of the number of
linearly independent paths through a program’s source code.</p>
<dl class="docutils">
<dt>The complexity M is then defined as</dt>
<dd><em>M = E − N + 2P</em></dd>
<dt>where</dt>
<dd><em>E = the number of edges of the graph, N = the number of nodes of the
graph, P = the number of connected components.</em></dd>
</dl>
<div align="center" class="align-center"><img alt="../../../_images/cyclomatic_complexity.svg" src="http://vladris.com/blog/_images/cyclomatic_complexity.svg"/></div>
<p>A control flow graph of a simple program. The program begins executing at
the red node, then enters a loop (group of three nodes immediately below
the red node). On exiting the loop, there is a conditional statement (group
below the loop), and finally the program exits at the blue node. This graph
has 9 edges, 8 nodes, and 1 connected component, so the cyclomatic
complexity of the program is 9 - 8 + 2 * 1 = 3.</p>
<p><em>Source:</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Wikipedia</a></p>
</div></blockquote>
<p>The cyclomatic complexity of any piece of code should be minimized. This can be
achieved by avoiding branching, namely, whenever possible, avoiding conditional
statements and loops. Linear code is easier to read and maintain, and provides
less opportunities for bugs.</p>
<div class="section" id="avoiding-conditional-statements">
<h3>Avoiding conditional statements</h3>
<p>One way to avoid conditional statements is to, whenever feasible, throw
exceptions instead of propagating errors through return values.</p>
<p>Here is an example of error code propagation through return values using the
Windows API’s <span class="docutils literal"><span class="pre">HRESULT</span></span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="n">HRESULT</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">// Does some work and returns an HRESULT</span>
<span class="n">HRESULT</span> <span class="nf">bar</span><span class="p">();</span> <span class="c1">// Does some work and returns an HRESULT</span>

<span class="n">HRESULT</span> <span class="nf">baz</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HRESULT</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">S_OK</span><span class="p">;</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="n">baz</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>

    <span class="p">...</span> <span class="c1">// Some more work here which might fail</span>

    <span class="k">return</span> <span class="n">hr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">baz</span><span class="p">()))</span>
<span class="p">{</span>
    <span class="c1">// :)</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// :(</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This can be replaced with the more concise and much easier to read:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span/><span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span> <span class="c1">// Does some work, might throw</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">();</span> <span class="c1">// Does some work, might throw</span>

<span class="kt">void</span> <span class="nf">baz</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
    <span class="n">baz</span><span class="p">();</span>

    <span class="p">...</span> <span class="c1">// Some more work here which might fail (and throw)</span>
<span class="p">}</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">baz</span><span class="p">();</span>
    <span class="c1">// :)</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(...)</span>
<span class="p">{</span>
    <span class="c1">// :(</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Error code return values come from the old days when exceptions didn’t exist
and make code harder to read. That being said, for C++ specifically, you
should be careful about throwing exceptions across DLL boundaries. In practice
though, a lot of code in the shape of the above example appears within the
same executable for no good reason. If cross-DLL boundary is a problem, I would
actually recommend using exceptions internally and switching to return codes at
the public API boundary.</p>
<p>Another way to avoid conditional statements is to use the <a class="reference external" href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null Object pattern</a>
instead of checking for null. For example, take an <span class="docutils literal"><span class="pre">IActivity</span></span> interface on
which we can log success or failure, and an <span class="docutils literal"><span class="pre">ActivityScope</span></span> which can retrieve
the current activity from a context:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">interface</span> <span class="n">IActivity</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">LogSuccess</span><span class="p">();</span>
    <span class="k">void</span> <span class="nf">LogFailure</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActivityScope</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IActivity</span> <span class="nf">GetCurrentActivity</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this implementation, all clients of the API have to make sure <span class="docutils literal"><span class="pre">GetCurrentActivity()</span></span>
returns an object as opposed to null. All callers look like this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">ActivityScope</span> <span class="n">activityScope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ActivityScope</span><span class="p">();</span>
<span class="n">activityScope</span><span class="p">.</span><span class="n">CreateActivity</span><span class="p">();</span>

<span class="p">...</span> <span class="c1">// Do a bunch of stuff</span>

<span class="kt">var</span> <span class="n">activity</span> <span class="p">=</span> <span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">activity</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">activity</span><span class="p">.</span><span class="n">LogSuccess</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While there is a single <span class="docutils literal"><span class="pre">ActivityScope</span></span> implementation, there are hundreds of
calls to <span class="docutils literal"><span class="pre">GetCurrentActivity</span></span>, all coming with a boilerplate null check. The
Null Object alternative for this is to provide a <span class="docutils literal"><span class="pre">NullActivity</span></span>, for which
<span class="docutils literal"><span class="pre">LogSuccess</span></span> and <span class="docutils literal"><span class="pre">LogFailure</span></span> don’t do anything. <span class="docutils literal"><span class="pre">ActivityScope</span></span> can return
<span class="docutils literal"><span class="pre">NullActivity</span></span> instead of null if there is no <span class="docutils literal"><span class="pre">Activity</span></span> in the context:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">NullActivity</span> <span class="p">:</span> <span class="n">IActivity</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LogSuccess</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LogFailure</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ActivityScope</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">private</span> <span class="k">static</span> <span class="n">NullActivity</span> <span class="n">_nullActivity</span> <span class="p">=</span> <span class="k">new</span> <span class="n">NullActivity</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">IActivity</span> <span class="nf">GetCurrentActivity</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_nullActivity</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now callers don’t need to worry about getting back a null, and can use the API
like this:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">().</span><span class="n">LogSuccess</span><span class="p">();</span>
</pre></div>
</div>
<p>Yet another way to reduce branching is when it used for mapping between two types:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="p">=</span> <span class="s">"Foo string"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span> <span class="p">=</span> <span class="s">"Bar string"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">...</span>
</pre></div>
</div>
<p>A pattern like this (which can also take the form of a big switch/case statement)
can usually be replaced with indexing into an array or looking up the
corresponding value in a hash map:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">IdTypeToStringMap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">,</span> <span class="s">"Foo"</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">,</span> <span class="s">"Bar"</span> <span class="p">},</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="n">b</span> <span class="p">=</span> <span class="n">IdTypeToStringMap</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
</pre></div>
</div>
<p>This is, again, easier to maintain, since it is declarative - the mapping is given as
data (<span class="docutils literal"><span class="pre">IdTypeToStringMap</span></span>), not as code (long series of if/else).</p>
</div>
<div class="section" id="avoid-loops">
<h3>Avoid loops</h3>
<p>This goes back to the C++ Seasoning talk, namely the <em>No Raw Loops</em> guideline. Here’s
a C# example: given a list of numbers, we want to get the square of all the odd
numbers in the list.</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="m">6</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">8</span> <span class="p">};</span>

<span class="c1">// Get the squares of all odd numbers</span>
</pre></div>
</div>
<p>One way to do this is to maintain a list of numbers, iterate over the list, check
if numbers are odd, and if so, square them and add them to the list:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">squares</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">squares</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
</pre></div>
</div>
<p>A neater way to do this is to use a generator instead of manually maintaining
the list of squares:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
</pre></div>
</div>
<p>That being said, what I would actually recommend is using Linq:</p>
<div class="highlight-c# notranslate"><div class="highlight"><pre><span/><span class="c1">// Get the squares of all odd numbers</span>
<span class="kt">var</span> <span class="n">squares</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span>
                <span class="n">Where</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span><span class="p">).</span>
                <span class="n">Select</span><span class="p">(</span><span class="n">number</span> <span class="p">=&gt;</span> <span class="n">number</span> <span class="p">*</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>Fewer lines of code and no branching whatsoever <a class="footnote-reference" href="#id2" id="id1">[*]</a>. <span class="docutils literal"><span class="pre">Where</span></span> and <span class="docutils literal"><span class="pre">Select</span></span>
are generic algorithms, and their arguments are the predicates we use. This makes
the intent of the code clear at a glance - we are filtering the collection with
a predicate (<span class="docutils literal"><span class="pre">number</span> <span class="pre">=&gt;</span> <span class="pre">number</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">!=</span> <span class="pre">0</span></span>) and applying a transformation to it
with another predicate (<span class="docutils literal"><span class="pre">number</span> <span class="pre">=&gt;</span> <span class="pre">number</span> <span class="pre">*</span> <span class="pre">number</span></span>). Also, the filtering and
transformation are library functions, so we can be fairly certain they work
well, and only need to worry about maintaining our predicates.</p>
<p>It might not look like a big deal in this simple made-up example, but as code
evolves, it becomes harder and harder to follow the iteration logic, as the
code gets littered with <span class="docutils literal"><span class="pre">break</span></span>, <span class="docutils literal"><span class="pre">continue</span></span>, and <span class="docutils literal"><span class="pre">return</span></span> statements (see
the Chrome example quoted in the Write Less Code section).</p>
<p>Key takeaways:</p>
<ul class="simple">
<li>Try to keep functions linear (or as linear as possible)</li>
<li>Default to throwing instead of propagating errors up the call stack</li>
<li>Consider creating a null object when code is littered with null checks</li>
<li>Separate algorithm logic from predicates to make the intent of the code clear (in other words, no raw loops).</li>
</ul>
</div>
</div>
<div class="section" id="notes-on-performance">
<h2>Notes on performance</h2>
<p>The most interesting question I was asked is what are the performance
implications of using an STL algorithm or Linq.</p>
<p>The default answer is, of course, you have to measure for your particular case!
Blanket statements cannot be made about performance, as there are many factors
involved: compiler, runtime, standard library, OS, architecture, whether code is
on a hot path or not, and so on and so forth.</p>
<p>Still, my recommendation is to use the library algorithms and, only if they
become the bottleneck (which in most cases shouldn’t happen), look into replacing
them with handcrafted code. Another thing to keep in mind is that standard
library authors know what they’re doing, so it’s very likely that library code is
already pretty well optimized. I ran a simple wall clock benchmark for 1M
iterations for some of the examples I used throughout the presentation (both the
handcrafted and the library versions), and in all cases the code leveraging
library functions ran slightly faster.</p>
<hr class="docutils"/>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[*]</a></td><td>Cyclomatic complexity of this is actually higher when computed by looking
at basic blocks (eg. from Visual Studio’s <span class="docutils literal"><span class="pre">Analyze</span></span> menu), since the compiler
will automatically add a finally block to dispose of the Linq-returned
IEnumerables in case of exception. That being said, I prefer
compiler-generated complexity to developer-generated complexity.</td></tr>
</tbody>
</table>
</div>
]]></description>
             <pubDate>Mon, 04 Jan 2016 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://vladris.com/blog/2015/12/28/hello-world.html</link>
            <guid>http://vladris.com/blog/2015/12/28/hello-world.html</guid>
            <title><![CDATA[Hello World]]></title>
            <description><![CDATA[<h1>Hello World</h1>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="s2">"Hello World!"</span><span class="p">)</span>
</pre></div>
</div>
]]></description>
             <pubDate>Mon, 28 Dec 2015 00:00:00 -0800</pubDate>
        </item>
    
    </channel>
</rss>